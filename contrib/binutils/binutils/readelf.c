begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readelf.c -- display contents of an ELF format file    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     Originally developed by Eric Youngdale<eric@andante.jic.com>    Modifications by Nick Clifton<nickc@redhat.com>     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The difference between readelf and objdump:    Both programs are capable of displaying the contents of ELF format files,   so why does the binutils project have two file dumpers ?    The reason is that objdump sees an ELF file through a BFD filter of the   world; if BFD has a bug where, say, it disagrees about a machine constant   in e_flags, then the odds are good that it will remain internally   consistent.  The linker sees it the BFD way, objdump sees it the BFD way,   GAS sees it the BFD way.  There was need for a tool to go find out what   the file actually says.    This is why the readelf program does not link against the BFD library - it   exists as an independent program to help verify the correct working of BFD.    There is also the case that readelf can provide more information about an   ELF file than is provided by objdump.  In particular it can display DWARF   debugging information which (at the moment) objdump cannot.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* for PATH_MAX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_comment
comment|/* for MAXPATHLEN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PARAM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAXPATHLEN
end_ifdef

begin_define
define|#
directive|define
name|PATH_MAX
value|MAXPATHLEN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_MAX
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
end_if

begin_comment
comment|/* Define BFD64 here, even if our default architecture is 32 bit ELF    as this will allow us to read in and parse 64bit and 32bit ELF files.    Only do this if we believe that the compiler can support a 64 bit    data type.  For now we only rely on GCC being able to do this.  */
end_comment

begin_define
define|#
directive|define
name|BFD64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"dwarf.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_comment
comment|/* Included here, before RELOC_MACROS_GEN_FUNC is defined, so that    we can obtain the H8 reloc numbers.  We need these for the    get_reloc_size() function.  We include h8.h again after defining    RELOC_MACROS_GEN_FUNC so that we get the naming function as well.  */
end_comment

begin_include
include|#
directive|include
file|"elf/h8.h"
end_include

begin_undef
undef|#
directive|undef
name|_ELF_H8_H
end_undef

begin_comment
comment|/* Undo the effects of #including reloc-macros.h.  */
end_comment

begin_undef
undef|#
directive|undef
name|START_RELOC_NUMBERS
end_undef

begin_undef
undef|#
directive|undef
name|RELOC_NUMBER
end_undef

begin_undef
undef|#
directive|undef
name|FAKE_RELOC
end_undef

begin_undef
undef|#
directive|undef
name|EMPTY_RELOC
end_undef

begin_undef
undef|#
directive|undef
name|END_RELOC_NUMBERS
end_undef

begin_undef
undef|#
directive|undef
name|_RELOC_MACROS_H
end_undef

begin_comment
comment|/* The following headers use the elf/reloc-macros.h file to    automatically generate relocation recognition functions    such as elf_mips_reloc_type()  */
end_comment

begin_define
define|#
directive|define
name|RELOC_MACROS_GEN_FUNC
end_define

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"elf/avr.h"
end_include

begin_include
include|#
directive|include
file|"elf/bfin.h"
end_include

begin_include
include|#
directive|include
file|"elf/cris.h"
end_include

begin_include
include|#
directive|include
file|"elf/crx.h"
end_include

begin_include
include|#
directive|include
file|"elf/d10v.h"
end_include

begin_include
include|#
directive|include
file|"elf/d30v.h"
end_include

begin_include
include|#
directive|include
file|"elf/dlx.h"
end_include

begin_include
include|#
directive|include
file|"elf/fr30.h"
end_include

begin_include
include|#
directive|include
file|"elf/frv.h"
end_include

begin_include
include|#
directive|include
file|"elf/h8.h"
end_include

begin_include
include|#
directive|include
file|"elf/hppa.h"
end_include

begin_include
include|#
directive|include
file|"elf/i386.h"
end_include

begin_include
include|#
directive|include
file|"elf/i370.h"
end_include

begin_include
include|#
directive|include
file|"elf/i860.h"
end_include

begin_include
include|#
directive|include
file|"elf/i960.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/ip2k.h"
end_include

begin_include
include|#
directive|include
file|"elf/iq2000.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32c.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32r.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68k.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"elf/mcore.h"
end_include

begin_include
include|#
directive|include
file|"elf/mep.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/mmix.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10200.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10300.h"
end_include

begin_include
include|#
directive|include
file|"elf/mt.h"
end_include

begin_include
include|#
directive|include
file|"elf/msp430.h"
end_include

begin_include
include|#
directive|include
file|"elf/or32.h"
end_include

begin_include
include|#
directive|include
file|"elf/pj.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc64.h"
end_include

begin_include
include|#
directive|include
file|"elf/s390.h"
end_include

begin_include
include|#
directive|include
file|"elf/score.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"elf/spu.h"
end_include

begin_include
include|#
directive|include
file|"elf/v850.h"
end_include

begin_include
include|#
directive|include
file|"elf/vax.h"
end_include

begin_include
include|#
directive|include
file|"elf/x86-64.h"
end_include

begin_include
include|#
directive|include
file|"elf/xstormy16.h"
end_include

begin_include
include|#
directive|include
file|"elf/xtensa.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"readelf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|archive_file_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|archive_file_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dynamic_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|dynamic_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dynamic_nent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dynamic_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dynamic_strings_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|string_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|string_table_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|num_dynamic_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Sym
modifier|*
name|dynamic_symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Syminfo
modifier|*
name|dynamic_syminfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|dynamic_syminfo_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dynamic_syminfo_nent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|program_interpreter
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|dynamic_info
index|[
name|DT_ENCODING
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|dynamic_info_DT_GNU_HASH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|version_info
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Ehdr
name|elf_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Shdr
modifier|*
name|section_headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Dyn
modifier|*
name|dynamic_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Shdr
modifier|*
name|symtab_shndx_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|show_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_section_groups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_section_details
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_segments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_unwind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_using_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_wide
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_histogram
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_notes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_32bit_elf
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|group_list
block|{
name|struct
name|group_list
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|section_index
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|group
block|{
name|struct
name|group_list
modifier|*
name|root
decl_stmt|;
name|unsigned
name|int
name|group_index
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|size_t
name|group_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|group
modifier|*
name|section_groups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|group
modifier|*
modifier|*
name|section_headers_groups
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A linked list of the section names for which dumps were requested    by name.  */
end_comment

begin_struct
struct|struct
name|dump_list_entry
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|dump_list_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dump_list_entry
modifier|*
name|dump_sects_byname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A dynamic array of flags indicating for which sections a hex dump    has been requested (via the -x switch) and/or a disassembly dump    (via the -i switch).  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cmdline_dump_sects
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|num_cmdline_dump_sects
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A dynamic array of flags indicating for which sections a dump of    some kind has been requested.  It is reset on a per-object file    basis and then initialised from the cmdline_dump_sects array,    the results of interpreting the -w switch, and the    dump_sects_byname list.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_sects
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_dump_sects
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEX_DUMP
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DISASS_DUMP
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUG_DUMP
value|(1<< 2)
end_define

begin_comment
comment|/* How to print a vma value.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|print_mode
block|{
name|HEX
block|,
name|DEC
block|,
name|DEC_5
block|,
name|UNSIGNED
block|,
name|PREFIX_HEX
block|,
name|FULL_HEX
block|,
name|LONG_HEX
block|}
name|print_mode
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|byte_put
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|UNKNOWN
value|-1
end_define

begin_define
define|#
directive|define
name|SECTION_NAME
parameter_list|(
name|X
parameter_list|)
define|\
value|((X) == NULL ? "<none>" \   : string_table == NULL ? "<no-name>" \   : ((X)->sh_name>= string_table_length ? "<corrupt>" \   : string_table + (X)->sh_name))
end_define

begin_comment
comment|/* Given st_shndx I, map to section_headers index.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_HEADER_INDEX
parameter_list|(
name|I
parameter_list|)
define|\
value|((I)< SHN_LORESERVE					\    ? (I)						\    : ((I)<= SHN_HIRESERVE				\       ? 0						\       : (I) - (SHN_HIRESERVE + 1 - SHN_LORESERVE)))
end_define

begin_comment
comment|/* Reverse of the above.  */
end_comment

begin_define
define|#
directive|define
name|SECTION_HEADER_NUM
parameter_list|(
name|N
parameter_list|)
define|\
value|((N)< SHN_LORESERVE					\    ? (N)						\    : (N) + (SHN_HIRESERVE + 1 - SHN_LORESERVE))
end_define

begin_define
define|#
directive|define
name|SECTION_HEADER
parameter_list|(
name|I
parameter_list|)
value|(section_headers + SECTION_HEADER_INDEX (I))
end_define

begin_define
define|#
directive|define
name|DT_VERSIONTAGIDX
parameter_list|(
name|tag
parameter_list|)
value|(DT_VERNEEDNUM - (tag))
end_define

begin_comment
comment|/* Reverse order!  */
end_comment

begin_define
define|#
directive|define
name|BYTE_GET
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, sizeof (field))
end_define

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|array
parameter_list|)
value|(sizeof (array) / sizeof ((array)[0]))
end_define

begin_define
define|#
directive|define
name|GET_ELF_SYMBOLS
parameter_list|(
name|file
parameter_list|,
name|section
parameter_list|)
define|\
value|(is_32bit_elf ? get_32bit_elf_symbols (file, section)	\    : get_64bit_elf_symbols (file, section))
end_define

begin_define
define|#
directive|define
name|VALID_DYNAMIC_NAME
parameter_list|(
name|offset
parameter_list|)
value|((dynamic_strings != NULL)&& (offset< dynamic_strings_length))
end_define

begin_comment
comment|/* GET_DYNAMIC_NAME asssumes that VALID_DYNAMIC_NAME has    already been called and verified that the string exists.  */
end_comment

begin_define
define|#
directive|define
name|GET_DYNAMIC_NAME
parameter_list|(
name|offset
parameter_list|)
value|(dynamic_strings + offset)
end_define

begin_comment
comment|/* This is just a bit of syntatic sugar.  */
end_comment

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp ((a), (b)) == 0)
end_define

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|(strncmp ((a), (b), (n)) == 0)
end_define

begin_define
define|#
directive|define
name|const_strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strncmp ((a), (b), sizeof (b) - 1) == 0)
end_define

begin_escape
end_escape

begin_function
specifier|static
name|void
modifier|*
name|get_data
parameter_list|(
name|void
modifier|*
name|var
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|nmemb
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|void
modifier|*
name|mvar
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|nmemb
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|archive_file_offset
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to 0x%lx for %s\n"
argument_list|)
argument_list|,
name|archive_file_offset
operator|+
name|offset
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mvar
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|mvar
operator|==
name|NULL
condition|)
block|{
comment|/* Check for overflow.  */
if|if
condition|(
name|nmemb
operator|<
operator|(
operator|~
operator|(
name|size_t
operator|)
literal|0
operator|-
literal|1
operator|)
operator|/
name|size
condition|)
comment|/* + 1 so that we can '\0' terminate invalid string table sections.  */
name|mvar
operator|=
name|malloc
argument_list|(
name|size
operator|*
name|nmemb
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvar
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating 0x%lx bytes for %s\n"
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|size
operator|*
name|nmemb
argument_list|)
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|(
name|char
operator|*
operator|)
name|mvar
operator|)
index|[
name|size
operator|*
name|nmemb
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|mvar
argument_list|,
name|size
argument_list|,
name|nmemb
argument_list|,
name|file
argument_list|)
operator|!=
name|nmemb
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read in 0x%lx bytes of %s\n"
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|size
operator|*
name|nmemb
argument_list|)
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvar
operator|!=
name|var
condition|)
name|free
argument_list|(
name|mvar
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|mvar
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|byte_put_little_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|field
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|24
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|6
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|4
case|:
name|field
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
name|field
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|field
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|BFD64
operator|&&
operator|!
name|BFD_HOST_64BIT_LONG
end_if

begin_function
specifier|static
name|int
name|print_dec_vma
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|int
name|is_signed
parameter_list|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|int
name|nc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_signed
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|vma
operator|<
literal|0
condition|)
block|{
name|vma
operator|=
operator|-
name|vma
expr_stmt|;
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|nc
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'0'
operator|+
name|vma
operator|%
literal|10
expr_stmt|;
name|vma
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|vma
operator|!=
literal|0
condition|)
do|;
name|nc
operator|+=
name|bufp
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|bufp
operator|>
name|buf
condition|)
name|putchar
argument_list|(
operator|*
operator|--
name|bufp
argument_list|)
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_hex_vma
parameter_list|(
name|bfd_vma
name|vma
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|int
name|nc
decl_stmt|;
do|do
block|{
name|char
name|digit
init|=
literal|'0'
operator|+
operator|(
name|vma
operator|&
literal|0x0f
operator|)
decl_stmt|;
if|if
condition|(
name|digit
operator|>
literal|'9'
condition|)
name|digit
operator|+=
literal|'a'
operator|-
literal|'0'
operator|-
literal|10
expr_stmt|;
operator|*
name|bufp
operator|++
operator|=
name|digit
expr_stmt|;
name|vma
operator|>>=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|vma
operator|!=
literal|0
condition|)
do|;
name|nc
operator|=
name|bufp
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|bufp
operator|>
name|buf
condition|)
name|putchar
argument_list|(
operator|*
operator|--
name|bufp
argument_list|)
expr_stmt|;
return|return
name|nc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print a VMA value.  */
end_comment

begin_function
specifier|static
name|int
name|print_vma
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|print_mode
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|is_32bit_elf
condition|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
return|return
name|printf
argument_list|(
literal|"0x%8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
case|case
name|LONG_HEX
case|:
return|return
name|printf
argument_list|(
literal|"%8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
case|case
name|DEC_5
case|:
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
return|return
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
name|vma
argument_list|)
return|;
comment|/* Drop through.  */
case|case
name|PREFIX_HEX
case|:
return|return
name|printf
argument_list|(
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
case|case
name|HEX
case|:
return|return
name|printf
argument_list|(
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
case|case
name|DEC
case|:
return|return
name|printf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
case|case
name|UNSIGNED
case|:
return|return
name|printf
argument_list|(
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|BFD64
else|else
block|{
name|int
name|nc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
name|nc
operator|=
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|LONG_HEX
case|:
name|printf_vma
argument_list|(
name|vma
argument_list|)
expr_stmt|;
return|return
name|nc
operator|+
literal|16
return|;
case|case
name|PREFIX_HEX
case|:
name|nc
operator|=
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
name|HEX
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
return|return
name|nc
operator|+
name|printf
argument_list|(
literal|"%lx"
argument_list|,
name|vma
argument_list|)
return|;
else|#
directive|else
return|return
name|nc
operator|+
name|print_hex_vma
argument_list|(
name|vma
argument_list|)
return|;
endif|#
directive|endif
case|case
name|DEC
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
return|return
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|vma
argument_list|)
return|;
else|#
directive|else
return|return
name|print_dec_vma
argument_list|(
name|vma
argument_list|,
literal|1
argument_list|)
return|;
endif|#
directive|endif
case|case
name|DEC_5
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
return|return
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|vma
argument_list|)
return|;
else|else
return|return
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
name|vma
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|vma
operator|<=
literal|99999
condition|)
return|return
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
return|;
else|else
return|return
name|print_hex_vma
argument_list|(
name|vma
argument_list|)
return|;
endif|#
directive|endif
case|case
name|UNSIGNED
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
return|return
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|vma
argument_list|)
return|;
else|#
directive|else
return|return
name|print_dec_vma
argument_list|(
name|vma
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display a symbol on stdout.  If do_wide is not true then    format the symbol to be at most WIDTH characters,    truncating as necessary.  If WIDTH is negative then    format the string to be exactly - WIDTH characters,    truncating or padding as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol
parameter_list|(
name|int
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"%-*.*s"
argument_list|,
name|width
argument_list|,
name|width
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-.*s"
argument_list|,
name|width
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|byte_put_big_endian
parameter_list|(
name|unsigned
name|char
modifier|*
name|field
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|8
case|:
name|field
index|[
literal|7
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|6
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|5
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|4
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|4
case|:
name|field
index|[
literal|3
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|field
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|2
case|:
name|field
index|[
literal|1
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|1
case|:
name|field
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to section NAME, or NULL if no such section exists.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Shdr
modifier|*
name|find_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|section_headers
operator|+
name|i
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Guess the relocation size commonly used by the specific machines.  */
end_comment

begin_function
specifier|static
name|int
name|guess_is_rela
parameter_list|(
name|unsigned
name|long
name|e_machine
parameter_list|)
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
comment|/* Targets that use REL relocations.  */
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
case|case
name|EM_960
case|:
case|case
name|EM_ARM
case|:
case|case
name|EM_D10V
case|:
case|case
name|EM_CYGNUS_D10V
case|:
case|case
name|EM_DLX
case|:
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
case|case
name|EM_CYGNUS_M32R
case|:
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
case|case
name|EM_SCORE
case|:
return|return
name|FALSE
return|;
comment|/* Targets that use RELA relocations.  */
case|case
name|EM_68K
case|:
case|case
name|EM_860
case|:
case|case
name|EM_ALPHA
case|:
case|case
name|EM_ALTERA_NIOS2
case|:
case|case
name|EM_AVR
case|:
case|case
name|EM_AVR_OLD
case|:
case|case
name|EM_BLACKFIN
case|:
case|case
name|EM_CRIS
case|:
case|case
name|EM_CRX
case|:
case|case
name|EM_D30V
case|:
case|case
name|EM_CYGNUS_D30V
case|:
case|case
name|EM_FR30
case|:
case|case
name|EM_CYGNUS_FR30
case|:
case|case
name|EM_CYGNUS_FRV
case|:
case|case
name|EM_H8S
case|:
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
case|case
name|EM_IA_64
case|:
case|case
name|EM_IP2K
case|:
case|case
name|EM_IP2K_OLD
case|:
case|case
name|EM_IQ2000
case|:
case|case
name|EM_M32C
case|:
case|case
name|EM_M32R
case|:
case|case
name|EM_MCORE
case|:
case|case
name|EM_CYGNUS_MEP
case|:
case|case
name|EM_MMIX
case|:
case|case
name|EM_MN10200
case|:
case|case
name|EM_CYGNUS_MN10200
case|:
case|case
name|EM_MN10300
case|:
case|case
name|EM_CYGNUS_MN10300
case|:
case|case
name|EM_MSP430
case|:
case|case
name|EM_MSP430_OLD
case|:
case|case
name|EM_MT
case|:
case|case
name|EM_NIOS32
case|:
case|case
name|EM_PPC64
case|:
case|case
name|EM_PPC
case|:
case|case
name|EM_S390
case|:
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_SH
case|:
case|case
name|EM_SPARC
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPU
case|:
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
case|case
name|EM_VAX
case|:
case|case
name|EM_X86_64
case|:
case|case
name|EM_XSTORMY16
case|:
case|case
name|EM_XTENSA
case|:
case|case
name|EM_XTENSA_OLD
case|:
return|return
name|TRUE
return|;
case|case
name|EM_68HC05
case|:
case|case
name|EM_68HC08
case|:
case|case
name|EM_68HC11
case|:
case|case
name|EM_68HC16
case|:
case|case
name|EM_FX66
case|:
case|case
name|EM_ME16
case|:
case|case
name|EM_MMA
case|:
case|case
name|EM_NCPU
case|:
case|case
name|EM_NDR1
case|:
case|case
name|EM_PCP
case|:
case|case
name|EM_ST100
case|:
case|case
name|EM_ST19
case|:
case|case
name|EM_ST7
case|:
case|case
name|EM_ST9PLUS
case|:
case|case
name|EM_STARCORE
case|:
case|case
name|EM_SVX
case|:
case|case
name|EM_TINYJ
case|:
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Don't know about relocations on this machine architecture\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rela_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
name|relasp
parameter_list|,
name|unsigned
name|long
modifier|*
name|nrelasp
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|relas
decl_stmt|;
name|unsigned
name|long
name|nrelas
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|erelas
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
literal|1
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erelas
condition|)
return|return
literal|0
return|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
name|cmalloc
argument_list|(
name|nrelas
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|erelas
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
literal|1
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erelas
condition|)
return|return
literal|0
return|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
name|cmalloc
argument_list|(
name|nrelas
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
operator|*
name|relasp
operator|=
name|relas
expr_stmt|;
operator|*
name|nrelasp
operator|=
name|nrelas
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rel_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
name|relsp
parameter_list|,
name|unsigned
name|long
modifier|*
name|nrelsp
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rels
decl_stmt|;
name|unsigned
name|long
name|nrels
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rel
modifier|*
name|erels
decl_stmt|;
name|erels
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
literal|1
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erels
condition|)
return|return
literal|0
return|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
name|cmalloc
argument_list|(
name|nrels
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rel
modifier|*
name|erels
decl_stmt|;
name|erels
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|rel_offset
argument_list|,
literal|1
argument_list|,
name|rel_size
argument_list|,
name|_
argument_list|(
literal|"relocs"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erels
condition|)
return|return
literal|0
return|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
name|cmalloc
argument_list|(
name|nrels
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
operator|*
name|relsp
operator|=
name|rels
expr_stmt|;
operator|*
name|nrelsp
operator|=
name|nrels
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the relocation data found at the specified    offset.  */
end_comment

begin_function
specifier|static
name|int
name|dump_relocations
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|rel_offset
parameter_list|,
name|unsigned
name|long
name|rel_size
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|symtab
parameter_list|,
name|unsigned
name|long
name|nsyms
parameter_list|,
name|char
modifier|*
name|strtab
parameter_list|,
name|unsigned
name|long
name|strtablen
parameter_list|,
name|int
name|is_rela
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rels
decl_stmt|;
if|if
condition|(
name|is_rela
operator|==
name|UNKNOWN
condition|)
name|is_rela
operator|=
name|guess_is_rela
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|rels
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|slurp_rel_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|rels
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type                Sym. Value  Symbol's Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|" Offset     Info    Type            Sym.Value  Sym. Name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"    Offset             Info             Type               Symbol's Value  Symbol's Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset          Info           Type           Sym. Value    Sym. Name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|rtype
decl_stmt|;
specifier|const
name|char
modifier|*
name|rtype2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|rtype3
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|info
decl_stmt|;
name|bfd_vma
name|symtab_index
decl_stmt|;
name|bfd_vma
name|type
decl_stmt|;
name|bfd_vma
name|type2
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|type3
init|=
literal|0
decl_stmt|;
name|offset
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|info
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The #ifdef BFD64 below is to prevent a compile time warning. 	     We know that if we do not have a 64 bit data type that we 	     will never execute this code anyway.  */
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
comment|/* In little-endian objects, r_info isn't really a 64-bit 		 little-endian value: it has a 32-bit little-endian 		 symbol index followed by four individual byte fields. 		 Reorder INFO accordingly.  */
if|if
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELFDATA2MSB
condition|)
name|info
operator|=
operator|(
operator|(
operator|(
name|info
operator|&
literal|0xffffffff
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|56
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|40
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|24
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|info
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator|)
expr_stmt|;
name|type
operator|=
name|ELF64_MIPS_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|type2
operator|=
name|ELF64_MIPS_R_TYPE2
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|type3
operator|=
name|ELF64_MIPS_R_TYPE3
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
condition|)
name|type
operator|=
name|ELF64_R_TYPE_ID
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_index
operator|=
name|ELF64_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
literal|"%8.8lx  %8.8lx "
argument_list|,
name|_bfd_int64_low
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%8.8lx  %8.8lx "
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%8.8lx%8.8lx  %8.8lx%8.8lx "
else|:
literal|"%4.4lx%8.8lx  %4.4lx%8.8lx "
argument_list|,
name|_bfd_int64_high
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_high
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%16.16lx  %16.16lx "
else|:
literal|"%12.12lx  %12.12lx "
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
default|default:
name|rtype
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|EM_M32R
case|:
case|case
name|EM_CYGNUS_M32R
case|:
name|rtype
operator|=
name|elf_m32r_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
name|rtype
operator|=
name|elf_i386_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68HC11
case|:
case|case
name|EM_68HC12
case|:
name|rtype
operator|=
name|elf_m68hc11_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
name|rtype
operator|=
name|elf_m68k_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_960
case|:
name|rtype
operator|=
name|elf_i960_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_AVR
case|:
case|case
name|EM_AVR_OLD
case|:
name|rtype
operator|=
name|elf_avr_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_OLD_SPARCV9
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPARC
case|:
name|rtype
operator|=
name|elf_sparc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SPU
case|:
name|rtype
operator|=
name|elf_spu_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
name|rtype
operator|=
name|v850_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_D10V
case|:
case|case
name|EM_CYGNUS_D10V
case|:
name|rtype
operator|=
name|elf_d10v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_D30V
case|:
case|case
name|EM_CYGNUS_D30V
case|:
name|rtype
operator|=
name|elf_d30v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_DLX
case|:
name|rtype
operator|=
name|elf_dlx_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SH
case|:
name|rtype
operator|=
name|elf_sh_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MN10300
case|:
case|case
name|EM_CYGNUS_MN10300
case|:
name|rtype
operator|=
name|elf_mn10300_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MN10200
case|:
case|case
name|EM_CYGNUS_MN10200
case|:
name|rtype
operator|=
name|elf_mn10200_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_FR30
case|:
case|case
name|EM_CYGNUS_FR30
case|:
name|rtype
operator|=
name|elf_fr30_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_FRV
case|:
name|rtype
operator|=
name|elf_frv_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MCORE
case|:
name|rtype
operator|=
name|elf_mcore_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MMIX
case|:
name|rtype
operator|=
name|elf_mmix_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MSP430
case|:
case|case
name|EM_MSP430_OLD
case|:
name|rtype
operator|=
name|elf_msp430_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
name|rtype
operator|=
name|elf_ppc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC64
case|:
name|rtype
operator|=
name|elf_ppc64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|rtype
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_32bit_elf
condition|)
block|{
name|rtype2
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type2
argument_list|)
expr_stmt|;
name|rtype3
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EM_ALPHA
case|:
name|rtype
operator|=
name|elf_alpha_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARM
case|:
name|rtype
operator|=
name|elf_arm_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARC
case|:
name|rtype
operator|=
name|elf_arc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|rtype
operator|=
name|elf_hppa_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
case|case
name|EM_H8S
case|:
name|rtype
operator|=
name|elf_h8_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
name|rtype
operator|=
name|elf_or32_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
case|case
name|EM_PJ_OLD
case|:
name|rtype
operator|=
name|elf_pj_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|rtype
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CRIS
case|:
name|rtype
operator|=
name|elf_cris_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_860
case|:
name|rtype
operator|=
name|elf_i860_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_X86_64
case|:
name|rtype
operator|=
name|elf_x86_64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_S370
case|:
name|rtype
operator|=
name|i370_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_S390
case|:
name|rtype
operator|=
name|elf_s390_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SCORE
case|:
name|rtype
operator|=
name|elf_score_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_XSTORMY16
case|:
name|rtype
operator|=
name|elf_xstormy16_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CRX
case|:
name|rtype
operator|=
name|elf_crx_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_VAX
case|:
name|rtype
operator|=
name|elf_vax_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IP2K
case|:
case|case
name|EM_IP2K_OLD
case|:
name|rtype
operator|=
name|elf_ip2k_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IQ2000
case|:
name|rtype
operator|=
name|elf_iq2000_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_XTENSA_OLD
case|:
case|case
name|EM_XTENSA
case|:
name|rtype
operator|=
name|elf_xtensa_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_M32C
case|:
name|rtype
operator|=
name|elf_m32c_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MT
case|:
name|rtype
operator|=
name|elf_mt_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_BLACKFIN
case|:
name|rtype
operator|=
name|elf_bfin_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_MEP
case|:
name|rtype
operator|=
name|elf_mep_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtype
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
name|do_wide
condition|?
literal|"%-22.22s"
else|:
literal|"%-17.17s"
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_ALPHA
operator|&&
name|rtype
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|rtype
argument_list|,
literal|"R_ALPHA_LITUSE"
argument_list|)
operator|&&
name|is_rela
condition|)
block|{
switch|switch
condition|(
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
condition|)
block|{
case|case
name|LITUSE_ALPHA_ADDR
case|:
name|rtype
operator|=
literal|"ADDR"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_BASE
case|:
name|rtype
operator|=
literal|"BASE"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_BYTOFF
case|:
name|rtype
operator|=
literal|"BYTOFF"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_JSR
case|:
name|rtype
operator|=
literal|"JSR"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_TLSGD
case|:
name|rtype
operator|=
literal|"TLSGD"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_TLSLDM
case|:
name|rtype
operator|=
literal|"TLSLDM"
expr_stmt|;
break|break;
case|case
name|LITUSE_ALPHA_JSRDIRECT
case|:
name|rtype
operator|=
literal|"JSRDIRECT"
expr_stmt|;
break|break;
default|default:
name|rtype
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rtype
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"<unknown addend: %lx>"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|symtab_index
condition|)
block|{
if|if
condition|(
name|symtab
operator|==
name|NULL
operator|||
name|symtab_index
operator|>=
name|nsyms
condition|)
name|printf
argument_list|(
literal|" bad symbol index: %08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symtab_index
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
name|symtab
operator|+
name|symtab_index
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|is_32bit_elf
condition|?
literal|"   "
else|:
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|sec_name
init|=
literal|"<null>"
decl_stmt|;
name|char
name|name_buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|bfd_vma
name|sec_index
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|sec_index
operator|=
name|psym
operator|->
name|st_shndx
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
name|sec_index
operator|=
name|psym
operator|->
name|st_shndx
operator|-
operator|(
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
operator|)
expr_stmt|;
if|if
condition|(
name|sec_index
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|sec_name
operator|=
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|sec_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sec_name
operator|=
literal|"ABS"
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sec_name
operator|=
literal|"COMMON"
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
operator|&&
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_MIPS_SCOMMON
condition|)
name|sec_name
operator|=
literal|"SCOMMON"
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
operator|&&
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_MIPS_SUNDEFINED
condition|)
name|sec_name
operator|=
literal|"SUNDEF"
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_X86_64
operator|&&
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_X86_64_LCOMMON
condition|)
name|sec_name
operator|=
literal|"LARGE_COMMON"
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_IA_64
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_HPUX
operator|&&
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_IA_64_ANSI_COMMON
condition|)
name|sec_name
operator|=
literal|"ANSI_COM"
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|name_buf
argument_list|,
literal|"<section 0x%x>"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|psym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sec_name
operator|=
name|name_buf
expr_stmt|;
block|}
block|}
name|print_symbol
argument_list|(
literal|22
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"<string table index: %3ld>"
argument_list|)
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psym
operator|->
name|st_name
operator|>=
name|strtablen
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"<corrupt string table index: %3ld>"
argument_list|)
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
else|else
name|print_symbol
argument_list|(
literal|22
argument_list|,
name|strtab
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_rela
condition|)
block|{
name|printf
argument_list|(
literal|"%*c"
argument_list|,
name|is_32bit_elf
condition|?
operator|(
name|do_wide
condition|?
literal|34
else|:
literal|28
operator|)
else|:
operator|(
name|do_wide
condition|?
literal|26
else|:
literal|20
operator|)
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|rels
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
name|rtype
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|rtype
argument_list|,
literal|"R_SPARC_OLO10"
argument_list|)
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ELF64_R_TYPE_DATA
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_32bit_elf
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
name|printf
argument_list|(
literal|"                    Type2: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype2
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type2
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-17.17s"
argument_list|,
name|rtype2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                    Type3: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype3
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type3
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognized: %-7lx"
argument_list|)
argument_list|,
name|type3
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-17.17s"
argument_list|,
name|rtype3
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_MIPS_RLD_VERSION
case|:
return|return
literal|"MIPS_RLD_VERSION"
return|;
case|case
name|DT_MIPS_TIME_STAMP
case|:
return|return
literal|"MIPS_TIME_STAMP"
return|;
case|case
name|DT_MIPS_ICHECKSUM
case|:
return|return
literal|"MIPS_ICHECKSUM"
return|;
case|case
name|DT_MIPS_IVERSION
case|:
return|return
literal|"MIPS_IVERSION"
return|;
case|case
name|DT_MIPS_FLAGS
case|:
return|return
literal|"MIPS_FLAGS"
return|;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
return|return
literal|"MIPS_BASE_ADDRESS"
return|;
case|case
name|DT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|DT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|DT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
return|return
literal|"MIPS_LOCAL_GOTNO"
return|;
case|case
name|DT_MIPS_CONFLICTNO
case|:
return|return
literal|"MIPS_CONFLICTNO"
return|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
return|return
literal|"MIPS_LIBLISTNO"
return|;
case|case
name|DT_MIPS_SYMTABNO
case|:
return|return
literal|"MIPS_SYMTABNO"
return|;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
return|return
literal|"MIPS_UNREFEXTNO"
return|;
case|case
name|DT_MIPS_GOTSYM
case|:
return|return
literal|"MIPS_GOTSYM"
return|;
case|case
name|DT_MIPS_HIPAGENO
case|:
return|return
literal|"MIPS_HIPAGENO"
return|;
case|case
name|DT_MIPS_RLD_MAP
case|:
return|return
literal|"MIPS_RLD_MAP"
return|;
case|case
name|DT_MIPS_DELTA_CLASS
case|:
return|return
literal|"MIPS_DELTA_CLASS"
return|;
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
return|return
literal|"MIPS_DELTA_CLASS_NO"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE
case|:
return|return
literal|"MIPS_DELTA_INSTANCE"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
return|return
literal|"MIPS_DELTA_INSTANCE_NO"
return|;
case|case
name|DT_MIPS_DELTA_RELOC
case|:
return|return
literal|"MIPS_DELTA_RELOC"
return|;
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
return|return
literal|"MIPS_DELTA_RELOC_NO"
return|;
case|case
name|DT_MIPS_DELTA_SYM
case|:
return|return
literal|"MIPS_DELTA_SYM"
return|;
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
return|return
literal|"MIPS_DELTA_SYM_NO"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM_NO"
return|;
case|case
name|DT_MIPS_CXX_FLAGS
case|:
return|return
literal|"MIPS_CXX_FLAGS"
return|;
case|case
name|DT_MIPS_PIXIE_INIT
case|:
return|return
literal|"MIPS_PIXIE_INIT"
return|;
case|case
name|DT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|DT_MIPS_LOCALPAGE_GOTIDX
case|:
return|return
literal|"MIPS_LOCALPAGE_GOTIDX"
return|;
case|case
name|DT_MIPS_LOCAL_GOTIDX
case|:
return|return
literal|"MIPS_LOCAL_GOTIDX"
return|;
case|case
name|DT_MIPS_HIDDEN_GOTIDX
case|:
return|return
literal|"MIPS_HIDDEN_GOTIDX"
return|;
case|case
name|DT_MIPS_PROTECTED_GOTIDX
case|:
return|return
literal|"MIPS_PROTECTED_GOTIDX"
return|;
case|case
name|DT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|DT_MIPS_INTERFACE
case|:
return|return
literal|"MIPS_INTERFACE"
return|;
case|case
name|DT_MIPS_DYNSTR_ALIGN
case|:
return|return
literal|"MIPS_DYNSTR_ALIGN"
return|;
case|case
name|DT_MIPS_INTERFACE_SIZE
case|:
return|return
literal|"MIPS_INTERFACE_SIZE"
return|;
case|case
name|DT_MIPS_RLD_TEXT_RESOLVE_ADDR
case|:
return|return
literal|"MIPS_RLD_TEXT_RESOLVE_ADDR"
return|;
case|case
name|DT_MIPS_PERF_SUFFIX
case|:
return|return
literal|"MIPS_PERF_SUFFIX"
return|;
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
return|return
literal|"MIPS_COMPACT_SIZE"
return|;
case|case
name|DT_MIPS_GP_VALUE
case|:
return|return
literal|"MIPS_GP_VALUE"
return|;
case|case
name|DT_MIPS_AUX_DYNAMIC
case|:
return|return
literal|"MIPS_AUX_DYNAMIC"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sparc64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_SPARC_REGISTER
case|:
return|return
literal|"SPARC_REGISTER"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ppc_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_PPC_GOT
case|:
return|return
literal|"PPC_GOT"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ppc64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_PPC64_GLINK
case|:
return|return
literal|"PPC64_GLINK"
return|;
case|case
name|DT_PPC64_OPD
case|:
return|return
literal|"PPC64_OPD"
return|;
case|case
name|DT_PPC64_OPDSZ
case|:
return|return
literal|"PPC64_OPDSZ"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_HP_LOAD_MAP
case|:
return|return
literal|"HP_LOAD_MAP"
return|;
case|case
name|DT_HP_DLD_FLAGS
case|:
return|return
literal|"HP_DLD_FLAGS"
return|;
case|case
name|DT_HP_DLD_HOOK
case|:
return|return
literal|"HP_DLD_HOOK"
return|;
case|case
name|DT_HP_UX10_INIT
case|:
return|return
literal|"HP_UX10_INIT"
return|;
case|case
name|DT_HP_UX10_INITSZ
case|:
return|return
literal|"HP_UX10_INITSZ"
return|;
case|case
name|DT_HP_PREINIT
case|:
return|return
literal|"HP_PREINIT"
return|;
case|case
name|DT_HP_PREINITSZ
case|:
return|return
literal|"HP_PREINITSZ"
return|;
case|case
name|DT_HP_NEEDED
case|:
return|return
literal|"HP_NEEDED"
return|;
case|case
name|DT_HP_TIME_STAMP
case|:
return|return
literal|"HP_TIME_STAMP"
return|;
case|case
name|DT_HP_CHECKSUM
case|:
return|return
literal|"HP_CHECKSUM"
return|;
case|case
name|DT_HP_GST_SIZE
case|:
return|return
literal|"HP_GST_SIZE"
return|;
case|case
name|DT_HP_GST_VERSION
case|:
return|return
literal|"HP_GST_VERSION"
return|;
case|case
name|DT_HP_GST_HASHVAL
case|:
return|return
literal|"HP_GST_HASHVAL"
return|;
case|case
name|DT_HP_EPLTREL
case|:
return|return
literal|"HP_GST_EPLTREL"
return|;
case|case
name|DT_HP_EPLTRELSZ
case|:
return|return
literal|"HP_GST_EPLTRELSZ"
return|;
case|case
name|DT_HP_FILTERED
case|:
return|return
literal|"HP_FILTERED"
return|;
case|case
name|DT_HP_FILTER_TLS
case|:
return|return
literal|"HP_FILTER_TLS"
return|;
case|case
name|DT_HP_COMPAT_FILTERED
case|:
return|return
literal|"HP_COMPAT_FILTERED"
return|;
case|case
name|DT_HP_LAZYLOAD
case|:
return|return
literal|"HP_LAZYLOAD"
return|;
case|case
name|DT_HP_BIND_NOW_COUNT
case|:
return|return
literal|"HP_BIND_NOW_COUNT"
return|;
case|case
name|DT_PLT
case|:
return|return
literal|"PLT"
return|;
case|case
name|DT_PLT_SIZE
case|:
return|return
literal|"PLT_SIZE"
return|;
case|case
name|DT_DLT
case|:
return|return
literal|"DLT"
return|;
case|case
name|DT_DLT_SIZE
case|:
return|return
literal|"DLT_SIZE"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_IA_64_PLT_RESERVE
case|:
return|return
literal|"IA_64_PLT_RESERVE"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_alpha_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_ALPHA_PLTRO
case|:
return|return
literal|"ALPHA_PLTRO"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_score_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_SCORE_BASE_ADDRESS
case|:
return|return
literal|"SCORE_BASE_ADDRESS"
return|;
case|case
name|DT_SCORE_LOCAL_GOTNO
case|:
return|return
literal|"SCORE_LOCAL_GOTNO"
return|;
case|case
name|DT_SCORE_SYMTABNO
case|:
return|return
literal|"SCORE_SYMTABNO"
return|;
case|case
name|DT_SCORE_GOTSYM
case|:
return|return
literal|"SCORE_GOTSYM"
return|;
case|case
name|DT_SCORE_UNREFEXTNO
case|:
return|return
literal|"SCORE_UNREFEXTNO"
return|;
case|case
name|DT_SCORE_HIPAGENO
case|:
return|return
literal|"SCORE_HIPAGENO"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"PREINIT_ARRAYSZ"
return|;
case|case
name|DT_CHECKSUM
case|:
return|return
literal|"CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"MOVESZ"
return|;
case|case
name|DT_FEATURE
case|:
return|return
literal|"FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"SYMINENT"
return|;
comment|/* aka VALRNGHI */
case|case
name|DT_ADDRRNGLO
case|:
return|return
literal|"ADDRRNGLO"
return|;
case|case
name|DT_CONFIG
case|:
return|return
literal|"CONFIG"
return|;
case|case
name|DT_DEPAUDIT
case|:
return|return
literal|"DEPAUDIT"
return|;
case|case
name|DT_AUDIT
case|:
return|return
literal|"AUDIT"
return|;
case|case
name|DT_PLTPAD
case|:
return|return
literal|"PLTPAD"
return|;
case|case
name|DT_MOVETAB
case|:
return|return
literal|"MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"SYMINFO"
return|;
comment|/* aka ADDRRNGHI */
case|case
name|DT_VERSYM
case|:
return|return
literal|"VERSYM"
return|;
case|case
name|DT_TLSDESC_GOT
case|:
return|return
literal|"TLSDESC_GOT"
return|;
case|case
name|DT_TLSDESC_PLT
case|:
return|return
literal|"TLSDESC_PLT"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"VERNEEDNUM"
return|;
case|case
name|DT_AUXILIARY
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
name|DT_USED
case|:
return|return
literal|"USED"
return|;
case|case
name|DT_FILTER
case|:
return|return
literal|"FILTER"
return|;
case|case
name|DT_GNU_PRELINKED
case|:
return|return
literal|"GNU_PRELINKED"
return|;
case|case
name|DT_GNU_CONFLICT
case|:
return|return
literal|"GNU_CONFLICT"
return|;
case|case
name|DT_GNU_CONFLICTSZ
case|:
return|return
literal|"GNU_CONFLICTSZ"
return|;
case|case
name|DT_GNU_LIBLIST
case|:
return|return
literal|"GNU_LIBLIST"
return|;
case|case
name|DT_GNU_LIBLISTSZ
case|:
return|return
literal|"GNU_LIBLISTSZ"
return|;
case|case
name|DT_GNU_HASH
case|:
return|return
literal|"GNU_HASH"
return|;
default|default:
if|if
condition|(
operator|(
name|type
operator|>=
name|DT_LOPROC
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SPARCV9
case|:
name|result
operator|=
name|get_sparc64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
name|result
operator|=
name|get_ppc_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC64
case|:
name|result
operator|=
name|get_ppc64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ALPHA
case|:
name|result
operator|=
name|get_alpha_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SCORE
case|:
name|result
operator|=
name|get_score_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|type
operator|>=
name|DT_LOOS
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIOS
operator|)
operator|)
operator|||
operator|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
operator|&&
operator|(
name|type
operator|>=
name|OLD_DT_LOOS
operator|)
operator|&&
operator|(
name|type
operator|<=
name|OLD_DT_HIOS
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Operating System specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_file_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|ET_NONE
case|:
return|return
name|_
argument_list|(
literal|"NONE (None)"
argument_list|)
return|;
case|case
name|ET_REL
case|:
return|return
name|_
argument_list|(
literal|"REL (Relocatable file)"
argument_list|)
return|;
case|case
name|ET_EXEC
case|:
return|return
name|_
argument_list|(
literal|"EXEC (Executable file)"
argument_list|)
return|;
case|case
name|ET_DYN
case|:
return|return
name|_
argument_list|(
literal|"DYN (Shared object file)"
argument_list|)
return|;
case|case
name|ET_CORE
case|:
return|return
name|_
argument_list|(
literal|"CORE (Core file)"
argument_list|)
return|;
default|default:
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOPROC
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIPROC
operator|)
condition|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOOS
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIOS
operator|)
condition|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"OS Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_name
parameter_list|(
name|unsigned
name|e_machine
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|e_machine
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
name|_
argument_list|(
literal|"None"
argument_list|)
return|;
case|case
name|EM_M32
case|:
return|return
literal|"WE32100"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"Sparc"
return|;
case|case
name|EM_SPU
case|:
return|return
literal|"SPU"
return|;
case|case
name|EM_386
case|:
return|return
literal|"Intel 80386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"MC68000"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"MC88000"
return|;
case|case
name|EM_486
case|:
return|return
literal|"Intel 80486"
return|;
case|case
name|EM_860
case|:
return|return
literal|"Intel 80860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"MIPS R3000"
return|;
case|case
name|EM_S370
case|:
return|return
literal|"IBM System/370"
return|;
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
literal|"MIPS R4000 big-endian"
return|;
case|case
name|EM_OLD_SPARCV9
case|:
return|return
literal|"Sparc v9 (old)"
return|;
case|case
name|EM_PARISC
case|:
return|return
literal|"HPPA"
return|;
case|case
name|EM_PPC_OLD
case|:
return|return
literal|"Power PC (old)"
return|;
case|case
name|EM_SPARC32PLUS
case|:
return|return
literal|"Sparc v8+"
return|;
case|case
name|EM_960
case|:
return|return
literal|"Intel 90860"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"PowerPC"
return|;
case|case
name|EM_PPC64
case|:
return|return
literal|"PowerPC64"
return|;
case|case
name|EM_V800
case|:
return|return
literal|"NEC V800"
return|;
case|case
name|EM_FR20
case|:
return|return
literal|"Fujitsu FR20"
return|;
case|case
name|EM_RH32
case|:
return|return
literal|"TRW RH32"
return|;
case|case
name|EM_MCORE
case|:
return|return
literal|"MCORE"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|EM_OLD_ALPHA
case|:
return|return
literal|"Digital Alpha (old)"
return|;
case|case
name|EM_SH
case|:
return|return
literal|"Renesas / SuperH SH"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"Sparc v9"
return|;
case|case
name|EM_TRICORE
case|:
return|return
literal|"Siemens Tricore"
return|;
case|case
name|EM_ARC
case|:
return|return
literal|"ARC"
return|;
case|case
name|EM_H8_300
case|:
return|return
literal|"Renesas H8/300"
return|;
case|case
name|EM_H8_300H
case|:
return|return
literal|"Renesas H8/300H"
return|;
case|case
name|EM_H8S
case|:
return|return
literal|"Renesas H8S"
return|;
case|case
name|EM_H8_500
case|:
return|return
literal|"Renesas H8/500"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"Intel IA-64"
return|;
case|case
name|EM_MIPS_X
case|:
return|return
literal|"Stanford MIPS-X"
return|;
case|case
name|EM_COLDFIRE
case|:
return|return
literal|"Motorola Coldfire"
return|;
case|case
name|EM_68HC12
case|:
return|return
literal|"Motorola M68HC12"
return|;
case|case
name|EM_ALPHA
case|:
return|return
literal|"Alpha"
return|;
case|case
name|EM_CYGNUS_D10V
case|:
case|case
name|EM_D10V
case|:
return|return
literal|"d10v"
return|;
case|case
name|EM_CYGNUS_D30V
case|:
case|case
name|EM_D30V
case|:
return|return
literal|"d30v"
return|;
case|case
name|EM_CYGNUS_M32R
case|:
case|case
name|EM_M32R
case|:
return|return
literal|"Renesas M32R (formerly Mitsubishi M32r)"
return|;
case|case
name|EM_CYGNUS_V850
case|:
case|case
name|EM_V850
case|:
return|return
literal|"NEC v850"
return|;
case|case
name|EM_CYGNUS_MN10300
case|:
case|case
name|EM_MN10300
case|:
return|return
literal|"mn10300"
return|;
case|case
name|EM_CYGNUS_MN10200
case|:
case|case
name|EM_MN10200
case|:
return|return
literal|"mn10200"
return|;
case|case
name|EM_CYGNUS_FR30
case|:
case|case
name|EM_FR30
case|:
return|return
literal|"Fujitsu FR30"
return|;
case|case
name|EM_CYGNUS_FRV
case|:
return|return
literal|"Fujitsu FR-V"
return|;
case|case
name|EM_PJ_OLD
case|:
case|case
name|EM_PJ
case|:
return|return
literal|"picoJava"
return|;
case|case
name|EM_MMA
case|:
return|return
literal|"Fujitsu Multimedia Accelerator"
return|;
case|case
name|EM_PCP
case|:
return|return
literal|"Siemens PCP"
return|;
case|case
name|EM_NCPU
case|:
return|return
literal|"Sony nCPU embedded RISC processor"
return|;
case|case
name|EM_NDR1
case|:
return|return
literal|"Denso NDR1 microprocesspr"
return|;
case|case
name|EM_STARCORE
case|:
return|return
literal|"Motorola Star*Core processor"
return|;
case|case
name|EM_ME16
case|:
return|return
literal|"Toyota ME16 processor"
return|;
case|case
name|EM_ST100
case|:
return|return
literal|"STMicroelectronics ST100 processor"
return|;
case|case
name|EM_TINYJ
case|:
return|return
literal|"Advanced Logic Corp. TinyJ embedded processor"
return|;
case|case
name|EM_FX66
case|:
return|return
literal|"Siemens FX66 microcontroller"
return|;
case|case
name|EM_ST9PLUS
case|:
return|return
literal|"STMicroelectronics ST9+ 8/16 bit microcontroller"
return|;
case|case
name|EM_ST7
case|:
return|return
literal|"STMicroelectronics ST7 8-bit microcontroller"
return|;
case|case
name|EM_68HC16
case|:
return|return
literal|"Motorola MC68HC16 Microcontroller"
return|;
case|case
name|EM_68HC11
case|:
return|return
literal|"Motorola MC68HC11 Microcontroller"
return|;
case|case
name|EM_68HC08
case|:
return|return
literal|"Motorola MC68HC08 Microcontroller"
return|;
case|case
name|EM_68HC05
case|:
return|return
literal|"Motorola MC68HC05 Microcontroller"
return|;
case|case
name|EM_SVX
case|:
return|return
literal|"Silicon Graphics SVx"
return|;
case|case
name|EM_ST19
case|:
return|return
literal|"STMicroelectronics ST19 8-bit microcontroller"
return|;
case|case
name|EM_VAX
case|:
return|return
literal|"Digital VAX"
return|;
case|case
name|EM_AVR_OLD
case|:
case|case
name|EM_AVR
case|:
return|return
literal|"Atmel AVR 8-bit microcontroller"
return|;
case|case
name|EM_CRIS
case|:
return|return
literal|"Axis Communications 32-bit embedded processor"
return|;
case|case
name|EM_JAVELIN
case|:
return|return
literal|"Infineon Technologies 32-bit embedded cpu"
return|;
case|case
name|EM_FIREPATH
case|:
return|return
literal|"Element 14 64-bit DSP processor"
return|;
case|case
name|EM_ZSP
case|:
return|return
literal|"LSI Logic's 16-bit DSP processor"
return|;
case|case
name|EM_MMIX
case|:
return|return
literal|"Donald Knuth's educational 64-bit processor"
return|;
case|case
name|EM_HUANY
case|:
return|return
literal|"Harvard Universitys's machine-independent object format"
return|;
case|case
name|EM_PRISM
case|:
return|return
literal|"Vitesse Prism"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"Advanced Micro Devices X86-64"
return|;
case|case
name|EM_S390_OLD
case|:
case|case
name|EM_S390
case|:
return|return
literal|"IBM S/390"
return|;
case|case
name|EM_SCORE
case|:
return|return
literal|"SUNPLUS S+Core"
return|;
case|case
name|EM_XSTORMY16
case|:
return|return
literal|"Sanyo Xstormy16 CPU core"
return|;
case|case
name|EM_OPENRISC
case|:
case|case
name|EM_OR32
case|:
return|return
literal|"OpenRISC"
return|;
case|case
name|EM_CRX
case|:
return|return
literal|"National Semiconductor CRX microprocessor"
return|;
case|case
name|EM_DLX
case|:
return|return
literal|"OpenDLX"
return|;
case|case
name|EM_IP2K_OLD
case|:
case|case
name|EM_IP2K
case|:
return|return
literal|"Ubicom IP2xxx 8-bit microcontrollers"
return|;
case|case
name|EM_IQ2000
case|:
return|return
literal|"Vitesse IQ2000"
return|;
case|case
name|EM_XTENSA_OLD
case|:
case|case
name|EM_XTENSA
case|:
return|return
literal|"Tensilica Xtensa Processor"
return|;
case|case
name|EM_M32C
case|:
return|return
literal|"Renesas M32c"
return|;
case|case
name|EM_MT
case|:
return|return
literal|"Morpho Techologies MT processor"
return|;
case|case
name|EM_BLACKFIN
case|:
return|return
literal|"Analog Devices Blackfin"
return|;
case|case
name|EM_NIOS32
case|:
return|return
literal|"Altera Nios"
return|;
case|case
name|EM_ALTERA_NIOS2
case|:
return|return
literal|"Altera Nios II"
return|;
case|case
name|EM_XC16X
case|:
return|return
literal|"Infineon Technologies xc16x"
return|;
case|case
name|EM_CYGNUS_MEP
case|:
return|return
literal|"Toshiba MeP Media Engine"
return|;
default|default:
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: 0x%x"
argument_list|)
argument_list|,
name|e_machine
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ARM_machine_flags
parameter_list|(
name|unsigned
name|e_flags
parameter_list|,
name|char
name|buf
index|[]
parameter_list|)
block|{
name|unsigned
name|eabi
decl_stmt|;
name|int
name|unknown
init|=
literal|0
decl_stmt|;
name|eabi
operator|=
name|EF_ARM_EABI_VERSION
argument_list|(
name|e_flags
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_EABIMASK
expr_stmt|;
comment|/* Handle "generic" ARM flags.  */
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_RELEXEC
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable executable"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_RELEXEC
expr_stmt|;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_HASENTRY
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", has entry point"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_HASENTRY
expr_stmt|;
block|}
comment|/* Now handle EABI specific flags.  */
switch|switch
condition|(
name|eabi
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unrecognized EABI>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version1 EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_SYMSARESORTED
case|:
comment|/* Conflicts with EF_ARM_INTERWORK.  */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sorted symbol tables"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_VER2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version2 EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_SYMSARESORTED
case|:
comment|/* Conflicts with EF_ARM_INTERWORK.  */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sorted symbol tables"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_DYNSYMSUSESEGIDX
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", dynamic symbols use segment index"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_MAPSYMSFIRST
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mapping symbols precede others"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_VER3
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version3 EABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER4
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version4 EABI"
argument_list|)
expr_stmt|;
goto|goto
name|eabi
goto|;
case|case
name|EF_ARM_EABI_VER5
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Version5 EABI"
argument_list|)
expr_stmt|;
name|eabi
label|:
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_BE8
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", BE8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_LE8
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", LE8"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", GNU EABI"
argument_list|)
expr_stmt|;
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_INTERWORK
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", interworking enabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_APCS_26
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/26"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_APCS_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_PIC
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", position independent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_ALIGN8
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 8 bit structure alignment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_NEW_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses new ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_OLD_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses old ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_SOFT_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", software FP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_VFP_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", VFP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_MAVERICK_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", Maverick FP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|unknown
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unknown>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_flags
parameter_list|(
name|unsigned
name|e_flags
parameter_list|,
name|unsigned
name|e_machine
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
default|default:
break|break;
case|case
name|EM_ARM
case|:
name|decode_ARM_machine_flags
argument_list|(
name|e_flags
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_FRV
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_FRV_CPU_MASK
condition|)
block|{
case|case
name|EF_FRV_CPU_GENERIC
case|:
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr???"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR300
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr300"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR400
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR405
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr405"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR450
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr450"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR500
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR550
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fr550"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_SIMPLE
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", simple"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_TOMCAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", tomcat"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_68K
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M68K_ARCH_MASK
operator|)
operator|==
name|EF_M68K_M68000
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", m68000"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M68K_ARCH_MASK
operator|)
operator|==
name|EF_M68K_CPU32
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpu32"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M68K_ARCH_MASK
operator|)
operator|==
name|EF_M68K_FIDO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", fido_a"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
specifier|const
modifier|*
name|isa
init|=
name|_
argument_list|(
literal|"unknown"
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|mac
init|=
name|_
argument_list|(
literal|"unknown mac"
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|additional
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|e_flags
operator|&
name|EF_M68K_CF_ISA_MASK
condition|)
block|{
case|case
name|EF_M68K_CF_ISA_A_NODIV
case|:
name|isa
operator|=
literal|"A"
expr_stmt|;
name|additional
operator|=
literal|", nodiv"
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_ISA_A
case|:
name|isa
operator|=
literal|"A"
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_ISA_A_PLUS
case|:
name|isa
operator|=
literal|"A+"
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_ISA_B_NOUSP
case|:
name|isa
operator|=
literal|"B"
expr_stmt|;
name|additional
operator|=
literal|", nousp"
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_ISA_B
case|:
name|isa
operator|=
literal|"B"
expr_stmt|;
break|break;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cf, isa "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|additional
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|additional
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_M68K_CF_FLOAT
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", float"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e_flags
operator|&
name|EF_M68K_CF_MAC_MASK
condition|)
block|{
case|case
literal|0
case|:
name|mac
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_MAC
case|:
name|mac
operator|=
literal|"mac"
expr_stmt|;
break|break;
case|case
name|EF_M68K_CF_EMAC
case|:
name|mac
operator|=
literal|"emac"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mac
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EM_PPC
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_EMB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", emb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable-lib"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_V850
case|:
case|case
name|EM_CYGNUS_V850
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_V850_ARCH
condition|)
block|{
case|case
name|E_V850E1_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850e1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850E_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850e"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown v850 architecture variant"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_M32R
case|:
case|case
name|EM_CYGNUS_M32R
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|==
name|E_M32R_ARCH
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", m32r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_NOREORDER
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", noreorder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_CPIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_UCODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ugen_reserved"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ABI2
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", abi2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_OPTIONS_FIRST
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", odk first"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_32BITMODE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 32bitmode"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_MACH
operator|)
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 3900"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4010
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4010"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4100
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4100"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4111
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4111"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4120
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4120"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4650
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4650"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_5400
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 5400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_5500
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 5500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_SB1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sb1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_9000
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 9000"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We simply ignore the field in this case to avoid confusion: 	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU 	       extension.  */
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown CPU"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
block|{
case|case
name|E_MIPS_ABI_O32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", o32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_O64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", o64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", eabi32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ABI_EABI64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", eabi64"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* We simply ignore the field in this case to avoid confusion: 	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension. 	       This means it is likely to be an o32 file, but not for 	       sure.  */
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown ABI"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_MDMX
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mdmx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_M16
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips16"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
condition|)
block|{
case|case
name|E_MIPS_ARCH_1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_3
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_4
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_5
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_32
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_32R2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32r2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_64
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_ARCH_64R2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips64r2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown ISA"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_SH
case|:
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_SH_MACH_MASK
operator|)
condition|)
block|{
case|case
name|EF_SH1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh3"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH_DSP
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh-dsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3_DSP
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh3-dsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4AL_DSP
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4al-dsp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3E
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh3e"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH5
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2E
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2e"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4A
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4a"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4-nofpu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4A_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4a-nofpu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a-nofpu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH3_NOMMU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh3-nommu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH4_NOMMU_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh4-nommu-nofpu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A_SH4_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a-nofpu-or-sh4-nommu-nofpu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A_SH3_NOFPU
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a-nofpu-or-sh3-nommu"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A_SH4
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a-or-sh4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SH2A_SH3E
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sh2a-or-sh3e"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown ISA"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_SPARCV9
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_32PLUS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v8+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcIII"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_HAL_R1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", halr1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_LEDATA
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ledata"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_TSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", tso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_PSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_RMO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", rmo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_PARISC_ARCH
condition|)
block|{
case|case
name|EFA_PARISC_1_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_1_1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_2_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 2.0"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_TRAPNIL
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", trapnil"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_EXT
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ext"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LSB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lsb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_WIDE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_NO_KABP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no kabp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LAZYSWAP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lazyswap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
case|case
name|EM_PJ_OLD
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_NEWCALLS
operator|)
operator|==
name|EF_PICOJAVA_NEWCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", new calling convention"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_GNUCALLS
operator|)
operator|==
name|EF_PICOJAVA_GNUCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", gnu calling convention"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 64-bit"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 32-bit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", reduced fp model"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no function descriptors, constant gp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", constant gp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABSOLUTE
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", absolute"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_VAX
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_NONPIC
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", non-PIC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_DFLOAT
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", D-Float"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_VAX_GFLOAT
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", G-Float"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_osabi_name
parameter_list|(
name|unsigned
name|int
name|osabi
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|osabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
return|return
literal|"UNIX - System V"
return|;
case|case
name|ELFOSABI_HPUX
case|:
return|return
literal|"UNIX - HP-UX"
return|;
case|case
name|ELFOSABI_NETBSD
case|:
return|return
literal|"UNIX - NetBSD"
return|;
case|case
name|ELFOSABI_LINUX
case|:
return|return
literal|"UNIX - Linux"
return|;
case|case
name|ELFOSABI_HURD
case|:
return|return
literal|"GNU/Hurd"
return|;
case|case
name|ELFOSABI_SOLARIS
case|:
return|return
literal|"UNIX - Solaris"
return|;
case|case
name|ELFOSABI_AIX
case|:
return|return
literal|"UNIX - AIX"
return|;
case|case
name|ELFOSABI_IRIX
case|:
return|return
literal|"UNIX - IRIX"
return|;
case|case
name|ELFOSABI_FREEBSD
case|:
return|return
literal|"UNIX - FreeBSD"
return|;
case|case
name|ELFOSABI_TRU64
case|:
return|return
literal|"UNIX - TRU64"
return|;
case|case
name|ELFOSABI_MODESTO
case|:
return|return
literal|"Novell - Modesto"
return|;
case|case
name|ELFOSABI_OPENBSD
case|:
return|return
literal|"UNIX - OpenBSD"
return|;
case|case
name|ELFOSABI_OPENVMS
case|:
return|return
literal|"VMS - OpenVMS"
return|;
case|case
name|ELFOSABI_NSK
case|:
return|return
literal|"HP - Non-Stop Kernel"
return|;
case|case
name|ELFOSABI_AROS
case|:
return|return
literal|"Amiga Research OS"
return|;
case|case
name|ELFOSABI_STANDALONE
case|:
return|return
name|_
argument_list|(
literal|"Standalone App"
argument_list|)
return|;
case|case
name|ELFOSABI_ARM
case|:
return|return
literal|"ARM"
return|;
default|default:
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|osabi
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_arm_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_ARM_EXIDX
case|:
return|return
literal|"EXIDX"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_MIPS_REGINFO
case|:
return|return
literal|"REGINFO"
return|;
case|case
name|PT_MIPS_RTPROC
case|:
return|return
literal|"RTPROC"
return|;
case|case
name|PT_MIPS_OPTIONS
case|:
return|return
literal|"OPTIONS"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_HP_TLS
case|:
return|return
literal|"HP_TLS"
return|;
case|case
name|PT_HP_CORE_NONE
case|:
return|return
literal|"HP_CORE_NONE"
return|;
case|case
name|PT_HP_CORE_VERSION
case|:
return|return
literal|"HP_CORE_VERSION"
return|;
case|case
name|PT_HP_CORE_KERNEL
case|:
return|return
literal|"HP_CORE_KERNEL"
return|;
case|case
name|PT_HP_CORE_COMM
case|:
return|return
literal|"HP_CORE_COMM"
return|;
case|case
name|PT_HP_CORE_PROC
case|:
return|return
literal|"HP_CORE_PROC"
return|;
case|case
name|PT_HP_CORE_LOADABLE
case|:
return|return
literal|"HP_CORE_LOADABLE"
return|;
case|case
name|PT_HP_CORE_STACK
case|:
return|return
literal|"HP_CORE_STACK"
return|;
case|case
name|PT_HP_CORE_SHM
case|:
return|return
literal|"HP_CORE_SHM"
return|;
case|case
name|PT_HP_CORE_MMF
case|:
return|return
literal|"HP_CORE_MMF"
return|;
case|case
name|PT_HP_PARALLEL
case|:
return|return
literal|"HP_PARALLEL"
return|;
case|case
name|PT_HP_FASTBIND
case|:
return|return
literal|"HP_FASTBIND"
return|;
case|case
name|PT_HP_OPT_ANNOT
case|:
return|return
literal|"HP_OPT_ANNOT"
return|;
case|case
name|PT_HP_HSL_ANNOT
case|:
return|return
literal|"HP_HSL_ANNOT"
return|;
case|case
name|PT_HP_STACK
case|:
return|return
literal|"HP_STACK"
return|;
case|case
name|PT_HP_CORE_UTSNAME
case|:
return|return
literal|"HP_CORE_UTSNAME"
return|;
case|case
name|PT_PARISC_ARCHEXT
case|:
return|return
literal|"PARISC_ARCHEXT"
return|;
case|case
name|PT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
case|case
name|PT_PARISC_WEAKORDER
case|:
return|return
literal|"PARISC_WEAKORDER"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_segment_type
parameter_list|(
name|unsigned
name|long
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_IA_64_ARCHEXT
case|:
return|return
literal|"IA_64_ARCHEXT"
return|;
case|case
name|PT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
case|case
name|PT_HP_TLS
case|:
return|return
literal|"HP_TLS"
return|;
case|case
name|PT_IA_64_HP_OPT_ANOT
case|:
return|return
literal|"HP_OPT_ANNOT"
return|;
case|case
name|PT_IA_64_HP_HSL_ANOT
case|:
return|return
literal|"HP_HSL_ANNOT"
return|;
case|case
name|PT_IA_64_HP_STACK
case|:
return|return
literal|"HP_STACK"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_segment_type
parameter_list|(
name|unsigned
name|long
name|p_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|PT_LOAD
case|:
return|return
literal|"LOAD"
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|PT_INTERP
case|:
return|return
literal|"INTERP"
return|;
case|case
name|PT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|PT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|PT_PHDR
case|:
return|return
literal|"PHDR"
return|;
case|case
name|PT_TLS
case|:
return|return
literal|"TLS"
return|;
case|case
name|PT_GNU_EH_FRAME
case|:
return|return
literal|"GNU_EH_FRAME"
return|;
case|case
name|PT_GNU_STACK
case|:
return|return
literal|"GNU_STACK"
return|;
case|case
name|PT_GNU_RELRO
case|:
return|return
literal|"GNU_RELRO"
return|;
default|default:
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOPROC
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_ARM
case|:
name|result
operator|=
name|get_arm_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOPROC+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOOS
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIOS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOOS+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOOS
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|p_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|SHT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|SHT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|SHT_MIPS_GPTAB
case|:
return|return
literal|"MIPS_GPTAB"
return|;
case|case
name|SHT_MIPS_UCODE
case|:
return|return
literal|"MIPS_UCODE"
return|;
case|case
name|SHT_MIPS_DEBUG
case|:
return|return
literal|"MIPS_DEBUG"
return|;
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_PACKAGE
case|:
return|return
literal|"MIPS_PACKAGE"
return|;
case|case
name|SHT_MIPS_PACKSYM
case|:
return|return
literal|"MIPS_PACKSYM"
return|;
case|case
name|SHT_MIPS_RELD
case|:
return|return
literal|"MIPS_RELD"
return|;
case|case
name|SHT_MIPS_IFACE
case|:
return|return
literal|"MIPS_IFACE"
return|;
case|case
name|SHT_MIPS_CONTENT
case|:
return|return
literal|"MIPS_CONTENT"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_SHDR
case|:
return|return
literal|"MIPS_SHDR"
return|;
case|case
name|SHT_MIPS_FDESC
case|:
return|return
literal|"MIPS_FDESC"
return|;
case|case
name|SHT_MIPS_EXTSYM
case|:
return|return
literal|"MIPS_EXTSYM"
return|;
case|case
name|SHT_MIPS_DENSE
case|:
return|return
literal|"MIPS_DENSE"
return|;
case|case
name|SHT_MIPS_PDESC
case|:
return|return
literal|"MIPS_PDESC"
return|;
case|case
name|SHT_MIPS_LOCSYM
case|:
return|return
literal|"MIPS_LOCSYM"
return|;
case|case
name|SHT_MIPS_AUXSYM
case|:
return|return
literal|"MIPS_AUXSYM"
return|;
case|case
name|SHT_MIPS_OPTSYM
case|:
return|return
literal|"MIPS_OPTSYM"
return|;
case|case
name|SHT_MIPS_LOCSTR
case|:
return|return
literal|"MIPS_LOCSTR"
return|;
case|case
name|SHT_MIPS_LINE
case|:
return|return
literal|"MIPS_LINE"
return|;
case|case
name|SHT_MIPS_RFDESC
case|:
return|return
literal|"MIPS_RFDESC"
return|;
case|case
name|SHT_MIPS_DELTASYM
case|:
return|return
literal|"MIPS_DELTASYM"
return|;
case|case
name|SHT_MIPS_DELTAINST
case|:
return|return
literal|"MIPS_DELTAINST"
return|;
case|case
name|SHT_MIPS_DELTACLASS
case|:
return|return
literal|"MIPS_DELTACLASS"
return|;
case|case
name|SHT_MIPS_DWARF
case|:
return|return
literal|"MIPS_DWARF"
return|;
case|case
name|SHT_MIPS_DELTADECL
case|:
return|return
literal|"MIPS_DELTADECL"
return|;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|SHT_MIPS_EVENTS
case|:
return|return
literal|"MIPS_EVENTS"
return|;
case|case
name|SHT_MIPS_TRANSLATE
case|:
return|return
literal|"MIPS_TRANSLATE"
return|;
case|case
name|SHT_MIPS_PIXIE
case|:
return|return
literal|"MIPS_PIXIE"
return|;
case|case
name|SHT_MIPS_XLATE
case|:
return|return
literal|"MIPS_XLATE"
return|;
case|case
name|SHT_MIPS_XLATE_DEBUG
case|:
return|return
literal|"MIPS_XLATE_DEBUG"
return|;
case|case
name|SHT_MIPS_WHIRL
case|:
return|return
literal|"MIPS_WHIRL"
return|;
case|case
name|SHT_MIPS_EH_REGION
case|:
return|return
literal|"MIPS_EH_REGION"
return|;
case|case
name|SHT_MIPS_XLATE_OLD
case|:
return|return
literal|"MIPS_XLATE_OLD"
return|;
case|case
name|SHT_MIPS_PDR_EXCEPTION
case|:
return|return
literal|"MIPS_PDR_EXCEPTION"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_PARISC_EXT
case|:
return|return
literal|"PARISC_EXT"
return|;
case|case
name|SHT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
case|case
name|SHT_PARISC_DOC
case|:
return|return
literal|"PARISC_DOC"
return|;
case|case
name|SHT_PARISC_ANNOT
case|:
return|return
literal|"PARISC_ANNOT"
return|;
case|case
name|SHT_PARISC_SYMEXTN
case|:
return|return
literal|"PARISC_SYMEXTN"
return|;
case|case
name|SHT_PARISC_STUBS
case|:
return|return
literal|"PARISC_STUBS"
return|;
case|case
name|SHT_PARISC_DLKM
case|:
return|return
literal|"PARISC_DLKM"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
comment|/* If the top 8 bits are 0x78 the next 8 are the os/abi ID.  */
if|if
condition|(
operator|(
name|sh_type
operator|&
literal|0xFF000000
operator|)
operator|==
name|SHT_IA_64_LOPSREG
condition|)
return|return
name|get_osabi_name
argument_list|(
operator|(
name|sh_type
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
argument_list|)
return|;
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_EXT
case|:
return|return
literal|"IA_64_EXT"
return|;
case|case
name|SHT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
case|case
name|SHT_IA_64_PRIORITY_INIT
case|:
return|return
literal|"IA_64_PRIORITY_INIT"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_x86_64_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_X86_64_UNWIND
case|:
return|return
literal|"X86_64_UNWIND"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_arm_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_ARM_EXIDX
case|:
return|return
literal|"ARM_EXIDX"
return|;
case|case
name|SHT_ARM_PREEMPTMAP
case|:
return|return
literal|"ARM_PREEMPTMAP"
return|;
case|case
name|SHT_ARM_ATTRIBUTES
case|:
return|return
literal|"ARM_ATTRIBUTES"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_section_type_name
parameter_list|(
name|unsigned
name|int
name|sh_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|SHT_GNU_HASH
case|:
return|return
literal|"GNU_HASH"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SYMTAB SECTION INDICIES"
return|;
case|case
name|SHT_GNU_verdef
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|SHT_GNU_verneed
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|SHT_GNU_versym
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffff0
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffffc
case|:
return|return
literal|"VERDEF"
return|;
case|case
literal|0x7ffffffd
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"FILTER"
return|;
case|case
name|SHT_GNU_LIBLIST
case|:
return|return
literal|"GNU_LIBLIST"
return|;
default|default:
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOPROC
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_X86_64
case|:
name|result
operator|=
name|get_x86_64_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARM
case|:
name|result
operator|=
name|get_arm_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOPROC+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOOS
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIOS
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOOS+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOOS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOUSER
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIUSER
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOUSER+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOUSER
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|sh_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OPTION_DEBUG_DUMP
value|512
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"file-header"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"program-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"histogram"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"segments"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"sections"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-groups"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"section-details"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"full-section-name"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"symbols"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"relocs"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"notes"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"arch-specific"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"version-info"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"use-dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"hex-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"debug-dump"
block|,
name|optional_argument
block|,
literal|0
block|,
name|OPTION_DEBUG_DUMP
block|}
block|,
block|{
literal|"unwind"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
block|{
literal|"instruction-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
endif|#
directive|endif
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"wide"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: readelf<option(s)> elf-file(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Display information about the contents of ELF format files\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Options are:\n\   -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n\   -h --file-header       Display the ELF file header\n\   -l --program-headers   Display the program headers\n\      --segments          An alias for --program-headers\n\   -S --section-headers   Display the sections' header\n\      --sections          An alias for --section-headers\n\   -g --section-groups    Display the section groups\n\   -t --section-details   Display the section details\n\   -e --headers           Equivalent to: -h -l -S\n\   -s --syms              Display the symbol table\n\       --symbols          An alias for --syms\n\   -n --notes             Display the core notes (if present)\n\   -r --relocs            Display the relocations (if present)\n\   -u --unwind            Display the unwind info (if present)\n\   -d --dynamic           Display the dynamic section (if present)\n\   -V --version-info      Display the version sections (if present)\n\   -A --arch-specific     Display architecture specific information (if any).\n\   -D --use-dynamic       Use the dynamic section info when displaying symbols\n\   -x --hex-dump=<number> Dump the contents of section<number>\n\   -w[liaprmfFsoR] or\n\   --debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=str,=loc,=Ranges]\n\                          Display the contents of DWARF2 debug sections\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -i --instruction-dump=<number>\n\                          Disassemble the contents of section<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -I --histogram         Display histogram of bucket list lengths\n\   -W --wide              Allow output width to exceed 80 characters\n\   @<file>                Read options from<file>\n\   -H --help              Display this information\n\   -v --version           Display the version number of readelf\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
operator|&&
name|stream
operator|==
name|stdout
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|stream
operator|==
name|stdout
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the fact that the user wants the contents of section number    SECTION to be displayed using the method(s) encoded as flags bits    in TYPE.  Note, TYPE can be zero if we are creating the array for    the first time.  */
end_comment

begin_function
specifier|static
name|void
name|request_dump
parameter_list|(
name|unsigned
name|int
name|section
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|section
operator|>=
name|num_dump_sects
condition|)
block|{
name|char
modifier|*
name|new_dump_sects
decl_stmt|;
name|new_dump_sects
operator|=
name|calloc
argument_list|(
name|section
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dump_sects
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Copy current flag settings.  */
name|memcpy
argument_list|(
name|new_dump_sects
argument_list|,
name|dump_sects
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
name|dump_sects
operator|=
name|new_dump_sects
expr_stmt|;
name|num_dump_sects
operator|=
name|section
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_sects
condition|)
name|dump_sects
index|[
name|section
index|]
operator||=
name|type
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Request a dump by section name.  */
end_comment

begin_function
specifier|static
name|void
name|request_dump_byname
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|dump_list_entry
modifier|*
name|new_request
decl_stmt|;
name|new_request
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dump_list_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_request
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|new_request
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_request
operator|->
name|name
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|new_request
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_request
operator|->
name|next
operator|=
name|dump_sects_byname
expr_stmt|;
name|dump_sects_byname
operator|=
name|new_request
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ersuahnldSDAINtgw::x:i:vVWH"
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|section
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long options.  */
break|break;
case|case
literal|'H'
case|:
name|usage
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|do_syms
operator|++
expr_stmt|;
name|do_reloc
operator|++
expr_stmt|;
name|do_unwind
operator|++
expr_stmt|;
name|do_dynamic
operator|++
expr_stmt|;
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_section_groups
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
name|do_version
operator|++
expr_stmt|;
name|do_histogram
operator|++
expr_stmt|;
name|do_arch
operator|++
expr_stmt|;
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|do_section_groups
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'N'
case|:
name|do_sections
operator|++
expr_stmt|;
name|do_section_details
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|do_arch
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_using_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|do_reloc
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|do_unwind
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|do_header
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|do_syms
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_sections
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|do_histogram
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
name|request_dump
argument_list|(
name|section
argument_list|,
name|HEX_DUMP
argument_list|)
expr_stmt|;
else|else
name|request_dump_byname
argument_list|(
name|optarg
argument_list|,
name|HEX_DUMP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|do_dump
operator|++
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
literal|0
condition|)
name|do_debugging
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
name|do_debugging
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|optarg
index|[
name|index
index|]
condition|)
switch|switch
condition|(
name|optarg
index|[
name|index
operator|++
index|]
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|do_debug_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|do_debug_abbrevs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|do_debug_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|do_debug_pubnames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|do_debug_aranges
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|do_debug_ranges
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|do_debug_frames_interp
operator|=
literal|1
expr_stmt|;
case|case
literal|'f'
case|:
name|do_debug_frames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|do_debug_macinfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|do_debug_str
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|do_debug_loc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug option '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|OPTION_DEBUG_DUMP
case|:
name|do_dump
operator|++
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
literal|0
condition|)
name|do_debugging
operator|=
literal|1
expr_stmt|;
else|else
block|{
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
block|}
name|debug_dump_long_opts
typedef|;
name|debug_dump_long_opts
name|opts_table
index|[]
init|=
block|{
comment|/* Please keep this table alpha- sorted.  */
block|{
literal|"Ranges"
block|,
operator|&
name|do_debug_ranges
block|}
block|,
block|{
literal|"abbrev"
block|,
operator|&
name|do_debug_abbrevs
block|}
block|,
block|{
literal|"aranges"
block|,
operator|&
name|do_debug_aranges
block|}
block|,
block|{
literal|"frames"
block|,
operator|&
name|do_debug_frames
block|}
block|,
block|{
literal|"frames-interp"
block|,
operator|&
name|do_debug_frames_interp
block|}
block|,
block|{
literal|"info"
block|,
operator|&
name|do_debug_info
block|}
block|,
block|{
literal|"line"
block|,
operator|&
name|do_debug_lines
block|}
block|,
block|{
literal|"loc"
block|,
operator|&
name|do_debug_loc
block|}
block|,
block|{
literal|"macro"
block|,
operator|&
name|do_debug_macinfo
block|}
block|,
block|{
literal|"pubnames"
block|,
operator|&
name|do_debug_pubnames
block|}
block|,
comment|/* This entry is for compatability 		     with earlier versions of readelf.  */
block|{
literal|"ranges"
block|,
operator|&
name|do_debug_aranges
block|}
block|,
block|{
literal|"str"
block|,
operator|&
name|do_debug_str
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|do_debugging
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|optarg
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|debug_dump_long_opts
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|opts_table
init|;
name|entry
operator|->
name|option
condition|;
name|entry
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|entry
operator|->
name|option
argument_list|)
decl_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|p
argument_list|,
name|entry
operator|->
name|option
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|','
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|entry
operator|->
name|variable
operator|=
literal|1
expr_stmt|;
comment|/* The --debug-dump=frames-interp option also 			     enables the --debug-dump=frames option.  */
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|do_debug_frames
operator|=
literal|1
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|option
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug option '%s'\n"
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
case|case
literal|'i'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
block|{
name|request_dump
argument_list|(
name|section
argument_list|,
name|DISASS_DUMP
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|oops
goto|;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|print_version
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|do_version
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|do_wide
operator|++
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
name|oops
label|:
endif|#
directive|endif
comment|/* xgettext:c-format */
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid option '-%c'\n"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|do_dynamic
operator|&&
operator|!
name|do_syms
operator|&&
operator|!
name|do_reloc
operator|&&
operator|!
name|do_unwind
operator|&&
operator|!
name|do_sections
operator|&&
operator|!
name|do_segments
operator|&&
operator|!
name|do_header
operator|&&
operator|!
name|do_dump
operator|&&
operator|!
name|do_version
operator|&&
operator|!
name|do_histogram
operator|&&
operator|!
name|do_debugging
operator|&&
operator|!
name|do_arch
operator|&&
operator|!
name|do_notes
operator|&&
operator|!
name|do_section_groups
condition|)
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Nothing to do.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_class
parameter_list|(
name|unsigned
name|int
name|elf_class
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|elf_class
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFCLASS32
case|:
return|return
literal|"ELF32"
return|;
case|case
name|ELFCLASS64
case|:
return|return
literal|"ELF64"
return|;
default|default:
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|elf_class
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_data_encoding
parameter_list|(
name|unsigned
name|int
name|encoding
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|ELFDATANONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFDATA2LSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, little endian"
argument_list|)
return|;
case|case
name|ELFDATA2MSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, big endian"
argument_list|)
return|;
default|default:
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the data held in 'elf_header'.  */
end_comment

begin_function
specifier|static
name|int
name|process_file_header
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not an ELF file - it has the wrong magic bytes at the start\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_header
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"ELF Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Magic:   "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EI_NIDENT
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%2.2x "
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Class:                             %s\n"
argument_list|)
argument_list|,
name|get_elf_class
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Data:                              %s\n"
argument_list|)
argument_list|,
name|get_data_encoding
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           %d %s\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|,
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|==
name|EV_CURRENT
condition|?
literal|"(current)"
else|:
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_NONE
condition|?
literal|"<unknown: %lx>"
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  OS/ABI:                            %s\n"
argument_list|)
argument_list|,
name|get_osabi_name
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  ABI Version:                       %d\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type:                              %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Machine:                           %s\n"
argument_list|)
argument_list|,
name|get_machine_name
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           0x%lx\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry point address:               "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n  Start of program headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n  Start of section headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags:                             0x%lx%s\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_flags
argument_list|,
name|get_machine_flags
argument_list|(
name|elf_header
operator|.
name|e_flags
argument_list|,
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of this header:               %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of program headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of program headers:         %ld\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of section headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of section headers:         %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|!=
name|NULL
operator|&&
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Section header string table index: %ld"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|!=
name|NULL
operator|&&
name|elf_header
operator|.
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
name|printf
argument_list|(
literal|" (%ld)"
argument_list|,
operator|(
name|long
operator|)
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_shstrndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|elf_header
operator|.
name|e_shstrndx
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
operator|(
name|elf_header
operator|.
name|e_shstrndx
operator|>=
name|SHN_LORESERVE
operator|&&
name|elf_header
operator|.
name|e_shstrndx
operator|<=
name|SHN_HIRESERVE
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"<corrupt: out of range>"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section_headers
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
name|elf_header
operator|.
name|e_shnum
operator|=
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|section_headers
index|[
literal|0
index|]
operator|.
name|sh_link
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_shstrndx
operator|!=
name|SHN_UNDEF
operator|&&
operator|(
name|elf_header
operator|.
name|e_shstrndx
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
operator|(
name|elf_header
operator|.
name|e_shstrndx
operator|>=
name|SHN_LORESERVE
operator|&&
name|elf_header
operator|.
name|e_shstrndx
operator|<=
name|SHN_HIRESERVE
operator|)
operator|)
condition|)
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|free
argument_list|(
name|section_headers
argument_list|)
expr_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|program_headers
parameter_list|)
block|{
name|Elf32_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf32_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|phdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
argument_list|,
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|_
argument_list|(
literal|"program headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phdrs
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|program_headers
parameter_list|)
block|{
name|Elf64_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf64_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|phdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
argument_list|,
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|_
argument_list|(
literal|"program headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phdrs
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the program headers were read into `program_headers'.  */
end_comment

begin_function
specifier|static
name|int
name|get_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdrs
decl_stmt|;
comment|/* Check cache of prior read.  */
if|if
condition|(
name|program_headers
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
name|phdrs
operator|=
name|cmalloc
argument_list|(
name|elf_header
operator|.
name|e_phnum
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdrs
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|?
name|get_32bit_program_headers
argument_list|(
name|file
argument_list|,
name|phdrs
argument_list|)
else|:
name|get_64bit_program_headers
argument_list|(
name|file
argument_list|,
name|phdrs
argument_list|)
condition|)
block|{
name|program_headers
operator|=
name|phdrs
expr_stmt|;
return|return
literal|1
return|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the program headers were loaded.  */
end_comment

begin_function
specifier|static
name|int
name|process_program_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no program headers in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_segments
operator|&&
operator|!
name|do_header
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nElf file type is %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Entry point "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are %d program headers, starting at offset "
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|do_segments
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|>
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nProgram Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nProgram Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset             VirtAddr           PhysAddr\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"                 FileSiz            MemSiz              Flags  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dynamic_addr
operator|=
literal|0
expr_stmt|;
name|dynamic_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|do_segments
condition|)
block|{
name|printf
argument_list|(
literal|"  %-14.14s "
argument_list|,
name|get_segment_type
argument_list|(
name|segment
operator|->
name|p_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c%c "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_wide
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
operator|==
name|segment
operator|->
name|p_offset
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|print_vma
argument_list|(
name|segment
operator|->
name|p_vaddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_paddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
operator|==
name|segment
operator|->
name|p_filesz
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_filesz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
operator|==
name|segment
operator|->
name|p_memsz
condition|)
name|printf
argument_list|(
literal|"0x%6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %c%c%c "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
operator|==
name|segment
operator|->
name|p_align
condition|)
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_align
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_vaddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_paddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                 "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_filesz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_memsz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %c%c%c    "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_align
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|segment
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_DYNAMIC
case|:
if|if
condition|(
name|dynamic_addr
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"more than one dynamic segment\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to locate the .dynamic section. If there is 	     a section header table, we can easily locate it.  */
if|if
condition|(
name|section_headers
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|find_section
argument_list|(
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|sh_size
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"no .dynamic section in the dynamic segment\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
break|break;
name|dynamic_addr
operator|=
name|sec
operator|->
name|sh_offset
expr_stmt|;
name|dynamic_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|dynamic_addr
operator|<
name|segment
operator|->
name|p_offset
operator|||
name|dynamic_addr
operator|>
name|segment
operator|->
name|p_offset
operator|+
name|segment
operator|->
name|p_filesz
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"the .dynamic section is not contained within the dynamic segment\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dynamic_addr
operator|>
name|segment
operator|->
name|p_offset
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"the .dynamic section is not the first section in the dynamic segment.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we can only assume that the .dynamic 		 section is the first section in the DYNAMIC segment.  */
name|dynamic_addr
operator|=
name|segment
operator|->
name|p_offset
expr_stmt|;
name|dynamic_size
operator|=
name|segment
operator|->
name|p_filesz
expr_stmt|;
block|}
break|break;
case|case
name|PT_INTERP
case|:
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|archive_file_offset
operator|+
operator|(
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to find program interpreter name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|fmt
index|[
literal|32
index|]
decl_stmt|;
name|int
name|ret
init|=
name|snprintf
argument_list|(
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|,
literal|"%%%ds"
argument_list|,
name|PATH_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|||
name|ret
operator|<
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Internal error: failed to create format string to display program interpreter\n"
argument_list|)
argument_list|)
expr_stmt|;
name|program_interpreter
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fscanf
argument_list|(
name|file
argument_list|,
name|fmt
argument_list|,
name|program_interpreter
argument_list|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read program interpreter name\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n      [Requesting program interpreter: %s]"
argument_list|)
argument_list|,
name|program_interpreter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|do_segments
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_segments
operator|&&
name|section_headers
operator|!=
name|NULL
operator|&&
name|string_table
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Section to Segment mapping:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Segment Sections...\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|segment
operator|=
name|program_headers
operator|+
name|i
expr_stmt|;
name|section
operator|=
name|section_headers
expr_stmt|;
name|printf
argument_list|(
literal|"   %2.2d     "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|j
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|ELF_IS_SECTION_IN_SEGMENT_MEMORY
argument_list|(
name|section
argument_list|,
name|segment
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find the file offset corresponding to VMA by using the program headers.  */
end_comment

begin_function
specifier|static
name|long
name|offset_from_vma
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|bfd_vma
name|vma
parameter_list|,
name|bfd_size_type
name|size
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|seg
decl_stmt|;
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Cannot interpret virtual addresses without program headers.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|vma
return|;
block|}
for|for
control|(
name|seg
operator|=
name|program_headers
init|;
name|seg
operator|<
name|program_headers
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|vma
operator|>=
operator|(
name|seg
operator|->
name|p_vaddr
operator|&
operator|-
name|seg
operator|->
name|p_align
operator|)
operator|&&
name|vma
operator|+
name|size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_filesz
condition|)
return|return
name|vma
operator|-
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_offset
return|;
block|}
name|warn
argument_list|(
name|_
argument_list|(
literal|"Virtual address 0x%lx not located in any PT_LOAD segment.\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
return|return
operator|(
name|long
operator|)
name|vma
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|Elf32_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|shdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
argument_list|,
name|num
argument_list|,
name|_
argument_list|(
literal|"section headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shdrs
condition|)
return|return
literal|0
return|;
name|section_headers
operator|=
name|cmalloc
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|)
block|{
name|Elf64_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|shdrs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
argument_list|,
name|num
argument_list|,
name|_
argument_list|(
literal|"section headers"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shdrs
condition|)
return|return
literal|0
return|;
name|section_headers
operator|=
name|cmalloc
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_32bit_elf_symbols
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|)
block|{
name|unsigned
name|long
name|number
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|esyms
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symbols"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esyms
condition|)
return|return
name|NULL
return|;
name|shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_shndx_hdr
operator|->
name|sh_link
operator|==
operator|(
name|unsigned
name|long
operator|)
name|SECTION_HEADER_NUM
argument_list|(
name|section
operator|-
name|section_headers
argument_list|)
operator|)
condition|)
block|{
name|shndx
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symtab shndx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shndx
condition|)
block|{
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|number
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|isyms
operator|=
name|cmalloc
argument_list|(
name|number
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_XINDEX
operator|&&
name|shndx
operator|!=
name|NULL
condition|)
name|psym
operator|->
name|st_shndx
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|shndx
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|shndx
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_64bit_elf_symbols
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|)
block|{
name|unsigned
name|long
name|number
decl_stmt|;
name|Elf64_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|esyms
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symbols"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esyms
condition|)
return|return
name|NULL
return|;
name|shndx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
operator|&&
operator|(
name|symtab_shndx_hdr
operator|->
name|sh_link
operator|==
operator|(
name|unsigned
name|long
operator|)
name|SECTION_HEADER_NUM
argument_list|(
name|section
operator|-
name|section_headers
argument_list|)
operator|)
condition|)
block|{
name|shndx
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|symtab_shndx_hdr
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"symtab shndx"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shndx
condition|)
block|{
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|number
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|isyms
operator|=
name|cmalloc
argument_list|(
name|number
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_shndx
operator|==
name|SHN_XINDEX
operator|&&
name|shndx
operator|!=
name|NULL
condition|)
name|psym
operator|->
name|st_shndx
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|shndx
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|shndx
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shndx
condition|)
name|free
argument_list|(
name|shndx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_section_flags
parameter_list|(
name|bfd_vma
name|sh_flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buff
decl_stmt|;
name|int
name|field_size
init|=
name|is_32bit_elf
condition|?
literal|8
else|:
literal|16
decl_stmt|;
name|int
name|index
decl_stmt|,
name|size
init|=
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
operator|(
name|field_size
operator|+
literal|4
operator|+
literal|1
operator|)
decl_stmt|;
name|bfd_vma
name|os_flags
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|proc_flags
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|unknown_flags
init|=
literal|0
decl_stmt|;
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|flags
index|[]
init|=
block|{
block|{
literal|"WRITE"
block|,
literal|5
block|}
block|,
block|{
literal|"ALLOC"
block|,
literal|5
block|}
block|,
block|{
literal|"EXEC"
block|,
literal|4
block|}
block|,
block|{
literal|"MERGE"
block|,
literal|5
block|}
block|,
block|{
literal|"STRINGS"
block|,
literal|7
block|}
block|,
block|{
literal|"INFO LINK"
block|,
literal|9
block|}
block|,
block|{
literal|"LINK ORDER"
block|,
literal|10
block|}
block|,
block|{
literal|"OS NONCONF"
block|,
literal|10
block|}
block|,
block|{
literal|"GROUP"
block|,
literal|5
block|}
block|,
block|{
literal|"TLS"
block|,
literal|3
block|}
block|}
struct|;
if|if
condition|(
name|do_section_details
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"[%*.*lx]: "
argument_list|,
name|field_size
argument_list|,
name|field_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sh_flags
argument_list|)
expr_stmt|;
name|p
operator|+=
name|field_size
operator|+
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|sh_flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|sh_flags
operator|&
operator|-
name|sh_flags
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|flag
expr_stmt|;
if|if
condition|(
name|do_section_details
condition|)
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SHF_WRITE
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SHF_ALLOC
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SHF_EXECINSTR
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SHF_MERGE
case|:
name|index
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|SHF_STRINGS
case|:
name|index
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|SHF_INFO_LINK
case|:
name|index
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|SHF_LINK_ORDER
case|:
name|index
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|SHF_OS_NONCONFORMING
case|:
name|index
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|SHF_GROUP
case|:
name|index
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|SHF_TLS
case|:
name|index
operator|=
literal|9
expr_stmt|;
break|break;
default|default:
name|index
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
name|field_size
operator|+
literal|4
condition|)
block|{
if|if
condition|(
name|size
operator|<
operator|(
literal|10
operator|+
literal|2
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|size
operator|-=
name|flags
index|[
name|index
index|]
operator|.
name|len
expr_stmt|;
name|p
operator|=
name|stpcpy
argument_list|(
name|p
argument_list|,
name|flags
index|[
name|index
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKOS
condition|)
name|os_flags
operator||=
name|flag
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKPROC
condition|)
name|proc_flags
operator||=
name|flag
expr_stmt|;
else|else
name|unknown_flags
operator||=
name|flag
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SHF_WRITE
case|:
operator|*
name|p
operator|=
literal|'W'
expr_stmt|;
break|break;
case|case
name|SHF_ALLOC
case|:
operator|*
name|p
operator|=
literal|'A'
expr_stmt|;
break|break;
case|case
name|SHF_EXECINSTR
case|:
operator|*
name|p
operator|=
literal|'X'
expr_stmt|;
break|break;
case|case
name|SHF_MERGE
case|:
operator|*
name|p
operator|=
literal|'M'
expr_stmt|;
break|break;
case|case
name|SHF_STRINGS
case|:
operator|*
name|p
operator|=
literal|'S'
expr_stmt|;
break|break;
case|case
name|SHF_INFO_LINK
case|:
operator|*
name|p
operator|=
literal|'I'
expr_stmt|;
break|break;
case|case
name|SHF_LINK_ORDER
case|:
operator|*
name|p
operator|=
literal|'L'
expr_stmt|;
break|break;
case|case
name|SHF_OS_NONCONFORMING
case|:
operator|*
name|p
operator|=
literal|'O'
expr_stmt|;
break|break;
case|case
name|SHF_GROUP
case|:
operator|*
name|p
operator|=
literal|'G'
expr_stmt|;
break|break;
case|case
name|SHF_TLS
case|:
operator|*
name|p
operator|=
literal|'T'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_X86_64
operator|&&
name|flag
operator|==
name|SHF_X86_64_LARGE
condition|)
operator|*
name|p
operator|=
literal|'l'
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKOS
condition|)
block|{
operator|*
name|p
operator|=
literal|'o'
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKPROC
condition|)
block|{
operator|*
name|p
operator|=
literal|'p'
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKPROC
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|=
literal|'x'
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_section_details
condition|)
block|{
if|if
condition|(
name|os_flags
condition|)
block|{
name|size
operator|-=
literal|5
operator|+
name|field_size
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
name|field_size
operator|+
literal|4
condition|)
block|{
if|if
condition|(
name|size
operator|<
operator|(
literal|2
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"OS (%*.*lx)"
argument_list|,
name|field_size
argument_list|,
name|field_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|os_flags
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|5
operator|+
name|field_size
expr_stmt|;
block|}
if|if
condition|(
name|proc_flags
condition|)
block|{
name|size
operator|-=
literal|7
operator|+
name|field_size
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
name|field_size
operator|+
literal|4
condition|)
block|{
if|if
condition|(
name|size
operator|<
operator|(
literal|2
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"PROC (%*.*lx)"
argument_list|,
name|field_size
argument_list|,
name|field_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|proc_flags
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|7
operator|+
name|field_size
expr_stmt|;
block|}
if|if
condition|(
name|unknown_flags
condition|)
block|{
name|size
operator|-=
literal|10
operator|+
name|field_size
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buff
operator|+
name|field_size
operator|+
literal|4
condition|)
block|{
if|if
condition|(
name|size
operator|<
operator|(
literal|2
operator|+
literal|1
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"UNKNOWN (%*.*lx)"
argument_list|,
name|field_size
argument_list|,
name|field_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|unknown_flags
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|10
operator|+
name|field_size
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_headers
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_sections
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|do_sections
operator|&&
operator|!
name|do_header
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"There are %d section headers, starting at offset 0x%lx:\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_section_headers
argument_list|(
name|file
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_section_headers
argument_list|(
name|file
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Read in the string table, so that we have names to display.  */
if|if
condition|(
name|elf_header
operator|.
name|e_shstrndx
operator|!=
name|SHN_UNDEF
operator|&&
name|SECTION_HEADER_INDEX
argument_list|(
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|section
operator|=
name|SECTION_HEADER
argument_list|(
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|string_table
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|string_table_length
operator|=
name|string_table
operator|!=
name|NULL
condition|?
name|section
operator|->
name|sh_size
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* Scan the sections for the dynamic symbol table      and dynamic string table and debug sections.  */
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
name|symtab_shndx_hdr
operator|=
name|NULL
expr_stmt|;
name|eh_addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
comment|/* The 64-bit MIPS EABI uses a combination of 32-bit ELF and 64-bit 	 FDE addresses.  However, the ABI also has a semi-official ILP32 	 variant for which the normal FDE address size rules apply.  	 GCC 4.0 marks EABI64 objects with a dummy .gcc_compiled_longXX 	 section, where XX is the size of longs in bits.  Unfortunately, 	 earlier compilers provided no way of distinguishing ILP32 objects 	 from LP64 objects, so if there's any doubt, we should assume that 	 the official LP64 form is being used.  */
if|if
condition|(
operator|(
name|elf_header
operator|.
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI64
operator|&&
name|find_section
argument_list|(
literal|".gcc_compiled_long32"
argument_list|)
operator|==
name|NULL
condition|)
name|eh_addr_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
switch|switch
condition|(
name|elf_header
operator|.
name|e_flags
operator|&
name|EF_H8_MACH
condition|)
block|{
case|case
name|E_H8_MACH_H8300
case|:
case|case
name|E_H8_MACH_H8300HN
case|:
case|case
name|E_H8_MACH_H8300SN
case|:
case|case
name|E_H8_MACH_H8300SXN
case|:
name|eh_addr_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|E_H8_MACH_H8300H
case|:
case|case
name|E_H8_MACH_H8300S
case|:
case|case
name|E_H8_MACH_H8300SX
case|:
name|eh_addr_size
operator|=
literal|4
expr_stmt|;
break|break;
block|}
block|}
define|#
directive|define
name|CHECK_ENTSIZE_VALUES
parameter_list|(
name|section
parameter_list|,
name|i
parameter_list|,
name|size32
parameter_list|,
name|size64
parameter_list|)
define|\
value|do									    \     {									    \       size_t expected_entsize						    \ 	= is_32bit_elf ? size32 : size64;				    \       if (section->sh_entsize != expected_entsize)			    \ 	error (_("Section %d has invalid sh_entsize %lx (expected %lx)\n"), \ 	       i, (unsigned long int) section->sh_entsize,		    \ 	       (unsigned long int) expected_entsize);			    \       section->sh_entsize = expected_entsize;				    \     }									    \   while (0)
define|#
directive|define
name|CHECK_ENTSIZE
parameter_list|(
name|section
parameter_list|,
name|i
parameter_list|,
name|type
parameter_list|)
define|\
value|CHECK_ENTSIZE_VALUES (section, i, sizeof (Elf32_External_##type),	    \ 			sizeof (Elf64_External_##type))
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|dynamic_symbols
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic symbol tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CHECK_ENTSIZE
argument_list|(
name|section
argument_list|,
name|i
argument_list|,
name|Sym
argument_list|)
expr_stmt|;
name|num_dynamic_syms
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_STRTAB
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic string tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_strings
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"dynamic strings"
argument_list|)
argument_list|)
expr_stmt|;
name|dynamic_strings_length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB_SHNDX
condition|)
block|{
if|if
condition|(
name|symtab_shndx_hdr
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple symtab shndx tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symtab_shndx_hdr
operator|=
name|section
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
name|CHECK_ENTSIZE
argument_list|(
name|section
argument_list|,
name|i
argument_list|,
name|Sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_GROUP
condition|)
name|CHECK_ENTSIZE_VALUES
argument_list|(
name|section
argument_list|,
name|i
argument_list|,
name|GRP_ENTRY_SIZE
argument_list|,
name|GRP_ENTRY_SIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
name|CHECK_ENTSIZE
argument_list|(
name|section
argument_list|,
name|i
argument_list|,
name|Rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_RELA
condition|)
name|CHECK_ENTSIZE
argument_list|(
name|section
argument_list|,
name|i
argument_list|,
name|Rela
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|||
name|do_debug_abbrevs
operator|||
name|do_debug_lines
operator|||
name|do_debug_pubnames
operator|||
name|do_debug_aranges
operator|||
name|do_debug_frames
operator|||
name|do_debug_macinfo
operator|||
name|do_debug_str
operator|||
name|do_debug_loc
operator|||
name|do_debug_ranges
operator|)
operator|&&
name|const_strneq
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|)
condition|)
block|{
name|name
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|do_debugging
operator|||
operator|(
name|do_debug_info
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"info"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_abbrevs
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"abbrev"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_lines
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"line"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_pubnames
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"pubnames"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_aranges
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"aranges"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_ranges
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"ranges"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_frames
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"frame"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_macinfo
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"macinfo"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_str
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"str"
argument_list|)
operator|)
operator|||
operator|(
name|do_debug_loc
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|"loc"
argument_list|)
operator|)
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
comment|/* linkonce section to be combined with .debug_info at link time.  */
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|)
operator|&&
name|const_strneq
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|)
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_debug_frames
operator|&&
name|streq
argument_list|(
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_sections
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|>
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection Headers:\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
name|do_section_details
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Type            Addr     Off    Size   ES   Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_wide
condition|)
block|{
if|if
condition|(
name|do_section_details
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Type            Address          Off    Size   ES   Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_section_details
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Type              Address          Offset            Link\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Size              EntSize          Info              Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type             Address           Offset\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Size              EntSize          Flags  Link  Info  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_section_details
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Flags\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|do_section_details
condition|)
block|{
name|printf
argument_list|(
literal|"  [%2u] %s\n"
argument_list|,
name|SECTION_HEADER_NUM
argument_list|(
name|i
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
operator|||
name|do_wide
condition|)
name|printf
argument_list|(
literal|"       %-15.15s "
argument_list|,
name|get_section_type_name
argument_list|(
name|section
operator|->
name|sh_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"  [%2u] %-17.17s %-15.15s "
argument_list|,
name|SECTION_HEADER_NUM
argument_list|(
name|i
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|get_section_type_name
argument_list|(
name|section
operator|->
name|sh_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6.6lx %6.6lx %2.2lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_section_details
condition|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %3lu %2ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_wide
condition|)
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|section
operator|->
name|sh_offset
operator|==
name|section
operator|->
name|sh_offset
condition|)
name|printf
argument_list|(
literal|" %6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
operator|==
name|section
operator|->
name|sh_size
condition|)
name|printf
argument_list|(
literal|" %6.6lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
operator|==
name|section
operator|->
name|sh_entsize
condition|)
name|printf
argument_list|(
literal|" %2.2lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_section_details
condition|)
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %3lu "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
operator|==
name|section
operator|->
name|sh_addralign
condition|)
name|printf
argument_list|(
literal|"%2ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
else|else
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addralign
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_section_details
condition|)
block|{
name|printf
argument_list|(
literal|"       %-15.15s  "
argument_list|,
name|get_section_type_name
argument_list|(
name|section
operator|->
name|sh_type
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|section
operator|->
name|sh_offset
operator|==
name|section
operator|->
name|sh_offset
condition|)
name|printf
argument_list|(
literal|"  %16.16lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %ld\n       "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %-16lu  %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|section
operator|->
name|sh_offset
operator|==
name|section
operator|->
name|sh_offset
condition|)
name|printf
argument_list|(
literal|"  %8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n       "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     %2ld   %3lu     %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_section_details
condition|)
name|printf
argument_list|(
literal|"       %s\n"
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_section_details
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Key to Flags:\n\   W (write), A (alloc), X (execute), M (merge), S (strings)\n\   I (info), L (link order), G (group), x (unknown)\n\   O (extra OS processing required) o (OS specific), p (processor specific)\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_group_flags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|GRP_COMDAT
case|:
return|return
literal|"COMDAT"
return|;
default|default:
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"[<unknown>: 0x%x]"
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_groups
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|group
modifier|*
name|group
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_sec
decl_stmt|,
modifier|*
name|strtab_sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|size_t
name|strtab_size
decl_stmt|;
comment|/* Don't process section groups unless needed.  */
if|if
condition|(
operator|!
name|do_unwind
operator|&&
operator|!
name|do_section_groups
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_section_groups
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Section headers are not available!\n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|section_headers_groups
operator|=
name|calloc
argument_list|(
name|elf_header
operator|.
name|e_shnum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers_groups
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Scan the sections for the group section.  */
name|group_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_GROUP
condition|)
name|group_count
operator|++
expr_stmt|;
if|if
condition|(
name|group_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_section_groups
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no section groups in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|section_groups
operator|=
name|calloc
argument_list|(
name|group_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_groups
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|symtab_sec
operator|=
name|NULL
expr_stmt|;
name|strtab_sec
operator|=
name|NULL
expr_stmt|;
name|symtab
operator|=
name|NULL
expr_stmt|;
name|strtab
operator|=
name|NULL
expr_stmt|;
name|strtab_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
operator|,
name|group
operator|=
name|section_groups
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_GROUP
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|char
modifier|*
name|group_name
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|indices
decl_stmt|;
name|unsigned
name|int
name|entry
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
comment|/* Get the symbol table.  */
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
operator|(
operator|(
name|sec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|)
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Bad sh_link in group section `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|symtab_sec
operator|!=
name|sec
condition|)
block|{
name|symtab_sec
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|symtab
condition|)
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symtab_sec
argument_list|)
expr_stmt|;
block|}
name|sym
operator|=
name|symtab
operator|+
name|section
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|bfd_vma
name|sec_index
init|=
name|SECTION_HEADER_INDEX
argument_list|(
name|sym
operator|->
name|st_shndx
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec_index
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Bad sh_info in group section `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|group_name
operator|=
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|sec_index
argument_list|)
expr_stmt|;
name|strtab_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|NULL
expr_stmt|;
name|strtab_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the string table.  */
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|symtab_sec
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|strtab_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|NULL
expr_stmt|;
name|strtab_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strtab_sec
operator|!=
operator|(
name|sec
operator|=
name|SECTION_HEADER
argument_list|(
name|symtab_sec
operator|->
name|sh_link
argument_list|)
operator|)
condition|)
block|{
name|strtab_sec
operator|=
name|sec
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strtab_sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|strtab_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_size
operator|=
name|strtab
operator|!=
name|NULL
condition|?
name|strtab_sec
operator|->
name|sh_size
else|:
literal|0
expr_stmt|;
block|}
name|group_name
operator|=
name|sym
operator|->
name|st_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|sym
operator|->
name|st_name
else|:
literal|"<corrupt>"
expr_stmt|;
block|}
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"section data"
argument_list|)
argument_list|)
expr_stmt|;
name|indices
operator|=
name|start
expr_stmt|;
name|size
operator|=
operator|(
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
operator|)
operator|-
literal|1
expr_stmt|;
name|entry
operator|=
name|byte_get
argument_list|(
name|indices
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|indices
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|do_section_groups
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s group section [%5u] `%s' [%s] contains %u sections:\n"
argument_list|,
name|get_group_flags
argument_list|(
name|entry
argument_list|)
argument_list|,
name|i
argument_list|,
name|name
argument_list|,
name|group_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   [Index]    Name\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|group
operator|->
name|group_index
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|group_list
modifier|*
name|g
decl_stmt|;
name|entry
operator|=
name|byte_get
argument_list|(
name|indices
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|indices
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|entry
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"section [%5u] in group section [%5u]> maximum section [%5u]\n"
argument_list|)
argument_list|,
name|entry
argument_list|,
name|i
argument_list|,
name|elf_header
operator|.
name|e_shnum
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|entry
operator|>=
name|SHN_LORESERVE
operator|&&
name|entry
operator|<=
name|SHN_HIRESERVE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid section [%5u] in group section [%5u]\n"
argument_list|)
argument_list|,
name|entry
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|section_headers_groups
index|[
name|SECTION_HEADER_INDEX
argument_list|(
name|entry
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|entry
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"section [%5u] in group section [%5u] already in group section [%5u]\n"
argument_list|)
argument_list|,
name|entry
argument_list|,
name|i
argument_list|,
name|section_headers_groups
index|[
name|SECTION_HEADER_INDEX
argument_list|(
name|entry
argument_list|)
index|]
operator|->
name|group_index
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Intel C/C++ compiler may put section 0 in a 			 section group. We just warn it the first time 			 and ignore it afterwards.  */
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"section 0 in group section [%5u]\n"
argument_list|)
argument_list|,
name|section_headers_groups
index|[
name|SECTION_HEADER_INDEX
argument_list|(
name|entry
argument_list|)
index|]
operator|->
name|group_index
argument_list|)
expr_stmt|;
name|warned
operator|++
expr_stmt|;
block|}
block|}
block|}
name|section_headers_groups
index|[
name|SECTION_HEADER_INDEX
argument_list|(
name|entry
argument_list|)
index|]
operator|=
name|group
expr_stmt|;
if|if
condition|(
name|do_section_groups
condition|)
block|{
name|sec
operator|=
name|SECTION_HEADER
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   [%5u]   %s\n"
argument_list|,
name|entry
argument_list|,
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|group_list
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|section_index
operator|=
name|entry
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|group
operator|->
name|root
expr_stmt|;
name|group
operator|->
name|root
operator|=
name|g
expr_stmt|;
block|}
if|if
condition|(
name|start
condition|)
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|group
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symtab
condition|)
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|rela
decl_stmt|;
block|}
name|dynamic_relocations
index|[]
init|=
block|{
block|{
literal|"REL"
block|,
name|DT_REL
block|,
name|DT_RELSZ
block|,
name|FALSE
block|}
block|,
block|{
literal|"RELA"
block|,
name|DT_RELA
block|,
name|DT_RELASZ
block|,
name|TRUE
block|}
block|,
block|{
literal|"PLT"
block|,
name|DT_JMPREL
block|,
name|DT_PLTRELSZ
block|,
name|UNKNOWN
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Process the reloc section.  */
end_comment

begin_function
specifier|static
name|int
name|process_relocs
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
if|if
condition|(
operator|!
name|do_reloc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|do_using_dynamic
condition|)
block|{
name|int
name|is_rela
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|has_dynamic_reloc
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|has_dynamic_reloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|dynamic_relocations
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|is_rela
operator|=
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|rela
expr_stmt|;
name|name
operator|=
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|rel_size
operator|=
name|dynamic_info
index|[
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|size
index|]
expr_stmt|;
name|rel_offset
operator|=
name|dynamic_info
index|[
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|reloc
index|]
expr_stmt|;
name|has_dynamic_reloc
operator||=
name|rel_size
expr_stmt|;
if|if
condition|(
name|is_rela
operator|==
name|UNKNOWN
condition|)
block|{
if|if
condition|(
name|dynamic_relocations
index|[
name|i
index|]
operator|.
name|reloc
operator|==
name|DT_JMPREL
condition|)
switch|switch
condition|(
name|dynamic_info
index|[
name|DT_PLTREL
index|]
condition|)
block|{
case|case
name|DT_REL
case|:
name|is_rela
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|is_rela
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rel_size
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"
argument_list|)
argument_list|,
name|name
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|)
expr_stmt|;
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|)
argument_list|,
name|rel_size
argument_list|,
name|dynamic_symbols
argument_list|,
name|num_dynamic_syms
argument_list|,
name|dynamic_strings
argument_list|,
name|dynamic_strings_length
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_dynamic_reloc
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no dynamic relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_REL
condition|)
continue|continue;
name|rel_offset
operator|=
name|section
operator|->
name|sh_offset
expr_stmt|;
name|rel_size
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|rel_size
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|strsec
decl_stmt|;
name|int
name|is_rela
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nRelocation section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
name|rel_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|rel_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
name|is_rela
operator|=
name|section
operator|->
name|sh_type
operator|==
name|SHT_RELA
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_link
operator|&&
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symsec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|unsigned
name|long
name|nsyms
decl_stmt|;
name|unsigned
name|long
name|strtablen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|strtab
init|=
name|NULL
decl_stmt|;
name|symsec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsec
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|symsec
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
continue|continue;
name|nsyms
operator|=
name|symsec
operator|->
name|sh_size
operator|/
name|symsec
operator|->
name|sh_entsize
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|symsec
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|strsec
operator|=
name|SECTION_HEADER
argument_list|(
name|symsec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strsec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|strsec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|strtablen
operator|=
name|strtab
operator|==
name|NULL
condition|?
literal|0
else|:
name|strsec
operator|->
name|sh_size
expr_stmt|;
block|}
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|symtab
argument_list|,
name|nsyms
argument_list|,
name|strtab
argument_list|,
name|strtablen
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
block|}
else|else
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process the unwind section.  */
end_comment

begin_include
include|#
directive|include
file|"unwind-ia64.h"
end_include

begin_comment
comment|/* An absolute address consists of a section and an offset.  If the    section is NULL, the offset itself is the address, otherwise, the    address equals to LOAD_ADDRESS(section) + offset.  */
end_comment

begin_struct
struct|struct
name|absaddr
block|{
name|unsigned
name|short
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ABSADDR
parameter_list|(
name|a
parameter_list|)
define|\
value|((a).section \    ? section_headers [(a).section].sh_addr + (a).offset \    : (a).offset)
end_define

begin_struct
struct|struct
name|ia64_unw_aux_info
block|{
struct|struct
name|ia64_unw_table_entry
block|{
name|struct
name|absaddr
name|start
decl_stmt|;
name|struct
name|absaddr
name|end
decl_stmt|;
name|struct
name|absaddr
name|info
decl_stmt|;
block|}
modifier|*
name|table
struct|;
comment|/* Unwind table.  */
name|unsigned
name|long
name|table_len
decl_stmt|;
comment|/* Length of unwind table.  */
name|unsigned
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Unwind info.  */
name|unsigned
name|long
name|info_size
decl_stmt|;
comment|/* Size of unwind info.  */
name|bfd_vma
name|info_addr
decl_stmt|;
comment|/* starting address of unwind info.  */
name|bfd_vma
name|seg_base
decl_stmt|;
comment|/* Starting address of segment.  */
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* The symbol table.  */
name|unsigned
name|long
name|nsyms
decl_stmt|;
comment|/* Number of symbols.  */
name|char
modifier|*
name|strtab
decl_stmt|;
comment|/* The string table.  */
name|unsigned
name|long
name|strtab_size
decl_stmt|;
comment|/* Size of string table.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|find_symbol_for_address
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|symtab
parameter_list|,
name|unsigned
name|long
name|nsyms
parameter_list|,
specifier|const
name|char
modifier|*
name|strtab
parameter_list|,
name|unsigned
name|long
name|strtab_size
parameter_list|,
name|struct
name|absaddr
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|symname
parameter_list|,
name|bfd_vma
modifier|*
name|offset
parameter_list|)
block|{
name|bfd_vma
name|dist
init|=
literal|0x100000
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sym
operator|=
name|symtab
init|;
name|i
operator|<
name|nsyms
condition|;
operator|++
name|i
operator|,
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
name|sym
operator|->
name|st_name
operator|!=
literal|0
operator|&&
operator|(
name|addr
operator|.
name|section
operator|==
name|SHN_UNDEF
operator|||
name|addr
operator|.
name|section
operator|==
name|sym
operator|->
name|st_shndx
operator|)
operator|&&
name|addr
operator|.
name|offset
operator|>=
name|sym
operator|->
name|st_value
operator|&&
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
operator|<
name|dist
condition|)
block|{
name|best
operator|=
name|sym
expr_stmt|;
name|dist
operator|=
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
operator|!
name|dist
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
operator|*
name|symname
operator|=
operator|(
name|best
operator|->
name|st_name
operator|>=
name|strtab_size
condition|?
literal|"<corrupt>"
else|:
name|strtab
operator|+
name|best
operator|->
name|st_name
operator|)
expr_stmt|;
operator|*
name|offset
operator|=
name|dist
expr_stmt|;
return|return;
block|}
operator|*
name|symname
operator|=
name|NULL
expr_stmt|;
operator|*
name|offset
operator|=
name|addr
operator|.
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ia64_unwind
parameter_list|(
name|struct
name|ia64_unw_aux_info
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|ia64_unw_table_entry
modifier|*
name|tp
decl_stmt|;
name|int
name|in_body
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|aux
operator|->
name|table
init|;
name|tp
operator|<
name|aux
operator|->
name|table
operator|+
name|aux
operator|->
name|table_len
condition|;
operator|++
name|tp
control|)
block|{
name|bfd_vma
name|stamp
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|procname
decl_stmt|;
name|find_symbol_for_address
argument_list|(
name|aux
operator|->
name|symtab
argument_list|,
name|aux
operator|->
name|nsyms
argument_list|,
name|aux
operator|->
name|strtab
argument_list|,
name|aux
operator|->
name|strtab_size
argument_list|,
name|tp
operator|->
name|start
argument_list|,
operator|&
name|procname
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n<"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|procname
condition|)
block|{
name|fputs
argument_list|(
name|procname
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf
argument_list|(
literal|"+%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|">: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|start
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|end
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"], info at +0x%lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tp
operator|->
name|info
operator|.
name|offset
operator|-
name|aux
operator|->
name|seg_base
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|aux
operator|->
name|info
operator|+
operator|(
name|ABSADDR
argument_list|(
name|tp
operator|->
name|info
argument_list|)
operator|-
name|aux
operator|->
name|info_addr
operator|)
expr_stmt|;
name|stamp
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|stamp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|stamp
operator|&
name|UNW_FLAG_MASK
operator|)
operator|>>
literal|32
argument_list|)
argument_list|,
name|UNW_FLAG_EHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" ehandler"
else|:
literal|""
argument_list|,
name|UNW_FLAG_UHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" uhandler"
else|:
literal|""
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|eh_addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\tUnknown version.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|in_body
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|head
operator|+
literal|8
init|;
name|dp
operator|<
name|head
operator|+
literal|8
operator|+
name|eh_addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
condition|;
control|)
name|dp
operator|=
name|unw_decode
argument_list|(
name|dp
argument_list|,
name|in_body
argument_list|,
operator|&
name|in_body
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_ia64_unwind_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|ia64_unw_aux_info
modifier|*
name|aux
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|sec
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|nrelas
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|seg
decl_stmt|;
name|struct
name|ia64_unw_table_entry
modifier|*
name|tep
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|table
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|relname
decl_stmt|;
comment|/* First, find the starting address of the segment that includes      this section: */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
condition|)
block|{
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|seg
operator|=
name|program_headers
init|;
name|seg
operator|<
name|program_headers
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|sh_addr
operator|>=
name|seg
operator|->
name|p_vaddr
operator|&&
operator|(
name|sec
operator|->
name|sh_addr
operator|+
name|sec
operator|->
name|sh_size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_memsz
operator|)
condition|)
block|{
name|aux
operator|->
name|seg_base
operator|=
name|seg
operator|->
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Second, build the unwind table from the contents of the unwind section:  */
name|size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|table
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|_
argument_list|(
literal|"unwind table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
literal|0
return|;
name|aux
operator|->
name|table
operator|=
name|xcmalloc
argument_list|(
name|size
operator|/
operator|(
literal|3
operator|*
name|eh_addr_size
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tep
operator|=
name|aux
operator|->
name|table
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|table
init|;
name|tp
operator|<
name|table
operator|+
name|size
condition|;
name|tp
operator|+=
literal|3
operator|*
name|eh_addr_size
operator|,
operator|++
name|tep
control|)
block|{
name|tep
operator|->
name|start
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|BYTE_GET
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|BYTE_GET
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|BYTE_GET
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
name|tep
operator|->
name|start
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
block|}
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* Third, apply any relocations to the unwind table: */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|sec
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF64_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|const_strneq
argument_list|(
name|relname
argument_list|,
literal|"R_IA64_SEGREL"
argument_list|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected relocation type %s\n"
argument_list|)
argument_list|,
name|relname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|rp
operator|->
name|r_offset
operator|/
operator|(
literal|3
operator|*
name|eh_addr_size
operator|)
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|r_offset
operator|/
name|eh_addr_size
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
block|}
name|aux
operator|->
name|table_len
operator|=
name|size
operator|/
operator|(
literal|3
operator|*
name|eh_addr_size
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_process_unwind
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|,
modifier|*
name|unwsec
init|=
name|NULL
decl_stmt|,
modifier|*
name|strsec
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|unwcount
init|=
literal|0
decl_stmt|,
name|unwstart
init|=
literal|0
decl_stmt|;
name|struct
name|ia64_unw_aux_info
name|aux
decl_stmt|;
name|memset
argument_list|(
operator|&
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|&&
name|SECTION_HEADER_INDEX
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|aux
operator|.
name|nsyms
operator|=
name|sec
operator|->
name|sh_size
operator|/
name|sec
operator|->
name|sh_entsize
expr_stmt|;
name|aux
operator|.
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|strsec
operator|=
name|SECTION_HEADER
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|aux
operator|.
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strsec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|strsec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|aux
operator|.
name|strtab_size
operator|=
name|aux
operator|.
name|strtab
operator|!=
name|NULL
condition|?
name|strsec
operator|->
name|sh_size
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
name|unwcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unwcount
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|unwcount
operator|--
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|len2
decl_stmt|;
for|for
control|(
name|i
operator|=
name|unwstart
operator|,
name|sec
operator|=
name|section_headers
operator|+
name|unwstart
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
block|{
name|unwsec
operator|=
name|sec
expr_stmt|;
break|break;
block|}
name|unwstart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|unwsec
operator|->
name|sh_flags
operator|&
name|SHF_GROUP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We need to find which section group it is in.  */
name|struct
name|group_list
modifier|*
name|g
init|=
name|section_headers_groups
index|[
name|i
index|]
operator|->
name|root
decl_stmt|;
for|for
control|(
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
name|sec
operator|=
name|SECTION_HEADER
argument_list|(
name|g
operator|->
name|section_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
name|i
operator|=
name|elf_header
operator|.
name|e_shnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strneq
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO.  */
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info_once
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strneq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info_once
argument_list|,
name|len2
argument_list|)
operator|&&
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO 	     .IA_64.unwind or BAR -> .IA_64.unwind_info.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strneq
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len
argument_list|)
condition|)
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strneq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|,
name|len2
argument_list|)
operator|&&
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nCould not find unwind info section for "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|.
name|info_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|aux
operator|.
name|info_addr
operator|=
name|sec
operator|->
name|sh_addr
expr_stmt|;
name|aux
operator|.
name|info
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|aux
operator|.
name|info_size
argument_list|,
name|_
argument_list|(
literal|"unwind info"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nUnwind section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|unwsec
operator|->
name|sh_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|unwsec
operator|->
name|sh_size
operator|/
operator|(
literal|3
operator|*
name|eh_addr_size
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|slurp_ia64_unwind_table
argument_list|(
name|file
argument_list|,
operator|&
name|aux
argument_list|,
name|unwsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table_len
operator|>
literal|0
condition|)
name|dump_ia64_unwind
argument_list|(
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|info
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|info
argument_list|)
expr_stmt|;
name|aux
operator|.
name|table
operator|=
name|NULL
expr_stmt|;
name|aux
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aux
operator|.
name|symtab
condition|)
name|free
argument_list|(
name|aux
operator|.
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|strtab
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|strtab
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
struct|struct
name|hppa_unw_aux_info
block|{
struct|struct
name|hppa_unw_table_entry
block|{
name|struct
name|absaddr
name|start
decl_stmt|;
name|struct
name|absaddr
name|end
decl_stmt|;
name|unsigned
name|int
name|Cannot_unwind
range|:
literal|1
decl_stmt|;
comment|/* 0 */
name|unsigned
name|int
name|Millicode
range|:
literal|1
decl_stmt|;
comment|/* 1 */
name|unsigned
name|int
name|Millicode_save_sr0
range|:
literal|1
decl_stmt|;
comment|/* 2 */
name|unsigned
name|int
name|Region_description
range|:
literal|2
decl_stmt|;
comment|/* 3..4 */
name|unsigned
name|int
name|reserved1
range|:
literal|1
decl_stmt|;
comment|/* 5 */
name|unsigned
name|int
name|Entry_SR
range|:
literal|1
decl_stmt|;
comment|/* 6 */
name|unsigned
name|int
name|Entry_FR
range|:
literal|4
decl_stmt|;
comment|/* number saved */
comment|/* 7..10 */
name|unsigned
name|int
name|Entry_GR
range|:
literal|5
decl_stmt|;
comment|/* number saved */
comment|/* 11..15 */
name|unsigned
name|int
name|Args_stored
range|:
literal|1
decl_stmt|;
comment|/* 16 */
name|unsigned
name|int
name|Variable_Frame
range|:
literal|1
decl_stmt|;
comment|/* 17 */
name|unsigned
name|int
name|Separate_Package_Body
range|:
literal|1
decl_stmt|;
comment|/* 18 */
name|unsigned
name|int
name|Frame_Extension_Millicode
range|:
literal|1
decl_stmt|;
comment|/* 19 */
name|unsigned
name|int
name|Stack_Overflow_Check
range|:
literal|1
decl_stmt|;
comment|/* 20 */
name|unsigned
name|int
name|Two_Instruction_SP_Increment
range|:
literal|1
decl_stmt|;
comment|/* 21 */
name|unsigned
name|int
name|Ada_Region
range|:
literal|1
decl_stmt|;
comment|/* 22 */
name|unsigned
name|int
name|cxx_info
range|:
literal|1
decl_stmt|;
comment|/* 23 */
name|unsigned
name|int
name|cxx_try_catch
range|:
literal|1
decl_stmt|;
comment|/* 24 */
name|unsigned
name|int
name|sched_entry_seq
range|:
literal|1
decl_stmt|;
comment|/* 25 */
name|unsigned
name|int
name|reserved2
range|:
literal|1
decl_stmt|;
comment|/* 26 */
name|unsigned
name|int
name|Save_SP
range|:
literal|1
decl_stmt|;
comment|/* 27 */
name|unsigned
name|int
name|Save_RP
range|:
literal|1
decl_stmt|;
comment|/* 28 */
name|unsigned
name|int
name|Save_MRP_in_frame
range|:
literal|1
decl_stmt|;
comment|/* 29 */
name|unsigned
name|int
name|extn_ptr_defined
range|:
literal|1
decl_stmt|;
comment|/* 30 */
name|unsigned
name|int
name|Cleanup_defined
range|:
literal|1
decl_stmt|;
comment|/* 31 */
name|unsigned
name|int
name|MPE_XL_interrupt_marker
range|:
literal|1
decl_stmt|;
comment|/* 0 */
name|unsigned
name|int
name|HP_UX_interrupt_marker
range|:
literal|1
decl_stmt|;
comment|/* 1 */
name|unsigned
name|int
name|Large_frame
range|:
literal|1
decl_stmt|;
comment|/* 2 */
name|unsigned
name|int
name|Pseudo_SP_Set
range|:
literal|1
decl_stmt|;
comment|/* 3 */
name|unsigned
name|int
name|reserved4
range|:
literal|1
decl_stmt|;
comment|/* 4 */
name|unsigned
name|int
name|Total_frame_size
range|:
literal|27
decl_stmt|;
comment|/* 5..31 */
block|}
modifier|*
name|table
struct|;
comment|/* Unwind table.  */
name|unsigned
name|long
name|table_len
decl_stmt|;
comment|/* Length of unwind table.  */
name|bfd_vma
name|seg_base
decl_stmt|;
comment|/* Starting address of segment.  */
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* The symbol table.  */
name|unsigned
name|long
name|nsyms
decl_stmt|;
comment|/* Number of symbols.  */
name|char
modifier|*
name|strtab
decl_stmt|;
comment|/* The string table.  */
name|unsigned
name|long
name|strtab_size
decl_stmt|;
comment|/* Size of string table.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|dump_hppa_unwind
parameter_list|(
name|struct
name|hppa_unw_aux_info
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|hppa_unw_table_entry
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|aux
operator|->
name|table
init|;
name|tp
operator|<
name|aux
operator|->
name|table
operator|+
name|aux
operator|->
name|table_len
condition|;
operator|++
name|tp
control|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|procname
decl_stmt|;
name|find_symbol_for_address
argument_list|(
name|aux
operator|->
name|symtab
argument_list|,
name|aux
operator|->
name|nsyms
argument_list|,
name|aux
operator|->
name|strtab
argument_list|,
name|aux
operator|->
name|strtab_size
argument_list|,
name|tp
operator|->
name|start
argument_list|,
operator|&
name|procname
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n<"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|procname
condition|)
block|{
name|fputs
argument_list|(
name|procname
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf
argument_list|(
literal|"+%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|">: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|start
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|end
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n\t"
argument_list|)
expr_stmt|;
define|#
directive|define
name|PF
parameter_list|(
name|_m
parameter_list|)
value|if (tp->_m) printf (#_m " ");
define|#
directive|define
name|PV
parameter_list|(
name|_m
parameter_list|)
value|if (tp->_m) printf (#_m "=%d ", tp->_m);
name|PF
argument_list|(
name|Cannot_unwind
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Millicode
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Millicode_save_sr0
argument_list|)
expr_stmt|;
comment|/* PV(Region_description);  */
name|PF
argument_list|(
name|Entry_SR
argument_list|)
expr_stmt|;
name|PV
argument_list|(
name|Entry_FR
argument_list|)
expr_stmt|;
name|PV
argument_list|(
name|Entry_GR
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Args_stored
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Variable_Frame
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Separate_Package_Body
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Frame_Extension_Millicode
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Stack_Overflow_Check
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Two_Instruction_SP_Increment
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Ada_Region
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|cxx_info
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|cxx_try_catch
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|sched_entry_seq
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Save_SP
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Save_RP
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Save_MRP_in_frame
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|extn_ptr_defined
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Cleanup_defined
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|MPE_XL_interrupt_marker
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HP_UX_interrupt_marker
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Large_frame
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|Pseudo_SP_Set
argument_list|)
expr_stmt|;
name|PV
argument_list|(
name|Total_frame_size
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PF
undef|#
directive|undef
name|PV
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_hppa_unwind_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|hppa_unw_aux_info
modifier|*
name|aux
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|sec
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|unw_ent_size
decl_stmt|,
name|nentries
decl_stmt|,
name|nrelas
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|seg
decl_stmt|;
name|struct
name|hppa_unw_table_entry
modifier|*
name|tep
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|table
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|relname
decl_stmt|;
comment|/* First, find the starting address of the segment that includes      this section.  */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
condition|)
block|{
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|seg
operator|=
name|program_headers
init|;
name|seg
operator|<
name|program_headers
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|sh_addr
operator|>=
name|seg
operator|->
name|p_vaddr
operator|&&
operator|(
name|sec
operator|->
name|sh_addr
operator|+
name|sec
operator|->
name|sh_size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_memsz
operator|)
condition|)
block|{
name|aux
operator|->
name|seg_base
operator|=
name|seg
operator|->
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Second, build the unwind table from the contents of the unwind      section.  */
name|size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|table
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|_
argument_list|(
literal|"unwind table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
literal|0
return|;
name|unw_ent_size
operator|=
literal|16
expr_stmt|;
name|nentries
operator|=
name|size
operator|/
name|unw_ent_size
expr_stmt|;
name|size
operator|=
name|unw_ent_size
operator|*
name|nentries
expr_stmt|;
name|tep
operator|=
name|aux
operator|->
name|table
operator|=
name|xcmalloc
argument_list|(
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|table
init|;
name|tp
operator|<
name|table
operator|+
name|size
condition|;
name|tp
operator|+=
name|unw_ent_size
operator|,
operator|++
name|tep
control|)
block|{
name|unsigned
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|tep
operator|->
name|start
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|12
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|start
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|Cannot_unwind
operator|=
operator|(
name|tmp1
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Millicode
operator|=
operator|(
name|tmp1
operator|>>
literal|30
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Millicode_save_sr0
operator|=
operator|(
name|tmp1
operator|>>
literal|29
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Region_description
operator|=
operator|(
name|tmp1
operator|>>
literal|27
operator|)
operator|&
literal|0x3
expr_stmt|;
name|tep
operator|->
name|reserved1
operator|=
operator|(
name|tmp1
operator|>>
literal|26
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Entry_SR
operator|=
operator|(
name|tmp1
operator|>>
literal|25
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Entry_FR
operator|=
operator|(
name|tmp1
operator|>>
literal|21
operator|)
operator|&
literal|0xf
expr_stmt|;
name|tep
operator|->
name|Entry_GR
operator|=
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|tep
operator|->
name|Args_stored
operator|=
operator|(
name|tmp1
operator|>>
literal|15
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Variable_Frame
operator|=
operator|(
name|tmp1
operator|>>
literal|14
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Separate_Package_Body
operator|=
operator|(
name|tmp1
operator|>>
literal|13
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Frame_Extension_Millicode
operator|=
operator|(
name|tmp1
operator|>>
literal|12
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Stack_Overflow_Check
operator|=
operator|(
name|tmp1
operator|>>
literal|11
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Two_Instruction_SP_Increment
operator|=
operator|(
name|tmp1
operator|>>
literal|10
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Ada_Region
operator|=
operator|(
name|tmp1
operator|>>
literal|9
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|cxx_info
operator|=
operator|(
name|tmp1
operator|>>
literal|8
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|cxx_try_catch
operator|=
operator|(
name|tmp1
operator|>>
literal|7
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|sched_entry_seq
operator|=
operator|(
name|tmp1
operator|>>
literal|6
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|reserved2
operator|=
operator|(
name|tmp1
operator|>>
literal|5
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Save_SP
operator|=
operator|(
name|tmp1
operator|>>
literal|4
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Save_RP
operator|=
operator|(
name|tmp1
operator|>>
literal|3
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Save_MRP_in_frame
operator|=
operator|(
name|tmp1
operator|>>
literal|2
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|extn_ptr_defined
operator|=
operator|(
name|tmp1
operator|>>
literal|1
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Cleanup_defined
operator|=
name|tmp1
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|MPE_XL_interrupt_marker
operator|=
operator|(
name|tmp2
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|HP_UX_interrupt_marker
operator|=
operator|(
name|tmp2
operator|>>
literal|30
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Large_frame
operator|=
operator|(
name|tmp2
operator|>>
literal|29
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Pseudo_SP_Set
operator|=
operator|(
name|tmp2
operator|>>
literal|28
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|reserved4
operator|=
operator|(
name|tmp2
operator|>>
literal|27
operator|)
operator|&
literal|0x1
expr_stmt|;
name|tep
operator|->
name|Total_frame_size
operator|=
name|tmp2
operator|&
literal|0x7ffffff
expr_stmt|;
block|}
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* Third, apply any relocations to the unwind table.  */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|sec
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|relname
operator|=
name|elf_hppa_reloc_type
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relname
operator|=
name|elf_hppa_reloc_type
argument_list|(
name|ELF64_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
comment|/* R_PARISC_SEGREL32 or R_PARISC_SEGREL64.  */
if|if
condition|(
operator|!
name|const_strneq
argument_list|(
name|relname
argument_list|,
literal|"R_PARISC_SEGREL"
argument_list|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected relocation type %s\n"
argument_list|)
argument_list|,
name|relname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|rp
operator|->
name|r_offset
operator|/
name|unw_ent_size
expr_stmt|;
switch|switch
condition|(
operator|(
name|rp
operator|->
name|r_offset
operator|%
name|unw_ent_size
operator|)
operator|/
name|eh_addr_size
condition|)
block|{
case|case
literal|0
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|offset
operator|+=
name|sym
operator|->
name|st_value
operator|+
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|offset
operator|+=
name|sym
operator|->
name|st_value
operator|+
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
block|}
name|aux
operator|->
name|table_len
operator|=
name|nentries
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hppa_process_unwind
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|hppa_unw_aux_info
name|aux
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|unwsec
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|strsec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|&&
name|SECTION_HEADER_INDEX
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|aux
operator|.
name|nsyms
operator|=
name|sec
operator|->
name|sh_size
operator|/
name|sec
operator|->
name|sh_entsize
expr_stmt|;
name|aux
operator|.
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|strsec
operator|=
name|SECTION_HEADER
argument_list|(
name|sec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|aux
operator|.
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|strsec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|strsec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|aux
operator|.
name|strtab_size
operator|=
name|aux
operator|.
name|strtab
operator|!=
name|NULL
condition|?
name|strsec
operator|->
name|sh_size
else|:
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|".PARISC.unwind"
argument_list|)
condition|)
name|unwsec
operator|=
name|sec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unwsec
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|".PARISC.unwind"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nUnwind section "
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"'%s'"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sec
operator|->
name|sh_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sec
operator|->
name|sh_size
operator|/
operator|(
literal|2
operator|*
name|eh_addr_size
operator|+
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|slurp_hppa_unwind_table
argument_list|(
name|file
argument_list|,
operator|&
name|aux
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table_len
operator|>
literal|0
condition|)
name|dump_hppa_unwind
argument_list|(
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|table
argument_list|)
expr_stmt|;
name|aux
operator|.
name|table
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aux
operator|.
name|symtab
condition|)
name|free
argument_list|(
name|aux
operator|.
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|strtab
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|strtab
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_unwind
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
struct|struct
name|unwind_handler
block|{
name|int
name|machtype
decl_stmt|;
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
function_decl|;
block|}
name|handlers
index|[]
init|=
block|{
block|{
name|EM_IA_64
block|,
name|ia64_process_unwind
block|}
block|,
block|{
name|EM_PARISC
block|,
name|hppa_process_unwind
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_unwind
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|handlers
index|[
name|i
index|]
operator|.
name|handler
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|handlers
index|[
name|i
index|]
operator|.
name|machtype
condition|)
return|return
name|handlers
index|[
name|i
index|]
operator|.
name|handler
argument_list|(
name|file
argument_list|)
return|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_section_mips_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_FLAGS
case|:
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"NONE\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|opts
index|[]
init|=
block|{
literal|"QUICKSTART"
block|,
literal|"NOTPOT"
block|,
literal|"NO_LIBRARY_REPLACEMENT"
block|,
literal|"NO_MOVE"
block|,
literal|"SGI_ONLY"
block|,
literal|"GUARANTEE_INIT"
block|,
literal|"DELTA_C_PLUS_PLUS"
block|,
literal|"GUARANTEE_START_INIT"
block|,
literal|"PIXIE"
block|,
literal|"DEFAULT_DELAY_LOAD"
block|,
literal|"REQUICKSTART"
block|,
literal|"REQUICKSTARTED"
block|,
literal|"CORD"
block|,
literal|"NO_UNRES_UNDEF"
block|,
literal|"RLD_ORDER_SAFE"
block|}
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|NUM_ELEM
argument_list|(
name|opts
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|&
operator|(
literal|1
operator|<<
name|cnt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|opts
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Interface Version: %s\n"
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<corrupt: %ld>\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
block|{
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|time
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|timebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Time Stamp: %s\n"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
case|case
name|DT_MIPS_CONFLICTNO
case|:
case|case
name|DT_MIPS_LIBLISTNO
case|:
case|case
name|DT_MIPS_SYMTABNO
case|:
case|case
name|DT_MIPS_UNREFEXTNO
case|:
case|case
name|DT_MIPS_HIPAGENO
case|:
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_section_parisc_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HP_DLD_FLAGS
case|:
block|{
specifier|static
struct|struct
block|{
name|long
name|int
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|flags
index|[]
init|=
block|{
block|{
name|DT_HP_DEBUG_PRIVATE
block|,
literal|"HP_DEBUG_PRIVATE"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK
block|,
literal|"HP_DEBUG_CALLBACK"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK_BOR
block|,
literal|"HP_DEBUG_CALLBACK_BOR"
block|}
block|,
block|{
name|DT_HP_NO_ENVVAR
block|,
literal|"HP_NO_ENVVAR"
block|}
block|,
block|{
name|DT_HP_BIND_NOW
block|,
literal|"HP_BIND_NOW"
block|}
block|,
block|{
name|DT_HP_BIND_NONFATAL
block|,
literal|"HP_BIND_NONFATAL"
block|}
block|,
block|{
name|DT_HP_BIND_VERBOSE
block|,
literal|"HP_BIND_VERBOSE"
block|}
block|,
block|{
name|DT_HP_BIND_RESTRICTED
block|,
literal|"HP_BIND_RESTRICTED"
block|}
block|,
block|{
name|DT_HP_BIND_SYMBOLIC
block|,
literal|"HP_BIND_SYMBOLIC"
block|}
block|,
block|{
name|DT_HP_RPATH_FIRST
block|,
literal|"HP_RPATH_FIRST"
block|}
block|,
block|{
name|DT_HP_BIND_DEPTH_FIRST
block|,
literal|"HP_BIND_DEPTH_FIRST"
block|}
block|,
block|{
name|DT_HP_GST
block|,
literal|"HP_GST"
block|}
block|,
block|{
name|DT_HP_SHLIB_FIXED
block|,
literal|"HP_SHLIB_FIXED"
block|}
block|,
block|{
name|DT_HP_MERGE_SHLIB_SEG
block|,
literal|"HP_MERGE_SHLIB_SEG"
block|}
block|,
block|{
name|DT_HP_NODELETE
block|,
literal|"HP_NODELETE"
block|}
block|,
block|{
name|DT_HP_GROUP
block|,
literal|"HP_GROUP"
block|}
block|,
block|{
name|DT_HP_PROTECT_LINKAGE_TABLE
block|,
literal|"HP_PROTECT_LINKAGE_TABLE"
block|}
block|}
struct|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|bfd_vma
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flags
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|val
operator|&
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|flags
index|[
name|cnt
index|]
operator|.
name|str
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|val
operator|^=
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
operator|||
name|first
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|val
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_section_ia64_val
parameter_list|(
name|Elf_Internal_Dyn
modifier|*
name|entry
parameter_list|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_IA_64_PLT_RESERVE
case|:
comment|/* First 3 slots reserved.  */
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -- "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
operator|+
operator|(
literal|3
operator|*
literal|8
operator|)
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_dynamic_section
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf32_External_Dyn
modifier|*
name|edyn
decl_stmt|,
modifier|*
name|ext
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|edyn
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_addr
argument_list|,
literal|1
argument_list|,
name|dynamic_size
argument_list|,
name|_
argument_list|(
literal|"dynamic section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edyn
condition|)
return|return
literal|0
return|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment, and we    might not have the luxury of section headers.  Look for the DT_NULL    terminator to determine the number of entries.  */
for|for
control|(
name|ext
operator|=
name|edyn
operator|,
name|dynamic_nent
operator|=
literal|0
init|;
operator|(
name|char
operator|*
operator|)
name|ext
operator|<
operator|(
name|char
operator|*
operator|)
name|edyn
operator|+
name|dynamic_size
condition|;
name|ext
operator|++
control|)
block|{
name|dynamic_nent
operator|++
expr_stmt|;
if|if
condition|(
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_tag
argument_list|)
operator|==
name|DT_NULL
condition|)
break|break;
block|}
name|dynamic_section
operator|=
name|cmalloc
argument_list|(
name|dynamic_nent
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_section
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ext
operator|=
name|edyn
operator|,
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
name|ext
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_dynamic_section
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf64_External_Dyn
modifier|*
name|edyn
decl_stmt|,
modifier|*
name|ext
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|edyn
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_addr
argument_list|,
literal|1
argument_list|,
name|dynamic_size
argument_list|,
name|_
argument_list|(
literal|"dynamic section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edyn
condition|)
return|return
literal|0
return|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment, and we    might not have the luxury of section headers.  Look for the DT_NULL    terminator to determine the number of entries.  */
for|for
control|(
name|ext
operator|=
name|edyn
operator|,
name|dynamic_nent
operator|=
literal|0
init|;
operator|(
name|char
operator|*
operator|)
name|ext
operator|<
operator|(
name|char
operator|*
operator|)
name|edyn
operator|+
name|dynamic_size
condition|;
name|ext
operator|++
control|)
block|{
name|dynamic_nent
operator|++
expr_stmt|;
if|if
condition|(
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_tag
argument_list|)
operator|==
name|DT_NULL
condition|)
break|break;
block|}
name|dynamic_section
operator|=
name|cmalloc
argument_list|(
name|dynamic_nent
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_section
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ext
operator|=
name|edyn
operator|,
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
name|ext
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET
argument_list|(
name|ext
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_dynamic_flags
parameter_list|(
name|bfd_vma
name|flags
parameter_list|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|flags
operator|&
operator|-
name|flags
expr_stmt|;
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|DF_ORIGIN
case|:
name|fputs
argument_list|(
literal|"ORIGIN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_SYMBOLIC
case|:
name|fputs
argument_list|(
literal|"SYMBOLIC"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_TEXTREL
case|:
name|fputs
argument_list|(
literal|"TEXTREL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_BIND_NOW
case|:
name|fputs
argument_list|(
literal|"BIND_NOW"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_STATIC_TLS
case|:
name|fputs
argument_list|(
literal|"STATIC_TLS"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
literal|"unknown"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse and display the contents of the dynamic section.  */
end_comment

begin_function
specifier|static
name|int
name|process_dynamic_section
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|dynamic_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere is no dynamic section in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_dynamic_section
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_dynamic_section
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the appropriate symbol table.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
operator|++
name|entry
control|)
block|{
name|Elf_Internal_Shdr
name|section
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_SYMTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_SYMTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the symbol table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work.  */
name|section
operator|.
name|sh_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_file_offset
operator|!=
literal|0
condition|)
name|section
operator|.
name|sh_size
operator|=
name|archive_file_size
operator|-
name|section
operator|.
name|sh_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file!\n"
argument_list|)
argument_list|)
expr_stmt|;
name|section
operator|.
name|sh_size
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|section
operator|.
name|sh_offset
expr_stmt|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
name|section
operator|.
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
else|else
name|section
operator|.
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
expr_stmt|;
name|num_dynamic_syms
operator|=
name|section
operator|.
name|sh_size
operator|/
name|section
operator|.
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|num_dynamic_syms
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the number of symbols to load\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
operator|&
name|section
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly find a string table.  */
if|if
condition|(
name|dynamic_strings
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
operator|++
name|entry
control|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
name|long
name|str_tab_len
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_STRTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_STRTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the string table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work.  */
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_file_offset
operator|!=
literal|0
condition|)
name|str_tab_len
operator|=
name|archive_file_size
operator|-
name|offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|str_tab_len
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|str_tab_len
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the length of the dynamic string table\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_strings
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|str_tab_len
argument_list|,
name|_
argument_list|(
literal|"dynamic string table"
argument_list|)
argument_list|)
expr_stmt|;
name|dynamic_strings_length
operator|=
name|str_tab_len
expr_stmt|;
break|break;
block|}
block|}
comment|/* And find the syminfo section if available.  */
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|syminsz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
operator|++
name|entry
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINENT
condition|)
block|{
comment|/* Note: these braces are necessary to avoid a syntax 		 error from the SunOS4 C compiler.  */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
operator|==
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINSZ
condition|)
name|syminsz
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINFO
condition|)
name|dynamic_syminfo_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|syminsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo_offset
operator|!=
literal|0
operator|&&
name|syminsz
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Syminfo
modifier|*
name|extsyminfo
decl_stmt|,
modifier|*
name|extsym
decl_stmt|;
name|Elf_Internal_Syminfo
modifier|*
name|syminfo
decl_stmt|;
comment|/* There is a syminfo section.  Read the data.  */
name|extsyminfo
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|dynamic_syminfo_offset
argument_list|,
literal|1
argument_list|,
name|syminsz
argument_list|,
name|_
argument_list|(
literal|"symbol information"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extsyminfo
condition|)
return|return
literal|0
return|;
name|dynamic_syminfo
operator|=
name|malloc
argument_list|(
name|syminsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dynamic_syminfo_nent
operator|=
name|syminsz
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
expr_stmt|;
for|for
control|(
name|syminfo
operator|=
name|dynamic_syminfo
operator|,
name|extsym
operator|=
name|extsyminfo
init|;
name|syminfo
operator|<
name|dynamic_syminfo
operator|+
name|dynamic_syminfo_nent
condition|;
operator|++
name|syminfo
operator|,
operator|++
name|extsym
control|)
block|{
name|syminfo
operator|->
name|si_boundto
operator|=
name|BYTE_GET
argument_list|(
name|extsym
operator|->
name|si_boundto
argument_list|)
expr_stmt|;
name|syminfo
operator|->
name|si_flags
operator|=
name|BYTE_GET
argument_list|(
name|extsym
operator|->
name|si_flags
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|extsyminfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_dynamic
operator|&&
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic section at offset 0x%lx contains %u entries:\n"
argument_list|)
argument_list|,
name|dynamic_addr
argument_list|,
name|dynamic_nent
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Tag        Type                         Name/Value\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|<
name|dynamic_section
operator|+
name|dynamic_nent
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
block|{
specifier|const
name|char
modifier|*
name|dtype
decl_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s)%*s"
argument_list|,
name|dtype
argument_list|,
operator|(
operator|(
name|is_32bit_elf
condition|?
literal|27
else|:
literal|19
operator|)
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dtype
argument_list|)
operator|)
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_FLAGS
case|:
if|if
condition|(
name|do_dynamic
condition|)
name|print_dynamic_flags
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUXILIARY
case|:
case|case
name|DT_FILTER
case|:
case|case
name|DT_CONFIG
case|:
case|case
name|DT_DEPAUDIT
case|:
case|case
name|DT_AUDIT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_AUXILIARY
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Auxiliary library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_FILTER
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Filter library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_CONFIG
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Configuration file"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_DEPAUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Dependency audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
condition|)
name|printf
argument_list|(
literal|": [%s]\n"
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FEATURE
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DTF_1_PARINIT
condition|)
block|{
name|printf
argument_list|(
literal|" PARINIT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_PARINIT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DTF_1_CONFEXP
condition|)
block|{
name|printf
argument_list|(
literal|" CONFEXP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_CONFEXP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_POSFLAG_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_P1_LAZYLOAD
condition|)
block|{
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_LAZYLOAD
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_P1_GROUPPERM
condition|)
block|{
name|printf
argument_list|(
literal|" GROUPPERM"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_GROUPPERM
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FLAGS_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_1_NOW
condition|)
block|{
name|printf
argument_list|(
literal|" NOW"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOW
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GLOBAL
condition|)
block|{
name|printf
argument_list|(
literal|" GLOBAL"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GLOBAL
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GROUP
condition|)
block|{
name|printf
argument_list|(
literal|" GROUP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GROUP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODELETE
condition|)
block|{
name|printf
argument_list|(
literal|" NODELETE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODELETE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_LOADFLTR
condition|)
block|{
name|printf
argument_list|(
literal|" LOADFLTR"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_LOADFLTR
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INITFIRST
condition|)
block|{
name|printf
argument_list|(
literal|" INITFIRST"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INITFIRST
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NOOPEN
condition|)
block|{
name|printf
argument_list|(
literal|" NOOPEN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOOPEN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_ORIGIN
condition|)
block|{
name|printf
argument_list|(
literal|" ORIGIN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_ORIGIN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_DIRECT
condition|)
block|{
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_DIRECT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_TRANS
condition|)
block|{
name|printf
argument_list|(
literal|" TRANS"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_TRANS
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INTERPOSE
condition|)
block|{
name|printf
argument_list|(
literal|" INTERPOSE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INTERPOSE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODEFLIB
condition|)
block|{
name|printf
argument_list|(
literal|" NODEFLIB"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODEFLIB
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODUMP
condition|)
block|{
name|printf
argument_list|(
literal|" NODUMP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODUMP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_CONLFAT
condition|)
block|{
name|printf
argument_list|(
literal|" CONLFAT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_CONLFAT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_PLTREL
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
name|puts
argument_list|(
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NULL
case|:
case|case
name|DT_NEEDED
case|:
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_DEBUG
case|:
case|case
name|DT_TEXTREL
case|:
case|case
name|DT_JMPREL
case|:
case|case
name|DT_RUNPATH
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
condition|)
name|name
operator|=
name|GET_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_NEEDED
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Shared library: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|name
argument_list|,
name|program_interpreter
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" program interpreter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library soname: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library rpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RUNPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library runpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELENT
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
case|case
name|DT_PLTPADSZ
case|:
case|case
name|DT_MOVEENT
case|:
case|case
name|DT_MOVESZ
case|:
case|case
name|DT_INIT_ARRAYSZ
case|:
case|case
name|DT_FINI_ARRAYSZ
case|:
case|case
name|DT_GNU_CONFLICTSZ
case|:
case|case
name|DT_GNU_LIBLISTSZ
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (bytes)\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_VERDEFNUM
case|:
case|case
name|DT_VERNEEDNUM
case|:
case|case
name|DT_RELACOUNT
case|:
case|case
name|DT_RELCOUNT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_SYMINSZ
case|:
case|case
name|DT_SYMINENT
case|:
case|case
name|DT_SYMINFO
case|:
case|case
name|DT_USED
case|:
case|case
name|DT_INIT_ARRAY
case|:
case|case
name|DT_FINI_ARRAY
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_USED
operator|&&
name|VALID_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|GET_DYNAMIC_NAME
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Not needed object: [%s]\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_BIND_NOW
case|:
comment|/* The value of this entry is ignored.  */
if|if
condition|(
name|do_dynamic
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_GNU_PRELINKED
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|time
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04u-%02u-%02uT%02u:%02u:%02u\n"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_GNU_HASH
case|:
name|dynamic_info_DT_GNU_HASH
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|entry
operator|->
name|d_tag
operator|>=
name|DT_VERSYM
operator|)
operator|&&
operator|(
name|entry
operator|->
name|d_tag
operator|<=
name|DT_VERNEEDNUM
operator|)
condition|)
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|dynamic_section_mips_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|dynamic_section_parisc_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|dynamic_section_ia64_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_ver_flags
parameter_list|(
name|unsigned
name|int
name|flags
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"BASE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_WEAK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"| "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"WEAK "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|VER_FLG_BASE
operator||
name|VER_FLG_WEAK
operator|)
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"|<unknown>"
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the version sections.  */
end_comment

begin_function
specifier|static
name|int
name|process_version_sections
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|do_version
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_GNU_verdef
case|:
block|{
name|Elf_External_Verdef
modifier|*
name|edefs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion definition section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|?
name|SECTION_NAME
argument_list|(
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
name|edefs
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version definition section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edefs
condition|)
break|break;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|char
modifier|*
name|vstart
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|edef
decl_stmt|;
name|Elf_Internal_Verdef
name|ent
decl_stmt|;
name|Elf_External_Verdaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Verdaux
name|aux
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|edefs
operator|)
operator|+
name|idx
expr_stmt|;
name|edef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vd_version
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_flags
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_cnt
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_hash
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Rev: %d  Flags: %s"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vd_version
argument_list|,
name|get_ver_flags
argument_list|(
name|ent
operator|.
name|vd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Index: %d  Cnt: %d  "
argument_list|)
argument_list|,
name|ent
operator|.
name|vd_ndx
argument_list|,
name|ent
operator|.
name|vd_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vd_aux
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vda_name
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name: %s\n"
argument_list|)
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vda_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name index: %ld\n"
argument_list|)
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vd_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|ent
operator|.
name|vd_cnt
condition|;
name|j
operator|++
control|)
block|{
name|isum
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vda_name
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d: %s\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vda_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d, name index: %ld\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vd_next
expr_stmt|;
block|}
name|free
argument_list|(
name|edefs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_verneed
case|:
block|{
name|Elf_External_Verneed
modifier|*
name|eneed
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion needs section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link to section: %ld (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|?
name|SECTION_NAME
argument_list|(
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
name|eneed
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version need section"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eneed
condition|)
break|break;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_External_Verneed
modifier|*
name|entry
decl_stmt|;
name|Elf_Internal_Verneed
name|ent
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|char
modifier|*
name|vstart
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|eneed
operator|)
operator|+
name|idx
expr_stmt|;
name|entry
operator|=
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vn_version
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_cnt
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_file
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Version: %d"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vn_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|ent
operator|.
name|vn_file
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %s"
argument_list|)
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|ent
operator|.
name|vn_file
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %lx"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Cnt: %d\n"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vn_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vn_aux
init|;
name|j
operator|<
name|ent
operator|.
name|vn_cnt
condition|;
operator|++
name|j
control|)
block|{
name|Elf_External_Vernaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Vernaux
name|aux
decl_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vna_hash
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_flags
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vna_name
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x:   Name: %s"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|aux
operator|.
name|vna_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x:   Name index: %lx"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|aux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags: %s  Version: %d\n"
argument_list|)
argument_list|,
name|get_ver_flags
argument_list|(
name|aux
operator|.
name|vna_flags
argument_list|)
argument_list|,
name|aux
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|isum
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vn_next
expr_stmt|;
block|}
name|free
argument_list|(
name|eneed
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_versym
case|:
block|{
name|Elf_Internal_Shdr
modifier|*
name|link_section
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|edata
decl_stmt|;
name|unsigned
name|short
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symbols
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|long
name|off
decl_stmt|;
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
break|break;
name|link_section
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|total
operator|=
name|section
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
expr_stmt|;
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|link_section
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
break|break;
name|found
operator|=
literal|1
expr_stmt|;
name|symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|link_section
argument_list|)
expr_stmt|;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|link_section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"version string table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strtab
condition|)
break|break;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion symbols section '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: "
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|link_section
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
argument_list|,
name|total
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|edata
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|off
argument_list|,
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"version symbol data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edata
condition|)
block|{
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|cmalloc
argument_list|(
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|total
init|;
name|cnt
operator|--
condition|;
control|)
name|data
index|[
name|cnt
index|]
operator|=
name|byte_get
argument_list|(
name|edata
operator|+
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edata
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|total
condition|;
name|cnt
operator|+=
literal|4
control|)
block|{
name|int
name|j
decl_stmt|,
name|nn
decl_stmt|;
name|int
name|check_def
decl_stmt|,
name|check_need
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|printf
argument_list|(
literal|"  %03x:"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
literal|4
operator|)
operator|&&
operator|(
name|cnt
operator|+
name|j
operator|)
operator|<
name|total
condition|;
operator|++
name|j
control|)
switch|switch
condition|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   0 (*local*)    "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   1 (*global*)   "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nn
operator|=
name|printf
argument_list|(
literal|"%4x%c"
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x8000
condition|?
literal|'h'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|1
expr_stmt|;
name|check_need
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
name|SECTION_HEADER
argument_list|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
argument_list|)
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
block|{
if|if
condition|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|check_def
operator|=
literal|0
expr_stmt|;
else|else
name|check_need
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|check_need
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Verneed
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|unsigned
name|long
name|a_off
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evn
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evn
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version need"
argument_list|)
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|a_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|get_data
argument_list|(
operator|&
name|evna
argument_list|,
name|file
argument_list|,
name|a_off
argument_list|,
sizeof|sizeof
argument_list|(
name|evna
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version need aux (2)"
argument_list|)
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|a_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
condition|)
do|;
block|}
if|if
condition|(
name|check_def
operator|&&
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|evd
argument_list|)
expr_stmt|;
do|do
block|{
name|get_data
argument_list|(
operator|&
name|evd
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version def"
argument_list|)
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivd
operator|.
name|vd_ndx
operator|==
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
condition|)
block|{
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|evda
argument_list|,
name|file
argument_list|,
name|offset
operator|-
name|ivd
operator|.
name|vd_next
operator|+
name|ivd
operator|.
name|vd_aux
argument_list|,
sizeof|sizeof
argument_list|(
name|evda
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version def aux"
argument_list|)
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nn
operator|<
literal|18
condition|)
name|printf
argument_list|(
literal|"%*c"
argument_list|,
literal|18
operator|-
name|nn
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNo version information found in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_binding
parameter_list|(
name|unsigned
name|int
name|binding
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|binding
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"LOCAL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"GLOBAL"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"WEAK"
return|;
default|default:
if|if
condition|(
name|binding
operator|>=
name|STB_LOPROC
operator|&&
name|binding
operator|<=
name|STB_HIPROC
condition|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
operator|>=
name|STB_LOOS
operator|&&
name|binding
operator|<=
name|STB_HIOS
condition|)
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"TLS"
return|;
case|case
name|STT_RELC
case|:
return|return
literal|"RELC"
return|;
case|case
name|STT_SRELC
case|:
return|return
literal|"SRELC"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|STT_LOPROC
operator|&&
name|type
operator|<=
name|STT_HIPROC
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_ARM
operator|&&
name|type
operator|==
name|STT_ARM_TFUNC
condition|)
return|return
literal|"THUMB_FUNC"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
name|type
operator|==
name|STT_REGISTER
condition|)
return|return
literal|"REGISTER"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
operator|&&
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
return|return
literal|"PARISC_MILLI"
return|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|STT_LOOS
operator|&&
name|type
operator|<=
name|STT_HIOS
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|STT_HP_OPAQUE
condition|)
return|return
literal|"HP_OPAQUE"
return|;
if|if
condition|(
name|type
operator|==
name|STT_HP_STUB
condition|)
return|return
literal|"HP_STUB"
return|;
block|}
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_visibility
parameter_list|(
name|unsigned
name|int
name|visibility
parameter_list|)
block|{
switch|switch
condition|(
name|visibility
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
return|return
literal|"DEFAULT"
return|;
case|case
name|STV_INTERNAL
case|:
return|return
literal|"INTERNAL"
return|;
case|case
name|STV_HIDDEN
case|:
return|return
literal|"HIDDEN"
return|;
case|case
name|STV_PROTECTED
case|:
return|return
literal|"PROTECTED"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_symbol_other
parameter_list|(
name|unsigned
name|int
name|other
parameter_list|)
block|{
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|STO_OPTIONAL
case|:
return|return
literal|"OPTIONAL"
return|;
case|case
name|STO_MIPS16
case|:
return|return
literal|"MIPS16"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_other
parameter_list|(
name|unsigned
name|int
name|other
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|other
operator|==
literal|0
condition|)
return|return
literal|""
return|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
name|result
operator|=
name|get_mips_symbol_other
argument_list|(
name|other
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|_
argument_list|(
literal|"<other>: %x"
argument_list|)
argument_list|,
name|other
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_index_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHN_UNDEF
case|:
return|return
literal|"UND"
return|;
case|case
name|SHN_ABS
case|:
return|return
literal|"ABS"
return|;
case|case
name|SHN_COMMON
case|:
return|return
literal|"COM"
return|;
default|default:
if|if
condition|(
name|type
operator|==
name|SHN_IA_64_ANSI_COMMON
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_IA_64
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|ELFOSABI_HPUX
condition|)
return|return
literal|"ANSI_COM"
return|;
elseif|else
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_X86_64
operator|&&
name|type
operator|==
name|SHN_X86_64_LCOMMON
condition|)
return|return
literal|"LARGE_COM"
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SHN_MIPS_SCOMMON
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
return|return
literal|"SCOM"
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SHN_MIPS_SUNDEFINED
operator|&&
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
return|return
literal|"SUND"
return|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LOPROC
operator|&&
name|type
operator|<=
name|SHN_HIPROC
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"PRC[0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LOOS
operator|&&
name|type
operator|<=
name|SHN_HIOS
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"OS [0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LORESERVE
operator|&&
name|type
operator|<=
name|SHN_HIRESERVE
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"RSV[0x%04x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%3d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
modifier|*
name|get_dynamic_data
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|number
parameter_list|,
name|unsigned
name|int
name|ent_size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|e_data
decl_stmt|;
name|bfd_vma
modifier|*
name|i_data
decl_stmt|;
name|e_data
operator|=
name|cmalloc
argument_list|(
name|number
argument_list|,
name|ent_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|e_data
argument_list|,
name|ent_size
argument_list|,
name|number
argument_list|,
name|file
argument_list|)
operator|!=
name|number
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read in dynamic data\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i_data
operator|=
name|cmalloc
argument_list|(
name|number
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|number
operator|--
condition|)
name|i_data
index|[
name|number
index|]
operator|=
name|byte_get
argument_list|(
name|e_data
operator|+
name|number
operator|*
name|ent_size
argument_list|,
name|ent_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|i_data
return|;
block|}
end_function

begin_comment
comment|/* Dump the symbol table.  */
end_comment

begin_function
specifier|static
name|int
name|process_symbol_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|nbuckets
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|nchains
init|=
literal|0
decl_stmt|;
name|bfd_vma
modifier|*
name|buckets
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|chains
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|ngnubuckets
init|=
literal|0
decl_stmt|;
name|bfd_vma
modifier|*
name|gnubuckets
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|gnuchains
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|do_syms
operator|&&
operator|!
name|do_histogram
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
operator|(
operator|(
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
operator|)
operator|||
name|do_histogram
operator|)
condition|)
block|{
name|unsigned
name|char
name|nb
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|nc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|hash_ent_size
init|=
literal|4
decl_stmt|;
if|if
condition|(
operator|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_ALPHA
operator|||
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_S390
operator|||
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_S390_OLD
operator|)
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
name|hash_ent_size
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|dynamic_info
index|[
name|DT_HASH
index|]
argument_list|,
sizeof|sizeof
name|nb
operator|+
sizeof|sizeof
name|nc
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nb
argument_list|,
name|hash_ent_size
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of buckets\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nc
argument_list|,
name|hash_ent_size
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of chains\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nbuckets
operator|=
name|byte_get
argument_list|(
name|nb
argument_list|,
name|hash_ent_size
argument_list|)
expr_stmt|;
name|nchains
operator|=
name|byte_get
argument_list|(
name|nc
argument_list|,
name|hash_ent_size
argument_list|)
expr_stmt|;
name|buckets
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nbuckets
argument_list|,
name|hash_ent_size
argument_list|)
expr_stmt|;
name|chains
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nchains
argument_list|,
name|hash_ent_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buckets
operator|==
name|NULL
operator|||
name|chains
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_syms
operator|&&
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|hn
decl_stmt|;
name|bfd_vma
name|si
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table for image:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
name|hn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|buckets
index|[
name|hn
index|]
condition|)
continue|continue;
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|<
name|nchains
operator|&&
name|si
operator|>
literal|0
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|psym
operator|=
name|dynamic_symbols
operator|+
name|si
expr_stmt|;
name|n
operator|=
name|print_vma
argument_list|(
name|si
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|5
condition|)
name|fputs
argument_list|(
operator|&
literal|"     "
index|[
name|n
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3lu: "
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %6s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if any other bits in the st_other field are set. 	         Note - displaying this information disrupts the layout of the 	         table being generated, but for the moment this case is very rare.  */
if|if
condition|(
name|psym
operator|->
name|st_other
operator|^
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
condition|)
name|printf
argument_list|(
literal|" [%s] "
argument_list|,
name|get_symbol_other
argument_list|(
name|psym
operator|->
name|st_other
operator|^
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3.3s "
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|psym
operator|->
name|st_name
argument_list|)
condition|)
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|psym
operator|->
name|st_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<corrupt: %14ld>"
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
operator|&&
operator|!
name|do_using_dynamic
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|unsigned
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|strtab
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|int
name|strtab_size
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
continue|continue;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table '%s' contains %lu entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|section
operator|->
name|sh_link
operator|==
name|elf_header
operator|.
name|e_shstrndx
condition|)
block|{
name|strtab
operator|=
name|string_table
expr_stmt|;
name|strtab_size
operator|=
name|string_table_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"string table"
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_size
operator|=
name|strtab
operator|!=
name|NULL
condition|?
name|string_sec
operator|->
name|sh_size
else|:
literal|0
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
literal|0
operator|,
name|psym
operator|=
name|symtab
init|;
name|si
operator|<
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
condition|;
name|si
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%6d: "
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-7s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if any other bits in the st_other field are set. 	         Note - displaying this information disrupts the layout of the 	         table being generated, but for the moment this case is very rare.  */
if|if
condition|(
name|psym
operator|->
name|st_other
operator|^
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
condition|)
name|printf
argument_list|(
literal|" [%s] "
argument_list|,
name|get_symbol_other
argument_list|(
name|psym
operator|->
name|st_other
operator|^
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s "
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|psym
operator|->
name|st_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|psym
operator|->
name|st_name
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|data
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|short
name|vers_data
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|is_nobits
decl_stmt|;
name|int
name|check_def
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|data
operator|+
name|si
operator|*
sizeof|sizeof
argument_list|(
name|vers_data
argument_list|)
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|data
argument_list|,
name|file
argument_list|,
name|offset
operator|+
name|si
operator|*
sizeof|sizeof
argument_list|(
name|vers_data
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version data"
argument_list|)
argument_list|)
expr_stmt|;
name|vers_data
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|is_nobits
operator|=
operator|(
name|SECTION_HEADER_INDEX
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
operator|<
name|elf_header
operator|.
name|e_shnum
operator|&&
name|SECTION_HEADER
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
operator|)
expr_stmt|;
name|check_def
operator|=
operator|(
name|psym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
operator|||
name|vers_data
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
operator|&&
operator|(
name|is_nobits
operator|||
operator|!
name|check_def
operator|)
condition|)
block|{
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
comment|/* We must test both.  */
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|evn
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|vna_off
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evn
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evn
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version need"
argument_list|)
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|vna_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evna
argument_list|,
name|file
argument_list|,
name|vna_off
argument_list|,
sizeof|sizeof
argument_list|(
name|evna
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version need aux (3)"
argument_list|)
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|vna_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|vers_data
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
break|break;
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
block|{
name|printf
argument_list|(
literal|"@%s (%d)"
argument_list|,
name|ivna
operator|.
name|vna_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
else|:
literal|"<corrupt>"
argument_list|,
name|ivna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_nobits
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad dynamic symbol\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|check_def
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|check_def
condition|)
block|{
if|if
condition|(
name|vers_data
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Verdef
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|get_data
argument_list|(
operator|&
name|evd
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version def"
argument_list|)
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|vers_data
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
name|offset
operator|-=
name|ivd
operator|.
name|vd_next
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_aux
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|evda
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|evda
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_
argument_list|(
literal|"version def aux"
argument_list|)
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|!=
name|ivda
operator|.
name|vda_name
condition|)
name|printf
argument_list|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
condition|?
literal|"@%s"
else|:
literal|"@@%s"
argument_list|,
name|ivda
operator|.
name|vda_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|!=
name|string_table
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic symbol information is not available for displaying symbols.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_histogram
operator|&&
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
modifier|*
name|lengths
decl_stmt|;
name|unsigned
name|long
modifier|*
name|counts
decl_stmt|;
name|unsigned
name|long
name|hn
decl_stmt|;
name|bfd_vma
name|si
decl_stmt|;
name|unsigned
name|long
name|maxlength
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|nzero_counts
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|nsyms
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHistogram for bucket list length (total of %lu buckets):\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nbuckets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Length  Number     %% of total  Coverage\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lengths
operator|=
name|calloc
argument_list|(
name|nbuckets
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lengths
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengths
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
block|{
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|>
literal|0
operator|&&
name|si
operator|<
name|nchains
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|maxlength
operator|<
operator|++
name|lengths
index|[
name|hn
index|]
condition|)
operator|++
name|maxlength
expr_stmt|;
block|}
block|}
name|counts
operator|=
name|calloc
argument_list|(
name|maxlength
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|counts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
operator|++
name|counts
index|[
name|lengths
index|[
name|hn
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nbuckets
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"      0  %-10lu (%5.1f%%)\n"
argument_list|,
name|counts
index|[
literal|0
index|]
argument_list|,
operator|(
name|counts
index|[
literal|0
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxlength
condition|;
operator|++
name|i
control|)
block|{
name|nzero_counts
operator|+=
name|counts
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"
argument_list|,
name|i
argument_list|,
name|counts
index|[
name|i
index|]
argument_list|,
operator|(
name|counts
index|[
name|i
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|,
operator|(
name|nzero_counts
operator|*
literal|100.0
operator|)
operator|/
name|nsyms
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lengths
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chains
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_histogram
operator|&&
name|dynamic_info_DT_GNU_HASH
condition|)
block|{
name|unsigned
name|char
name|nb
index|[
literal|16
index|]
decl_stmt|;
name|bfd_vma
name|i
decl_stmt|,
name|maxchain
init|=
literal|0xffffffff
decl_stmt|,
name|symidx
decl_stmt|,
name|bitmaskwords
decl_stmt|;
name|unsigned
name|long
modifier|*
name|lengths
decl_stmt|;
name|unsigned
name|long
modifier|*
name|counts
decl_stmt|;
name|unsigned
name|long
name|hn
decl_stmt|;
name|unsigned
name|long
name|maxlength
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|nzero_counts
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|nsyms
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|buckets_vma
decl_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|dynamic_info_DT_GNU_HASH
argument_list|,
sizeof|sizeof
name|nb
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nb
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of buckets\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ngnubuckets
operator|=
name|byte_get
argument_list|(
name|nb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|symidx
operator|=
name|byte_get
argument_list|(
name|nb
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bitmaskwords
operator|=
name|byte_get
argument_list|(
name|nb
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buckets_vma
operator|=
name|dynamic_info_DT_GNU_HASH
operator|+
literal|16
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|buckets_vma
operator|+=
name|bitmaskwords
operator|*
literal|4
expr_stmt|;
else|else
name|buckets_vma
operator|+=
name|bitmaskwords
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|buckets_vma
argument_list|,
literal|4
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|gnubuckets
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|ngnubuckets
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnubuckets
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngnubuckets
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gnubuckets
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|gnubuckets
index|[
name|i
index|]
operator|<
name|symidx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|maxchain
operator|==
literal|0xffffffff
operator|||
name|gnubuckets
index|[
name|i
index|]
operator|>
name|maxchain
condition|)
name|maxchain
operator|=
name|gnubuckets
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|maxchain
operator|==
literal|0xffffffff
condition|)
return|return
literal|0
return|;
name|maxchain
operator|-=
name|symidx
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|buckets_vma
operator|+
literal|4
operator|*
operator|(
name|ngnubuckets
operator|+
name|maxchain
operator|)
argument_list|,
literal|4
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
name|nb
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to determine last chain length\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|maxchain
operator|+
literal|1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|++
name|maxchain
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|byte_get
argument_list|(
name|nb
argument_list|,
literal|4
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|buckets_vma
operator|+
literal|4
operator|*
name|ngnubuckets
argument_list|,
literal|4
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|gnuchains
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|maxchain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnuchains
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|lengths
operator|=
name|calloc
argument_list|(
name|ngnubuckets
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lengths
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengths
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ngnubuckets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Length  Number     %% of total  Coverage\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|ngnubuckets
condition|;
operator|++
name|hn
control|)
if|if
condition|(
name|gnubuckets
index|[
name|hn
index|]
operator|!=
literal|0
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|,
name|length
init|=
literal|1
decl_stmt|;
for|for
control|(
name|off
operator|=
name|gnubuckets
index|[
name|hn
index|]
operator|-
name|symidx
init|;
operator|(
name|gnuchains
index|[
name|off
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
operator|++
name|off
control|)
operator|++
name|length
expr_stmt|;
name|lengths
index|[
name|hn
index|]
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|maxlength
condition|)
name|maxlength
operator|=
name|length
expr_stmt|;
name|nsyms
operator|+=
name|length
expr_stmt|;
block|}
name|counts
operator|=
name|calloc
argument_list|(
name|maxlength
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|counts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|ngnubuckets
condition|;
operator|++
name|hn
control|)
operator|++
name|counts
index|[
name|lengths
index|[
name|hn
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ngnubuckets
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"      0  %-10lu (%5.1f%%)\n"
argument_list|,
name|counts
index|[
literal|0
index|]
argument_list|,
operator|(
name|counts
index|[
literal|0
index|]
operator|*
literal|100.0
operator|)
operator|/
name|ngnubuckets
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|maxlength
condition|;
operator|++
name|j
control|)
block|{
name|nzero_counts
operator|+=
name|counts
index|[
name|j
index|]
operator|*
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n"
argument_list|,
name|j
argument_list|,
name|counts
index|[
name|j
index|]
argument_list|,
operator|(
name|counts
index|[
name|j
index|]
operator|*
literal|100.0
operator|)
operator|/
name|ngnubuckets
argument_list|,
operator|(
name|nzero_counts
operator|*
literal|100.0
operator|)
operator|/
name|nsyms
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lengths
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gnubuckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gnuchains
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_syminfo
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
operator|||
operator|!
name|do_dynamic
condition|)
comment|/* No syminfo, this is ok.  */
return|return
literal|1
return|;
comment|/* There better should be a dynamic symbol section.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
operator|||
name|dynamic_strings
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic info segment at offset 0x%lx contains %d entries:\n"
argument_list|)
argument_list|,
name|dynamic_syminfo_offset
argument_list|,
name|dynamic_syminfo_nent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Num: Name                           BoundTo     Flags\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dynamic_syminfo_nent
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|short
name|int
name|flags
init|=
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_flags
decl_stmt|;
name|printf
argument_list|(
literal|"%4d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|dynamic_symbols
index|[
name|i
index|]
operator|.
name|st_name
argument_list|)
condition|)
name|print_symbol
argument_list|(
literal|30
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|dynamic_symbols
index|[
name|i
index|]
operator|.
name|st_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<corrupt: %19ld>"
argument_list|,
name|dynamic_symbols
index|[
name|i
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
condition|)
block|{
case|case
name|SYMINFO_BT_SELF
case|:
name|fputs
argument_list|(
literal|"SELF       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMINFO_BT_PARENT
case|:
name|fputs
argument_list|(
literal|"PARENT     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|>
literal|0
operator|&&
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|<
name|dynamic_nent
operator|&&
name|VALID_DYNAMIC_NAME
argument_list|(
name|dynamic_section
index|[
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
condition|)
block|{
name|print_symbol
argument_list|(
literal|10
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|dynamic_section
index|[
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%-10d "
argument_list|,
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_DIRECT
condition|)
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_PASSTHRU
condition|)
name|printf
argument_list|(
literal|" PASSTHRU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_COPY
condition|)
name|printf
argument_list|(
literal|" COPY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_LAZYLOAD
condition|)
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_function
specifier|static
name|int
name|disassemble_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nAssembly dump of section %s\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX -- to be done --- XXX */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dump_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|bfd_size_type
name|bytes
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|bytes
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
operator|||
name|section
operator|->
name|sh_type
operator|==
name|SHT_NOBITS
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no data to dump.\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHex dump of section '%s':\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|section
operator|->
name|sh_addr
expr_stmt|;
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|bytes
argument_list|,
name|_
argument_list|(
literal|"section data"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start
condition|)
return|return
literal|0
return|;
comment|/* If the section being dumped has relocations against it the user might      be expecting these relocations to have been applied.  Check for this      case and issue a warning message in order to avoid confusion.      FIXME: Maybe we ought to have an option that dumps a section with      relocs applied ?  */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
if|if
condition|(
operator|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|&&
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_REL
operator|)
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|section
operator|||
name|relsec
operator|->
name|sh_size
operator|==
literal|0
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
continue|continue;
name|printf
argument_list|(
name|_
argument_list|(
literal|" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|bytes
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|lbytes
decl_stmt|;
name|lbytes
operator|=
operator|(
name|bytes
operator|>
literal|16
condition|?
literal|16
else|:
name|bytes
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lbytes
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|' '
operator|&&
name|k
operator|<
literal|0x7f
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|data
operator|+=
name|lbytes
expr_stmt|;
name|addr
operator|+=
name|lbytes
expr_stmt|;
name|bytes
operator|-=
name|lbytes
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes affected by a given reloc.    This information is architecture and reloc dependent.    Returns 4 by default, although this is not always correct.    It should return 0 if a decision cannot be made.    FIXME: This is not the correct way to solve this problem.    The proper way is to have target specific reloc sizing functions    created by the reloc-macros.h header, in the same way that it    already creates the reloc naming functions.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_reloc_size
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|reloc
parameter_list|)
block|{
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_H8S
case|:
case|case
name|EM_H8_300
case|:
case|case
name|EM_H8_300H
case|:
case|case
name|EM_H8_500
case|:
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|reloc
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* PR gas/3800 - without this information we do not correctly 	     decode the debug information generated by the h8300 assembler.  */
case|case
name|R_H8_DIR16
case|:
return|return
literal|2
return|;
default|default:
return|return
literal|4
return|;
block|}
default|default:
comment|/* FIXME: We need to extend this switch statement to cope with other 	 architecture's relocs.  (When those relocs are used against debug 	 sections, and when their size is not 4).  But see the multiple 	 inclusions of<elf/h8.h> for an example of the hoops that we need 	 to jump through in order to obtain the reloc numbers.  */
return|return
literal|4
return|;
block|}
block|}
end_function

begin_comment
comment|/* Apply addends of RELA relocations.  */
end_comment

begin_function
specifier|static
name|int
name|debug_apply_rela_addends
parameter_list|(
name|void
modifier|*
name|file
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|unsigned
name|char
modifier|*
name|start
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
if|if
condition|(
operator|!
name|is_relocatable
condition|)
return|return
literal|1
return|;
comment|/* SH uses RELA but uses in place value instead of the addend field.  */
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SH
condition|)
return|return
literal|0
return|;
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
name|unsigned
name|long
name|nrelas
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symsec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
operator|||
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_info
argument_list|)
operator|!=
name|section
operator|||
name|relsec
operator|->
name|sh_size
operator|==
literal|0
operator|||
name|SECTION_HEADER_INDEX
argument_list|(
name|relsec
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
name|symsec
operator|=
name|SECTION_HEADER
argument_list|(
name|relsec
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symsec
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
name|unsigned
name|char
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|int
name|reloc_size
decl_stmt|;
name|reloc_size
operator|=
name|get_reloc_size
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"skipping relocation of unknown size against offset 0x%lx in section %s\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rp
operator|->
name|r_offset
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|loc
operator|=
name|start
operator|+
name|rp
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
operator|(
name|loc
operator|+
name|reloc_size
operator|)
operator|>
name|end
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"skipping invalid relocation offset 0x%lx in section %s\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rp
operator|->
name|r_offset
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|sym
operator|=
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
operator|!=
literal|0
operator|&&
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
comment|/* Relocations against symbols without type can happen. 		     Gcc -feliminate-dwarf2-dups may generate symbols 		     without type for debug info.  */
operator|&&
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
comment|/* Relocations against object symbols can happen, 		     eg when referencing a global array.  For an 		     example of this see the _clz.o binary in libgcc.a.  */
operator|&&
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_OBJECT
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"skipping unexpected symbol type %s in relocation in section .rela%s\n"
argument_list|)
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* In MIPS little-endian objects, r_info isn't really a 		 64-bit little-endian value: it has a 32-bit little-endian 		 symbol index followed by four individual byte fields. 		 Reorder INFO accordingly.  */
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
operator|&&
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELFDATA2MSB
condition|)
name|rp
operator|->
name|r_info
operator|=
operator|(
operator|(
operator|(
name|rp
operator|->
name|r_info
operator|&
literal|0xffffffff
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|rp
operator|->
name|r_info
operator|>>
literal|56
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|rp
operator|->
name|r_info
operator|>>
literal|40
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|rp
operator|->
name|r_info
operator|>>
literal|24
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
name|rp
operator|->
name|r_info
operator|>>
literal|8
operator|)
operator|&
literal|0xff000000
operator|)
operator|)
expr_stmt|;
name|sym
operator|=
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
operator|!=
literal|0
operator|&&
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
operator|&&
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
operator|&&
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_OBJECT
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"skipping unexpected symbol type %s in relocation in section .rela.%s\n"
argument_list|)
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|byte_put
argument_list|(
name|loc
argument_list|,
name|rp
operator|->
name|r_addend
argument_list|,
name|reloc_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|load_debug_section
parameter_list|(
name|enum
name|dwarf_section_display_enum
name|debug
parameter_list|,
name|void
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|dwarf_section
modifier|*
name|section
init|=
operator|&
name|debug_displays
index|[
name|debug
index|]
operator|.
name|section
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
comment|/* If it is already loaded, do nothing.  */
if|if
condition|(
name|section
operator|->
name|start
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* Locate the debug section.  */
name|sec
operator|=
name|find_section
argument_list|(
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"%s section data"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|section
operator|->
name|address
operator|=
name|sec
operator|->
name|sh_addr
expr_stmt|;
name|section
operator|->
name|size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|section
operator|->
name|start
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|sec
operator|->
name|sh_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_displays
index|[
name|debug
index|]
operator|.
name|relocate
condition|)
name|debug_apply_rela_addends
argument_list|(
name|file
argument_list|,
name|sec
argument_list|,
name|section
operator|->
name|start
argument_list|)
expr_stmt|;
return|return
name|section
operator|->
name|start
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|free_debug_section
parameter_list|(
name|enum
name|dwarf_section_display_enum
name|debug
parameter_list|)
block|{
name|struct
name|dwarf_section
modifier|*
name|section
init|=
operator|&
name|debug_displays
index|[
name|debug
index|]
operator|.
name|section
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|start
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|section
operator|->
name|start
argument_list|)
expr_stmt|;
name|section
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
name|section
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_section
parameter_list|(
name|Elf_Internal_Shdr
modifier|*
name|section
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|enum
name|dwarf_section_display_enum
name|i
decl_stmt|;
name|length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no debugging data.\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|const_strneq
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|)
condition|)
name|name
operator|=
literal|".debug_info"
expr_stmt|;
comment|/* See if we know how to display the contents of this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|debug_displays
index|[
name|i
index|]
operator|.
name|section
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|struct
name|dwarf_section
modifier|*
name|sec
init|=
operator|&
name|debug_displays
index|[
name|i
index|]
operator|.
name|section
decl_stmt|;
if|if
condition|(
name|load_debug_section
argument_list|(
name|i
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|result
operator|&=
name|debug_displays
index|[
name|i
index|]
operator|.
name|display
argument_list|(
name|sec
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|info
operator|&&
name|i
operator|!=
name|abbrev
condition|)
name|free_debug_section
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|max
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Unrecognized debug section: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Set DUMP_SECTS for all sections where dumps were requested    based on section name.  */
end_comment

begin_function
specifier|static
name|void
name|initialise_dumps_byname
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dump_list_entry
modifier|*
name|cur
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|dump_sects_byname
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|any
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|any
operator|=
literal|0
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|i
argument_list|)
argument_list|,
name|cur
operator|->
name|name
argument_list|)
condition|)
block|{
name|request_dump
argument_list|(
name|i
argument_list|,
name|cur
operator|->
name|type
argument_list|)
expr_stmt|;
name|any
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|any
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"Section '%s' was not dumped because it does not exist!\n"
argument_list|)
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|process_section_contents
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_dump
condition|)
return|return;
name|initialise_dumps_byname
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
operator|&&
name|i
operator|<
name|num_dump_sects
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DISASS_DUMP
condition|)
name|disassemble_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|HEX_DUMP
condition|)
name|dump_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DEBUG_DUMP
condition|)
name|display_debug_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see if the user requested a      dump of a section that does not exist.  */
while|while
condition|(
name|i
operator|++
operator|<
name|num_dump_sects
condition|)
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"Section %d was not dumped because it does not exist!\n"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_mips_fpe_exception
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INEX
condition|)
name|fputs
argument_list|(
literal|"INEX"
argument_list|,
name|stdout
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_UFLO
condition|)
name|printf
argument_list|(
literal|"%sUFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_OFLO
condition|)
name|printf
argument_list|(
literal|"%sOFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_DIV0
condition|)
name|printf
argument_list|(
literal|"%sDIV0"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INVAL
condition|)
name|printf
argument_list|(
literal|"%sINVAL"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARM EABI attributes section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 0 = special, 1 = string, 2 = uleb123,> 0x80 == table lookup.  */
name|int
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
block|}
name|arm_attr_public_tag
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_CPU_arch
index|[]
init|=
block|{
literal|"Pre-v4"
block|,
literal|"v4"
block|,
literal|"v4T"
block|,
literal|"v5T"
block|,
literal|"v5TE"
block|,
literal|"v5TEJ"
block|,
literal|"v6"
block|,
literal|"v6KZ"
block|,
literal|"v6T2"
block|,
literal|"v6K"
block|,
literal|"v7"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ARM_ISA_use
index|[]
init|=
block|{
literal|"No"
block|,
literal|"Yes"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_THUMB_ISA_use
index|[]
init|=
block|{
literal|"No"
block|,
literal|"Thumb-1"
block|,
literal|"Thumb-2"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: VFPv3 encoding was extrapolated!  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_VFP_arch
index|[]
init|=
block|{
literal|"No"
block|,
literal|"VFPv1"
block|,
literal|"VFPv2"
block|,
literal|"VFPv3"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_WMMX_arch
index|[]
init|=
block|{
literal|"No"
block|,
literal|"WMMXv1"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_NEON_arch
index|[]
init|=
block|{
literal|"No"
block|,
literal|"NEONv1"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_config
index|[]
init|=
block|{
literal|"None"
block|,
literal|"Bare platform"
block|,
literal|"Linux application"
block|,
literal|"Linux DSO"
block|,
literal|"PalmOS 2004"
block|,
literal|"PalmOS (reserved)"
block|,
literal|"SymbianOS 2004"
block|,
literal|"SymbianOS (reserved)"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_R9_use
index|[]
init|=
block|{
literal|"V6"
block|,
literal|"SB"
block|,
literal|"TLS"
block|,
literal|"Unused"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_RW_data
index|[]
init|=
block|{
literal|"Absolute"
block|,
literal|"PC-relative"
block|,
literal|"SB-relative"
block|,
literal|"None"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_RO_DATA
index|[]
init|=
block|{
literal|"Absolute"
block|,
literal|"PC-relative"
block|,
literal|"None"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_GOT_use
index|[]
init|=
block|{
literal|"None"
block|,
literal|"direct"
block|,
literal|"GOT-indirect"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_PCS_wchar_t
index|[]
init|=
block|{
literal|"None"
block|,
literal|"??? 1"
block|,
literal|"2"
block|,
literal|"??? 3"
block|,
literal|"4"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_rounding
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"Needed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_denormal
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"Needed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_exceptions
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"Needed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_user_exceptions
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"Needed"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_number_model
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"Finite"
block|,
literal|"RTABI"
block|,
literal|"IEEE 754"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_align8_needed
index|[]
init|=
block|{
literal|"No"
block|,
literal|"Yes"
block|,
literal|"4-byte"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_align8_preserved
index|[]
init|=
block|{
literal|"No"
block|,
literal|"Yes, except leaf SP"
block|,
literal|"Yes"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_enum_size
index|[]
init|=
block|{
literal|"Unused"
block|,
literal|"small"
block|,
literal|"int"
block|,
literal|"forced to int"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_HardFP_use
index|[]
init|=
block|{
literal|"As Tag_VFP_arch"
block|,
literal|"SP only"
block|,
literal|"DP only"
block|,
literal|"SP and DP"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_VFP_args
index|[]
init|=
block|{
literal|"AAPCS"
block|,
literal|"VFP registers"
block|,
literal|"custom"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_WMMX_args
index|[]
init|=
block|{
literal|"AAPCS"
block|,
literal|"WMMX registers"
block|,
literal|"custom"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_optimization_goals
index|[]
init|=
block|{
literal|"None"
block|,
literal|"Prefer Speed"
block|,
literal|"Aggressive Speed"
block|,
literal|"Prefer Size"
block|,
literal|"Aggressive Size"
block|,
literal|"Prefer Debug"
block|,
literal|"Aggressive Debug"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arm_attr_tag_ABI_FP_optimization_goals
index|[]
init|=
block|{
literal|"None"
block|,
literal|"Prefer Speed"
block|,
literal|"Aggressive Speed"
block|,
literal|"Prefer Size"
block|,
literal|"Aggressive Size"
block|,
literal|"Prefer Accuracy"
block|,
literal|"Aggressive Accuracy"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOOKUP
parameter_list|(
name|id
parameter_list|,
name|name
parameter_list|)
define|\
value|{id, #name, 0x80 | ARRAY_SIZE(arm_attr_tag_##name), arm_attr_tag_##name}
end_define

begin_decl_stmt
specifier|static
name|arm_attr_public_tag
name|arm_attr_public_tags
index|[]
init|=
block|{
block|{
literal|4
block|,
literal|"CPU_raw_name"
block|,
literal|1
block|,
name|NULL
block|}
block|,
block|{
literal|5
block|,
literal|"CPU_name"
block|,
literal|1
block|,
name|NULL
block|}
block|,
name|LOOKUP
argument_list|(
literal|6
argument_list|,
name|CPU_arch
argument_list|)
block|,
block|{
literal|7
block|,
literal|"CPU_arch_profile"
block|,
literal|0
block|,
name|NULL
block|}
block|,
name|LOOKUP
argument_list|(
literal|8
argument_list|,
name|ARM_ISA_use
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|9
argument_list|,
name|THUMB_ISA_use
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|10
argument_list|,
name|VFP_arch
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|11
argument_list|,
name|WMMX_arch
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|12
argument_list|,
name|NEON_arch
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|13
argument_list|,
name|ABI_PCS_config
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|14
argument_list|,
name|ABI_PCS_R9_use
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|15
argument_list|,
name|ABI_PCS_RW_data
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|16
argument_list|,
name|ABI_PCS_RO_DATA
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|17
argument_list|,
name|ABI_PCS_GOT_use
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|18
argument_list|,
name|ABI_PCS_wchar_t
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|19
argument_list|,
name|ABI_FP_rounding
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|20
argument_list|,
name|ABI_FP_denormal
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|21
argument_list|,
name|ABI_FP_exceptions
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|22
argument_list|,
name|ABI_FP_user_exceptions
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|23
argument_list|,
name|ABI_FP_number_model
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|24
argument_list|,
name|ABI_align8_needed
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|25
argument_list|,
name|ABI_align8_preserved
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|26
argument_list|,
name|ABI_enum_size
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|27
argument_list|,
name|ABI_HardFP_use
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|28
argument_list|,
name|ABI_VFP_args
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|29
argument_list|,
name|ABI_WMMX_args
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|30
argument_list|,
name|ABI_optimization_goals
argument_list|)
block|,
name|LOOKUP
argument_list|(
literal|31
argument_list|,
name|ABI_FP_optimization_goals
argument_list|)
block|,
block|{
literal|32
block|,
literal|"compatibility"
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|LOOKUP
end_undef

begin_comment
comment|/* Read an unsigned LEB128 encoded value from p.  Set *PLEN to the number of    bytes read.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_uleb128
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
modifier|*
name|plen
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|len
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|&
literal|0x80
condition|)
do|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|display_arm_attribute
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|tag
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
name|arm_attr_public_tag
modifier|*
name|attr
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
name|tag
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|attr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|arm_attr_public_tags
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arm_attr_public_tags
index|[
name|i
index|]
operator|.
name|tag
operator|==
name|tag
condition|)
block|{
name|attr
operator|=
operator|&
name|arm_attr_public_tags
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|attr
condition|)
block|{
name|printf
argument_list|(
literal|"  Tag_%s: "
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|type
condition|)
block|{
case|case
literal|0
case|:
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|7
case|:
comment|/* Tag_CPU_arch_profile.  */
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"None\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"Application\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|printf
argument_list|(
literal|"Realtime\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|printf
argument_list|(
literal|"Microcontroller\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"??? (%d)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|32
case|:
comment|/* Tag_compatibility.  */
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"flag = %d, vendor = %s\n"
argument_list|,
name|val
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|p
return|;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|type
operator|=
name|attr
operator|->
name|type
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|attr
operator|->
name|type
operator|&
literal|0x80
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|type
operator|=
name|attr
operator|->
name|type
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|type
condition|)
name|printf
argument_list|(
literal|"??? (%d)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|attr
operator|->
name|table
index|[
name|val
index|]
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tag
operator|&
literal|1
condition|)
name|type
operator|=
literal|1
expr_stmt|;
comment|/* String.  */
else|else
name|type
operator|=
literal|2
expr_stmt|;
comment|/* uleb128.  */
name|printf
argument_list|(
literal|"  Tag_unknown_%d: "
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"%d (0x%x)\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|display_gnu_attribute
argument_list|(
name|unsigned
name|char
operator|*
name|p
argument_list|,
name|unsigned
name|char
operator|*
operator|(
operator|*
name|display_proc_gnu_attribute
operator|)
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
block|{
name|int
name|tag
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|type
decl_stmt|;
name|tag
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
comment|/* Tag_compatibility is the only generic GNU attribute defined at      present.  */
if|if
condition|(
name|tag
operator|==
literal|32
condition|)
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"flag = %d, vendor = %s\n"
argument_list|,
name|val
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
operator|(
name|tag
operator|&
literal|2
operator|)
operator|==
literal|0
operator|&&
name|display_proc_gnu_attribute
condition|)
return|return
name|display_proc_gnu_attribute
argument_list|(
name|p
argument_list|,
name|tag
argument_list|)
return|;
if|if
condition|(
name|tag
operator|&
literal|1
condition|)
name|type
operator|=
literal|1
expr_stmt|;
comment|/* String.  */
else|else
name|type
operator|=
literal|2
expr_stmt|;
comment|/* uleb128.  */
name|printf
argument_list|(
literal|"  Tag_unknown_%d: "
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"%d (0x%x)\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|display_power_gnu_attribute
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|Tag_GNU_Power_ABI_FP
condition|)
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"  Tag_GNU_Power_ABI_FP: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"Hard or soft float\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"Hard float\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"Soft float\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"??? (%d)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|p
return|;
block|}
if|if
condition|(
name|tag
operator|&
literal|1
condition|)
name|type
operator|=
literal|1
expr_stmt|;
comment|/* String.  */
else|else
name|type
operator|=
literal|2
expr_stmt|;
comment|/* uleb128.  */
name|printf
argument_list|(
literal|"  Tag_unknown_%d: "
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"%d (0x%x)\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|display_mips_gnu_attribute
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|tag
operator|==
name|Tag_GNU_MIPS_ABI_FP
condition|)
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"  Tag_GNU_MIPS_ABI_FP: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"Hard or soft float\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"Hard float (-mdouble-float)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"Hard float (-msingle-float)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"Soft float\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"??? (%d)\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|p
return|;
block|}
if|if
condition|(
name|tag
operator|&
literal|1
condition|)
name|type
operator|=
literal|1
expr_stmt|;
comment|/* String.  */
else|else
name|type
operator|=
literal|2
expr_stmt|;
comment|/* uleb128.  */
name|printf
argument_list|(
literal|"  Tag_unknown_%d: "
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|printf
argument_list|(
literal|"%d (0x%x)\n"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|process_attributes
argument_list|(
name|FILE
operator|*
name|file
argument_list|,
specifier|const
name|char
operator|*
name|public_name
argument_list|,
name|unsigned
name|int
name|proc_type
argument_list|,
name|unsigned
name|char
operator|*
operator|(
operator|*
name|display_pub_attribute
operator|)
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|,
name|unsigned
name|char
operator|*
operator|(
operator|*
name|display_proc_gnu_attribute
operator|)
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|sect
decl_stmt|;
name|unsigned
name|char
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|bfd_vma
name|section_len
decl_stmt|;
name|bfd_vma
name|len
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Find the section header so that we get the size.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sect
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|sect
operator|++
control|)
block|{
if|if
condition|(
name|sect
operator|->
name|sh_type
operator|!=
name|proc_type
operator|&&
name|sect
operator|->
name|sh_type
operator|!=
name|SHT_GNU_ATTRIBUTES
condition|)
continue|continue;
name|contents
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|sect
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|sect
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"attributes"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
continue|continue;
name|p
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'A'
condition|)
block|{
name|len
operator|=
name|sect
operator|->
name|sh_size
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|namelen
decl_stmt|;
name|bfd_boolean
name|public_section
decl_stmt|;
name|bfd_boolean
name|gnu_section
decl_stmt|;
name|section_len
operator|=
name|byte_get
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|section_len
operator|>
name|len
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"ERROR: Bad section length (%d> %d)\n"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|section_len
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|section_len
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|-=
name|section_len
expr_stmt|;
name|printf
argument_list|(
literal|"Attribute Section: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|public_name
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|public_name
argument_list|)
operator|==
literal|0
condition|)
name|public_section
operator|=
name|TRUE
expr_stmt|;
else|else
name|public_section
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
name|gnu_section
operator|=
name|TRUE
expr_stmt|;
else|else
name|gnu_section
operator|=
name|FALSE
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|+=
name|namelen
expr_stmt|;
name|section_len
operator|-=
name|namelen
operator|+
literal|4
expr_stmt|;
while|while
condition|(
name|section_len
operator|>
literal|0
condition|)
block|{
name|int
name|tag
init|=
operator|*
operator|(
name|p
operator|++
operator|)
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|size
operator|=
name|byte_get
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|section_len
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"ERROR: Bad subsection length (%d> %d)\n"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|section_len
argument_list|)
expr_stmt|;
name|size
operator|=
name|section_len
expr_stmt|;
block|}
name|section_len
operator|-=
name|size
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|size
operator|-
literal|1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"File Attributes\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"Section Attributes:"
argument_list|)
expr_stmt|;
goto|goto
name|do_numlist
goto|;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"Symbol Attributes:"
argument_list|)
expr_stmt|;
name|do_numlist
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|val
operator|=
name|read_uleb128
argument_list|(
name|p
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown tag: %d\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|public_section
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|public_section
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
name|p
operator|=
name|display_pub_attribute
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gnu_section
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|end
condition|)
name|p
operator|=
name|display_gnu_attribute
argument_list|(
name|p
argument_list|,
name|display_proc_gnu_attribute
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Do something sensible, like dump hex.  */
name|printf
argument_list|(
literal|"  Unknown section contexts\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Unknown format '%c'\n"
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|process_arm_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
return|return
name|process_attributes
argument_list|(
name|file
argument_list|,
literal|"aeabi"
argument_list|,
name|SHT_ARM_ATTRIBUTES
argument_list|,
name|display_arm_attribute
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_power_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
return|return
name|process_attributes
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|,
name|SHT_GNU_ATTRIBUTES
argument_list|,
name|NULL
argument_list|,
name|display_power_gnu_attribute
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_mips_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|size_t
name|liblist_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|liblistno
init|=
literal|0
decl_stmt|;
name|size_t
name|conflictsno
init|=
literal|0
decl_stmt|;
name|size_t
name|options_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|conflicts_offset
init|=
literal|0
decl_stmt|;
name|process_attributes
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|,
name|SHT_GNU_ATTRIBUTES
argument_list|,
name|NULL
argument_list|,
name|display_mips_gnu_attribute
argument_list|)
expr_stmt|;
comment|/* We have a lot of special sections.  Thanks SGI!  */
if|if
condition|(
name|dynamic_section
operator|==
name|NULL
condition|)
comment|/* No information available.  */
return|return
literal|0
return|;
for|for
control|(
name|entry
operator|=
name|dynamic_section
init|;
name|entry
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
operator|++
name|entry
control|)
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_LIBLIST
case|:
name|liblist_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|liblistno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|liblistno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|options_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICT
case|:
name|conflicts_offset
operator|=
name|offset_from_vma
argument_list|(
name|file
argument_list|,
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Conflict
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|conflictsno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|liblist_offset
operator|!=
literal|0
operator|&&
name|liblistno
operator|!=
literal|0
operator|&&
name|do_dynamic
condition|)
block|{
name|Elf32_External_Lib
modifier|*
name|elib
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|elib
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|liblist_offset
argument_list|,
name|liblistno
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"liblist"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elib
condition|)
block|{
name|printf
argument_list|(
literal|"\nSection '.liblist' contains %lu entries:\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|liblistno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"     Library              Time Stamp          Checksum   Version Flags\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|liblistno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf32_Lib
name|liblist
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|liblist
operator|.
name|l_name
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|time
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_time_stamp
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_checksum
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_checksum
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_version
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_version
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_flags
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|timebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3lu: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|liblist
operator|.
name|l_name
argument_list|)
condition|)
name|print_symbol
argument_list|(
literal|20
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|liblist
operator|.
name|l_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<corrupt: %9ld>"
argument_list|,
name|liblist
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s %#10lx %-7ld"
argument_list|,
name|timebuf
argument_list|,
name|liblist
operator|.
name|l_checksum
argument_list|,
name|liblist
operator|.
name|l_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|liblist
operator|.
name|l_flags
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|" NONE"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
name|l_flags_vals
index|[]
init|=
block|{
block|{
literal|" EXACT_MATCH"
block|,
name|LL_EXACT_MATCH
block|}
block|,
block|{
literal|" IGNORE_INT_VER"
block|,
name|LL_IGNORE_INT_VER
block|}
block|,
block|{
literal|" REQUIRE_MINOR"
block|,
name|LL_REQUIRE_MINOR
block|}
block|,
block|{
literal|" EXPORTS"
block|,
name|LL_EXPORTS
block|}
block|,
block|{
literal|" DELAY_LOAD"
block|,
name|LL_DELAY_LOAD
block|}
block|,
block|{
literal|" DELTA"
block|,
name|LL_DELTA
block|}
block|}
struct|;
name|int
name|flags
init|=
name|liblist
operator|.
name|l_flags
decl_stmt|;
name|size_t
name|fcnt
decl_stmt|;
for|for
control|(
name|fcnt
operator|=
literal|0
init|;
name|fcnt
operator|<
sizeof|sizeof
argument_list|(
name|l_flags_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|l_flags_vals
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|fcnt
control|)
if|if
condition|(
operator|(
name|flags
operator|&
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|flags
operator|^=
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %#x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flags
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|options_offset
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eopt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sect
init|=
name|section_headers
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|iopt
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|option
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Find the section header so that we get the size.  */
while|while
condition|(
name|sect
operator|->
name|sh_type
operator|!=
name|SHT_MIPS_OPTIONS
condition|)
operator|++
name|sect
expr_stmt|;
name|eopt
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|options_offset
argument_list|,
literal|1
argument_list|,
name|sect
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"options"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eopt
condition|)
block|{
name|iopt
operator|=
name|cmalloc
argument_list|(
operator|(
name|sect
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|eopt
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iopt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopt
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|offset
operator|=
name|cnt
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|sect
operator|->
name|sh_size
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eoption
decl_stmt|;
name|eoption
operator|=
operator|(
name|Elf_External_Options
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|eopt
operator|+
name|offset
operator|)
expr_stmt|;
name|option
operator|->
name|kind
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|kind
argument_list|)
expr_stmt|;
name|option
operator|->
name|size
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|size
argument_list|)
expr_stmt|;
name|option
operator|->
name|section
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|section
argument_list|)
expr_stmt|;
name|option
operator|->
name|info
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|info
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|option
operator|->
name|size
expr_stmt|;
operator|++
name|option
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|sect
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|option
operator|->
name|kind
condition|)
block|{
case|case
name|ODK_NULL
case|:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" NULL       %d %lx"
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_REGINFO
case|:
name|printf
argument_list|(
literal|" REGINFO    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
comment|/* 32bit form.  */
name|Elf32_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x%lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 64 bit form.  */
name|Elf64_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf64_Internal_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|option
expr_stmt|;
continue|continue;
case|case
name|ODK_EXCEPTIONS
case|:
name|fputs
argument_list|(
literal|" EXCEPTIONS fpe_min("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MIN
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") fpe_max("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
operator|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MAX
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_PAGE0
condition|)
name|fputs
argument_list|(
literal|" PAGE0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_SMM
condition|)
name|fputs
argument_list|(
literal|" SMM"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_FPDBUG
condition|)
name|fputs
argument_list|(
literal|" FPDBUG"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_DISMISS
condition|)
name|fputs
argument_list|(
literal|" DISMISS"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_PAD
case|:
name|fputs
argument_list|(
literal|" PAD       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_PREFIX
condition|)
name|fputs
argument_list|(
literal|" PREFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_POSTFIX
condition|)
name|fputs
argument_list|(
literal|" POSTFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_SYMBOL
condition|)
name|fputs
argument_list|(
literal|" SYMBOL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWPATCH
case|:
name|fputs
argument_list|(
literal|" HWPATCH   "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R4KEOP
condition|)
name|fputs
argument_list|(
literal|" R4KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R8KPFETCH
condition|)
name|fputs
argument_list|(
literal|" R8KPFETCH"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KEOP
condition|)
name|fputs
argument_list|(
literal|" R5KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KCVTL
condition|)
name|fputs
argument_list|(
literal|" R5KCVTL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_FILL
case|:
name|fputs
argument_list|(
literal|" FILL       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_TAGS
case|:
name|fputs
argument_list|(
literal|" TAGS       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_HWAND
case|:
name|fputs
argument_list|(
literal|" HWAND     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWOR
case|:
name|fputs
argument_list|(
literal|" HWOR      "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_GP_GROUP
case|:
name|printf
argument_list|(
literal|" GP_GROUP  %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_IDENT
case|:
name|printf
argument_list|(
literal|" IDENT     %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" %3d ???     %d %lx"
argument_list|,
name|option
operator|->
name|kind
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eopt
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|option
operator|->
name|size
condition|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|>=
literal|' '
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|<
literal|0x7f
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|option
expr_stmt|;
block|}
name|free
argument_list|(
name|eopt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conflicts_offset
operator|!=
literal|0
operator|&&
name|conflictsno
operator|!=
literal|0
condition|)
block|{
name|Elf32_Conflict
modifier|*
name|iconf
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"conflict list found without a dynamic symbol table\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iconf
operator|=
name|cmalloc
argument_list|(
name|conflictsno
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iconf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iconf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Conflict
modifier|*
name|econf32
decl_stmt|;
name|econf32
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|conflicts_offset
argument_list|,
name|conflictsno
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|econf32
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"conflict"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|econf32
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf32
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|econf32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Conflict
modifier|*
name|econf64
decl_stmt|;
name|econf64
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|conflicts_offset
argument_list|,
name|conflictsno
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|econf64
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"conflict"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|econf64
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf64
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|econf64
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '.conflict' contains %lu entries:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|conflictsno
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Num:    Index       Value  Name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
init|=
operator|&
name|dynamic_symbols
index|[
name|iconf
index|[
name|cnt
index|]
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%5lu: %8lu  "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|,
name|iconf
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_DYNAMIC_NAME
argument_list|(
name|psym
operator|->
name|st_name
argument_list|)
condition|)
name|print_symbol
argument_list|(
literal|25
argument_list|,
name|GET_DYNAMIC_NAME
argument_list|(
name|psym
operator|->
name|st_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<corrupt: %14ld>"
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iconf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_gnu_liblist
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|,
modifier|*
name|string_sec
decl_stmt|;
name|Elf32_External_Lib
modifier|*
name|elib
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|size_t
name|strtab_size
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_arch
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_GNU_LIBLIST
case|:
if|if
condition|(
name|SECTION_HEADER_INDEX
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
operator|>=
name|elf_header
operator|.
name|e_shnum
condition|)
break|break;
name|elib
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"liblist"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elib
operator|==
name|NULL
condition|)
break|break;
name|string_sec
operator|=
name|SECTION_HEADER
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|string_sec
operator|->
name|sh_offset
argument_list|,
literal|1
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|_
argument_list|(
literal|"liblist string table"
argument_list|)
argument_list|)
expr_stmt|;
name|strtab_size
operator|=
name|string_sec
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
operator|||
name|section
operator|->
name|sh_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nLibrary list section '%s' contains %lu entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|section
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"     Library              Time Stamp          Checksum   Version Flags"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf32_Lib
name|liblist
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|liblist
operator|.
name|l_name
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|time
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_time_stamp
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_checksum
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_checksum
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_version
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_version
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_flags
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|timebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|timebuf
argument_list|)
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3lu: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_wide
condition|)
name|printf
argument_list|(
literal|"%-20s"
argument_list|,
name|liblist
operator|.
name|l_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|liblist
operator|.
name|l_name
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-20.20s"
argument_list|,
name|liblist
operator|.
name|l_name
operator|<
name|strtab_size
condition|?
name|strtab
operator|+
name|liblist
operator|.
name|l_name
else|:
literal|"<corrupt>"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s %#010lx %-7ld %-7ld\n"
argument_list|,
name|timebuf
argument_list|,
name|liblist
operator|.
name|l_checksum
argument_list|,
name|liblist
operator|.
name|l_version
argument_list|,
name|liblist
operator|.
name|l_flags
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_type
operator|==
name|ET_CORE
condition|)
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_AUXV
case|:
return|return
name|_
argument_list|(
literal|"NT_AUXV (auxiliary vector)"
argument_list|)
return|;
case|case
name|NT_PRSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PRSTATUS (prstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGSET
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGSET (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PRPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PRPSINFO (prpsinfo structure)"
argument_list|)
return|;
case|case
name|NT_TASKSTRUCT
case|:
return|return
name|_
argument_list|(
literal|"NT_TASKSTRUCT (task structure)"
argument_list|)
return|;
case|case
name|NT_PRXFPREG
case|:
return|return
name|_
argument_list|(
literal|"NT_PRXFPREG (user_xfpregs structure)"
argument_list|)
return|;
case|case
name|NT_PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PSTATUS (pstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGS
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGS (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PSINFO (psinfo structure)"
argument_list|)
return|;
case|case
name|NT_LWPSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSTATUS (lwpstatus_t structure)"
argument_list|)
return|;
case|case
name|NT_LWPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSINFO (lwpsinfo_t structure)"
argument_list|)
return|;
case|case
name|NT_WIN32PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_WIN32PSTATUS (win32_pstatus structure)"
argument_list|)
return|;
case|case
name|NT_FILE
case|:
return|return
name|_
argument_list|(
literal|"NT_FILE"
argument_list|)
return|;
case|case
name|NT_SIGINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_SIGINFO"
argument_list|)
return|;
default|default:
break|break;
block|}
else|else
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_VERSION
case|:
return|return
name|_
argument_list|(
literal|"NT_VERSION (version)"
argument_list|)
return|;
case|case
name|NT_ARCH
case|:
return|return
name|_
argument_list|(
literal|"NT_ARCH (architecture)"
argument_list|)
return|;
default|default:
break|break;
block|}
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_freebsd_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_type
operator|==
name|ET_CORE
condition|)
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_THRMISC
case|:
return|return
name|_
argument_list|(
literal|"NT_THRMISC (thrmisc structure)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_PROC
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_PROC (proc data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_FILES
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_FILES (files data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_VMMAP
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_VMMAP (vmmap data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_GROUPS
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_GROUPS (groups data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_UMASK
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_UMASK (umask data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_RLIMIT
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_RLIMIT (rlimit data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_OSREL
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_OSREL (osreldate data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_PSSTRINGS
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_PSSTRINGS (ps_strings data)"
argument_list|)
return|;
case|case
name|NT_PROCSTAT_AUXV
case|:
return|return
name|_
argument_list|(
literal|"NT_PROCSTAT_AUXV (auxv data)"
argument_list|)
return|;
default|default:
return|return
name|get_note_type
argument_list|(
name|e_type
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_FREEBSD_ABI_TAG
case|:
return|return
name|_
argument_list|(
literal|"NT_FREEBSD_ABI_TAG"
argument_list|)
return|;
case|case
name|NT_FREEBSD_NOINIT_TAG
case|:
return|return
name|_
argument_list|(
literal|"NT_FREEBSD_NOINIT_TAG"
argument_list|)
return|;
case|case
name|NT_FREEBSD_ARCH_TAG
case|:
return|return
name|_
argument_list|(
literal|"NT_FREEBSD_ARCH_TAG"
argument_list|)
return|;
default|default:
break|break;
block|}
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_gnu_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_GNU_ABI_TAG
case|:
return|return
name|_
argument_list|(
literal|"NT_GNU_ABI_TAG"
argument_list|)
return|;
case|case
name|NT_GNU_BUILD_ID
case|:
return|return
name|_
argument_list|(
literal|"NT_GNU_BUILD_ID"
argument_list|)
return|;
block|}
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unknown GNU note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_netbsd_elfcore_note_type
parameter_list|(
name|unsigned
name|e_type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|e_type
operator|==
name|NT_NETBSDCORE_PROCINFO
condition|)
block|{
comment|/* NetBSD core "procinfo" structure.  */
return|return
name|_
argument_list|(
literal|"NetBSD procinfo structure"
argument_list|)
return|;
block|}
comment|/* As of Jan 2002 there are no other machine-independent notes      defined for NetBSD core files.  If the note type is less      than the start of the machine-dependent note types, we don't      understand it.  */
if|if
condition|(
name|e_type
operator|<
name|NT_NETBSDCORE_FIRSTMACH
condition|)
block|{
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
comment|/* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0        and PT_GETFPREGS == mach+2.  */
case|case
name|EM_OLD_ALPHA
case|:
case|case
name|EM_ALPHA
case|:
case|case
name|EM_SPARC
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|0
case|:
return|return
name|_
argument_list|(
literal|"PT_GETREGS (reg structure)"
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|2
case|:
return|return
name|_
argument_list|(
literal|"PT_GETFPREGS (fpreg structure)"
argument_list|)
return|;
default|default:
break|break;
block|}
break|break;
comment|/* On all other arch's, PT_GETREGS == mach+1 and        PT_GETFPREGS == mach+3.  */
default|default:
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|1
case|:
return|return
name|_
argument_list|(
literal|"PT_GETREGS (reg structure)"
argument_list|)
return|;
case|case
name|NT_NETBSDCORE_FIRSTMACH
operator|+
literal|3
case|:
return|return
name|_
argument_list|(
literal|"PT_GETFPREGS (fpreg structure)"
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
name|snprintf
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"PT_FIRSTMACH+%d"
argument_list|)
argument_list|,
name|e_type
operator|-
name|NT_NETBSDCORE_FIRSTMACH
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Note that by the ELF standard, the name field is already null byte    terminated, and namesz includes the terminating null byte.    I.E. the value of namesz for the name "FSF" is 4.     If the value of namesz is zero, there is no name present.  */
end_comment

begin_function
specifier|static
name|int
name|process_note
parameter_list|(
name|Elf_Internal_Note
modifier|*
name|pnote
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|nt
decl_stmt|;
if|if
condition|(
name|pnote
operator|->
name|namesz
operator|==
literal|0
condition|)
comment|/* If there is no note name, then use the default set of        note type strings.  */
name|nt
operator|=
name|get_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_strneq
argument_list|(
name|pnote
operator|->
name|namedata
argument_list|,
literal|"FreeBSD"
argument_list|)
condition|)
comment|/* FreeBSD-specific core file notes.  */
name|nt
operator|=
name|get_freebsd_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_strneq
argument_list|(
name|pnote
operator|->
name|namedata
argument_list|,
literal|"GNU"
argument_list|)
condition|)
comment|/* GNU-specific notes */
name|nt
operator|=
name|get_gnu_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_strneq
argument_list|(
name|pnote
operator|->
name|namedata
argument_list|,
literal|"NetBSD-CORE"
argument_list|)
condition|)
comment|/* NetBSD-specific core file notes.  */
name|nt
operator|=
name|get_netbsd_elfcore_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
comment|/* Don't recognize this note name; just use the default set of        note type strings.  */
name|nt
operator|=
name|get_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %-13s 0x%08lx\t%s\n"
argument_list|,
name|pnote
operator|->
name|namesz
condition|?
name|pnote
operator|->
name|namedata
else|:
literal|"(NONE)"
argument_list|,
name|pnote
operator|->
name|descsz
argument_list|,
name|nt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segment
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|length
parameter_list|)
block|{
name|Elf_External_Note
modifier|*
name|pnotes
decl_stmt|;
name|Elf_External_Note
modifier|*
name|external
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|pnotes
operator|=
name|get_data
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|_
argument_list|(
literal|"notes"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnotes
condition|)
return|return
literal|0
return|;
name|external
operator|=
name|pnotes
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNotes at offset 0x%08lx with length 0x%08lx:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Owner\t\tData size\tDescription\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|external
operator|<
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|+
name|length
operator|)
condition|)
block|{
name|Elf_External_Note
modifier|*
name|next
decl_stmt|;
name|Elf_Internal_Note
name|inote
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|NULL
decl_stmt|;
name|inote
operator|.
name|type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|type
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namedata
operator|=
name|external
operator|->
name|name
expr_stmt|;
name|inote
operator|.
name|descsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descdata
operator|=
name|inote
operator|.
name|namedata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|namesz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descpos
operator|=
name|offset
operator|+
operator|(
name|inote
operator|.
name|descdata
operator|-
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
expr_stmt|;
name|next
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|inote
operator|.
name|descdata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|descsz
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|next
operator|)
operator|>
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
operator|+
name|length
operator|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"corrupt note found at offset %lx into core notes\n"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|external
operator|-
operator|(
name|char
operator|*
operator|)
name|pnotes
argument_list|)
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|_
argument_list|(
literal|" type: %lx, namesize: %08lx, descsize: %08lx\n"
argument_list|)
argument_list|,
name|inote
operator|.
name|type
argument_list|,
name|inote
operator|.
name|namesz
argument_list|,
name|inote
operator|.
name|descsz
argument_list|)
expr_stmt|;
break|break;
block|}
name|external
operator|=
name|next
expr_stmt|;
comment|/* Verify that name is null terminated.  It appears that at least 	 one version of Linux (RedHat 6.0) generates corefiles that don't 	 comply with the ELF spec by failing to include the null byte in 	 namesz.  */
if|if
condition|(
name|inote
operator|.
name|namedata
index|[
name|inote
operator|.
name|namesz
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|temp
operator|=
name|malloc
argument_list|(
name|inote
operator|.
name|namesz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|temp
argument_list|,
name|inote
operator|.
name|namedata
argument_list|,
name|inote
operator|.
name|namesz
argument_list|)
expr_stmt|;
name|temp
index|[
name|inote
operator|.
name|namesz
index|]
operator|=
literal|0
expr_stmt|;
comment|/* warn (_("'%s' NOTE name not properly null terminated\n"), temp);  */
name|inote
operator|.
name|namedata
operator|=
name|temp
expr_stmt|;
block|}
name|res
operator|&=
name|process_note
argument_list|(
operator|&
name|inote
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pnotes
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segments
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|get_program_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
name|res
operator|&=
name|process_corefile_note_segment
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_note_sections
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_NOTE
condition|)
name|res
operator|&=
name|process_corefile_note_segment
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
operator|(
name|bfd_vma
operator|)
name|section
operator|->
name|sh_size
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_notes
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* If we have not been asked to display the notes then do nothing.  */
if|if
condition|(
operator|!
name|do_notes
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_type
operator|!=
name|ET_CORE
condition|)
return|return
name|process_note_sections
argument_list|(
name|file
argument_list|)
return|;
comment|/* No program headers means no NOTE segment.  */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|>
literal|0
condition|)
return|return
name|process_corefile_note_segments
argument_list|(
name|file
argument_list|)
return|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"No note segments present in the core file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_arch_specific
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|do_arch
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_ARM
case|:
return|return
name|process_arm_specific
argument_list|(
name|file
argument_list|)
return|;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
name|process_mips_specific
argument_list|(
name|file
argument_list|)
return|;
break|break;
case|case
name|EM_PPC
case|:
return|return
name|process_power_specific
argument_list|(
name|file
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_file_header
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
comment|/* Read in the identity array.  */
if|if
condition|(
name|fread
argument_list|(
name|elf_header
operator|.
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Determine how to read the rest of the header.  */
switch|switch
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
default|default:
comment|/* fall through */
case|case
name|ELFDATANONE
case|:
comment|/* fall through */
case|case
name|ELFDATA2LSB
case|:
name|byte_get
operator|=
name|byte_get_little_endian
expr_stmt|;
name|byte_put
operator|=
name|byte_put_little_endian
expr_stmt|;
break|break;
case|case
name|ELFDATA2MSB
case|:
name|byte_get
operator|=
name|byte_get_big_endian
expr_stmt|;
name|byte_put
operator|=
name|byte_put_big_endian
expr_stmt|;
break|break;
block|}
comment|/* For now we only support 32 bit and 64 bit ELF files.  */
name|is_32bit_elf
operator|=
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS64
operator|)
expr_stmt|;
comment|/* Read in the rest of the header.  */
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Ehdr
name|ehdr32
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr32
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Ehdr
name|ehdr64
decl_stmt|;
comment|/* If we have been compiled with sizeof (bfd_vma) == 4, then 	 we will not be able to cope with the 64bit data found in 	 64 ELF files.  Detect this now and abort before we start 	 overwriting things.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<
literal|8
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"This instance of readelf has been built without support for a\n\ 64 bit data type and so it cannot read 64 bit ELF files.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr64
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_header
operator|.
name|e_shoff
condition|)
block|{
comment|/* There may be some extensions in the first section header.  Don't 	 bomb if we can't read it.  */
if|if
condition|(
name|is_32bit_elf
condition|)
name|get_32bit_section_headers
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|get_64bit_section_headers
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|is_relocatable
operator|=
name|elf_header
operator|.
name|e_type
operator|==
name|ET_REL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process one ELF object file according to the command line options.    This file may actually be stored in an archive.  The file is    positioned at the start of the ELF object.  */
end_comment

begin_function
specifier|static
name|int
name|process_object
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|get_file_header
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: Failed to read file header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Initialise per file variables.  */
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|version_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|version_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|dynamic_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|dynamic_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Process the file.  */
if|if
condition|(
name|show_name
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nFile: %s\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
comment|/* Initialise the dump_sects array from the cmdline_dump_sects array.      Note we do this even if cmdline_dump_sects is empty because we      must make sure that the dump_sets array is zeroed out before each      object file is processed.  */
if|if
condition|(
name|num_dump_sects
operator|>
name|num_cmdline_dump_sects
condition|)
name|memset
argument_list|(
name|dump_sects
argument_list|,
literal|0
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_cmdline_dump_sects
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|num_dump_sects
operator|==
literal|0
condition|)
comment|/* A sneaky way of allocating the dump_sects array.  */
name|request_dump
argument_list|(
name|num_cmdline_dump_sects
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|num_dump_sects
operator|>=
name|num_cmdline_dump_sects
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dump_sects
argument_list|,
name|cmdline_dump_sects
argument_list|,
name|num_cmdline_dump_sects
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|process_file_header
argument_list|()
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|process_section_headers
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* Without loaded section headers we cannot process lots of 	 things.  */
name|do_unwind
operator|=
name|do_version
operator|=
name|do_dump
operator|=
name|do_arch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|do_using_dynamic
condition|)
name|do_syms
operator|=
name|do_reloc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|process_section_groups
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* Without loaded section groups we cannot process unwind.  */
name|do_unwind
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|process_program_headers
argument_list|(
name|file
argument_list|)
condition|)
name|process_dynamic_section
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_relocs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_unwind
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_symbol_table
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_syminfo
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_version_sections
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_section_contents
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_notes
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_gnu_liblist
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_arch_specific
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_headers
condition|)
block|{
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
name|program_headers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|section_headers
condition|)
block|{
name|free
argument_list|(
name|section_headers
argument_list|)
expr_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|string_table
condition|)
block|{
name|free
argument_list|(
name|string_table
argument_list|)
expr_stmt|;
name|string_table
operator|=
name|NULL
expr_stmt|;
name|string_table_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_strings
condition|)
block|{
name|free
argument_list|(
name|dynamic_strings
argument_list|)
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
name|dynamic_strings_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_symbols
condition|)
block|{
name|free
argument_list|(
name|dynamic_symbols
argument_list|)
expr_stmt|;
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|num_dynamic_syms
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo
condition|)
block|{
name|free
argument_list|(
name|dynamic_syminfo
argument_list|)
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|section_headers_groups
condition|)
block|{
name|free
argument_list|(
name|section_headers_groups
argument_list|)
expr_stmt|;
name|section_headers_groups
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|section_groups
condition|)
block|{
name|struct
name|group_list
modifier|*
name|g
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|group_count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|g
operator|=
name|section_groups
index|[
name|i
index|]
operator|.
name|root
init|;
name|g
operator|!=
name|NULL
condition|;
name|g
operator|=
name|next
control|)
block|{
name|next
operator|=
name|g
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|section_groups
argument_list|)
expr_stmt|;
name|section_groups
operator|=
name|NULL
expr_stmt|;
block|}
name|free_debug_memory
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process an ELF archive.  The file is positioned just after the    ARMAG string.  */
end_comment

begin_function
specifier|static
name|int
name|process_archive
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|ar_hdr
name|arhdr
decl_stmt|;
name|size_t
name|got
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|longnames
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|longnames_size
init|=
literal|0
decl_stmt|;
name|size_t
name|file_name_size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|show_name
operator|=
literal|1
expr_stmt|;
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|const_strneq
argument_list|(
name|arhdr
operator|.
name|ar_name
argument_list|,
literal|"/               "
argument_list|)
condition|)
block|{
comment|/* This is the archive symbol table.  Skip it. 	 FIXME: We should have an option to dump it.  */
name|size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|size
operator|+
operator|(
name|size
operator|&
literal|1
operator|)
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to skip archive symbol table\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|const_strneq
argument_list|(
name|arhdr
operator|.
name|ar_name
argument_list|,
literal|"//              "
argument_list|)
condition|)
block|{
comment|/* This is the archive string table holding long member 	 names.  */
name|longnames_size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|longnames
operator|=
name|malloc
argument_list|(
name|longnames_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|longnames
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|longnames
argument_list|,
name|longnames_size
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read string table\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|longnames_size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|file_name_size
operator|=
name|strlen
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|nameend
decl_stmt|;
name|char
modifier|*
name|namealc
decl_stmt|;
if|if
condition|(
name|arhdr
operator|.
name|ar_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|unsigned
name|long
name|off
decl_stmt|;
name|off
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|longnames_size
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: invalid archive string table offset %lu\n"
argument_list|)
argument_list|,
name|file_name
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|name
operator|=
name|longnames
operator|+
name|off
expr_stmt|;
name|nameend
operator|=
name|memchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|,
name|longnames_size
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|arhdr
operator|.
name|ar_name
expr_stmt|;
name|nameend
operator|=
name|memchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nameend
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: bad archive file name\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|namealc
operator|=
name|malloc
argument_list|(
name|file_name_size
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|namealc
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|namealc
argument_list|,
name|file_name
argument_list|,
name|file_name_size
argument_list|)
expr_stmt|;
name|namealc
index|[
name|file_name_size
index|]
operator|=
literal|'('
expr_stmt|;
name|memcpy
argument_list|(
name|namealc
operator|+
name|file_name_size
operator|+
literal|1
argument_list|,
name|name
argument_list|,
name|nameend
operator|-
name|name
argument_list|)
expr_stmt|;
name|namealc
index|[
name|file_name_size
operator|+
literal|1
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
index|]
operator|=
literal|')'
expr_stmt|;
name|namealc
index|[
name|file_name_size
operator|+
literal|2
operator|+
operator|(
name|nameend
operator|-
name|name
operator|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|archive_file_offset
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|archive_file_size
operator|=
name|strtoul
argument_list|(
name|arhdr
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|ret
operator||=
name|process_object
argument_list|(
name|namealc
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|namealc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|archive_file_offset
operator|+
name|archive_file_size
operator|+
operator|(
name|archive_file_size
operator|&
literal|1
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to seek to next archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|got
operator|=
name|fread
argument_list|(
operator|&
name|arhdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|arhdr
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|!=
sizeof|sizeof
name|arhdr
condition|)
block|{
if|if
condition|(
name|got
operator|==
literal|0
condition|)
break|break;
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: failed to read archive header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|longnames
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|longnames
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_file
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
name|armag
index|[
name|SARMAG
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s': No such file\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"Could not locate '%s'.  System error message: %s\n"
argument_list|)
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"'%s' is not an ordinary file\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Input file '%s' is not readable.\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|armag
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: Failed to read file header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|process_archive
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|rewind
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|archive_file_size
operator|=
name|archive_file_offset
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|process_object
argument_list|(
name|file_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_comment
comment|/* Needed by the i386 disassembler.  For extra credit, someone could    fix this so that we insert symbolic addresses here, esp for GOT/PLT    symbols.  */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"0x%8.8x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed by the i386 disassembler.  */
end_comment

begin_function
name|void
name|db_task_printsym
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|expandargv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_dump_sects
operator|>
literal|0
condition|)
block|{
comment|/* Make a copy of the dump_sects array.  */
name|cmdline_dump_sects
operator|=
name|malloc
argument_list|(
name|num_dump_sects
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdline_dump_sects
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|cmdline_dump_sects
argument_list|,
name|dump_sects
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
name|num_cmdline_dump_sects
operator|=
name|num_dump_sects
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
name|show_name
operator|=
literal|1
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|err
operator||=
name|process_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_sects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdline_dump_sects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmdline_dump_sects
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

