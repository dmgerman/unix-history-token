begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* readelf.c -- display contents of an ELF format file    Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.     Originally developed by Eric Youngdale<eric@andante.jic.com>    Modifications by Nick Clifton<nickc@redhat.com>     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|__GNUC__
operator|>=
literal|2
end_if

begin_comment
comment|/* Define BFD64 here, even if our default architecture is 32 bit ELF    as this will allow us to read in and parse 64bit and 32bit ELF files.    Only do this if we belive that the compiler can support a 64 bit    data type.  For now we only rely on GCC being able to do this.  */
end_comment

begin_define
define|#
directive|define
name|BFD64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* The following headers use the elf/reloc-macros.h file to    automatically generate relocation recognition functions    such as elf_mips_reloc_type()  */
end_comment

begin_define
define|#
directive|define
name|RELOC_MACROS_GEN_FUNC
end_define

begin_include
include|#
directive|include
file|"elf/i386.h"
end_include

begin_include
include|#
directive|include
file|"elf/v850.h"
end_include

begin_include
include|#
directive|include
file|"elf/ppc.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/alpha.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68k.h"
end_include

begin_include
include|#
directive|include
file|"elf/sparc.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32r.h"
end_include

begin_include
include|#
directive|include
file|"elf/d10v.h"
end_include

begin_include
include|#
directive|include
file|"elf/d30v.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10200.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10300.h"
end_include

begin_include
include|#
directive|include
file|"elf/hppa.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf/fr30.h"
end_include

begin_include
include|#
directive|include
file|"elf/mcore.h"
end_include

begin_include
include|#
directive|include
file|"elf/i960.h"
end_include

begin_include
include|#
directive|include
file|"elf/pj.h"
end_include

begin_include
include|#
directive|include
file|"elf/avr.h"
end_include

begin_include
include|#
directive|include
file|"elf/ia64.h"
end_include

begin_include
include|#
directive|include
file|"elf/cris.h"
end_include

begin_include
include|#
directive|include
file|"elf/i860.h"
end_include

begin_include
include|#
directive|include
file|"elf/x86-64.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"readelf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|dynamic_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|dynamic_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|rela_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|rela_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dynamic_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|string_table_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|num_dynamic_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Sym
modifier|*
name|dynamic_symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Syminfo
modifier|*
name|dynamic_syminfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|dynamic_syminfo_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|dynamic_syminfo_nent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|program_interpreter
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dynamic_info
index|[
name|DT_JMPREL
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|version_info
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|loadaddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Ehdr
name|elf_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Shdr
modifier|*
name|section_headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf_Internal_Dyn
modifier|*
name|dynamic_segment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|show_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_segments
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_unwind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_using_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_histogram
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_abbrevs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_pubnames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_aranges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_frames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_debug_frames_interp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_arch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_notes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|is_32bit_elf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A dynamic array of flags indicating which sections require dumping.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dump_sects
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|num_dump_sects
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEX_DUMP
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DISASS_DUMP
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUG_DUMP
value|(1<< 2)
end_define

begin_comment
comment|/* How to rpint a vma value.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|print_mode
block|{
name|HEX
block|,
name|DEC
block|,
name|DEC_5
block|,
name|UNSIGNED
block|,
name|PREFIX_HEX
block|,
name|FULL_HEX
block|,
name|LONG_HEX
block|}
name|print_mode
typedef|;
end_typedef

begin_comment
comment|/* Forward declarations for dumb compilers.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_vma
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|print_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|bfd_vma
argument_list|(
argument|*         byte_get
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|byte_get_little_endian
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|byte_get_big_endian
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_dynamic_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_sparc64_dynamic_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_dynamic_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slurp_rela_relocs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|Elf_Internal_Rela
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slurp_rel_relocs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|Elf_Internal_Rel
operator|*
operator|*
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dump_relocations
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|unsigned
name|long
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_file_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_machine_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_ARM_machine_flags
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|char
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_machine_flags
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_segment_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_segment_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_segment_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_segment_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_section_type_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_section_type_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_section_type_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_section_type_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_binding
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_visibility
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_index_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_flags
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_args
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_file_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_program_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_section_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_unwind
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dynamic_segment_mips_val
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dynamic_segment_parisc_val
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_dynamic_segment
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_symbol_table
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_section_contents
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_relocs
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_version_sections
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_ver_flags
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_32bit_section_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_64bit_section_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_32bit_program_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_64bit_program_headers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Elf_Internal_Phdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_file_header
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_32bit_elf_symbols
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_64bit_elf_symbols
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_section_flags
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|get_dynamic_data
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_32bit_dynamic_segment
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_64bit_dynamic_segment
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|disassemble_section
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|dump_section
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_section
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_info
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_not_supported
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_lines
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_abbrev
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_aranges
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|display_debug_frames
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|process_abbrev_section
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|read_leb128
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_extended_line_op
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_state_machine
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_TAG_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_AT_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_FORM_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_abbrevs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_abbrev
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_abbrev_attr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|read_and_display_attr
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|display_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_location_expression
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|request_dump
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_class
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_data_encoding
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_osabi_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|guess_is_rela
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_note_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_note
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_corefile_note_segment
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_corefile_note_segments
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_corefile_contents
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|Elf32_Word
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UNKNOWN
value|-1
end_define

begin_define
define|#
directive|define
name|SECTION_NAME
parameter_list|(
name|X
parameter_list|)
value|((X) == NULL ? "<none>" : \ 				 ((X)->sh_name>= string_table_length \ 				  ? "<corrupt>" : string_table + (X)->sh_name))
end_define

begin_define
define|#
directive|define
name|DT_VERSIONTAGIDX
parameter_list|(
name|tag
parameter_list|)
value|(DT_VERNEEDNUM - (tag))
end_define

begin_comment
comment|/* Reverse order! */
end_comment

begin_define
define|#
directive|define
name|BYTE_GET
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, sizeof (field))
end_define

begin_comment
comment|/* If we can support a 64 bit data type then BFD64 should be defined    and sizeof (bfd_vma) == 8.  In this case when translating from an    external 8 byte field to an internal field, we can assume that the    internal field is also 8 bytes wide and so we can extract all the data.    If, however, BFD64 is not defined, then we must assume that the    internal data structure only has 4 byte wide fields that are the    equivalent of the 8 byte wide external counterparts, and so we must    truncate the data.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|BYTE_GET8
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, -8)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BYTE_GET8
parameter_list|(
name|field
parameter_list|)
value|byte_get (field, 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|array
parameter_list|)
value|(sizeof (array) / sizeof ((array)[0]))
end_define

begin_define
define|#
directive|define
name|GET_DATA_ALLOC
parameter_list|(
name|offset
parameter_list|,
name|size
parameter_list|,
name|var
parameter_list|,
name|type
parameter_list|,
name|reason
parameter_list|)
define|\
value|if (fseek (file, offset, SEEK_SET))					\     {									\       error (_("Unable to seek to start of %s at %x\n"), reason, offset); \       return 0;								\     }									\ 									\   var = (type) malloc (size);						\ 									\   if (var == NULL)							\     {									\       error (_("Out of memory allocating %d bytes for %s\n"), size, reason); \       return 0;								\     }									\ 									\   if (fread (var, size, 1, file) != 1)					\     {									\       error (_("Unable to read in %d bytes of %s\n"), size, reason);	\       free (var);							\       var = NULL;							\       return 0;							\     }
end_define

begin_define
define|#
directive|define
name|GET_DATA
parameter_list|(
name|offset
parameter_list|,
name|var
parameter_list|,
name|reason
parameter_list|)
define|\
value|if (fseek (file, offset, SEEK_SET))					\     {									\       error (_("Unable to seek to %x for %s\n"), offset, reason);	\       return 0;								\     }									\   else if (fread (& var, sizeof (var), 1, file) != 1)			\     {									\       error (_("Unable to read data at %x for %s\n"), offset, reason);	\       return 0;								\     }
end_define

begin_define
define|#
directive|define
name|GET_ELF_SYMBOLS
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
define|\
value|(is_32bit_elf ? get_32bit_elf_symbols (file, offset, size)	\    : get_64bit_elf_symbols (file, offset, size))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Error: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|warn
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Warning: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Error: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|message
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|warn
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Warning: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|message
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bfd_vma
name|byte_get_little_endian
parameter_list|(
name|field
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|char
modifier|*
name|field
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|*
name|field
return|;
case|case
literal|2
case|:
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
return|;
ifndef|#
directive|ifndef
name|BFD64
case|case
literal|8
case|:
comment|/* We want to extract data from an 8 byte wide field and 	 place it into a 4 byte wide field.  Since this is a little 	 endian source we can juts use the 4 byte extraction code.  */
comment|/* Fall through.  */
endif|#
directive|endif
case|case
literal|4
case|:
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
ifdef|#
directive|ifdef
name|BFD64
case|case
literal|8
case|:
case|case
operator|-
literal|8
case|:
comment|/* This is a special case, generated by the BYTE_GET8 macro. 	 It means that we are loading an 8 byte value from a field 	 in an external structure into an 8 byte value in a field 	 in an internal strcuture.  */
return|return
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator|<<
literal|56
operator|)
return|;
endif|#
directive|endif
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a VMA value.  */
end_comment

begin_function
specifier|static
name|void
name|print_vma
parameter_list|(
name|vma
parameter_list|,
name|mode
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|print_mode
name|mode
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD64
if|if
condition|(
name|is_32bit_elf
condition|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* drop through */
case|case
name|LONG_HEX
case|:
name|printf
argument_list|(
literal|"%8.8lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREFIX_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* drop through */
case|case
name|HEX
case|:
name|printf
argument_list|(
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEC
case|:
name|printf
argument_list|(
literal|"%ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEC_5
case|:
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
operator|(
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSIGNED
case|:
name|printf
argument_list|(
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|BFD64
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FULL_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* drop through */
case|case
name|LONG_HEX
case|:
name|printf_vma
argument_list|(
name|vma
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREFIX_HEX
case|:
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
comment|/* drop through */
case|case
name|HEX
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%lx"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%lx%lx"
argument_list|,
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lx"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DEC
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DEC_5
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%5ld"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|UNSIGNED
case|:
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|vma
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_bfd_int64_high
argument_list|(
name|vma
argument_list|)
condition|)
comment|/* ugg */
name|printf
argument_list|(
literal|"++%lu"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lu"
argument_list|,
name|_bfd_int64_low
argument_list|(
name|vma
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|byte_get_big_endian
parameter_list|(
name|field
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|char
modifier|*
name|field
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|*
name|field
return|;
case|case
literal|2
case|:
return|return
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
ifndef|#
directive|ifndef
name|BFD64
case|case
literal|8
case|:
comment|/* Although we are extracing data from an 8 byte wide field, we 	 are returning only 4 bytes of data.  */
return|return
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
return|;
else|#
directive|else
case|case
literal|8
case|:
case|case
operator|-
literal|8
case|:
comment|/* This is a special case, generated by the BYTE_GET8 macro. 	 It means that we are loading an 8 byte value from a field 	 in an external structure into an 8 byte value in a field 	 in an internal strcuture.  */
return|return
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|7
index|]
argument_list|)
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|6
index|]
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|5
index|]
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|3
index|]
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|field
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<<
literal|56
operator|)
return|;
endif|#
directive|endif
default|default:
name|error
argument_list|(
name|_
argument_list|(
literal|"Unhandled data length: %d\n"
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Guess the relocation size commonly used by the specific machines.  */
end_comment

begin_function
specifier|static
name|int
name|guess_is_rela
parameter_list|(
name|e_machine
parameter_list|)
name|unsigned
name|long
name|e_machine
decl_stmt|;
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
comment|/* Targets that use REL relocations.  */
case|case
name|EM_ARM
case|:
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
case|case
name|EM_960
case|:
case|case
name|EM_CYGNUS_M32R
case|:
case|case
name|EM_CYGNUS_D10V
case|:
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
name|FALSE
return|;
comment|/* Targets that use RELA relocations.  */
case|case
name|EM_68K
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPARC
case|:
case|case
name|EM_PPC
case|:
case|case
name|EM_CYGNUS_V850
case|:
case|case
name|EM_CYGNUS_D30V
case|:
case|case
name|EM_CYGNUS_MN10200
case|:
case|case
name|EM_CYGNUS_MN10300
case|:
case|case
name|EM_CYGNUS_FR30
case|:
case|case
name|EM_SH
case|:
case|case
name|EM_ALPHA
case|:
case|case
name|EM_MCORE
case|:
case|case
name|EM_IA_64
case|:
case|case
name|EM_AVR
case|:
case|case
name|EM_CRIS
case|:
case|case
name|EM_860
case|:
case|case
name|EM_X86_64
case|:
return|return
name|TRUE
return|;
case|case
name|EM_MMA
case|:
case|case
name|EM_PCP
case|:
case|case
name|EM_NCPU
case|:
case|case
name|EM_NDR1
case|:
case|case
name|EM_STARCORE
case|:
case|case
name|EM_ME16
case|:
case|case
name|EM_ST100
case|:
case|case
name|EM_TINYJ
case|:
case|case
name|EM_FX66
case|:
case|case
name|EM_ST9PLUS
case|:
case|case
name|EM_ST7
case|:
case|case
name|EM_68HC16
case|:
case|case
name|EM_68HC11
case|:
case|case
name|EM_68HC08
case|:
case|case
name|EM_68HC05
case|:
case|case
name|EM_SVX
case|:
case|case
name|EM_ST19
case|:
case|case
name|EM_VAX
case|:
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Don't know about relocations on this machine architecture\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rela_relocs
parameter_list|(
name|file
parameter_list|,
name|rel_offset
parameter_list|,
name|rel_size
parameter_list|,
name|relasp
parameter_list|,
name|nrelasp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
modifier|*
name|relasp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|nrelasp
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|relas
decl_stmt|;
name|unsigned
name|long
name|nrelas
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|erelas
argument_list|,
name|Elf32_External_Rela
operator|*
argument_list|,
literal|"relocs"
argument_list|)
expr_stmt|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|malloc
argument_list|(
name|nrelas
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rela
modifier|*
name|erelas
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|erelas
argument_list|,
name|Elf64_External_Rela
operator|*
argument_list|,
literal|"relocs"
argument_list|)
expr_stmt|;
name|nrelas
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|relas
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|malloc
argument_list|(
name|nrelas
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relas
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelas
condition|;
name|i
operator|++
control|)
block|{
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
operator|=
name|BYTE_GET8
argument_list|(
name|erelas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erelas
argument_list|)
expr_stmt|;
block|}
operator|*
name|relasp
operator|=
name|relas
expr_stmt|;
operator|*
name|nrelasp
operator|=
name|nrelas
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_rel_relocs
parameter_list|(
name|file
parameter_list|,
name|rel_offset
parameter_list|,
name|rel_size
parameter_list|,
name|relsp
parameter_list|,
name|nrelsp
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
modifier|*
name|relsp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|nrelsp
decl_stmt|;
block|{
name|Elf_Internal_Rel
modifier|*
name|rels
decl_stmt|;
name|unsigned
name|long
name|nrels
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Rel
modifier|*
name|erels
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|erels
argument_list|,
name|Elf32_External_Rel
operator|*
argument_list|,
literal|"relocs"
argument_list|)
expr_stmt|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
operator|(
name|Elf_Internal_Rel
operator|*
operator|)
name|malloc
argument_list|(
name|nrels
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Rel
modifier|*
name|erels
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|erels
argument_list|,
name|Elf64_External_Rel
operator|*
argument_list|,
literal|"relocs"
argument_list|)
expr_stmt|;
name|nrels
operator|=
name|rel_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
expr_stmt|;
name|rels
operator|=
operator|(
name|Elf_Internal_Rel
operator|*
operator|)
name|malloc
argument_list|(
name|nrels
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rels
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"out of memory parsing relocs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrels
condition|;
name|i
operator|++
control|)
block|{
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
operator|=
name|BYTE_GET8
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|rels
index|[
name|i
index|]
operator|.
name|r_info
operator|=
name|BYTE_GET8
argument_list|(
name|erels
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|erels
argument_list|)
expr_stmt|;
block|}
operator|*
name|relsp
operator|=
name|rels
expr_stmt|;
operator|*
name|nrelsp
operator|=
name|nrels
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the relocation data found at the specified offset.  */
end_comment

begin_function
specifier|static
name|int
name|dump_relocations
parameter_list|(
name|file
parameter_list|,
name|rel_offset
parameter_list|,
name|rel_size
parameter_list|,
name|symtab
parameter_list|,
name|nsyms
parameter_list|,
name|strtab
parameter_list|,
name|is_rela
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|unsigned
name|long
name|nsyms
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|int
name|is_rela
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Rel
modifier|*
name|rels
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relas
decl_stmt|;
if|if
condition|(
name|is_rela
operator|==
name|UNKNOWN
condition|)
name|is_rela
operator|=
name|guess_is_rela
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
block|{
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|relas
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|slurp_rel_relocs
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
operator|&
name|rels
argument_list|,
operator|&
name|rel_size
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_rela
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset    Info  Type            Symbol's Value  Symbol's Name          Addend\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset    Info  Type            Symbol's Value  Symbol's Name\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|rtype
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|info
decl_stmt|;
name|bfd_vma
name|symtab_index
decl_stmt|;
name|bfd_vma
name|type
decl_stmt|;
if|if
condition|(
name|is_rela
condition|)
block|{
name|offset
operator|=
name|relas
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|info
operator|=
name|relas
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_offset
expr_stmt|;
name|info
operator|=
name|rels
index|[
name|i
index|]
operator|.
name|r_info
expr_stmt|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
condition|)
name|type
operator|=
name|ELF64_R_TYPE_ID
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* The #ifdef BFD64 below is to prevent a compile time warning. 	     We know that if we do not have a 64 bit data type that we 	     will never execute this code anyway.  */
ifdef|#
directive|ifdef
name|BFD64
name|symtab_index
operator|=
name|ELF64_R_SYM
argument_list|(
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
literal|"  %8.8lx  %5.5lx "
argument_list|,
name|_bfd_int64_low
argument_list|(
name|offset
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"  %8.8lx  %5.5lx "
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
default|default:
name|rtype
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_M32R
case|:
name|rtype
operator|=
name|elf_m32r_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_386
case|:
case|case
name|EM_486
case|:
name|rtype
operator|=
name|elf_i386_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
name|rtype
operator|=
name|elf_m68k_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_960
case|:
name|rtype
operator|=
name|elf_i960_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_AVR
case|:
name|rtype
operator|=
name|elf_avr_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_OLD_SPARCV9
case|:
case|case
name|EM_SPARC32PLUS
case|:
case|case
name|EM_SPARCV9
case|:
case|case
name|EM_SPARC
case|:
name|rtype
operator|=
name|elf_sparc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_V850
case|:
name|rtype
operator|=
name|v850_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_D10V
case|:
name|rtype
operator|=
name|elf_d10v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_D30V
case|:
name|rtype
operator|=
name|elf_d30v_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SH
case|:
name|rtype
operator|=
name|elf_sh_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_MN10300
case|:
name|rtype
operator|=
name|elf_mn10300_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_MN10200
case|:
name|rtype
operator|=
name|elf_mn10200_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_FR30
case|:
name|rtype
operator|=
name|elf_fr30_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MCORE
case|:
name|rtype
operator|=
name|elf_mcore_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
name|rtype
operator|=
name|elf_ppc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|rtype
operator|=
name|elf_mips_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ALPHA
case|:
name|rtype
operator|=
name|elf_alpha_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_ARM
case|:
name|rtype
operator|=
name|elf_arm_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_ARC
case|:
case|case
name|EM_ARC
case|:
name|rtype
operator|=
name|elf_arc_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|rtype
operator|=
name|elf_hppa_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
name|rtype
operator|=
name|elf_pj_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|rtype
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CRIS
case|:
name|rtype
operator|=
name|elf_cris_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_860
case|:
name|rtype
operator|=
name|elf_i860_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_X86_64
case|:
name|rtype
operator|=
name|elf_x86_64_reloc_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rtype
operator|==
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_bfd_int64_low
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognised: %-7lx"
argument_list|)
argument_list|,
name|_bfd_int64_low
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"unrecognised: %-7lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-21.21s"
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_index
condition|)
block|{
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|symtab_index
operator|>=
name|nsyms
condition|)
name|printf
argument_list|(
literal|" bad symbol index: %08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symtab_index
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
name|symtab
operator|+
name|symtab_index
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%-25.25s"
argument_list|,
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"<string table index %3ld>"
argument_list|)
argument_list|,
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-25.25s"
argument_list|,
name|strtab
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rela
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|is_rela
condition|)
block|{
name|printf
argument_list|(
literal|"%*c"
argument_list|,
name|is_32bit_elf
condition|?
literal|34
else|:
literal|26
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|relas
index|[
name|i
index|]
operator|.
name|r_addend
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
operator|!
name|strcmp
argument_list|(
name|rtype
argument_list|,
literal|"R_SPARC_OLO10"
argument_list|)
condition|)
name|printf
argument_list|(
literal|" + %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ELF64_R_TYPE_DATA
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_rela
condition|)
name|free
argument_list|(
name|relas
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|rels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_dynamic_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_MIPS_RLD_VERSION
case|:
return|return
literal|"MIPS_RLD_VERSION"
return|;
case|case
name|DT_MIPS_TIME_STAMP
case|:
return|return
literal|"MIPS_TIME_STAMP"
return|;
case|case
name|DT_MIPS_ICHECKSUM
case|:
return|return
literal|"MIPS_ICHECKSUM"
return|;
case|case
name|DT_MIPS_IVERSION
case|:
return|return
literal|"MIPS_IVERSION"
return|;
case|case
name|DT_MIPS_FLAGS
case|:
return|return
literal|"MIPS_FLAGS"
return|;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
return|return
literal|"MIPS_BASE_ADDRESS"
return|;
case|case
name|DT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|DT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|DT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
return|return
literal|"MIPS_LOCAL_GOTNO"
return|;
case|case
name|DT_MIPS_CONFLICTNO
case|:
return|return
literal|"MIPS_CONFLICTNO"
return|;
case|case
name|DT_MIPS_LIBLISTNO
case|:
return|return
literal|"MIPS_LIBLISTNO"
return|;
case|case
name|DT_MIPS_SYMTABNO
case|:
return|return
literal|"MIPS_SYMTABNO"
return|;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
return|return
literal|"MIPS_UNREFEXTNO"
return|;
case|case
name|DT_MIPS_GOTSYM
case|:
return|return
literal|"MIPS_GOTSYM"
return|;
case|case
name|DT_MIPS_HIPAGENO
case|:
return|return
literal|"MIPS_HIPAGENO"
return|;
case|case
name|DT_MIPS_RLD_MAP
case|:
return|return
literal|"MIPS_RLD_MAP"
return|;
case|case
name|DT_MIPS_DELTA_CLASS
case|:
return|return
literal|"MIPS_DELTA_CLASS"
return|;
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
return|return
literal|"MIPS_DELTA_CLASS_NO"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE
case|:
return|return
literal|"MIPS_DELTA_INSTANCE"
return|;
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
return|return
literal|"MIPS_DELTA_INSTANCE_NO"
return|;
case|case
name|DT_MIPS_DELTA_RELOC
case|:
return|return
literal|"MIPS_DELTA_RELOC"
return|;
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
return|return
literal|"MIPS_DELTA_RELOC_NO"
return|;
case|case
name|DT_MIPS_DELTA_SYM
case|:
return|return
literal|"MIPS_DELTA_SYM"
return|;
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
return|return
literal|"MIPS_DELTA_SYM_NO"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM"
return|;
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
return|return
literal|"MIPS_DELTA_CLASSSYM_NO"
return|;
case|case
name|DT_MIPS_CXX_FLAGS
case|:
return|return
literal|"MIPS_CXX_FLAGS"
return|;
case|case
name|DT_MIPS_PIXIE_INIT
case|:
return|return
literal|"MIPS_PIXIE_INIT"
return|;
case|case
name|DT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|DT_MIPS_LOCALPAGE_GOTIDX
case|:
return|return
literal|"MIPS_LOCALPAGE_GOTIDX"
return|;
case|case
name|DT_MIPS_LOCAL_GOTIDX
case|:
return|return
literal|"MIPS_LOCAL_GOTIDX"
return|;
case|case
name|DT_MIPS_HIDDEN_GOTIDX
case|:
return|return
literal|"MIPS_HIDDEN_GOTIDX"
return|;
case|case
name|DT_MIPS_PROTECTED_GOTIDX
case|:
return|return
literal|"MIPS_PROTECTED_GOTIDX"
return|;
case|case
name|DT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|DT_MIPS_INTERFACE
case|:
return|return
literal|"MIPS_INTERFACE"
return|;
case|case
name|DT_MIPS_DYNSTR_ALIGN
case|:
return|return
literal|"MIPS_DYNSTR_ALIGN"
return|;
case|case
name|DT_MIPS_INTERFACE_SIZE
case|:
return|return
literal|"MIPS_INTERFACE_SIZE"
return|;
case|case
name|DT_MIPS_RLD_TEXT_RESOLVE_ADDR
case|:
return|return
literal|"MIPS_RLD_TEXT_RESOLVE_ADDR"
return|;
case|case
name|DT_MIPS_PERF_SUFFIX
case|:
return|return
literal|"MIPS_PERF_SUFFIX"
return|;
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
return|return
literal|"MIPS_COMPACT_SIZE"
return|;
case|case
name|DT_MIPS_GP_VALUE
case|:
return|return
literal|"MIPS_GP_VALUE"
return|;
case|case
name|DT_MIPS_AUX_DYNAMIC
case|:
return|return
literal|"MIPS_AUX_DYNAMIC"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_sparc64_dynamic_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_SPARC_REGISTER
case|:
return|return
literal|"SPARC_REGISTER"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_dynamic_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_HP_LOAD_MAP
case|:
return|return
literal|"HP_LOAD_MAP"
return|;
case|case
name|DT_HP_DLD_FLAGS
case|:
return|return
literal|"HP_DLD_FLAGS"
return|;
case|case
name|DT_HP_DLD_HOOK
case|:
return|return
literal|"HP_DLD_HOOK"
return|;
case|case
name|DT_HP_UX10_INIT
case|:
return|return
literal|"HP_UX10_INIT"
return|;
case|case
name|DT_HP_UX10_INITSZ
case|:
return|return
literal|"HP_UX10_INITSZ"
return|;
case|case
name|DT_HP_PREINIT
case|:
return|return
literal|"HP_PREINIT"
return|;
case|case
name|DT_HP_PREINITSZ
case|:
return|return
literal|"HP_PREINITSZ"
return|;
case|case
name|DT_HP_NEEDED
case|:
return|return
literal|"HP_NEEDED"
return|;
case|case
name|DT_HP_TIME_STAMP
case|:
return|return
literal|"HP_TIME_STAMP"
return|;
case|case
name|DT_HP_CHECKSUM
case|:
return|return
literal|"HP_CHECKSUM"
return|;
case|case
name|DT_HP_GST_SIZE
case|:
return|return
literal|"HP_GST_SIZE"
return|;
case|case
name|DT_HP_GST_VERSION
case|:
return|return
literal|"HP_GST_VERSION"
return|;
case|case
name|DT_HP_GST_HASHVAL
case|:
return|return
literal|"HP_GST_HASHVAL"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"PREINIT_ARRAYSZ"
return|;
case|case
name|DT_CHECKSUM
case|:
return|return
literal|"CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"MOVESZ"
return|;
case|case
name|DT_FEATURE
case|:
return|return
literal|"FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"SYMINENT"
return|;
comment|/* aka VALRNGHI */
case|case
name|DT_ADDRRNGLO
case|:
return|return
literal|"ADDRRNGLO"
return|;
case|case
name|DT_CONFIG
case|:
return|return
literal|"CONFIG"
return|;
case|case
name|DT_DEPAUDIT
case|:
return|return
literal|"DEPAUDIT"
return|;
case|case
name|DT_AUDIT
case|:
return|return
literal|"AUDIT"
return|;
case|case
name|DT_PLTPAD
case|:
return|return
literal|"PLTPAD"
return|;
case|case
name|DT_MOVETAB
case|:
return|return
literal|"MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"SYMINFO"
return|;
comment|/* aka ADDRRNGHI */
case|case
name|DT_VERSYM
case|:
return|return
literal|"VERSYM"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"VERNEEDNUM"
return|;
case|case
name|DT_AUXILIARY
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
name|DT_USED
case|:
return|return
literal|"USED"
return|;
case|case
name|DT_FILTER
case|:
return|return
literal|"FILTER"
return|;
default|default:
if|if
condition|(
operator|(
name|type
operator|>=
name|DT_LOPROC
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_SPARCV9
case|:
name|result
operator|=
name|get_sparc64_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|>=
name|DT_LOOS
operator|)
operator|&&
operator|(
name|type
operator|<=
name|DT_HIOS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_dynamic_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Operating System specific: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_file_type
parameter_list|(
name|e_type
parameter_list|)
name|unsigned
name|e_type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|ET_NONE
case|:
return|return
name|_
argument_list|(
literal|"NONE (None)"
argument_list|)
return|;
case|case
name|ET_REL
case|:
return|return
name|_
argument_list|(
literal|"REL (Relocatable file)"
argument_list|)
return|;
case|case
name|ET_EXEC
case|:
return|return
name|_
argument_list|(
literal|"EXEC (Executable file)"
argument_list|)
return|;
case|case
name|ET_DYN
case|:
return|return
name|_
argument_list|(
literal|"DYN (Shared object file)"
argument_list|)
return|;
case|case
name|ET_CORE
case|:
return|return
name|_
argument_list|(
literal|"CORE (Core file)"
argument_list|)
return|;
default|default:
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOPROC
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIPROC
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Processor Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_type
operator|>=
name|ET_LOOS
operator|)
operator|&&
operator|(
name|e_type
operator|<=
name|ET_HIOS
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"OS Specific: (%x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_name
parameter_list|(
name|e_machine
parameter_list|)
name|unsigned
name|e_machine
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
comment|/* XXX */
switch|switch
condition|(
name|e_machine
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
name|_
argument_list|(
literal|"None"
argument_list|)
return|;
case|case
name|EM_M32
case|:
return|return
literal|"WE32100"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"Sparc"
return|;
case|case
name|EM_386
case|:
return|return
literal|"Intel 80386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"MC68000"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"MC88000"
return|;
case|case
name|EM_486
case|:
return|return
literal|"Intel 80486"
return|;
case|case
name|EM_860
case|:
return|return
literal|"Intel 80860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"MIPS R3000"
return|;
case|case
name|EM_S370
case|:
return|return
literal|"IBM System/370"
return|;
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
literal|"MIPS R4000 big-endian"
return|;
case|case
name|EM_OLD_SPARCV9
case|:
return|return
literal|"Sparc v9 (old)"
return|;
case|case
name|EM_PARISC
case|:
return|return
literal|"HPPA"
return|;
case|case
name|EM_PPC_OLD
case|:
return|return
literal|"Power PC (old)"
return|;
case|case
name|EM_SPARC32PLUS
case|:
return|return
literal|"Sparc v8+"
return|;
case|case
name|EM_960
case|:
return|return
literal|"Intel 90860"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"PowerPC"
return|;
case|case
name|EM_V800
case|:
return|return
literal|"NEC V800"
return|;
case|case
name|EM_FR20
case|:
return|return
literal|"Fujitsu FR20"
return|;
case|case
name|EM_RH32
case|:
return|return
literal|"TRW RH32"
return|;
case|case
name|EM_MCORE
case|:
return|return
literal|"MCORE"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"ARM"
return|;
case|case
name|EM_OLD_ALPHA
case|:
return|return
literal|"Digital Alpha (old)"
return|;
case|case
name|EM_SH
case|:
return|return
literal|"Hitachi SH"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"Sparc v9"
return|;
case|case
name|EM_TRICORE
case|:
return|return
literal|"Siemens Tricore"
return|;
case|case
name|EM_ARC
case|:
return|return
literal|"ARC"
return|;
case|case
name|EM_H8_300
case|:
return|return
literal|"Hitachi H8/300"
return|;
case|case
name|EM_H8_300H
case|:
return|return
literal|"Hitachi H8/300H"
return|;
case|case
name|EM_H8S
case|:
return|return
literal|"Hitachi H8S"
return|;
case|case
name|EM_H8_500
case|:
return|return
literal|"Hitachi H8/500"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"Intel IA-64"
return|;
case|case
name|EM_MIPS_X
case|:
return|return
literal|"Stanford MIPS-X"
return|;
case|case
name|EM_COLDFIRE
case|:
return|return
literal|"Motorola Coldfire"
return|;
case|case
name|EM_68HC12
case|:
return|return
literal|"Motorola M68HC12"
return|;
case|case
name|EM_ALPHA
case|:
return|return
literal|"Alpha"
return|;
case|case
name|EM_CYGNUS_D10V
case|:
return|return
literal|"d10v"
return|;
case|case
name|EM_CYGNUS_D30V
case|:
return|return
literal|"d30v"
return|;
case|case
name|EM_CYGNUS_ARC
case|:
return|return
literal|"ARC"
return|;
case|case
name|EM_CYGNUS_M32R
case|:
return|return
literal|"Mitsubishi M32r"
return|;
case|case
name|EM_CYGNUS_V850
case|:
return|return
literal|"NEC v850"
return|;
case|case
name|EM_CYGNUS_MN10300
case|:
return|return
literal|"mn10300"
return|;
case|case
name|EM_CYGNUS_MN10200
case|:
return|return
literal|"mn10200"
return|;
case|case
name|EM_CYGNUS_FR30
case|:
return|return
literal|"Fujitsu FR30"
return|;
case|case
name|EM_PJ
case|:
return|return
literal|"picoJava"
return|;
case|case
name|EM_MMA
case|:
return|return
literal|"Fujitsu Multimedia Accelerator"
return|;
case|case
name|EM_PCP
case|:
return|return
literal|"Siemens PCP"
return|;
case|case
name|EM_NCPU
case|:
return|return
literal|"Sony nCPU embedded RISC processor"
return|;
case|case
name|EM_NDR1
case|:
return|return
literal|"Denso NDR1 microprocesspr"
return|;
case|case
name|EM_STARCORE
case|:
return|return
literal|"Motorola Star*Core processor"
return|;
case|case
name|EM_ME16
case|:
return|return
literal|"Toyota ME16 processor"
return|;
case|case
name|EM_ST100
case|:
return|return
literal|"STMicroelectronics ST100 processor"
return|;
case|case
name|EM_TINYJ
case|:
return|return
literal|"Advanced Logic Corp. TinyJ embedded processor"
return|;
case|case
name|EM_FX66
case|:
return|return
literal|"Siemens FX66 microcontroller"
return|;
case|case
name|EM_ST9PLUS
case|:
return|return
literal|"STMicroelectronics ST9+ 8/16 bit microcontroller"
return|;
case|case
name|EM_ST7
case|:
return|return
literal|"STMicroelectronics ST7 8-bit microcontroller"
return|;
case|case
name|EM_68HC16
case|:
return|return
literal|"Motorola MC68HC16 Microcontroller"
return|;
case|case
name|EM_68HC11
case|:
return|return
literal|"Motorola MC68HC11 Microcontroller"
return|;
case|case
name|EM_68HC08
case|:
return|return
literal|"Motorola MC68HC08 Microcontroller"
return|;
case|case
name|EM_68HC05
case|:
return|return
literal|"Motorola MC68HC05 Microcontroller"
return|;
case|case
name|EM_SVX
case|:
return|return
literal|"Silicon Graphics SVx"
return|;
case|case
name|EM_ST19
case|:
return|return
literal|"STMicroelectronics ST19 8-bit microcontroller"
return|;
case|case
name|EM_VAX
case|:
return|return
literal|"Digital VAX"
return|;
case|case
name|EM_AVR
case|:
return|return
literal|"Atmel AVR 8-bit microcontroller"
return|;
case|case
name|EM_CRIS
case|:
return|return
literal|"Axis Communications 32-bit embedded processor"
return|;
case|case
name|EM_JAVELIN
case|:
return|return
literal|"Infineon Technologies 32-bit embedded cpu"
return|;
case|case
name|EM_FIREPATH
case|:
return|return
literal|"Element 14 64-bit DSP processor"
return|;
case|case
name|EM_ZSP
case|:
return|return
literal|"LSI Logic's 16-bit DSP processor"
return|;
case|case
name|EM_MMIX
case|:
return|return
literal|"Donald Knuth's educational 64-bit processor"
return|;
case|case
name|EM_HUANY
case|:
return|return
literal|"Harvard Universitys's machine-independent object format"
return|;
case|case
name|EM_PRISM
case|:
return|return
literal|"SiTera Prism"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"Advanced Micro Devices X86-64"
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|e_machine
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|decode_ARM_machine_flags
parameter_list|(
name|e_flags
parameter_list|,
name|buf
parameter_list|)
name|unsigned
name|e_flags
decl_stmt|;
name|char
name|buf
index|[]
decl_stmt|;
block|{
name|unsigned
name|eabi
decl_stmt|;
name|int
name|unknown
init|=
literal|0
decl_stmt|;
name|eabi
operator|=
name|EF_ARM_EABI_VERSION
argument_list|(
name|e_flags
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_EABIMASK
expr_stmt|;
comment|/* Handle "generic" ARM flags.  */
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_RELEXEC
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable executable"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_RELEXEC
expr_stmt|;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_ARM_HASENTRY
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", has entry point"
argument_list|)
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_ARM_HASENTRY
expr_stmt|;
block|}
comment|/* Now handle EABI specific flags.  */
switch|switch
condition|(
name|eabi
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unknown EABI>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER1
case|:
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_ARM_SYMSARESORTED
case|:
comment|/* Conflicts with EF_INTERWORK.  */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sorted symbol tables"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
while|while
condition|(
name|e_flags
condition|)
block|{
name|unsigned
name|flag
decl_stmt|;
comment|/* Process flags one bit at a time.  */
name|flag
operator|=
name|e_flags
operator|&
operator|-
name|e_flags
expr_stmt|;
name|e_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|EF_INTERWORK
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", interworking enabled"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_APCS_26
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/26"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_APCS_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses APCS/float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_PIC
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", position independent"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ALIGN8
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 8 bit structure alignment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_NEW_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses new ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_OLD_ABI
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", uses old ABI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_SOFT_FLOAT
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", software FP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|unknown
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|unknown
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",<unknown>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_machine_flags
parameter_list|(
name|e_flags
parameter_list|,
name|e_machine
parameter_list|)
name|unsigned
name|e_flags
decl_stmt|;
name|unsigned
name|e_machine
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|e_flags
condition|)
block|{
switch|switch
condition|(
name|e_machine
condition|)
block|{
default|default:
break|break;
case|case
name|EM_ARM
case|:
name|decode_ARM_machine_flags
argument_list|(
name|e_flags
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_68K
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_CPU32
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpu32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PPC
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_EMB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", emb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PPC_RELOCATABLE_LIB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relocatable-lib"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_CYGNUS_V850
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_V850_ARCH
condition|)
block|{
case|case
name|E_V850E_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850e"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850EA_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850ea"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_V850_ARCH
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v850"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", unknown v850 architecture variant"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_CYGNUS_M32R
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|==
name|E_M32R_ARCH
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", m32r"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_NOREORDER
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", noreorder"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_CPIC
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", cpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_MIPS_ABI2
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", abi2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_3
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips3"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_4
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips4"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_5
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips5"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips64"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|e_flags
operator|&
name|EF_MIPS_MACH
operator|)
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 3900"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4010
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4010"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4100
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4100"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4650
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4650"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_4111
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 4111"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_MIPS32_4K
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mips32-4k"
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_MIPS_MACH_SB1
case|:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", sb1"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" UNKNOWN"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|EM_SPARCV9
case|:
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_32PLUS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", v8+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_SUN_US3
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ultrasparcIII"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_HAL_R1
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", halr1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_SPARC_LEDATA
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ledata"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_TSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", tso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_PSO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", pso"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_SPARCV9_MM
operator|)
operator|==
name|EF_SPARCV9_RMO
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", rmo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
switch|switch
condition|(
name|e_flags
operator|&
name|EF_PARISC_ARCH
condition|)
block|{
case|case
name|EFA_PARISC_1_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_1_1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 1.1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EFA_PARISC_2_0
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|", PA-RISC 2.0"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_TRAPNIL
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", trapnil"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_EXT
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", ext"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LSB
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lsb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_WIDE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", wide"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_NO_KABP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no kabp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_flags
operator|&
name|EF_PARISC_LAZYSWAP
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", lazyswap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PJ
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_NEWCALLS
operator|)
operator|==
name|EF_PICOJAVA_NEWCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", new calling convention"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_PICOJAVA_GNUCALLS
operator|)
operator|==
name|EF_PICOJAVA_GNUCALLS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", gnu calling convention"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABI64
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 64-bit"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", 32-bit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_REDUCEDFP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", reduced fp model"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_NOFUNCDESC_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", no function descriptors, constant gp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_CONS_GP
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", constant gp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_IA_64_ABSOLUTE
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", absolute"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_segment_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_MIPS_REGINFO
case|:
return|return
literal|"REGINFO"
return|;
case|case
name|PT_MIPS_RTPROC
case|:
return|return
literal|"RTPROC"
return|;
case|case
name|PT_MIPS_OPTIONS
case|:
return|return
literal|"OPTIONS"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_segment_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_HP_TLS
case|:
return|return
literal|"HP_TLS"
return|;
case|case
name|PT_HP_CORE_NONE
case|:
return|return
literal|"HP_CORE_NONE"
return|;
case|case
name|PT_HP_CORE_VERSION
case|:
return|return
literal|"HP_CORE_VERSION"
return|;
case|case
name|PT_HP_CORE_KERNEL
case|:
return|return
literal|"HP_CORE_KERNEL"
return|;
case|case
name|PT_HP_CORE_COMM
case|:
return|return
literal|"HP_CORE_COMM"
return|;
case|case
name|PT_HP_CORE_PROC
case|:
return|return
literal|"HP_CORE_PROC"
return|;
case|case
name|PT_HP_CORE_LOADABLE
case|:
return|return
literal|"HP_CORE_LOADABLE"
return|;
case|case
name|PT_HP_CORE_STACK
case|:
return|return
literal|"HP_CORE_STACK"
return|;
case|case
name|PT_HP_CORE_SHM
case|:
return|return
literal|"HP_CORE_SHM"
return|;
case|case
name|PT_HP_CORE_MMF
case|:
return|return
literal|"HP_CORE_MMF"
return|;
case|case
name|PT_HP_PARALLEL
case|:
return|return
literal|"HP_PARALLEL"
return|;
case|case
name|PT_HP_FASTBIND
case|:
return|return
literal|"HP_FASTBIND"
return|;
case|case
name|PT_PARISC_ARCHEXT
case|:
return|return
literal|"PARISC_ARCHEXT"
return|;
case|case
name|PT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_segment_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|long
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_IA_64_ARCHEXT
case|:
return|return
literal|"IA_64_ARCHEXT"
return|;
case|case
name|PT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_segment_type
parameter_list|(
name|p_type
parameter_list|)
name|unsigned
name|long
name|p_type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|PT_LOAD
case|:
return|return
literal|"LOAD"
return|;
case|case
name|PT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|PT_INTERP
case|:
return|return
literal|"INTERP"
return|;
case|case
name|PT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|PT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|PT_PHDR
case|:
return|return
literal|"PHDR"
return|;
default|default:
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOPROC
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOPROC+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p_type
operator|>=
name|PT_LOOS
operator|)
operator|&&
operator|(
name|p_type
operator|<=
name|PT_HIOS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_segment_type
argument_list|(
name|p_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"LOOS+%lx"
argument_list|,
name|p_type
operator|-
name|PT_LOOS
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %lx"
argument_list|)
argument_list|,
name|p_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_mips_section_type_name
parameter_list|(
name|sh_type
parameter_list|)
name|unsigned
name|int
name|sh_type
decl_stmt|;
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
return|return
literal|"MIPS_LIBLIST"
return|;
case|case
name|SHT_MIPS_MSYM
case|:
return|return
literal|"MIPS_MSYM"
return|;
case|case
name|SHT_MIPS_CONFLICT
case|:
return|return
literal|"MIPS_CONFLICT"
return|;
case|case
name|SHT_MIPS_GPTAB
case|:
return|return
literal|"MIPS_GPTAB"
return|;
case|case
name|SHT_MIPS_UCODE
case|:
return|return
literal|"MIPS_UCODE"
return|;
case|case
name|SHT_MIPS_DEBUG
case|:
return|return
literal|"MIPS_DEBUG"
return|;
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_PACKAGE
case|:
return|return
literal|"MIPS_PACKAGE"
return|;
case|case
name|SHT_MIPS_PACKSYM
case|:
return|return
literal|"MIPS_PACKSYM"
return|;
case|case
name|SHT_MIPS_RELD
case|:
return|return
literal|"MIPS_RELD"
return|;
case|case
name|SHT_MIPS_IFACE
case|:
return|return
literal|"MIPS_IFACE"
return|;
case|case
name|SHT_MIPS_CONTENT
case|:
return|return
literal|"MIPS_CONTENT"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_SHDR
case|:
return|return
literal|"MIPS_SHDR"
return|;
case|case
name|SHT_MIPS_FDESC
case|:
return|return
literal|"MIPS_FDESC"
return|;
case|case
name|SHT_MIPS_EXTSYM
case|:
return|return
literal|"MIPS_EXTSYM"
return|;
case|case
name|SHT_MIPS_DENSE
case|:
return|return
literal|"MIPS_DENSE"
return|;
case|case
name|SHT_MIPS_PDESC
case|:
return|return
literal|"MIPS_PDESC"
return|;
case|case
name|SHT_MIPS_LOCSYM
case|:
return|return
literal|"MIPS_LOCSYM"
return|;
case|case
name|SHT_MIPS_AUXSYM
case|:
return|return
literal|"MIPS_AUXSYM"
return|;
case|case
name|SHT_MIPS_OPTSYM
case|:
return|return
literal|"MIPS_OPTSYM"
return|;
case|case
name|SHT_MIPS_LOCSTR
case|:
return|return
literal|"MIPS_LOCSTR"
return|;
case|case
name|SHT_MIPS_LINE
case|:
return|return
literal|"MIPS_LINE"
return|;
case|case
name|SHT_MIPS_RFDESC
case|:
return|return
literal|"MIPS_RFDESC"
return|;
case|case
name|SHT_MIPS_DELTASYM
case|:
return|return
literal|"MIPS_DELTASYM"
return|;
case|case
name|SHT_MIPS_DELTAINST
case|:
return|return
literal|"MIPS_DELTAINST"
return|;
case|case
name|SHT_MIPS_DELTACLASS
case|:
return|return
literal|"MIPS_DELTACLASS"
return|;
case|case
name|SHT_MIPS_DWARF
case|:
return|return
literal|"MIPS_DWARF"
return|;
case|case
name|SHT_MIPS_DELTADECL
case|:
return|return
literal|"MIPS_DELTADECL"
return|;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
return|return
literal|"MIPS_SYMBOL_LIB"
return|;
case|case
name|SHT_MIPS_EVENTS
case|:
return|return
literal|"MIPS_EVENTS"
return|;
case|case
name|SHT_MIPS_TRANSLATE
case|:
return|return
literal|"MIPS_TRANSLATE"
return|;
case|case
name|SHT_MIPS_PIXIE
case|:
return|return
literal|"MIPS_PIXIE"
return|;
case|case
name|SHT_MIPS_XLATE
case|:
return|return
literal|"MIPS_XLATE"
return|;
case|case
name|SHT_MIPS_XLATE_DEBUG
case|:
return|return
literal|"MIPS_XLATE_DEBUG"
return|;
case|case
name|SHT_MIPS_WHIRL
case|:
return|return
literal|"MIPS_WHIRL"
return|;
case|case
name|SHT_MIPS_EH_REGION
case|:
return|return
literal|"MIPS_EH_REGION"
return|;
case|case
name|SHT_MIPS_XLATE_OLD
case|:
return|return
literal|"MIPS_XLATE_OLD"
return|;
case|case
name|SHT_MIPS_PDR_EXCEPTION
case|:
return|return
literal|"MIPS_PDR_EXCEPTION"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_parisc_section_type_name
parameter_list|(
name|sh_type
parameter_list|)
name|unsigned
name|int
name|sh_type
decl_stmt|;
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_PARISC_EXT
case|:
return|return
literal|"PARISC_EXT"
return|;
case|case
name|SHT_PARISC_UNWIND
case|:
return|return
literal|"PARISC_UNWIND"
return|;
case|case
name|SHT_PARISC_DOC
case|:
return|return
literal|"PARISC_DOC"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ia64_section_type_name
parameter_list|(
name|sh_type
parameter_list|)
name|unsigned
name|int
name|sh_type
decl_stmt|;
block|{
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_IA_64_EXT
case|:
return|return
literal|"IA_64_EXT"
return|;
case|case
name|SHT_IA_64_UNWIND
case|:
return|return
literal|"IA_64_UNWIND"
return|;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_section_type_name
parameter_list|(
name|sh_type
parameter_list|)
name|unsigned
name|int
name|sh_type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"PREINIT_ARRAY"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SYMTAB SECTION INDICIES"
return|;
case|case
name|SHT_GNU_verdef
case|:
return|return
literal|"VERDEF"
return|;
case|case
name|SHT_GNU_verneed
case|:
return|return
literal|"VERNEED"
return|;
case|case
name|SHT_GNU_versym
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffff0
case|:
return|return
literal|"VERSYM"
return|;
case|case
literal|0x6ffffffc
case|:
return|return
literal|"VERDEF"
return|;
case|case
literal|0x7ffffffd
case|:
return|return
literal|"AUXILIARY"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"FILTER"
return|;
default|default:
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOPROC
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIPROC
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|result
operator|=
name|get_mips_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|result
operator|=
name|get_parisc_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_IA_64
case|:
name|result
operator|=
name|get_ia64_section_type_name
argument_list|(
name|sh_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"SHT_LOPROC+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOPROC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOOS
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIOS
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"SHT_LOOS+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOOS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sh_type
operator|>=
name|SHT_LOUSER
operator|)
operator|&&
operator|(
name|sh_type
operator|<=
name|SHT_HIUSER
operator|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"SHT_LOUSER+%x"
argument_list|,
name|sh_type
operator|-
name|SHT_LOUSER
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %x"
argument_list|)
argument_list|,
name|sh_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_decl_stmt
name|struct
name|option
name|options
index|[]
init|=
block|{
block|{
literal|"all"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"file-header"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"program-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"histogram"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"segments"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"sections"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"symbols"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"relocs"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"notes"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"arch-specific"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"version-info"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"use-dynamic"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"hex-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"debug-dump"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"unwind"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'u'
block|}
block|,
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
block|{
literal|"instruction-dump"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
endif|#
directive|endif
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Usage: readelf {options} elf-file(s)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  Options are:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -a or --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -h or --file-header       Display the ELF file header\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -l or --program-headers or --segments\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"                            Display the program headers\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -S or --section-headers or --sections\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"                            Display the sections' header\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -e or --headers           Equivalent to: -h -l -S\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -s or --syms or --symbols Display the symbol table\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -n or --notes             Display the core notes (if present)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -r or --relocs            Display the relocations (if present)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -u or --unwind            Display the unwind info (if present)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -d or --dynamic           Display the dynamic segment (if present)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -V or --version-info      Display the version sections (if present)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -A or --arch-specific     Display architecture specific information (if any).\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -D or --use-dynamic       Use the dynamic section info when displaying symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -x<number> or --hex-dump=<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"                            Dump the contents of section<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -w[liaprf] or --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=frames]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"                            Display the contents of DWARF2 debug sections\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -i<number> or --instruction-dump=<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"                            Disassemble the contents of section<number>\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -I or --histogram         Display histogram of bucket list lengths\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -v or --version           Display the version number of readelf\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"  -H or --help              Display this information\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|request_dump
parameter_list|(
name|section
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|int
name|section
decl_stmt|;
name|char
name|type
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|>=
name|num_dump_sects
condition|)
block|{
name|char
modifier|*
name|new_dump_sects
decl_stmt|;
name|new_dump_sects
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|section
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_dump_sects
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory allocating dump request table."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Copy current flag settings.  */
name|memcpy
argument_list|(
name|new_dump_sects
argument_list|,
name|dump_sects
argument_list|,
name|num_dump_sects
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
name|dump_sects
operator|=
name|new_dump_sects
expr_stmt|;
name|num_dump_sects
operator|=
name|section
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_sects
condition|)
name|dump_sects
index|[
name|section
index|]
operator||=
name|type
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ersuahnldSDAIw::x:i:vV"
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|section
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long options.  */
break|break;
case|case
literal|'H'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|do_syms
operator|++
expr_stmt|;
name|do_reloc
operator|++
expr_stmt|;
name|do_unwind
operator|++
expr_stmt|;
name|do_dynamic
operator|++
expr_stmt|;
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
name|do_version
operator|++
expr_stmt|;
name|do_histogram
operator|++
expr_stmt|;
name|do_arch
operator|++
expr_stmt|;
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|do_header
operator|++
expr_stmt|;
name|do_sections
operator|++
expr_stmt|;
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|do_arch
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|do_using_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|do_reloc
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|do_unwind
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|do_header
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|do_segments
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|do_syms
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|do_sections
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_dynamic
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|do_histogram
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|do_notes
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
block|{
name|request_dump
argument_list|(
name|section
argument_list|,
name|HEX_DUMP
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|oops
goto|;
case|case
literal|'w'
case|:
name|do_dump
operator|++
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
literal|0
condition|)
name|do_debugging
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|do_debugging
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optarg
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|do_debug_info
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|do_debug_abbrevs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|do_debug_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|do_debug_pubnames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|do_debug_aranges
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|do_debug_frames_interp
operator|=
literal|1
expr_stmt|;
case|case
literal|'f'
case|:
name|do_debug_frames
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognised debug option '%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
case|case
literal|'i'
case|:
name|do_dump
operator|++
expr_stmt|;
name|section
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
operator|&&
name|section
operator|>=
literal|0
condition|)
block|{
name|request_dump
argument_list|(
name|section
argument_list|,
name|DISASS_DUMP
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|oops
goto|;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|print_version
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|do_version
operator|++
expr_stmt|;
break|break;
default|default:
name|oops
label|:
comment|/* xgettext:c-format */
name|error
argument_list|(
name|_
argument_list|(
literal|"Invalid option '-%c'\n"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Drop through.  */
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|do_dynamic
operator|&&
operator|!
name|do_syms
operator|&&
operator|!
name|do_reloc
operator|&&
operator|!
name|do_unwind
operator|&&
operator|!
name|do_sections
operator|&&
operator|!
name|do_segments
operator|&&
operator|!
name|do_header
operator|&&
operator|!
name|do_dump
operator|&&
operator|!
name|do_version
operator|&&
operator|!
name|do_histogram
operator|&&
operator|!
name|do_debugging
operator|&&
operator|!
name|do_arch
operator|&&
operator|!
name|do_notes
condition|)
name|usage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Nothing to do.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_class
parameter_list|(
name|elf_class
parameter_list|)
name|unsigned
name|char
name|elf_class
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|elf_class
condition|)
block|{
case|case
name|ELFCLASSNONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFCLASS32
case|:
return|return
name|_
argument_list|(
literal|"ELF32"
argument_list|)
return|;
case|case
name|ELFCLASS64
case|:
return|return
name|_
argument_list|(
literal|"ELF64"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|elf_class
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_data_encoding
parameter_list|(
name|encoding
parameter_list|)
name|unsigned
name|char
name|encoding
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|ELFDATANONE
case|:
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
case|case
name|ELFDATA2LSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, little endian"
argument_list|)
return|;
case|case
name|ELFDATA2MSB
case|:
return|return
name|_
argument_list|(
literal|"2's complement, big endian"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_osabi_name
parameter_list|(
name|osabi
parameter_list|)
name|unsigned
name|char
name|osabi
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|osabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
return|return
name|_
argument_list|(
literal|"UNIX - System V"
argument_list|)
return|;
case|case
name|ELFOSABI_HPUX
case|:
return|return
name|_
argument_list|(
literal|"UNIX - HP-UX"
argument_list|)
return|;
case|case
name|ELFOSABI_NETBSD
case|:
return|return
name|_
argument_list|(
literal|"UNIX - NetBSD"
argument_list|)
return|;
case|case
name|ELFOSABI_LINUX
case|:
return|return
name|_
argument_list|(
literal|"UNIX - Linux"
argument_list|)
return|;
case|case
name|ELFOSABI_HURD
case|:
return|return
name|_
argument_list|(
literal|"GNU/Hurd"
argument_list|)
return|;
case|case
name|ELFOSABI_SOLARIS
case|:
return|return
name|_
argument_list|(
literal|"UNIX - Solaris"
argument_list|)
return|;
case|case
name|ELFOSABI_AIX
case|:
return|return
name|_
argument_list|(
literal|"UNIX - AIX"
argument_list|)
return|;
case|case
name|ELFOSABI_IRIX
case|:
return|return
name|_
argument_list|(
literal|"UNIX - IRIX"
argument_list|)
return|;
case|case
name|ELFOSABI_FREEBSD
case|:
return|return
name|_
argument_list|(
literal|"UNIX - FreeBSD"
argument_list|)
return|;
case|case
name|ELFOSABI_TRU64
case|:
return|return
name|_
argument_list|(
literal|"UNIX - TRU64"
argument_list|)
return|;
case|case
name|ELFOSABI_MODESTO
case|:
return|return
name|_
argument_list|(
literal|"Novell - Modesto"
argument_list|)
return|;
case|case
name|ELFOSABI_OPENBSD
case|:
return|return
name|_
argument_list|(
literal|"UNIX - OpenBSD"
argument_list|)
return|;
case|case
name|ELFOSABI_STANDALONE
case|:
return|return
name|_
argument_list|(
literal|"Standalone App"
argument_list|)
return|;
case|case
name|ELFOSABI_ARM
case|:
return|return
name|_
argument_list|(
literal|"ARM"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown: %x>"
argument_list|)
argument_list|,
name|osabi
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_comment
comment|/* Decode the data held in 'elf_header'.  */
end_comment

begin_function
specifier|static
name|int
name|process_file_header
parameter_list|()
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|elf_header
operator|.
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Not an ELF file - it has the wrong magic bytes at the start\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_header
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"ELF Header:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Magic:   "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EI_NIDENT
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%2.2x "
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Class:                             %s\n"
argument_list|)
argument_list|,
name|get_elf_class
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Data:                              %s\n"
argument_list|)
argument_list|,
name|get_data_encoding
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           %d %s\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
argument_list|,
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|==
name|EV_CURRENT
condition|?
literal|"(current)"
else|:
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_NONE
condition|?
literal|"<unknown: %lx>"
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  OS/ABI:                            %s\n"
argument_list|)
argument_list|,
name|get_osabi_name
argument_list|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  ABI Version:                       %d\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_ident
index|[
name|EI_ABIVERSION
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type:                              %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Machine:                           %s\n"
argument_list|)
argument_list|,
name|get_machine_name
argument_list|(
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                           0x%lx\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry point address:               "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n  Start of program headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n  Start of section headers:          "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" (bytes into file)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags:                             0x%lx%s\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_flags
argument_list|,
name|get_machine_flags
argument_list|(
name|elf_header
operator|.
name|e_flags
argument_list|,
name|elf_header
operator|.
name|e_machine
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of this header:               %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of program headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of program headers:         %ld\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of section headers:           %ld (bytes)\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of section headers:         %ld\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Section header string table index: %ld\n"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|elf_header
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_program_headers
parameter_list|(
name|file
parameter_list|,
name|program_headers
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
block|{
name|Elf32_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf32_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf32_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
operator|*
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|phdrs
argument_list|,
name|Elf32_External_Phdr
operator|*
argument_list|,
literal|"program headers"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_program_headers
parameter_list|(
name|file
parameter_list|,
name|program_headers
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
block|{
name|Elf64_External_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|Elf64_External_Phdr
modifier|*
name|external
decl_stmt|;
name|Elf64_Internal_Phdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|elf_header
operator|.
name|e_phentsize
operator|*
name|elf_header
operator|.
name|e_phnum
argument_list|,
name|phdrs
argument_list|,
name|Elf64_External_Phdr
operator|*
argument_list|,
literal|"program headers"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|program_headers
operator|,
name|external
operator|=
name|phdrs
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
operator|,
name|external
operator|++
control|)
block|{
name|internal
operator|->
name|p_type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_flags
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_offset
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_vaddr
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_paddr
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_filesz
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_memsz
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|internal
operator|->
name|p_align
operator|=
name|BYTE_GET8
argument_list|(
name|external
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|phdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_program_headers
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no program headers in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|do_segments
operator|&&
operator|!
name|do_header
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nElf file type is %s\n"
argument_list|)
argument_list|,
name|get_file_type
argument_list|(
name|elf_header
operator|.
name|e_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Entry point "
argument_list|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_entry
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are %d program headers, starting at offset "
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
name|elf_header
operator|.
name|e_phoff
argument_list|,
name|DEC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|program_headers
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|malloc
argument_list|(
name|elf_header
operator|.
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
name|i
operator|=
name|get_32bit_program_headers
argument_list|(
name|file
argument_list|,
name|program_headers
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|get_64bit_program_headers
argument_list|(
name|file
argument_list|,
name|program_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_segments
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nProgram Header%s:\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_phnum
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Type           Offset             VirtAddr           PhysAddr\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"                 FileSiz            MemSiz              Flags  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|loadaddr
operator|=
operator|-
literal|1
expr_stmt|;
name|dynamic_addr
operator|=
literal|0
expr_stmt|;
name|dynamic_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|do_segments
condition|)
block|{
name|printf
argument_list|(
literal|"  %-14.14s "
argument_list|,
name|get_segment_type
argument_list|(
name|segment
operator|->
name|p_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|printf
argument_list|(
literal|"0x%6.6lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%5.5lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c%c "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%#lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|segment
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_vma
argument_list|(
name|segment
operator|->
name|p_offset
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_vaddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_paddr
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n                 "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_filesz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_memsz
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %c%c%c    "
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_R
condition|?
literal|'R'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_W
condition|?
literal|'W'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|segment
operator|->
name|p_flags
operator|&
name|PF_X
condition|?
literal|'E'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|segment
operator|->
name|p_align
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|segment
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
if|if
condition|(
name|loadaddr
operator|==
operator|-
literal|1
condition|)
name|loadaddr
operator|=
operator|(
name|segment
operator|->
name|p_vaddr
operator|&
literal|0xfffff000
operator|)
operator|-
operator|(
name|segment
operator|->
name|p_offset
operator|&
literal|0xfffff000
operator|)
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
if|if
condition|(
name|dynamic_addr
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"more than one dynamic segment\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dynamic_addr
operator|=
name|segment
operator|->
name|p_offset
expr_stmt|;
name|dynamic_size
operator|=
name|segment
operator|->
name|p_filesz
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
operator|(
name|long
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to find program interpreter name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|program_interpreter
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fscanf
argument_list|(
name|file
argument_list|,
literal|"%63s"
argument_list|,
name|program_interpreter
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_segments
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n      [Requesting program interpreter: %s]"
argument_list|)
argument_list|,
name|program_interpreter
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|do_segments
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loadaddr
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Very strange. */
name|loadaddr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|do_segments
operator|&&
name|section_headers
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Section to Segment mapping:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Segment Sections...\n"
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|segment
operator|=
name|program_headers
operator|+
name|i
expr_stmt|;
name|section
operator|=
name|section_headers
expr_stmt|;
name|printf
argument_list|(
literal|"   %2.2d     "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|j
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_size
operator|>
literal|0
comment|/* Compare allocated sections by VMA, unallocated 		     sections by file offset.  */
operator|&&
operator|(
name|section
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
condition|?
operator|(
name|section
operator|->
name|sh_addr
operator|>=
name|segment
operator|->
name|p_vaddr
operator|&&
name|section
operator|->
name|sh_addr
operator|+
name|section
operator|->
name|sh_size
operator|<=
name|segment
operator|->
name|p_vaddr
operator|+
name|segment
operator|->
name|p_memsz
operator|)
else|:
operator|(
operator|(
name|bfd_vma
operator|)
name|section
operator|->
name|sh_offset
operator|>=
name|segment
operator|->
name|p_offset
operator|&&
operator|(
name|section
operator|->
name|sh_offset
operator|+
name|section
operator|->
name|sh_size
operator|<=
name|segment
operator|->
name|p_offset
operator|+
name|segment
operator|->
name|p_filesz
operator|)
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_section_headers
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
operator|*
name|elf_header
operator|.
name|e_shnum
argument_list|,
name|shdrs
argument_list|,
name|Elf32_External_Shdr
operator|*
argument_list|,
literal|"section headers"
argument_list|)
expr_stmt|;
name|section_headers
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|malloc
argument_list|(
name|elf_header
operator|.
name|e_shnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_section_headers
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf64_External_Shdr
modifier|*
name|shdrs
decl_stmt|;
name|Elf64_Internal_Shdr
modifier|*
name|internal
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|elf_header
operator|.
name|e_shoff
argument_list|,
name|elf_header
operator|.
name|e_shentsize
operator|*
name|elf_header
operator|.
name|e_shnum
argument_list|,
name|shdrs
argument_list|,
name|Elf64_External_Shdr
operator|*
argument_list|,
literal|"section headers"
argument_list|)
expr_stmt|;
name|section_headers
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|malloc
argument_list|(
name|elf_header
operator|.
name|e_shnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|internal
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|internal
operator|++
control|)
block|{
name|internal
operator|->
name|sh_name
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_name
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_type
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_flags
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_flags
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addr
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_size
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_entsize
operator|=
name|BYTE_GET8
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_entsize
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_link
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_info
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_info
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_offset
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
expr_stmt|;
name|internal
operator|->
name|sh_addralign
operator|=
name|BYTE_GET
argument_list|(
name|shdrs
index|[
name|i
index|]
operator|.
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|shdrs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_32bit_elf_symbols
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|number
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
block|{
name|Elf32_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|offset
argument_list|,
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
argument_list|,
name|esyms
argument_list|,
name|Elf32_External_Sym
operator|*
argument_list|,
literal|"symbols"
argument_list|)
expr_stmt|;
name|isyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|get_64bit_elf_symbols
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|number
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|number
decl_stmt|;
block|{
name|Elf64_External_Sym
modifier|*
name|esyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isyms
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|offset
argument_list|,
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
argument_list|,
name|esyms
argument_list|,
name|Elf64_External_Sym
operator|*
argument_list|,
literal|"symbols"
argument_list|)
expr_stmt|;
name|isyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isyms
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|psym
operator|=
name|isyms
init|;
name|j
operator|<
name|number
condition|;
name|j
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|psym
operator|->
name|st_name
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_info
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_other
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_other
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_shndx
operator|=
name|BYTE_GET
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_shndx
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_value
operator|=
name|BYTE_GET8
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_value
argument_list|)
expr_stmt|;
name|psym
operator|->
name|st_size
operator|=
name|BYTE_GET8
argument_list|(
name|esyms
index|[
name|j
index|]
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|esyms
argument_list|)
expr_stmt|;
return|return
name|isyms
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_elf_section_flags
parameter_list|(
name|sh_flags
parameter_list|)
name|bfd_vma
name|sh_flags
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
operator|*
name|buff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sh_flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|sh_flags
operator|&
operator|-
name|sh_flags
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SHF_WRITE
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_ALLOC
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_EXECINSTR
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"X"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_MERGE
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"M"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_STRINGS
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_INFO_LINK
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_LINK_ORDER
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_OS_NONCONFORMING
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"O"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHF_GROUP
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"G"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|flag
operator|&
name|SHF_MASKOS
condition|)
block|{
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"o"
argument_list|)
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|&
name|SHF_MASKPROC
condition|)
block|{
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
name|sh_flags
operator|&=
operator|~
name|SHF_MASKPROC
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_headers
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|int
name|i
decl_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_shnum
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_sections
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|do_sections
operator|&&
operator|!
name|do_header
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"There are %d section headers, starting at offset 0x%lx:\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_shnum
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|elf_header
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_section_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_section_headers
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Read in the string table, so that we have names to display.  */
name|section
operator|=
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shstrndx
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|GET_DATA_ALLOC
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|string_table
argument_list|,
name|char
operator|*
argument_list|,
literal|"string table"
argument_list|)
expr_stmt|;
name|string_table_length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
block|}
comment|/* Scan the sections for the dynamic symbol table      and dynamic string table and debug sections. */
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|dynamic_symbols
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic symbol tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|num_dynamic_syms
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|num_dynamic_syms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_STRTAB
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"File contains multiple dynamic string tables\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|GET_DATA_ALLOC
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|dynamic_strings
argument_list|,
name|char
operator|*
argument_list|,
literal|"dynamic strings"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|||
name|do_debug_abbrevs
operator|||
name|do_debug_lines
operator|||
name|do_debug_pubnames
operator|||
name|do_debug_aranges
operator|||
name|do_debug_frames
operator|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|do_debugging
operator|||
operator|(
name|do_debug_info
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_abbrevs
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"abbrev"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_lines
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"line"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_pubnames
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pubnames"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_aranges
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"aranges"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|do_debug_frames
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"frame"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
comment|/* linkonce section to be combined with .debug_info at link time.  */
elseif|else
if|if
condition|(
operator|(
name|do_debugging
operator|||
name|do_debug_info
operator|)
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_debug_frames
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
condition|)
name|request_dump
argument_list|(
name|i
argument_list|,
name|DEBUG_DUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_sections
condition|)
return|return
literal|1
return|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection Header%s:\n"
argument_list|)
argument_list|,
name|elf_header
operator|.
name|e_shnum
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  [Nr] Name              Type             Address           Offset\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"       Size              EntSize          Flags  Link  Info  Align\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  [%2d] %-17.17s %-15.15s "
argument_list|,
name|i
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|get_section_type_name
argument_list|(
name|section
operator|->
name|sh_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6.6lx %6.6lx %2.2lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_size
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2ld %3lx %2ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %8.8lx"
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n       "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_size
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|section
operator|->
name|sh_entsize
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s "
argument_list|,
name|get_elf_section_flags
argument_list|(
name|section
operator|->
name|sh_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     %2ld   %3lx     %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_link
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_info
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Key to Flags:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  W (write), A (alloc), X (execute), M (merge), S (strings)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  I (info), L (link order), G (group), x (unknown)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  O (extra OS processing required) o (OS specific), p (processor specific)\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process the reloc section.  */
end_comment

begin_function
specifier|static
name|int
name|process_relocs
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|unsigned
name|long
name|rel_size
decl_stmt|;
name|unsigned
name|long
name|rel_offset
decl_stmt|;
if|if
condition|(
operator|!
name|do_reloc
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|do_using_dynamic
condition|)
block|{
name|int
name|is_rela
init|=
name|FALSE
decl_stmt|;
name|rel_size
operator|=
literal|0
expr_stmt|;
name|rel_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dynamic_info
index|[
name|DT_REL
index|]
condition|)
block|{
name|rel_offset
operator|=
name|dynamic_info
index|[
name|DT_REL
index|]
expr_stmt|;
name|rel_size
operator|=
name|dynamic_info
index|[
name|DT_RELSZ
index|]
expr_stmt|;
name|is_rela
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dynamic_info
index|[
name|DT_RELA
index|]
condition|)
block|{
name|rel_offset
operator|=
name|dynamic_info
index|[
name|DT_RELA
index|]
expr_stmt|;
name|rel_size
operator|=
name|dynamic_info
index|[
name|DT_RELASZ
index|]
expr_stmt|;
name|is_rela
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dynamic_info
index|[
name|DT_JMPREL
index|]
condition|)
block|{
name|rel_offset
operator|=
name|dynamic_info
index|[
name|DT_JMPREL
index|]
expr_stmt|;
name|rel_size
operator|=
name|dynamic_info
index|[
name|DT_PLTRELSZ
index|]
expr_stmt|;
switch|switch
condition|(
name|dynamic_info
index|[
name|DT_PLTREL
index|]
condition|)
block|{
case|case
name|DT_REL
case|:
name|is_rela
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|is_rela
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|is_rela
operator|=
name|UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rel_size
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nRelocation section at offset 0x%lx contains %ld bytes:\n"
argument_list|)
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|)
expr_stmt|;
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|rel_offset
operator|-
name|loadaddr
argument_list|,
name|rel_size
argument_list|,
name|dynamic_symbols
argument_list|,
name|num_dynamic_syms
argument_list|,
name|dynamic_strings
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no dynamic relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_REL
condition|)
continue|continue;
name|rel_offset
operator|=
name|section
operator|->
name|sh_offset
expr_stmt|;
name|rel_size
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|rel_size
condition|)
block|{
name|Elf32_Internal_Shdr
modifier|*
name|strsec
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|symsec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|int
name|is_rela
decl_stmt|;
name|unsigned
name|long
name|nsyms
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nRelocation section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|section
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"'%s'"
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
name|rel_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|rel_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
name|symsec
operator|=
name|section_headers
operator|+
name|section
operator|->
name|sh_link
expr_stmt|;
name|nsyms
operator|=
name|symsec
operator|->
name|sh_size
operator|/
name|symsec
operator|->
name|sh_entsize
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|symsec
operator|->
name|sh_offset
argument_list|,
name|nsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
name|strsec
operator|=
name|section_headers
operator|+
name|symsec
operator|->
name|sh_link
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|strsec
operator|->
name|sh_offset
argument_list|,
name|strsec
operator|->
name|sh_size
argument_list|,
name|strtab
argument_list|,
name|char
operator|*
argument_list|,
literal|"string table"
argument_list|)
expr_stmt|;
name|is_rela
operator|=
name|section
operator|->
name|sh_type
operator|==
name|SHT_RELA
expr_stmt|;
name|dump_relocations
argument_list|(
name|file
argument_list|,
name|rel_offset
argument_list|,
name|rel_size
argument_list|,
name|symtab
argument_list|,
name|nsyms
argument_list|,
name|strtab
argument_list|,
name|is_rela
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no relocations in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"unwind-ia64.h"
end_include

begin_comment
comment|/* An absolute address consists of a section and an offset.  If the    section is NULL, the offset itself is the address, otherwise, the    address equals to LOAD_ADDRESS(section) + offset.  */
end_comment

begin_struct
struct|struct
name|absaddr
block|{
name|unsigned
name|short
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|unw_aux_info
block|{
struct|struct
name|unw_table_entry
block|{
name|struct
name|absaddr
name|start
decl_stmt|;
name|struct
name|absaddr
name|end
decl_stmt|;
name|struct
name|absaddr
name|info
decl_stmt|;
block|}
modifier|*
name|table
struct|;
comment|/* Unwind table.  */
name|unsigned
name|long
name|table_len
decl_stmt|;
comment|/* Length of unwind table.  */
name|unsigned
name|char
modifier|*
name|info
decl_stmt|;
comment|/* Unwind info.  */
name|unsigned
name|long
name|info_size
decl_stmt|;
comment|/* Size of unwind info.  */
name|bfd_vma
name|info_addr
decl_stmt|;
comment|/* starting address of unwind info.  */
name|bfd_vma
name|seg_base
decl_stmt|;
comment|/* Starting address of segment.  */
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* The symbol table.  */
name|unsigned
name|long
name|nsyms
decl_stmt|;
comment|/* Number of symbols.  */
name|char
modifier|*
name|strtab
decl_stmt|;
comment|/* The string table.  */
name|unsigned
name|long
name|strtab_size
decl_stmt|;
comment|/* Size of string table.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|find_symbol_for_address
name|PARAMS
argument_list|(
operator|(
expr|struct
name|unw_aux_info
operator|*
operator|,
expr|struct
name|absaddr
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_ia64_unwind
name|PARAMS
argument_list|(
operator|(
expr|struct
name|unw_aux_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slurp_ia64_unwind_table
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|unw_aux_info
operator|*
operator|,
name|Elf32_Internal_Shdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_symbol_for_address
parameter_list|(
name|aux
parameter_list|,
name|addr
parameter_list|,
name|symname
parameter_list|,
name|offset
parameter_list|)
name|struct
name|unw_aux_info
modifier|*
name|aux
decl_stmt|;
name|struct
name|absaddr
name|addr
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|symname
decl_stmt|;
name|bfd_vma
modifier|*
name|offset
decl_stmt|;
block|{
name|bfd_vma
name|dist
init|=
operator|(
name|bfd_vma
operator|)
literal|0x100000
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|,
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sym
operator|=
name|aux
operator|->
name|symtab
init|;
name|i
operator|<
name|aux
operator|->
name|nsyms
condition|;
operator|++
name|i
operator|,
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
name|sym
operator|->
name|st_name
operator|!=
literal|0
operator|&&
operator|(
name|addr
operator|.
name|section
operator|==
name|SHN_UNDEF
operator|||
name|addr
operator|.
name|section
operator|==
name|sym
operator|->
name|st_shndx
operator|)
operator|&&
name|addr
operator|.
name|offset
operator|>=
name|sym
operator|->
name|st_value
operator|&&
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
operator|<
name|dist
condition|)
block|{
name|best
operator|=
name|sym
expr_stmt|;
name|dist
operator|=
name|addr
operator|.
name|offset
operator|-
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
operator|!
name|dist
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|best
condition|)
block|{
operator|*
name|symname
operator|=
operator|(
name|best
operator|->
name|st_name
operator|>=
name|aux
operator|->
name|strtab_size
condition|?
literal|"<corrupt>"
else|:
name|aux
operator|->
name|strtab
operator|+
name|best
operator|->
name|st_name
operator|)
expr_stmt|;
operator|*
name|offset
operator|=
name|dist
expr_stmt|;
return|return;
block|}
operator|*
name|symname
operator|=
name|NULL
expr_stmt|;
operator|*
name|offset
operator|=
name|addr
operator|.
name|offset
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_ia64_unwind
parameter_list|(
name|aux
parameter_list|)
name|struct
name|unw_aux_info
modifier|*
name|aux
decl_stmt|;
block|{
name|bfd_vma
name|addr_size
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|tp
decl_stmt|;
name|int
name|in_body
decl_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|aux
operator|->
name|table
init|;
name|tp
operator|<
name|aux
operator|->
name|table
operator|+
name|aux
operator|->
name|table_len
condition|;
operator|++
name|tp
control|)
block|{
name|bfd_vma
name|stamp
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|head
decl_stmt|;
specifier|const
name|char
modifier|*
name|procname
decl_stmt|;
name|find_symbol_for_address
argument_list|(
name|aux
argument_list|,
name|tp
operator|->
name|start
argument_list|,
operator|&
name|procname
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n<"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|procname
condition|)
block|{
name|fputs
argument_list|(
name|procname
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|printf
argument_list|(
literal|"+%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|">: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|start
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|tp
operator|->
name|end
operator|.
name|offset
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"), info at +0x%lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|tp
operator|->
name|info
operator|.
name|offset
operator|-
name|aux
operator|->
name|seg_base
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|aux
operator|->
name|info
operator|+
operator|(
name|tp
operator|->
name|info
operator|.
name|offset
operator|-
name|aux
operator|->
name|info_addr
operator|)
expr_stmt|;
name|stamp
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|head
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  v%u, flags=0x%lx (%s%s ), len=%lu bytes\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|stamp
operator|&
name|UNW_FLAG_MASK
operator|)
operator|>>
literal|32
argument_list|)
argument_list|,
name|UNW_FLAG_EHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" ehandler"
else|:
literal|""
argument_list|,
name|UNW_FLAG_UHANDLER
argument_list|(
name|stamp
argument_list|)
condition|?
literal|" uhandler"
else|:
literal|""
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNW_VER
argument_list|(
name|stamp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\tUnknown version.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|in_body
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|head
operator|+
literal|8
init|;
name|dp
operator|<
name|head
operator|+
literal|8
operator|+
name|addr_size
operator|*
name|UNW_LENGTH
argument_list|(
name|stamp
argument_list|)
condition|;
control|)
name|dp
operator|=
name|unw_decode
argument_list|(
name|dp
argument_list|,
name|in_body
argument_list|,
operator|&
name|in_body
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slurp_ia64_unwind_table
parameter_list|(
name|file
parameter_list|,
name|aux
parameter_list|,
name|sec
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|unw_aux_info
modifier|*
name|aux
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
block|{
name|unsigned
name|long
name|size
decl_stmt|,
name|addr_size
decl_stmt|,
name|nrelas
decl_stmt|,
name|i
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|prog_hdrs
decl_stmt|,
modifier|*
name|seg
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|tep
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|relsec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|table
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|relname
decl_stmt|;
name|int
name|result
decl_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
comment|/* First, find the starting address of the segment that includes      this section: */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
condition|)
block|{
name|prog_hdrs
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|xmalloc
argument_list|(
name|elf_header
operator|.
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|result
operator|=
name|get_32bit_program_headers
argument_list|(
name|file
argument_list|,
name|prog_hdrs
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|get_64bit_program_headers
argument_list|(
name|file
argument_list|,
name|prog_hdrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|free
argument_list|(
name|prog_hdrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|seg
operator|=
name|prog_hdrs
init|;
name|seg
operator|<
name|prog_hdrs
operator|+
name|elf_header
operator|.
name|e_phnum
condition|;
operator|++
name|seg
control|)
block|{
if|if
condition|(
name|seg
operator|->
name|p_type
operator|!=
name|PT_LOAD
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|sh_addr
operator|>=
name|seg
operator|->
name|p_vaddr
operator|&&
operator|(
name|sec
operator|->
name|sh_addr
operator|+
name|sec
operator|->
name|sh_size
operator|<=
name|seg
operator|->
name|p_vaddr
operator|+
name|seg
operator|->
name|p_memsz
operator|)
condition|)
block|{
name|aux
operator|->
name|seg_base
operator|=
name|seg
operator|->
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|prog_hdrs
argument_list|)
expr_stmt|;
block|}
comment|/* Second, build the unwind table from the contents of the unwind section:  */
name|size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|sec
operator|->
name|sh_offset
argument_list|,
name|size
argument_list|,
name|table
argument_list|,
name|char
operator|*
argument_list|,
literal|"unwind table"
argument_list|)
expr_stmt|;
name|tep
operator|=
name|aux
operator|->
name|table
operator|=
name|xmalloc
argument_list|(
name|size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|aux
operator|->
name|table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|table
init|;
name|tp
operator|<
name|table
operator|+
name|size
condition|;
name|tp
operator|+=
literal|3
operator|*
name|addr_size
operator|,
operator|++
name|tep
control|)
block|{
name|tep
operator|->
name|start
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|section
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|byte_get
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tep
operator|->
name|start
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|0
argument_list|)
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|=
name|BYTE_GET8
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tp
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
name|tep
operator|->
name|start
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|end
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
name|tep
operator|->
name|info
operator|.
name|offset
operator|+=
name|aux
operator|->
name|seg_base
expr_stmt|;
block|}
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* Third, apply any relocations to the unwind table: */
for|for
control|(
name|relsec
operator|=
name|section_headers
init|;
name|relsec
operator|<
name|section_headers
operator|+
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|relsec
control|)
block|{
if|if
condition|(
name|relsec
operator|->
name|sh_type
operator|!=
name|SHT_RELA
operator|||
name|section_headers
operator|+
name|relsec
operator|->
name|sh_info
operator|!=
name|sec
condition|)
continue|continue;
if|if
condition|(
operator|!
name|slurp_rela_relocs
argument_list|(
name|file
argument_list|,
name|relsec
operator|->
name|sh_offset
argument_list|,
name|relsec
operator|->
name|sh_size
argument_list|,
operator|&
name|rela
argument_list|,
operator|&
name|nrelas
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|rp
operator|=
name|rela
init|;
name|rp
operator|<
name|rela
operator|+
name|nrelas
condition|;
operator|++
name|rp
control|)
block|{
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF32_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u"
argument_list|)
argument_list|,
name|ELF32_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|relname
operator|=
name|elf_ia64_reloc_type
argument_list|(
name|ELF64_R_TYPE
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|aux
operator|->
name|symtab
operator|+
name|ELF64_R_SYM
argument_list|(
name|rp
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected symbol type %u"
argument_list|)
argument_list|,
name|ELF64_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|relname
argument_list|,
literal|"R_IA64_SEGREL"
argument_list|,
literal|13
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Skipping unexpected relocation type %s"
argument_list|)
argument_list|,
name|relname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|rp
operator|->
name|r_offset
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
expr_stmt|;
switch|switch
condition|(
name|rp
operator|->
name|r_offset
operator|/
name|addr_size
operator|%
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|start
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|end
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|section
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
name|aux
operator|->
name|table
index|[
name|i
index|]
operator|.
name|info
operator|.
name|offset
operator|+=
name|rp
operator|->
name|r_addend
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|free
argument_list|(
name|rela
argument_list|)
expr_stmt|;
block|}
name|aux
operator|->
name|table_len
operator|=
name|size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_unwind
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_Internal_Shdr
modifier|*
name|sec
decl_stmt|,
modifier|*
name|unwsec
init|=
name|NULL
decl_stmt|,
modifier|*
name|strsec
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|,
name|addr_size
decl_stmt|,
name|unwcount
init|=
literal|0
decl_stmt|,
name|unwstart
init|=
literal|0
decl_stmt|;
name|struct
name|unw_aux_info
name|aux
decl_stmt|;
if|if
condition|(
operator|!
name|do_unwind
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|!=
name|EM_IA_64
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|memset
argument_list|(
operator|&
name|aux
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aux
argument_list|)
argument_list|)
expr_stmt|;
name|addr_size
operator|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
condition|)
block|{
name|aux
operator|.
name|nsyms
operator|=
name|sec
operator|->
name|sh_size
operator|/
name|sec
operator|->
name|sh_entsize
expr_stmt|;
name|aux
operator|.
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|sec
operator|->
name|sh_offset
argument_list|,
name|aux
operator|.
name|nsyms
argument_list|)
expr_stmt|;
name|strsec
operator|=
name|section_headers
operator|+
name|sec
operator|->
name|sh_link
expr_stmt|;
name|aux
operator|.
name|strtab_size
operator|=
name|strsec
operator|->
name|sh_size
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|strsec
operator|->
name|sh_offset
argument_list|,
name|aux
operator|.
name|strtab_size
argument_list|,
name|aux
operator|.
name|strtab
argument_list|,
name|char
operator|*
argument_list|,
literal|"string table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
name|unwcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unwcount
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere are no unwind sections in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|unwcount
operator|--
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|len2
decl_stmt|;
for|for
control|(
name|i
operator|=
name|unwstart
operator|,
name|sec
operator|=
name|section_headers
operator|+
name|unwstart
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|sec
operator|->
name|sh_type
operator|==
name|SHT_IA_64_UNWIND
condition|)
block|{
name|unwsec
operator|=
name|sec
expr_stmt|;
break|break;
block|}
name|unwstart
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_once
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_once
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO */
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info_once
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info_once
argument_list|,
name|len2
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO 	     .IA_64.unwind or BAR -> .IA_64.unwind_info */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind
argument_list|)
operator|-
literal|1
expr_stmt|;
name|len2
operator|=
sizeof|sizeof
argument_list|(
name|ELF_STRING_ia64_unwind_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|suffix
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|suffix
operator|=
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
operator|+
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
operator|++
name|i
operator|,
operator|++
name|sec
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
name|ELF_STRING_ia64_unwind_info
argument_list|,
name|len2
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
operator|+
name|len2
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|elf_header
operator|.
name|e_shnum
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nCould not find unwind info section for "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"'%s'"
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|.
name|info_size
operator|=
name|sec
operator|->
name|sh_size
expr_stmt|;
name|aux
operator|.
name|info_addr
operator|=
name|sec
operator|->
name|sh_addr
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|sec
operator|->
name|sh_offset
argument_list|,
name|aux
operator|.
name|info_size
argument_list|,
name|aux
operator|.
name|info
argument_list|,
name|char
operator|*
argument_list|,
literal|"unwind info"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nUnwind section "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|unwsec
operator|->
name|sh_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"'%s'"
argument_list|,
name|SECTION_NAME
argument_list|(
name|unwsec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" at offset 0x%lx contains %lu entries:\n"
argument_list|)
argument_list|,
name|unwsec
operator|->
name|sh_offset
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|unwsec
operator|->
name|sh_size
operator|/
operator|(
literal|3
operator|*
name|addr_size
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|slurp_ia64_unwind_table
argument_list|(
name|file
argument_list|,
operator|&
name|aux
argument_list|,
name|unwsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table_len
operator|>
literal|0
condition|)
name|dump_ia64_unwind
argument_list|(
operator|&
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|table
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|info
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|info
argument_list|)
expr_stmt|;
name|aux
operator|.
name|table
operator|=
name|NULL
expr_stmt|;
name|aux
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aux
operator|.
name|symtab
condition|)
name|free
argument_list|(
name|aux
operator|.
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|strtab
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aux
operator|.
name|strtab
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_segment_mips_val
parameter_list|(
name|entry
parameter_list|)
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_FLAGS
case|:
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"NONE\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|opts
index|[]
init|=
block|{
literal|"QUICKSTART"
block|,
literal|"NOTPOT"
block|,
literal|"NO_LIBRARY_REPLACEMENT"
block|,
literal|"NO_MOVE"
block|,
literal|"SGI_ONLY"
block|,
literal|"GUARANTEE_INIT"
block|,
literal|"DELTA_C_PLUS_PLUS"
block|,
literal|"GUARANTEE_START_INIT"
block|,
literal|"PIXIE"
block|,
literal|"DEFAULT_DELAY_LOAD"
block|,
literal|"REQUICKSTART"
block|,
literal|"REQUICKSTARTED"
block|,
literal|"CORD"
block|,
literal|"NO_UNRES_UNDEF"
block|,
literal|"RLD_ORDER_SAFE"
block|}
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|NUM_ELEM
argument_list|(
name|opts
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|&
operator|(
literal|1
operator|<<
name|cnt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|opts
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Interface Version: %s\n"
argument_list|,
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
block|{
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|time_t
name|time
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Time Stamp: %s\n"
argument_list|,
name|timebuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
case|case
name|DT_MIPS_CONFLICTNO
case|:
case|case
name|DT_MIPS_LIBLISTNO
case|:
case|case
name|DT_MIPS_SYMTABNO
case|:
case|case
name|DT_MIPS_UNREFEXTNO
case|:
case|case
name|DT_MIPS_HIPAGENO
case|:
case|case
name|DT_MIPS_DELTA_CLASS_NO
case|:
case|case
name|DT_MIPS_DELTA_INSTANCE_NO
case|:
case|case
name|DT_MIPS_DELTA_RELOC_NO
case|:
case|case
name|DT_MIPS_DELTA_SYM_NO
case|:
case|case
name|DT_MIPS_DELTA_CLASSSYM_NO
case|:
case|case
name|DT_MIPS_COMPACT_SIZE
case|:
name|printf
argument_list|(
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_segment_parisc_val
parameter_list|(
name|entry
parameter_list|)
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HP_DLD_FLAGS
case|:
block|{
specifier|static
struct|struct
block|{
name|long
name|int
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|flags
index|[]
init|=
block|{
block|{
name|DT_HP_DEBUG_PRIVATE
block|,
literal|"HP_DEBUG_PRIVATE"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK
block|,
literal|"HP_DEBUG_CALLBACK"
block|}
block|,
block|{
name|DT_HP_DEBUG_CALLBACK_BOR
block|,
literal|"HP_DEBUG_CALLBACK_BOR"
block|}
block|,
block|{
name|DT_HP_NO_ENVVAR
block|,
literal|"HP_NO_ENVVAR"
block|}
block|,
block|{
name|DT_HP_BIND_NOW
block|,
literal|"HP_BIND_NOW"
block|}
block|,
block|{
name|DT_HP_BIND_NONFATAL
block|,
literal|"HP_BIND_NONFATAL"
block|}
block|,
block|{
name|DT_HP_BIND_VERBOSE
block|,
literal|"HP_BIND_VERBOSE"
block|}
block|,
block|{
name|DT_HP_BIND_RESTRICTED
block|,
literal|"HP_BIND_RESTRICTED"
block|}
block|,
block|{
name|DT_HP_BIND_SYMBOLIC
block|,
literal|"HP_BIND_SYMBOLIC"
block|}
block|,
block|{
name|DT_HP_RPATH_FIRST
block|,
literal|"HP_RPATH_FIRST"
block|}
block|,
block|{
name|DT_HP_BIND_DEPTH_FIRST
block|,
literal|"HP_BIND_DEPTH_FIRST"
block|}
block|}
struct|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|bfd_vma
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|flags
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|val
operator|&
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|flags
index|[
name|cnt
index|]
operator|.
name|str
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|val
operator|^=
name|flags
index|[
name|cnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
operator|||
name|first
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|val
argument_list|,
name|HEX
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_32bit_dynamic_segment
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_External_Dyn
modifier|*
name|edyn
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|dynamic_addr
argument_list|,
name|dynamic_size
argument_list|,
name|edyn
argument_list|,
name|Elf32_External_Dyn
operator|*
argument_list|,
literal|"dynamic segment"
argument_list|)
expr_stmt|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment.  Determine      how large this .dynamic is now.  We can do this even before the byte      swapping since the DT_NULL tag is recognizable.  */
name|dynamic_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|Elf32_Word
operator|*
operator|)
name|edyn
index|[
name|dynamic_size
operator|++
index|]
operator|.
name|d_tag
operator|!=
name|DT_NULL
condition|)
empty_stmt|;
name|dynamic_segment
operator|=
operator|(
name|Elf_Internal_Dyn
operator|*
operator|)
name|malloc
argument_list|(
name|dynamic_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Dyn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_64bit_dynamic_segment
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf64_External_Dyn
modifier|*
name|edyn
decl_stmt|;
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|dynamic_addr
argument_list|,
name|dynamic_size
argument_list|,
name|edyn
argument_list|,
name|Elf64_External_Dyn
operator|*
argument_list|,
literal|"dynamic segment"
argument_list|)
expr_stmt|;
comment|/* SGI's ELF has more than one section in the DYNAMIC segment.  Determine      how large this .dynamic is now.  We can do this even before the byte      swapping since the DT_NULL tag is recognizable.  */
name|dynamic_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|bfd_vma
operator|*
operator|)
name|edyn
index|[
name|dynamic_size
operator|++
index|]
operator|.
name|d_tag
operator|!=
name|DT_NULL
condition|)
empty_stmt|;
name|dynamic_segment
operator|=
operator|(
name|Elf_Internal_Dyn
operator|*
operator|)
name|malloc
argument_list|(
name|dynamic_size
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Dyn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|d_tag
operator|=
name|BYTE_GET8
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|BYTE_GET8
argument_list|(
name|edyn
index|[
name|i
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|edyn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dynamic_flags
parameter_list|(
name|flags
parameter_list|)
name|bfd_vma
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
while|while
condition|(
name|flags
condition|)
block|{
name|bfd_vma
name|flag
decl_stmt|;
name|flag
operator|=
name|flags
operator|&
operator|-
name|flags
expr_stmt|;
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|DF_ORIGIN
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"ORIGIN "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_SYMBOLIC
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"SYMBOLIC "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_TEXTREL
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"TEXTREL "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DF_BIND_NOW
case|:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"BIND_NOW "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"unknown "
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Parse and display the contents of the dynamic segment.  */
end_comment

begin_function
specifier|static
name|int
name|process_dynamic_segment
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|bfd_size_type
name|i
decl_stmt|;
if|if
condition|(
name|dynamic_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nThere is no dynamic segment in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
if|if
condition|(
operator|!
name|get_32bit_dynamic_segment
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|get_64bit_dynamic_segment
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the appropriate symbol table.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_SYMTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_SYMTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the symbol table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work. */
name|offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file!"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|num_dynamic_syms
operator|=
operator|(
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|offset
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
else|else
name|num_dynamic_syms
operator|=
operator|(
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|offset
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_dynamic_syms
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the number of symbols to load\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dynamic_symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|num_dynamic_syms
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Similarly find a string table.  */
if|if
condition|(
name|dynamic_strings
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
name|long
name|str_tab_len
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|!=
name|DT_STRTAB
condition|)
continue|continue;
name|dynamic_info
index|[
name|DT_STRTAB
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
comment|/* Since we do not know how big the string table is, 	     we default to reading in the entire file (!) and 	     processing that.  This is overkill, I know, but it 	     should work. */
name|offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to end of file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|str_tab_len
operator|=
name|ftell
argument_list|(
name|file
argument_list|)
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|str_tab_len
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to determine the length of the dynamic string table\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|GET_DATA_ALLOC
argument_list|(
name|offset
argument_list|,
name|str_tab_len
argument_list|,
name|dynamic_strings
argument_list|,
name|char
operator|*
argument_list|,
literal|"dynamic string table"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* And find the syminfo section if available.  */
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|syminsz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
operator|++
name|i
operator|,
operator|++
name|entry
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINENT
condition|)
block|{
comment|/* Note: these braces are necessary to avoid a syntax 		 error from the SunOS4 C compiler.  */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
operator|==
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINSZ
condition|)
name|syminsz
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|d_tag
operator|==
name|DT_SYMINFO
condition|)
name|dynamic_syminfo_offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo_offset
operator|!=
literal|0
operator|&&
name|syminsz
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Syminfo
modifier|*
name|extsyminfo
decl_stmt|;
name|Elf_Internal_Syminfo
modifier|*
name|syminfo
decl_stmt|;
comment|/* There is a syminfo section.  Read the data.  */
name|GET_DATA_ALLOC
argument_list|(
name|dynamic_syminfo_offset
argument_list|,
name|syminsz
argument_list|,
name|extsyminfo
argument_list|,
name|Elf_External_Syminfo
operator|*
argument_list|,
literal|"symbol information"
argument_list|)
expr_stmt|;
name|dynamic_syminfo
operator|=
operator|(
name|Elf_Internal_Syminfo
operator|*
operator|)
name|malloc
argument_list|(
name|syminsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dynamic_syminfo_nent
operator|=
name|syminsz
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Syminfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|syminfo
operator|=
name|dynamic_syminfo
init|;
name|i
operator|<
name|dynamic_syminfo_nent
condition|;
operator|++
name|i
operator|,
operator|++
name|syminfo
control|)
block|{
name|syminfo
operator|->
name|si_boundto
operator|=
name|BYTE_GET
argument_list|(
name|extsyminfo
index|[
name|i
index|]
operator|.
name|si_boundto
argument_list|)
expr_stmt|;
name|syminfo
operator|->
name|si_flags
operator|=
name|BYTE_GET
argument_list|(
name|extsyminfo
index|[
name|i
index|]
operator|.
name|si_flags
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|extsyminfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_dynamic
operator|&&
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic segment at offset 0x%x contains %ld entries:\n"
argument_list|)
argument_list|,
name|dynamic_addr
argument_list|,
operator|(
name|long
operator|)
name|dynamic_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Tag        Type                         Name/Value\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|dynamic_segment
init|;
name|i
operator|<
name|dynamic_size
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|do_dynamic
condition|)
block|{
specifier|const
name|char
modifier|*
name|dtype
decl_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s)%*s"
argument_list|,
name|dtype
argument_list|,
operator|(
operator|(
name|is_32bit_elf
condition|?
literal|27
else|:
literal|19
operator|)
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dtype
argument_list|)
operator|)
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_FLAGS
case|:
if|if
condition|(
name|do_dynamic
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|get_dynamic_flags
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUXILIARY
case|:
case|case
name|DT_FILTER
case|:
case|case
name|DT_CONFIG
case|:
case|case
name|DT_DEPAUDIT
case|:
case|case
name|DT_AUDIT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_AUXILIARY
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Auxiliary library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_FILTER
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Filter library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_CONFIG
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Configuration file"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_DEPAUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Dependency audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_AUDIT
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Audit library"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
literal|": [%s]\n"
argument_list|,
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FEATURE
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DTF_1_PARINIT
condition|)
block|{
name|printf
argument_list|(
literal|" PARINIT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_PARINIT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DTF_1_CONFEXP
condition|)
block|{
name|printf
argument_list|(
literal|" CONFEXP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DTF_1_CONFEXP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_POSFLAG_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_P1_LAZYLOAD
condition|)
block|{
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_LAZYLOAD
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_P1_GROUPPERM
condition|)
block|{
name|printf
argument_list|(
literal|" GROUPPERM"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_P1_GROUPPERM
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_FLAGS_1
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Flags:"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" None\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|long
name|int
name|val
init|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
name|DF_1_NOW
condition|)
block|{
name|printf
argument_list|(
literal|" NOW"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOW
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GLOBAL
condition|)
block|{
name|printf
argument_list|(
literal|" GLOBAL"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GLOBAL
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_GROUP
condition|)
block|{
name|printf
argument_list|(
literal|" GROUP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_GROUP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODELETE
condition|)
block|{
name|printf
argument_list|(
literal|" NODELETE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODELETE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_LOADFLTR
condition|)
block|{
name|printf
argument_list|(
literal|" LOADFLTR"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_LOADFLTR
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INITFIRST
condition|)
block|{
name|printf
argument_list|(
literal|" INITFIRST"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INITFIRST
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NOOPEN
condition|)
block|{
name|printf
argument_list|(
literal|" NOOPEN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NOOPEN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_ORIGIN
condition|)
block|{
name|printf
argument_list|(
literal|" ORIGIN"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_ORIGIN
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_DIRECT
condition|)
block|{
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_DIRECT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_TRANS
condition|)
block|{
name|printf
argument_list|(
literal|" TRANS"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_TRANS
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_INTERPOSE
condition|)
block|{
name|printf
argument_list|(
literal|" INTERPOSE"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_INTERPOSE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODEFLIB
condition|)
block|{
name|printf
argument_list|(
literal|" NODEFLIB"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODEFLIB
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_NODUMP
condition|)
block|{
name|printf
argument_list|(
literal|" NODUMP"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_NODUMP
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|DF_1_CONLFAT
condition|)
block|{
name|printf
argument_list|(
literal|" CONLFAT"
argument_list|)
expr_stmt|;
name|val
operator|^=
name|DF_1_CONLFAT
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_PLTREL
case|:
if|if
condition|(
name|do_dynamic
condition|)
name|puts
argument_list|(
name|get_dynamic_type
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NULL
case|:
case|case
name|DT_NEEDED
case|:
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_DEBUG
case|:
case|case
name|DT_TEXTREL
case|:
case|case
name|DT_JMPREL
case|:
case|case
name|DT_RUNPATH
case|:
name|dynamic_info
index|[
name|entry
operator|->
name|d_tag
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|dynamic_strings
operator|==
name|NULL
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|name
operator|=
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_NEEDED
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Shared library: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|program_interpreter
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|" program interpreter"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library soname: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library rpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RUNPATH
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"Library runpath: [%s]"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELENT
case|:
case|case
name|DT_PLTPADSZ
case|:
case|case
name|DT_MOVEENT
case|:
case|case
name|DT_MOVESZ
case|:
case|case
name|DT_INIT_ARRAYSZ
case|:
case|case
name|DT_FINI_ARRAYSZ
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (bytes)\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_VERDEFNUM
case|:
case|case
name|DT_VERNEEDNUM
case|:
case|case
name|DT_RELACOUNT
case|:
case|case
name|DT_RELCOUNT
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|UNSIGNED
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_SYMINSZ
case|:
case|case
name|DT_SYMINENT
case|:
case|case
name|DT_SYMINFO
case|:
case|case
name|DT_USED
case|:
case|case
name|DT_INIT_ARRAY
case|:
case|case
name|DT_FINI_ARRAY
case|:
if|if
condition|(
name|do_dynamic
condition|)
block|{
if|if
condition|(
name|dynamic_strings
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|d_tag
operator|==
name|DT_USED
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|dynamic_strings
operator|+
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Not needed object: [%s]\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DT_BIND_NOW
case|:
comment|/* The value of this entry is ignored.  */
break|break;
default|default:
if|if
condition|(
operator|(
name|entry
operator|->
name|d_tag
operator|>=
name|DT_VERSYM
operator|)
operator|&&
operator|(
name|entry
operator|->
name|d_tag
operator|<=
name|DT_VERNEEDNUM
operator|)
condition|)
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|entry
operator|->
name|d_tag
argument_list|)
index|]
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
if|if
condition|(
name|do_dynamic
condition|)
block|{
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
name|dynamic_segment_mips_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|EM_PARISC
case|:
name|dynamic_segment_parisc_val
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_vma
argument_list|(
name|entry
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|PREFIX_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_ver_flags
parameter_list|(
name|flags
parameter_list|)
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
return|return
name|_
argument_list|(
literal|"none"
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"BASE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VER_FLG_WEAK
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|VER_FLG_BASE
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"| "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"WEAK "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|~
operator|(
name|VER_FLG_BASE
operator||
name|VER_FLG_WEAK
operator|)
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|"|<unknown>"
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* Display the contents of the version sections.  */
end_comment

begin_function
specifier|static
name|int
name|process_version_sections
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|do_version
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_GNU_verdef
case|:
block|{
name|Elf_External_Verdef
modifier|*
name|edefs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion definition section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|edefs
argument_list|,
name|Elf_External_Verdef
operator|*
argument_list|,
literal|"version definition section"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|char
modifier|*
name|vstart
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|edef
decl_stmt|;
name|Elf_Internal_Verdef
name|ent
decl_stmt|;
name|Elf_External_Verdaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Verdaux
name|aux
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|edefs
operator|)
operator|+
name|idx
expr_stmt|;
name|edef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vd_version
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_flags
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_cnt
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_hash
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|edef
operator|->
name|vd_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Rev: %d  Flags: %s"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vd_version
argument_list|,
name|get_ver_flags
argument_list|(
name|ent
operator|.
name|vd_flags
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Index: %d  Cnt: %d  "
argument_list|)
argument_list|,
name|ent
operator|.
name|vd_ndx
argument_list|,
name|ent
operator|.
name|vd_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vd_aux
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name: %s\n"
argument_list|)
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"Name index: %ld\n"
argument_list|)
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vd_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|ent
operator|.
name|vd_cnt
condition|;
name|j
operator|++
control|)
block|{
name|isum
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vda_next
expr_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vda_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vda_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d: %s\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Parent %d, name index: %ld\n"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|j
argument_list|,
name|aux
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vd_next
expr_stmt|;
block|}
name|free
argument_list|(
name|edefs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_verneed
case|:
block|{
name|Elf_External_Verneed
modifier|*
name|eneed
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|cnt
decl_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion needs section '%s' contains %ld entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|section
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link to section: %ld (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|section_headers
operator|+
name|section
operator|->
name|sh_link
argument_list|)
argument_list|)
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
argument_list|,
name|eneed
argument_list|,
name|Elf_External_Verneed
operator|*
argument_list|,
literal|"version need section"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|section
operator|->
name|sh_info
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_External_Verneed
modifier|*
name|entry
decl_stmt|;
name|Elf_Internal_Verneed
name|ent
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|isum
decl_stmt|;
name|char
modifier|*
name|vstart
decl_stmt|;
name|vstart
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|eneed
operator|)
operator|+
name|idx
expr_stmt|;
name|entry
operator|=
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|vstart
expr_stmt|;
name|ent
operator|.
name|vn_version
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_cnt
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_file
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|ent
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|entry
operator|->
name|vn_next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Version: %d"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ent
operator|.
name|vn_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %s"
argument_list|)
argument_list|,
name|dynamic_strings
operator|+
name|ent
operator|.
name|vn_file
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  File: %lx"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Cnt: %d\n"
argument_list|)
argument_list|,
name|ent
operator|.
name|vn_cnt
argument_list|)
expr_stmt|;
name|vstart
operator|+=
name|ent
operator|.
name|vn_aux
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|isum
operator|=
name|idx
operator|+
name|ent
operator|.
name|vn_aux
init|;
name|j
operator|<
name|ent
operator|.
name|vn_cnt
condition|;
operator|++
name|j
control|)
block|{
name|Elf_External_Vernaux
modifier|*
name|eaux
decl_stmt|;
name|Elf_Internal_Vernaux
name|aux
decl_stmt|;
name|eaux
operator|=
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
name|vstart
expr_stmt|;
name|aux
operator|.
name|vna_hash
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_flags
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|aux
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|eaux
operator|->
name|vna_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_strings
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Name: %s"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|dynamic_strings
operator|+
name|aux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %#06x: Name index: %lx"
argument_list|)
argument_list|,
name|isum
argument_list|,
name|aux
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags: %s  Version: %d\n"
argument_list|)
argument_list|,
name|get_ver_flags
argument_list|(
name|aux
operator|.
name|vna_flags
argument_list|)
argument_list|,
name|aux
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|isum
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
name|vstart
operator|+=
name|aux
operator|.
name|vna_next
expr_stmt|;
block|}
name|idx
operator|+=
name|ent
operator|.
name|vn_next
expr_stmt|;
block|}
name|free
argument_list|(
name|eneed
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHT_GNU_versym
case|:
block|{
name|Elf32_Internal_Shdr
modifier|*
name|link_section
decl_stmt|;
name|int
name|total
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|unsigned
name|char
modifier|*
name|edata
decl_stmt|;
name|unsigned
name|short
modifier|*
name|data
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symbols
decl_stmt|;
name|Elf32_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|link_section
operator|=
name|section_headers
operator|+
name|section
operator|->
name|sh_link
expr_stmt|;
name|total
operator|=
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
name|symbols
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|link_section
operator|->
name|sh_offset
argument_list|,
name|link_section
operator|->
name|sh_size
operator|/
name|link_section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|string_sec
operator|=
name|section_headers
operator|+
name|link_section
operator|->
name|sh_link
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|string_sec
operator|->
name|sh_offset
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|strtab
argument_list|,
name|char
operator|*
argument_list|,
literal|"version string table"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nVersion symbols section '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Addr: "
argument_list|)
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|section
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset: %#08lx  Link: %lx (%s)\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_link
argument_list|,
name|SECTION_NAME
argument_list|(
name|link_section
argument_list|)
argument_list|)
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
argument|version_info [DT_VERSIONTAGIDX (DT_VERSYM)] 			    - loadaddr
argument_list|,
argument|total * sizeof (short)
argument_list|,
argument|edata
argument_list|,
argument|unsigned char *
argument_list|,
literal|"version symbol data"
argument_list|)
empty_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|malloc
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|total
init|;
name|cnt
operator|--
condition|;
control|)
name|data
index|[
name|cnt
index|]
operator|=
name|byte_get
argument_list|(
name|edata
operator|+
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edata
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|total
condition|;
name|cnt
operator|+=
literal|4
control|)
block|{
name|int
name|j
decl_stmt|,
name|nn
decl_stmt|;
name|int
name|check_def
decl_stmt|,
name|check_need
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|printf
argument_list|(
literal|"  %03x:"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
literal|4
operator|)
operator|&&
operator|(
name|cnt
operator|+
name|j
operator|)
operator|<
name|total
condition|;
operator|++
name|j
control|)
switch|switch
condition|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
case|case
literal|0
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   0 (*local*)    "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs
argument_list|(
name|_
argument_list|(
literal|"   1 (*global*)   "
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nn
operator|=
name|printf
argument_list|(
literal|"%4x%c"
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
argument_list|,
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x8000
condition|?
literal|'h'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|1
expr_stmt|;
name|check_need
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|||
name|section_headers
index|[
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
index|]
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
block|{
if|if
condition|(
name|symbols
index|[
name|cnt
operator|+
name|j
index|]
operator|.
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|check_def
operator|=
literal|0
expr_stmt|;
else|else
name|check_need
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|check_need
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
operator|-
name|loadaddr
expr_stmt|;
do|do
block|{
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|unsigned
name|long
name|a_off
decl_stmt|;
name|GET_DATA
argument_list|(
name|offset
argument_list|,
name|evn
argument_list|,
literal|"version need"
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|a_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|GET_DATA
argument_list|(
name|a_off
argument_list|,
name|evna
argument_list|,
literal|"version need aux (2)"
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|a_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|data
index|[
name|cnt
operator|+
name|j
index|]
condition|)
block|{
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
condition|)
do|;
block|}
if|if
condition|(
name|check_def
operator|&&
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
operator|-
name|loadaddr
expr_stmt|;
do|do
block|{
name|GET_DATA
argument_list|(
name|offset
argument_list|,
name|evd
argument_list|,
literal|"version def"
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivd
operator|.
name|vd_ndx
operator|==
operator|(
name|data
index|[
name|cnt
operator|+
name|j
index|]
operator|&
literal|0x7fff
operator|)
condition|)
block|{
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|GET_DATA
argument_list|(
name|offset
operator|-
name|ivd
operator|.
name|vd_next
operator|+
name|ivd
operator|.
name|vd_aux
argument_list|,
name|evda
argument_list|,
literal|"version def aux"
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
expr_stmt|;
name|nn
operator|+=
name|printf
argument_list|(
literal|"(%s%-*s"
argument_list|,
name|name
argument_list|,
literal|12
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nn
operator|<
literal|18
condition|)
name|printf
argument_list|(
literal|"%*c"
argument_list|,
literal|18
operator|-
name|nn
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|symbols
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNo version information found in this file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_binding
parameter_list|(
name|binding
parameter_list|)
name|unsigned
name|int
name|binding
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|binding
condition|)
block|{
case|case
name|STB_LOCAL
case|:
return|return
literal|"LOCAL"
return|;
case|case
name|STB_GLOBAL
case|:
return|return
literal|"GLOBAL"
return|;
case|case
name|STB_WEAK
case|:
return|return
literal|"WEAK"
return|;
default|default:
if|if
condition|(
name|binding
operator|>=
name|STB_LOPROC
operator|&&
name|binding
operator|<=
name|STB_HIPROC
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
operator|>=
name|STB_LOOS
operator|&&
name|binding
operator|<=
name|STB_HIOS
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|binding
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|int
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"COMMON"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|STT_LOPROC
operator|&&
name|type
operator|<=
name|STT_HIPROC
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_ARM
operator|&&
name|type
operator|==
name|STT_ARM_TFUNC
condition|)
return|return
literal|"THUMB_FUNC"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_SPARCV9
operator|&&
name|type
operator|==
name|STT_REGISTER
condition|)
return|return
literal|"REGISTER"
return|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
operator|&&
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
return|return
literal|"PARISC_MILLI"
return|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|>=
name|STT_LOOS
operator|&&
name|type
operator|<=
name|STT_HIOS
condition|)
block|{
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_PARISC
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|STT_HP_OPAQUE
condition|)
return|return
literal|"HP_OPAQUE"
return|;
if|if
condition|(
name|type
operator|==
name|STT_HP_STUB
condition|)
return|return
literal|"HP_STUB"
return|;
block|}
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_visibility
parameter_list|(
name|visibility
parameter_list|)
name|unsigned
name|int
name|visibility
decl_stmt|;
block|{
switch|switch
condition|(
name|visibility
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
return|return
literal|"DEFAULT"
return|;
case|case
name|STV_INTERNAL
case|:
return|return
literal|"INTERNAL"
return|;
case|case
name|STV_HIDDEN
case|:
return|return
literal|"HIDDEN"
return|;
case|case
name|STV_PROTECTED
case|:
return|return
literal|"PROTECTED"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_index_type
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|int
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHN_UNDEF
case|:
return|return
literal|"UND"
return|;
case|case
name|SHN_ABS
case|:
return|return
literal|"ABS"
return|;
case|case
name|SHN_COMMON
case|:
return|return
literal|"COM"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|SHN_LOPROC
operator|&&
name|type
operator|<=
name|SHN_HIPROC
condition|)
return|return
literal|"PRC"
return|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LORESERVE
operator|&&
name|type
operator|<=
name|SHN_HIRESERVE
condition|)
return|return
literal|"RSV"
return|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|SHN_LOOS
operator|&&
name|type
operator|<=
name|SHN_HIOS
condition|)
return|return
literal|"OS "
return|;
else|else
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%3d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
name|get_dynamic_data
parameter_list|(
name|file
parameter_list|,
name|number
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|number
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|e_data
decl_stmt|;
name|int
modifier|*
name|i_data
decl_stmt|;
name|e_data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|number
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|e_data
argument_list|,
literal|4
argument_list|,
name|number
argument_list|,
name|file
argument_list|)
operator|!=
name|number
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to read in dynamic data\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i_data
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|number
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|i_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_data
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|number
operator|--
condition|)
name|i_data
index|[
name|number
index|]
operator|=
name|byte_get
argument_list|(
name|e_data
operator|+
name|number
operator|*
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_data
argument_list|)
expr_stmt|;
return|return
name|i_data
return|;
block|}
end_function

begin_comment
comment|/* Dump the symbol table */
end_comment

begin_function
specifier|static
name|int
name|process_symbol_table
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
name|nb
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|nc
index|[
literal|4
index|]
decl_stmt|;
name|int
name|nbuckets
init|=
literal|0
decl_stmt|;
name|int
name|nchains
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|buckets
init|=
name|NULL
decl_stmt|;
name|int
modifier|*
name|chains
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|do_syms
operator|&&
operator|!
name|do_histogram
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
operator|(
operator|(
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
operator|)
operator|||
name|do_histogram
operator|)
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|file
argument_list|,
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|-
name|loadaddr
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Unable to seek to start of dynamic information"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nb
argument_list|,
sizeof|sizeof
argument_list|(
name|nb
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of buckets\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|nc
argument_list|,
sizeof|sizeof
argument_list|(
name|nc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Failed to read in number of chains\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nbuckets
operator|=
name|byte_get
argument_list|(
name|nb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nchains
operator|=
name|byte_get
argument_list|(
name|nc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buckets
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nbuckets
argument_list|)
expr_stmt|;
name|chains
operator|=
name|get_dynamic_data
argument_list|(
name|file
argument_list|,
name|nchains
argument_list|)
expr_stmt|;
if|if
condition|(
name|buckets
operator|==
name|NULL
operator|||
name|chains
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|do_syms
operator|&&
name|dynamic_info
index|[
name|DT_HASH
index|]
operator|&&
name|do_using_dynamic
operator|&&
name|dynamic_strings
operator|!=
name|NULL
condition|)
block|{
name|int
name|hn
decl_stmt|;
name|int
name|si
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table for image:\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
name|hn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|buckets
index|[
name|hn
index|]
condition|)
continue|continue;
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|<
name|nchains
operator|&&
name|si
operator|>
literal|0
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
name|psym
operator|=
name|dynamic_symbols
operator|+
name|si
expr_stmt|;
name|printf
argument_list|(
literal|"  %3d %3d: "
argument_list|,
name|si
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %6s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3.3s"
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|dynamic_strings
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
operator|&&
operator|!
name|do_using_dynamic
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|unsigned
name|int
name|si
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|symtab
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|psym
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|section
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
continue|continue;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSymbol table '%s' contains %lu entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_32bit_elf
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|GET_ELF_SYMBOLS
argument_list|(
name|file
argument_list|,
name|section
operator|->
name|sh_offset
argument_list|,
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|section
operator|->
name|sh_link
operator|==
name|elf_header
operator|.
name|e_shstrndx
condition|)
name|strtab
operator|=
name|string_table
expr_stmt|;
else|else
block|{
name|Elf32_Internal_Shdr
modifier|*
name|string_sec
decl_stmt|;
name|string_sec
operator|=
name|section_headers
operator|+
name|section
operator|->
name|sh_link
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|string_sec
operator|->
name|sh_offset
argument_list|,
name|string_sec
operator|->
name|sh_size
argument_list|,
name|strtab
argument_list|,
name|char
operator|*
argument_list|,
literal|"string table"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|si
operator|=
literal|0
operator|,
name|psym
operator|=
name|symtab
init|;
name|si
operator|<
name|section
operator|->
name|sh_size
operator|/
name|section
operator|->
name|sh_entsize
condition|;
name|si
operator|++
operator|,
name|psym
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%6d: "
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|LONG_HEX
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_size
argument_list|,
name|DEC_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-7s"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6s"
argument_list|,
name|get_symbol_binding
argument_list|(
name|ELF_ST_BIND
argument_list|(
name|psym
operator|->
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-3s"
argument_list|,
name|get_symbol_visibility
argument_list|(
name|ELF_ST_VISIBILITY
argument_list|(
name|psym
operator|->
name|st_other
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s"
argument_list|,
name|get_symbol_index_type
argument_list|(
name|psym
operator|->
name|st_shndx
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|strtab
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|data
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|short
name|vers_data
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
name|is_nobits
decl_stmt|;
name|int
name|check_def
decl_stmt|;
name|offset
operator|=
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERSYM
argument_list|)
index|]
operator|-
name|loadaddr
expr_stmt|;
name|GET_DATA
argument_list|(
name|offset
operator|+
name|si
operator|*
sizeof|sizeof
argument_list|(
name|vers_data
argument_list|)
argument_list|,
name|data
argument_list|,
literal|"version data"
argument_list|)
expr_stmt|;
name|vers_data
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|is_nobits
operator|=
name|psym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|?
operator|(
name|section_headers
index|[
name|psym
operator|->
name|st_shndx
index|]
operator|.
name|sh_type
operator|==
name|SHT_NOBITS
operator|)
else|:
literal|0
expr_stmt|;
name|check_def
operator|=
operator|(
name|psym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
operator|||
name|vers_data
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
operator|&&
operator|(
name|is_nobits
operator|||
operator|!
name|check_def
operator|)
condition|)
block|{
name|Elf_External_Verneed
name|evn
decl_stmt|;
name|Elf_Internal_Verneed
name|ivn
decl_stmt|;
name|Elf_Internal_Vernaux
name|ivna
decl_stmt|;
comment|/* We must test both.  */
name|offset
operator|=
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERNEED
argument_list|)
index|]
operator|-
name|loadaddr
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|vna_off
decl_stmt|;
name|GET_DATA
argument_list|(
name|offset
argument_list|,
name|evn
argument_list|,
literal|"version need"
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_aux
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_aux
argument_list|)
expr_stmt|;
name|ivn
operator|.
name|vn_next
operator|=
name|BYTE_GET
argument_list|(
name|evn
operator|.
name|vn_next
argument_list|)
expr_stmt|;
name|vna_off
operator|=
name|offset
operator|+
name|ivn
operator|.
name|vn_aux
expr_stmt|;
do|do
block|{
name|Elf_External_Vernaux
name|evna
decl_stmt|;
name|GET_DATA
argument_list|(
name|vna_off
argument_list|,
name|evna
argument_list|,
literal|"version need aux (3)"
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_other
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_next
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_next
argument_list|)
expr_stmt|;
name|ivna
operator|.
name|vna_name
operator|=
name|BYTE_GET
argument_list|(
name|evna
operator|.
name|vna_name
argument_list|)
expr_stmt|;
name|vna_off
operator|+=
name|ivna
operator|.
name|vna_next
expr_stmt|;
block|}
do|while
condition|(
name|ivna
operator|.
name|vna_other
operator|!=
name|vers_data
operator|&&
name|ivna
operator|.
name|vna_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
break|break;
name|offset
operator|+=
name|ivn
operator|.
name|vn_next
expr_stmt|;
block|}
do|while
condition|(
name|ivn
operator|.
name|vn_next
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|ivna
operator|.
name|vna_other
operator|==
name|vers_data
condition|)
block|{
name|printf
argument_list|(
literal|"@%s (%d)"
argument_list|,
name|strtab
operator|+
name|ivna
operator|.
name|vna_name
argument_list|,
name|ivna
operator|.
name|vna_other
argument_list|)
expr_stmt|;
name|check_def
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_nobits
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"bad dynamic symbol"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|check_def
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|check_def
condition|)
block|{
if|if
condition|(
name|vers_data
operator|!=
literal|0x8001
operator|&&
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
condition|)
block|{
name|Elf_Internal_Verdef
name|ivd
decl_stmt|;
name|Elf_Internal_Verdaux
name|ivda
decl_stmt|;
name|Elf_External_Verdaux
name|evda
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|version_info
index|[
name|DT_VERSIONTAGIDX
argument_list|(
name|DT_VERDEF
argument_list|)
index|]
operator|-
name|loadaddr
expr_stmt|;
do|do
block|{
name|Elf_External_Verdef
name|evd
decl_stmt|;
name|GET_DATA
argument_list|(
name|offset
argument_list|,
name|evd
argument_list|,
literal|"version def"
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_ndx
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_ndx
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_aux
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_aux
argument_list|)
expr_stmt|;
name|ivd
operator|.
name|vd_next
operator|=
name|BYTE_GET
argument_list|(
name|evd
operator|.
name|vd_next
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_next
expr_stmt|;
block|}
do|while
condition|(
name|ivd
operator|.
name|vd_ndx
operator|!=
operator|(
name|vers_data
operator|&
literal|0x7fff
operator|)
operator|&&
name|ivd
operator|.
name|vd_next
operator|!=
literal|0
condition|)
do|;
name|offset
operator|-=
name|ivd
operator|.
name|vd_next
expr_stmt|;
name|offset
operator|+=
name|ivd
operator|.
name|vd_aux
expr_stmt|;
name|GET_DATA
argument_list|(
name|offset
argument_list|,
name|evda
argument_list|,
literal|"version def aux"
argument_list|)
expr_stmt|;
name|ivda
operator|.
name|vda_name
operator|=
name|BYTE_GET
argument_list|(
name|evda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|psym
operator|->
name|st_name
operator|!=
name|ivda
operator|.
name|vda_name
condition|)
name|printf
argument_list|(
operator|(
name|vers_data
operator|&
literal|0x8000
operator|)
condition|?
literal|"@%s"
else|:
literal|"@@%s"
argument_list|,
name|strtab
operator|+
name|ivda
operator|.
name|vda_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|!=
name|string_table
condition|)
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_syms
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic symbol information is not available for displaying symbols.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_histogram
operator|&&
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|int
modifier|*
name|lengths
decl_stmt|;
name|int
modifier|*
name|counts
decl_stmt|;
name|int
name|hn
decl_stmt|;
name|int
name|si
decl_stmt|;
name|int
name|maxlength
init|=
literal|0
decl_stmt|;
name|int
name|nzero_counts
init|=
literal|0
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHistogram for bucket list length (total of %d buckets):\n"
argument_list|)
argument_list|,
name|nbuckets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Length  Number     %% of total  Coverage\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lengths
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
name|nbuckets
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengths
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
block|{
if|if
condition|(
operator|!
name|buckets
index|[
name|hn
index|]
condition|)
continue|continue;
for|for
control|(
name|si
operator|=
name|buckets
index|[
name|hn
index|]
init|;
name|si
operator|>
literal|0
operator|&&
name|si
operator|<
name|nchains
condition|;
name|si
operator|=
name|chains
index|[
name|si
index|]
control|)
block|{
operator|++
name|nsyms
expr_stmt|;
if|if
condition|(
name|maxlength
operator|<
operator|++
name|lengths
index|[
name|hn
index|]
condition|)
operator|++
name|maxlength
expr_stmt|;
block|}
block|}
name|counts
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
name|maxlength
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|counts
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|hn
operator|=
literal|0
init|;
name|hn
operator|<
name|nbuckets
condition|;
operator|++
name|hn
control|)
operator|++
name|counts
index|[
name|lengths
index|[
name|hn
index|]
index|]
expr_stmt|;
if|if
condition|(
name|nbuckets
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"      0  %-10d (%5.1f%%)\n"
argument_list|,
name|counts
index|[
literal|0
index|]
argument_list|,
operator|(
name|counts
index|[
literal|0
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|)
expr_stmt|;
for|for
control|(
name|si
operator|=
literal|1
init|;
name|si
operator|<=
name|maxlength
condition|;
operator|++
name|si
control|)
block|{
name|nzero_counts
operator|+=
name|counts
index|[
name|si
index|]
operator|*
name|si
expr_stmt|;
name|printf
argument_list|(
literal|"%7d  %-10d (%5.1f%%)    %5.1f%%\n"
argument_list|,
name|si
argument_list|,
name|counts
index|[
name|si
index|]
argument_list|,
operator|(
name|counts
index|[
name|si
index|]
operator|*
literal|100.0
operator|)
operator|/
name|nbuckets
argument_list|,
operator|(
name|nzero_counts
operator|*
literal|100.0
operator|)
operator|/
name|nsyms
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|counts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lengths
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buckets
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chains
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_syminfo
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dynamic_syminfo
operator|==
name|NULL
operator|||
operator|!
name|do_dynamic
condition|)
comment|/* No syminfo, this is ok.  */
return|return
literal|1
return|;
comment|/* There better should be a dynamic symbol section.  */
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
operator|||
name|dynamic_strings
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dynamic_addr
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDynamic info segment at offset 0x%lx contains %d entries:\n"
argument_list|)
argument_list|,
name|dynamic_syminfo_offset
argument_list|,
name|dynamic_syminfo_nent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" Num: Name                           BoundTo     Flags\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dynamic_syminfo_nent
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|short
name|int
name|flags
init|=
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_flags
decl_stmt|;
name|printf
argument_list|(
literal|"%4d: %-30s "
argument_list|,
name|i
argument_list|,
name|dynamic_strings
operator|+
name|dynamic_symbols
index|[
name|i
index|]
operator|.
name|st_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
condition|)
block|{
case|case
name|SYMINFO_BT_SELF
case|:
name|fputs
argument_list|(
literal|"SELF       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMINFO_BT_PARENT
case|:
name|fputs
argument_list|(
literal|"PARENT     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|>
literal|0
operator|&&
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
operator|<
name|dynamic_size
condition|)
name|printf
argument_list|(
literal|"%-10s "
argument_list|,
name|dynamic_strings
operator|+
name|dynamic_segment
index|[
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
index|]
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-10d "
argument_list|,
name|dynamic_syminfo
index|[
name|i
index|]
operator|.
name|si_boundto
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_DIRECT
condition|)
name|printf
argument_list|(
literal|" DIRECT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_PASSTHRU
condition|)
name|printf
argument_list|(
literal|" PASSTHRU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_COPY
condition|)
name|printf
argument_list|(
literal|" COPY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYMINFO_FLG_LAZYLOAD
condition|)
name|printf
argument_list|(
literal|" LAZYLOAD"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_function
specifier|static
name|void
name|disassemble_section
parameter_list|(
name|section
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nAssembly dump of section %s\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX -- to be done --- XXX */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dump_section
parameter_list|(
name|section
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|bfd_size_type
name|bytes
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|bytes
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no data to dump.\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nHex dump of section '%s':\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|section
operator|->
name|sh_addr
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
argument|section->sh_offset
argument_list|,
argument|bytes
argument_list|,
argument|start
argument_list|,
argument|unsigned char *
argument_list|,
literal|"section data"
argument_list|)
empty_stmt|;
name|data
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|bytes
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|lbytes
decl_stmt|;
name|lbytes
operator|=
operator|(
name|bytes
operator|>
literal|16
condition|?
literal|16
else|:
name|bytes
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  0x%8.8lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
default|default:
case|case
name|ELFDATA2LSB
case|:
for|for
control|(
name|j
operator|=
literal|15
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|j
operator|&
literal|0x3
operator|)
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFDATA2MSB
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|lbytes
condition|)
name|printf
argument_list|(
literal|"%2.2x"
argument_list|,
name|data
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lbytes
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|' '
operator|&&
name|k
operator|<
literal|0x80
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|k
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|data
operator|+=
name|lbytes
expr_stmt|;
name|addr
operator|+=
name|lbytes
expr_stmt|;
name|bytes
operator|-=
name|lbytes
expr_stmt|;
block|}
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|int
name|read_leb128
parameter_list|(
name|data
parameter_list|,
name|length_return
parameter_list|,
name|sign
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
modifier|*
name|length_return
decl_stmt|;
name|int
name|sign
decl_stmt|;
block|{
name|unsigned
name|long
name|int
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_read
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
do|while
condition|(
name|byte
operator|&
literal|0x80
condition|)
do|;
if|if
condition|(
name|length_return
operator|!=
name|NULL
condition|)
operator|*
name|length_return
operator|=
name|num_read
expr_stmt|;
if|if
condition|(
name|sign
operator|&&
operator|(
name|shift
operator|<
literal|32
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
name|result
operator||=
operator|-
literal|1
operator|<<
name|shift
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|State_Machine_Registers
block|{
name|unsigned
name|long
name|address
decl_stmt|;
name|unsigned
name|int
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|is_stmt
decl_stmt|;
name|int
name|basic_block
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
comment|/* This variable hold the number of the last entry seen    in the File Table.  */
name|unsigned
name|int
name|last_file_entry
decl_stmt|;
block|}
name|SMR
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|SMR
name|state_machine_regs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|reset_state_machine
parameter_list|(
name|is_stmt
parameter_list|)
name|int
name|is_stmt
decl_stmt|;
block|{
name|state_machine_regs
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|file
operator|=
literal|1
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|=
literal|1
expr_stmt|;
name|state_machine_regs
operator|.
name|column
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|is_stmt
operator|=
name|is_stmt
expr_stmt|;
name|state_machine_regs
operator|.
name|basic_block
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|end_sequence
operator|=
literal|0
expr_stmt|;
name|state_machine_regs
operator|.
name|last_file_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handled an extend line op.  Returns true if this is the end    of sequence.  */
end_comment

begin_function
specifier|static
name|int
name|process_extended_line_op
parameter_list|(
name|data
parameter_list|,
name|is_stmt
parameter_list|,
name|pointer_size
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|is_stmt
decl_stmt|;
name|int
name|pointer_size
decl_stmt|;
block|{
name|unsigned
name|char
name|op_code
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|adr
decl_stmt|;
name|len
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"badly formed extended line op encountered!"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bytes_read
return|;
block|}
name|len
operator|+=
name|bytes_read
expr_stmt|;
name|op_code
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Extended opcode %d: "
argument_list|)
argument_list|,
name|op_code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"End of Sequence\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|reset_state_machine
argument_list|(
name|is_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|adr
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"set Address to 0x%lx\n"
argument_list|)
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|=
name|adr
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  define new File Table entry\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry\tDir\tTime\tSize\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   %d\t"
argument_list|)
argument_list|,
operator|++
name|state_machine_regs
operator|.
name|last_file_entry
argument_list|)
expr_stmt|;
name|name
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s\n\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"UNKNOWN: length %d\n"
argument_list|)
argument_list|,
name|len
operator|-
name|bytes_read
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Size of pointers in the .debug_line section.  This information is not    really present in that section.  It's obtained before dumping the debug    sections by doing some pre-scan of the .debug_info section.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_line_pointer_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|display_debug_lines
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|DWARF2_External_LineInfo
modifier|*
name|external
decl_stmt|;
name|DWARF2_Internal_LineInfo
name|info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcodes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end_of_sequence
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nDump of debug contents of section %s:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|external
operator|=
operator|(
name|DWARF2_External_LineInfo
operator|*
operator|)
name|data
expr_stmt|;
comment|/* Check the length of the block.  */
name|info
operator|.
name|li_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|li_length
operator|+
sizeof|sizeof
argument_list|(
name|external
operator|->
name|li_length
argument_list|)
operator|>
name|section
operator|->
name|sh_size
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"The line info appears to be corrupt - the section is too small\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check its version number.  */
name|info
operator|.
name|li_version
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|li_version
operator|!=
literal|2
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF version 2 line info is currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|info
operator|.
name|li_prologue_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_prologue_length
argument_list|)
expr_stmt|;
name|info
operator|.
name|li_min_insn_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_min_insn_length
argument_list|)
expr_stmt|;
name|info
operator|.
name|li_default_is_stmt
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_default_is_stmt
argument_list|)
expr_stmt|;
name|info
operator|.
name|li_line_base
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_line_base
argument_list|)
expr_stmt|;
name|info
operator|.
name|li_line_range
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_line_range
argument_list|)
expr_stmt|;
name|info
operator|.
name|li_opcode_base
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|li_opcode_base
argument_list|)
expr_stmt|;
comment|/* Sign extend the line base field.  */
name|info
operator|.
name|li_line_base
operator|<<=
literal|24
expr_stmt|;
name|info
operator|.
name|li_line_base
operator|>>=
literal|24
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                      %ld\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  DWARF Version:               %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Prologue Length:             %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_prologue_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Minimum Instruction Length:  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_min_insn_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Initial value of 'is_stmt':  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_default_is_stmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Line Base:                   %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_line_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Line Range:                  %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_line_range
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Opcode Base:                 %d\n"
argument_list|)
argument_list|,
name|info
operator|.
name|li_opcode_base
argument_list|)
expr_stmt|;
name|end_of_sequence
operator|=
name|data
operator|+
name|info
operator|.
name|li_length
operator|+
sizeof|sizeof
argument_list|(
name|external
operator|->
name|li_length
argument_list|)
expr_stmt|;
name|reset_state_machine
argument_list|(
name|info
operator|.
name|li_default_is_stmt
argument_list|)
expr_stmt|;
comment|/* Display the contents of the Opcodes table.  */
name|standard_opcodes
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|external
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Opcodes:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|info
operator|.
name|li_opcode_base
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Opcode %d has %d args\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|standard_opcodes
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Display the contents of the Directory table.  */
name|data
operator|=
name|standard_opcodes
operator|+
name|info
operator|.
name|li_opcode_base
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The Directory Table is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The Directory Table:\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %s\n"
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Skip the NUL at the end of the table.  */
name|data
operator|++
expr_stmt|;
comment|/* Display the contents of the File Name table.  */
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The File Name Table is empty.\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n The File Name Table:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Entry\tDir\tTime\tSize\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  %d\t"
argument_list|)
argument_list|,
operator|++
name|state_machine_regs
operator|.
name|last_file_entry
argument_list|)
expr_stmt|;
name|name
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%lu\t"
argument_list|)
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip the NUL at the end of the table.  */
name|data
operator|++
expr_stmt|;
comment|/* Now display the statements.  */
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n Line Number Statements:\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|<
name|end_of_sequence
condition|)
block|{
name|unsigned
name|char
name|op_code
decl_stmt|;
name|int
name|adv
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|op_code
operator|=
operator|*
name|data
operator|++
expr_stmt|;
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
name|data
operator|+=
name|process_extended_line_op
argument_list|(
name|data
argument_list|,
name|info
operator|.
name|li_default_is_stmt
argument_list|,
name|debug_line_pointer_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_copy
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Copy\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|adv
operator|=
name|info
operator|.
name|li_min_insn_length
operator|*
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by %d to %lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance Line by %d to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set File Name to entry %d in the File Name Table\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|file
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_column
case|:
name|adv
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set column to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|column
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|adv
operator|=
name|state_machine_regs
operator|.
name|is_stmt
expr_stmt|;
name|adv
operator|=
operator|!
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set is_stmt to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|is_stmt
operator|=
name|adv
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Set basic block\n"
argument_list|)
argument_list|)
expr_stmt|;
name|state_machine_regs
operator|.
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|adv
operator|=
operator|(
operator|(
operator|(
literal|255
operator|-
name|info
operator|.
name|li_opcode_base
operator|)
operator|/
name|info
operator|.
name|li_line_range
operator|)
operator|*
name|info
operator|.
name|li_min_insn_length
operator|)
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by constant %d to 0x%lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|adv
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Advance PC by fixed size amount %d to 0x%lx\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|op_code
operator|-=
name|info
operator|.
name|li_opcode_base
expr_stmt|;
name|adv
operator|=
operator|(
name|op_code
operator|/
name|info
operator|.
name|li_line_range
operator|)
operator|*
name|info
operator|.
name|li_min_insn_length
expr_stmt|;
name|state_machine_regs
operator|.
name|address
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Special opcode %d: advance Address by %d to 0x%lx"
argument_list|)
argument_list|,
name|op_code
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|address
argument_list|)
expr_stmt|;
name|adv
operator|=
operator|(
name|op_code
operator|%
name|info
operator|.
name|li_line_range
operator|)
operator|+
name|info
operator|.
name|li_line_base
expr_stmt|;
name|state_machine_regs
operator|.
name|line
operator|+=
name|adv
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|" and Line by %d to %d\n"
argument_list|)
argument_list|,
name|adv
argument_list|,
name|state_machine_regs
operator|.
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_pubnames
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|DWARF2_External_PubNames
modifier|*
name|external
decl_stmt|;
name|DWARF2_Internal_PubNames
name|pubnames
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|start
operator|+
name|section
operator|->
name|sh_size
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the %s section:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|external
operator|=
operator|(
name|DWARF2_External_PubNames
operator|*
operator|)
name|start
expr_stmt|;
name|pubnames
operator|.
name|pn_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|pn_length
argument_list|)
expr_stmt|;
name|pubnames
operator|.
name|pn_version
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|pn_version
argument_list|)
expr_stmt|;
name|pubnames
operator|.
name|pn_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|pn_offset
argument_list|)
expr_stmt|;
name|pubnames
operator|.
name|pn_size
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|pn_size
argument_list|)
expr_stmt|;
name|data
operator|=
name|start
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|external
argument_list|)
expr_stmt|;
name|start
operator|+=
name|pubnames
operator|.
name|pn_length
operator|+
sizeof|sizeof
argument_list|(
name|external
operator|->
name|pn_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|pubnames
operator|.
name|pn_version
operator|!=
literal|2
condition|)
block|{
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF 2 pubnames are currently supported\n"
argument_list|)
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                              %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                             %d\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset into .debug_info section:     %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Size of area in .debug_info section: %ld\n"
argument_list|)
argument_list|,
name|pubnames
operator|.
name|pn_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n    Offset\tName\n"
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|offset
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|data
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|"    %ld\t\t%s\n"
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|offset
operator|!=
literal|0
condition|)
do|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_TAG_name
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|long
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown TAG value: %lx"
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_AT_name
parameter_list|(
name|attribute
parameter_list|)
name|unsigned
name|long
name|attribute
decl_stmt|;
block|{
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
comment|/* DWARF 2.1 values.  */
case|case
name|DW_AT_allocated
case|:
return|return
literal|"DW_AT_allocated"
return|;
case|case
name|DW_AT_associated
case|:
return|return
literal|"DW_AT_associated"
return|;
case|case
name|DW_AT_data_location
case|:
return|return
literal|"DW_AT_data_location"
return|;
case|case
name|DW_AT_stride
case|:
return|return
literal|"DW_AT_stride"
return|;
case|case
name|DW_AT_entry_pc
case|:
return|return
literal|"DW_AT_entry_pc"
return|;
case|case
name|DW_AT_use_UTF8
case|:
return|return
literal|"DW_AT_use_UTF8"
return|;
case|case
name|DW_AT_extension
case|:
return|return
literal|"DW_AT_extension"
return|;
case|case
name|DW_AT_ranges
case|:
return|return
literal|"DW_AT_ranges"
return|;
case|case
name|DW_AT_trampoline
case|:
return|return
literal|"DW_AT_trampoline"
return|;
case|case
name|DW_AT_call_column
case|:
return|return
literal|"DW_AT_call_column"
return|;
case|case
name|DW_AT_call_file
case|:
return|return
literal|"DW_AT_call_file"
return|;
case|case
name|DW_AT_call_line
case|:
return|return
literal|"DW_AT_call_line"
return|;
comment|/* SGI/MIPS extensions.  */
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_MIPS_stride
case|:
return|return
literal|"DW_AT_MIPS_stride"
return|;
case|case
name|DW_AT_MIPS_abstract_name
case|:
return|return
literal|"DW_AT_MIPS_abstract_name"
return|;
case|case
name|DW_AT_MIPS_clone_origin
case|:
return|return
literal|"DW_AT_MIPS_clone_origin"
return|;
case|case
name|DW_AT_MIPS_has_inlines
case|:
return|return
literal|"DW_AT_MIPS_has_inlines"
return|;
comment|/* GNU extensions.  */
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown AT value: %lx"
argument_list|)
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_FORM_name
parameter_list|(
name|form
parameter_list|)
name|unsigned
name|long
name|form
decl_stmt|;
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
block|{
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|_
argument_list|(
literal|"Unknown FORM value: %lx"
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FIXME:  There are better and more effiecint ways to handle    these structures.  For now though, I just want something that    is simple to implement.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|abbrev_attr
block|{
name|unsigned
name|long
name|attribute
decl_stmt|;
name|unsigned
name|long
name|form
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|next
decl_stmt|;
block|}
name|abbrev_attr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|abbrev_entry
block|{
name|unsigned
name|long
name|entry
decl_stmt|;
name|unsigned
name|long
name|tag
decl_stmt|;
name|int
name|children
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|first_attr
decl_stmt|;
name|struct
name|abbrev_attr
modifier|*
name|last_attr
decl_stmt|;
name|struct
name|abbrev_entry
modifier|*
name|next
decl_stmt|;
block|}
name|abbrev_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|abbrev_entry
modifier|*
name|first_abbrev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|abbrev_entry
modifier|*
name|last_abbrev
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_abbrevs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|abbrev_entry
modifier|*
name|abbrev
decl_stmt|;
for|for
control|(
name|abbrev
operator|=
name|first_abbrev
init|;
name|abbrev
condition|;
control|)
block|{
name|abbrev_entry
modifier|*
name|next
init|=
name|abbrev
operator|->
name|next
decl_stmt|;
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
for|for
control|(
name|attr
operator|=
name|abbrev
operator|->
name|first_attr
init|;
name|attr
condition|;
control|)
block|{
name|abbrev_attr
modifier|*
name|next
init|=
name|attr
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|next
expr_stmt|;
block|}
name|last_abbrev
operator|=
name|first_abbrev
operator|=
name|NULL
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|add_abbrev
parameter_list|(
name|number
parameter_list|,
name|tag
parameter_list|,
name|children
parameter_list|)
name|unsigned
name|long
name|number
decl_stmt|;
name|unsigned
name|long
name|tag
decl_stmt|;
name|int
name|children
decl_stmt|;
block|{
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
name|abbrev_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
comment|/* ugg */
return|return;
name|entry
operator|->
name|entry
operator|=
name|number
expr_stmt|;
name|entry
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|entry
operator|->
name|children
operator|=
name|children
expr_stmt|;
name|entry
operator|->
name|first_attr
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|last_attr
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|first_abbrev
operator|==
name|NULL
condition|)
name|first_abbrev
operator|=
name|entry
expr_stmt|;
else|else
name|last_abbrev
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|last_abbrev
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_abbrev_attr
parameter_list|(
name|attribute
parameter_list|,
name|form
parameter_list|)
name|unsigned
name|long
name|attribute
decl_stmt|;
name|unsigned
name|long
name|form
decl_stmt|;
block|{
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
operator|(
name|abbrev_attr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
comment|/* ugg */
return|return;
name|attr
operator|->
name|attribute
operator|=
name|attribute
expr_stmt|;
name|attr
operator|->
name|form
operator|=
name|form
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_abbrev
operator|->
name|first_attr
operator|==
name|NULL
condition|)
name|last_abbrev
operator|->
name|first_attr
operator|=
name|attr
expr_stmt|;
else|else
name|last_abbrev
operator|->
name|last_attr
operator|->
name|next
operator|=
name|attr
expr_stmt|;
name|last_abbrev
operator|->
name|last_attr
operator|=
name|attr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Processes the (partial) contents of a .debug_abbrev section.    Returns NULL if the end of the section was encountered.    Returns the address after the last byte read if the end of    an abbreviation set was found.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|process_abbrev_section
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
decl_stmt|;
block|{
if|if
condition|(
name|first_abbrev
operator|!=
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|entry
decl_stmt|;
name|unsigned
name|long
name|tag
decl_stmt|;
name|unsigned
name|long
name|attribute
decl_stmt|;
name|int
name|children
decl_stmt|;
name|entry
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
comment|/* A single zero is supposed to end the section according 	 to the standard.  If there's more, then signal that to 	 the caller.  */
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
return|return
name|start
operator|==
name|end
condition|?
name|NULL
else|:
name|start
return|;
name|tag
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
name|children
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|add_abbrev
argument_list|(
name|entry
argument_list|,
name|tag
argument_list|,
name|children
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|long
name|form
decl_stmt|;
name|attribute
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
name|form
operator|=
name|read_leb128
argument_list|(
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|attribute
operator|!=
literal|0
condition|)
name|add_abbrev_attr
argument_list|(
name|attribute
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|attribute
operator|!=
literal|0
condition|)
do|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_abbrev
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of the %s section:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|start
operator|=
name|process_abbrev_section
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number TAG\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|first_abbrev
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   %ld      %s    [%s]\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|entry
argument_list|,
name|get_TAG_name
argument_list|(
name|entry
operator|->
name|tag
argument_list|)
argument_list|,
name|entry
operator|->
name|children
condition|?
name|_
argument_list|(
literal|"has children"
argument_list|)
else|:
name|_
argument_list|(
literal|"no children"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|entry
operator|->
name|first_attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"    %-18s %s\n"
argument_list|)
argument_list|,
name|get_AT_name
argument_list|(
name|attr
operator|->
name|attribute
argument_list|)
argument_list|,
name|get_FORM_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|start
condition|)
do|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|display_block
parameter_list|(
name|data
parameter_list|,
name|length
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|" %lu byte block: "
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
name|printf
argument_list|(
literal|"%lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|decode_location_expression
parameter_list|(
name|data
parameter_list|,
name|pointer_size
parameter_list|,
name|length
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|pointer_size
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|{
name|unsigned
name|op
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|uvalue
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|data
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|data
operator|<
name|end
condition|)
block|{
name|op
operator|=
operator|*
name|data
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
name|printf
argument_list|(
literal|"DW_OP_addr: %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|pointer_size
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
name|printf
argument_list|(
literal|"DW_OP_deref"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|printf
argument_list|(
literal|"DW_OP_const1u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|printf
argument_list|(
literal|"DW_OP_const1s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|printf
argument_list|(
literal|"DW_OP_const2u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|printf
argument_list|(
literal|"DW_OP_const2s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|printf
argument_list|(
literal|"DW_OP_const4u: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|printf
argument_list|(
literal|"DW_OP_const4s: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|printf
argument_list|(
literal|"DW_OP_const8u: %lu %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|printf
argument_list|(
literal|"DW_OP_const8s: %ld %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|printf
argument_list|(
literal|"DW_OP_constu: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|printf
argument_list|(
literal|"DW_OP_consts: %ld"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
name|printf
argument_list|(
literal|"DW_OP_dup"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
name|printf
argument_list|(
literal|"DW_OP_drop"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
name|printf
argument_list|(
literal|"DW_OP_over"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|printf
argument_list|(
literal|"DW_OP_pick: %ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_swap
case|:
name|printf
argument_list|(
literal|"DW_OP_swap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_rot
case|:
name|printf
argument_list|(
literal|"DW_OP_rot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xderef
case|:
name|printf
argument_list|(
literal|"DW_OP_xderef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_abs
case|:
name|printf
argument_list|(
literal|"DW_OP_abs"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_and
case|:
name|printf
argument_list|(
literal|"DW_OP_and"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|printf
argument_list|(
literal|"DW_OP_div"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|printf
argument_list|(
literal|"DW_OP_minus"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|printf
argument_list|(
literal|"DW_OP_mod"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|printf
argument_list|(
literal|"DW_OP_mul"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|printf
argument_list|(
literal|"DW_OP_neg"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|printf
argument_list|(
literal|"DW_OP_not"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|printf
argument_list|(
literal|"DW_OP_or"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|printf
argument_list|(
literal|"DW_OP_plus"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|printf
argument_list|(
literal|"DW_OP_plus_uconst: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|printf
argument_list|(
literal|"DW_OP_shl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|printf
argument_list|(
literal|"DW_OP_shr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_shra
case|:
name|printf
argument_list|(
literal|"DW_OP_shra"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|printf
argument_list|(
literal|"DW_OP_xor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bra
case|:
name|printf
argument_list|(
literal|"DW_OP_bra: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|printf
argument_list|(
literal|"DW_OP_eq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|printf
argument_list|(
literal|"DW_OP_ge"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|printf
argument_list|(
literal|"DW_OP_gt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|printf
argument_list|(
literal|"DW_OP_le"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|printf
argument_list|(
literal|"DW_OP_lt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|printf
argument_list|(
literal|"DW_OP_ne"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
name|printf
argument_list|(
literal|"DW_OP_skip: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|printf
argument_list|(
literal|"DW_OP_lit%d"
argument_list|,
name|op
operator|-
name|DW_OP_lit0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|printf
argument_list|(
literal|"DW_OP_reg%d"
argument_list|,
name|op
operator|-
name|DW_OP_reg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|printf
argument_list|(
literal|"DW_OP_breg%d: %ld"
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|printf
argument_list|(
literal|"DW_OP_regx: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|printf
argument_list|(
literal|"DW_OP_fbreg: %ld"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
name|printf
argument_list|(
literal|"DW_OP_bregx: %lu %ld"
argument_list|,
name|uvalue
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|printf
argument_list|(
literal|"DW_OP_piece: %lu"
argument_list|,
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
name|printf
argument_list|(
literal|"DW_OP_deref_size: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_xderef_size
case|:
name|printf
argument_list|(
literal|"DW_OP_xderef_size: %ld"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_nop
case|:
name|printf
argument_list|(
literal|"DW_OP_nop"
argument_list|)
expr_stmt|;
break|break;
comment|/* DWARF 2.1 extensions.  */
case|case
name|DW_OP_push_object_address
case|:
name|printf
argument_list|(
literal|"DW_OP_push_object_address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_call2
case|:
name|printf
argument_list|(
literal|"DW_OP_call2:<%lx>"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_call4
case|:
name|printf
argument_list|(
literal|"DW_OP_call4:<%lx>"
argument_list|,
operator|(
name|long
operator|)
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_calli
case|:
name|printf
argument_list|(
literal|"DW_OP_calli"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|op
operator|>=
name|DW_OP_lo_user
operator|&&
name|op
operator|<=
name|DW_OP_hi_user
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"(User defined location op)"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"(Unknown location op)"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No way to tell where the next op is, so just bail.  */
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|read_and_display_attr
parameter_list|(
name|attribute
parameter_list|,
name|form
parameter_list|,
name|data
parameter_list|,
name|cu_offset
parameter_list|,
name|pointer_size
parameter_list|)
name|unsigned
name|long
name|attribute
decl_stmt|;
name|unsigned
name|long
name|form
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|long
name|cu_offset
decl_stmt|;
name|unsigned
name|long
name|pointer_size
decl_stmt|;
block|{
name|unsigned
name|long
name|uvalue
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_start
init|=
name|NULL
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|printf
argument_list|(
literal|"     %-18s:"
argument_list|,
name|get_AT_name
argument_list|(
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
default|default:
break|break;
case|case
name|DW_FORM_ref_addr
case|:
case|case
name|DW_FORM_addr
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
name|pointer_size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|pointer_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_flag
case|:
case|case
name|DW_FORM_data1
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_data2
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_data4
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
case|case
name|DW_FORM_udata
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bytes_read
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
name|printf
argument_list|(
literal|"<#%lx>"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_ref_udata
case|:
name|printf
argument_list|(
literal|"<%lx>"
argument_list|,
name|uvalue
operator|+
name|cu_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_addr
case|:
name|printf
argument_list|(
literal|" %#lx"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
case|case
name|DW_FORM_flag
case|:
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_sdata
case|:
case|case
name|DW_FORM_udata
case|:
name|printf
argument_list|(
literal|" %ld"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
case|case
name|DW_FORM_data8
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %lx"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_get
argument_list|(
name|data
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|uvalue
operator|=
name|read_leb128
argument_list|(
name|data
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
name|bytes_read
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|1
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|2
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|uvalue
operator|=
name|byte_get
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|data
operator|+
literal|4
expr_stmt|;
name|data
operator|=
name|display_block
argument_list|(
name|block_start
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
case|case
name|DW_FORM_indirect
case|:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unable to handle FORM: %d"
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unrecognised form: %d"
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* For some attributes we can display futher information.  */
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|DW_AT_inline
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_INL_not_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(not inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_declared_not_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(declared as inline but ignored)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_INL_declared_inlined
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"(declared as inline and inlined)"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|_
argument_list|(
literal|"  (Unknown inline attribute value: %lx)"
argument_list|)
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_language
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_LANG_C
case|:
name|printf
argument_list|(
literal|"(non-ANSI C)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_C89
case|:
name|printf
argument_list|(
literal|"(ANSI C)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_C_plus_plus
case|:
name|printf
argument_list|(
literal|"(C++)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran77
case|:
name|printf
argument_list|(
literal|"(FORTRAN 77)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran90
case|:
name|printf
argument_list|(
literal|"(Fortran 90)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Modula2
case|:
name|printf
argument_list|(
literal|"(Modula 2)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Pascal83
case|:
name|printf
argument_list|(
literal|"(ANSI Pascal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Ada83
case|:
name|printf
argument_list|(
literal|"(Ada)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Cobol74
case|:
name|printf
argument_list|(
literal|"(Cobol 74)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Cobol85
case|:
name|printf
argument_list|(
literal|"(Cobol 85)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LANG_Mips_Assembler
case|:
name|printf
argument_list|(
literal|"(MIPS assembler)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(Unknown: %lx)"
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_encoding
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ATE_void
case|:
name|printf
argument_list|(
literal|"(void)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_address
case|:
name|printf
argument_list|(
literal|"(machine address)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_boolean
case|:
name|printf
argument_list|(
literal|"(boolean)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_complex_float
case|:
name|printf
argument_list|(
literal|"(complex float)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_float
case|:
name|printf
argument_list|(
literal|"(float)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed
case|:
name|printf
argument_list|(
literal|"(signed)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed_char
case|:
name|printf
argument_list|(
literal|"(signed char)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_unsigned
case|:
name|printf
argument_list|(
literal|"(unsigned)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ATE_unsigned_char
case|:
name|printf
argument_list|(
literal|"(unsigned char)"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uvalue
operator|>=
name|DW_ATE_lo_user
operator|&&
name|uvalue
operator|<=
name|DW_ATE_hi_user
condition|)
name|printf
argument_list|(
literal|"(user defined type)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(unknown type)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_accessibility
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ACCESS_public
case|:
name|printf
argument_list|(
literal|"(public)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|printf
argument_list|(
literal|"(protected)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_private
case|:
name|printf
argument_list|(
literal|"(private)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown accessibility)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_visibility
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_VIS_local
case|:
name|printf
argument_list|(
literal|"(local)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIS_exported
case|:
name|printf
argument_list|(
literal|"(exported)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIS_qualified
case|:
name|printf
argument_list|(
literal|"(qualified)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown visibility)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_virtuality
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_VIRTUALITY_none
case|:
name|printf
argument_list|(
literal|"(none)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIRTUALITY_virtual
case|:
name|printf
argument_list|(
literal|"(virtual)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_VIRTUALITY_pure_virtual
case|:
name|printf
argument_list|(
literal|"(pure_virtual)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown virtuality)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_identifier_case
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_ID_case_sensitive
case|:
name|printf
argument_list|(
literal|"(case_sensitive)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_up_case
case|:
name|printf
argument_list|(
literal|"(up_case)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_down_case
case|:
name|printf
argument_list|(
literal|"(down_case)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ID_case_insensitive
case|:
name|printf
argument_list|(
literal|"(case_insensitive)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"(unknown case)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_calling_convention
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
name|DW_CC_normal
case|:
name|printf
argument_list|(
literal|"(normal)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CC_program
case|:
name|printf
argument_list|(
literal|"(program)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CC_nocall
case|:
name|printf
argument_list|(
literal|"(nocall)"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|uvalue
operator|>=
name|DW_CC_lo_user
operator|&&
name|uvalue
operator|<=
name|DW_CC_hi_user
condition|)
name|printf
argument_list|(
literal|"(user defined)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(unknown convention)"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_AT_ordering
case|:
switch|switch
condition|(
name|uvalue
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"(undefined)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"(row major)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"(column major)"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DW_AT_frame_base
case|:
case|case
name|DW_AT_location
case|:
case|case
name|DW_AT_data_member_location
case|:
case|case
name|DW_AT_vtable_elem_location
case|:
case|case
name|DW_AT_allocated
case|:
case|case
name|DW_AT_associated
case|:
case|case
name|DW_AT_data_location
case|:
case|case
name|DW_AT_stride
case|:
case|case
name|DW_AT_upper_bound
case|:
case|case
name|DW_AT_lower_bound
case|:
if|if
condition|(
name|block_start
condition|)
block|{
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|decode_location_expression
argument_list|(
name|block_start
argument_list|,
name|pointer_size
argument_list|,
name|uvalue
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_info
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|section_begin
init|=
name|start
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|DWARF2_External_CompUnit
modifier|*
name|external
decl_stmt|;
name|DWARF2_Internal_CompUnit
name|compunit
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|level
decl_stmt|;
name|unsigned
name|long
name|cu_offset
decl_stmt|;
name|external
operator|=
operator|(
name|DWARF2_External_CompUnit
operator|*
operator|)
name|start
expr_stmt|;
name|compunit
operator|.
name|cu_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|cu_length
argument_list|)
expr_stmt|;
name|compunit
operator|.
name|cu_version
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|cu_version
argument_list|)
expr_stmt|;
name|compunit
operator|.
name|cu_abbrev_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|cu_abbrev_offset
argument_list|)
expr_stmt|;
name|compunit
operator|.
name|cu_pointer_size
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|cu_pointer_size
argument_list|)
expr_stmt|;
name|tags
operator|=
name|start
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|external
argument_list|)
expr_stmt|;
name|cu_offset
operator|=
name|start
operator|-
name|section_begin
expr_stmt|;
name|start
operator|+=
name|compunit
operator|.
name|cu_length
operator|+
sizeof|sizeof
argument_list|(
name|external
operator|->
name|cu_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Compilation Unit @ %lx:\n"
argument_list|)
argument_list|,
name|cu_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Length:        %ld\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Version:       %d\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Abbrev Offset: %ld\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_abbrev_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"   Pointer Size:  %d\n"
argument_list|)
argument_list|,
name|compunit
operator|.
name|cu_pointer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|compunit
operator|.
name|cu_version
operator|!=
literal|2
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only version 2 DWARF debug information is currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first_abbrev
operator|!=
name|NULL
condition|)
name|free_abbrevs
argument_list|()
expr_stmt|;
comment|/* Read in the abbrevs used by this compilation unit.  */
block|{
name|Elf32_Internal_Shdr
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|char
modifier|*
name|begin
decl_stmt|;
comment|/* Locate the .debug_abbrev section and process it.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sec
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|sec
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|sec
argument_list|)
argument_list|,
literal|".debug_abbrev"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|||
name|sec
operator|->
name|sh_size
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unable to locate .debug_abbrev section!\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|GET_DATA_ALLOC
argument_list|(
argument|sec->sh_offset
argument_list|,
argument|sec->sh_size
argument_list|,
argument|begin
argument_list|,
argument|unsigned char *
argument_list|,
literal|"debug_abbrev section data"
argument_list|)
empty_stmt|;
name|process_abbrev_section
argument_list|(
name|begin
operator|+
name|compunit
operator|.
name|cu_abbrev_offset
argument_list|,
name|begin
operator|+
name|sec
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|begin
argument_list|)
expr_stmt|;
block|}
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tags
operator|<
name|start
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|unsigned
name|long
name|abbrev_number
decl_stmt|;
name|abbrev_entry
modifier|*
name|entry
decl_stmt|;
name|abbrev_attr
modifier|*
name|attr
decl_stmt|;
name|abbrev_number
operator|=
name|read_leb128
argument_list|(
name|tags
argument_list|,
operator|&
name|bytes_read
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tags
operator|+=
name|bytes_read
expr_stmt|;
comment|/* A null DIE marks the end of a list of children.  */
if|if
condition|(
name|abbrev_number
operator|==
literal|0
condition|)
block|{
operator|--
name|level
expr_stmt|;
continue|continue;
block|}
comment|/* Scan through the abbreviation list until we reach the 	     correct entry.  */
for|for
control|(
name|entry
operator|=
name|first_abbrev
init|;
name|entry
operator|&&
name|entry
operator|->
name|entry
operator|!=
name|abbrev_number
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
continue|continue;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Unable to locate entry %lu in the abbreviation table\n"
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"<%d><%x>: Abbrev Number: %lu (%s)\n"
argument_list|)
argument_list|,
name|level
argument_list|,
name|tags
operator|-
name|section_begin
operator|-
name|bytes_read
argument_list|,
name|abbrev_number
argument_list|,
name|get_TAG_name
argument_list|(
name|entry
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|entry
operator|->
name|first_attr
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
name|tags
operator|=
name|read_and_display_attr
argument_list|(
name|attr
operator|->
name|attribute
argument_list|,
name|attr
operator|->
name|form
argument_list|,
name|tags
argument_list|,
name|cu_offset
argument_list|,
name|compunit
operator|.
name|cu_pointer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|children
condition|)
operator|++
name|level
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|display_debug_aranges
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|DWARF2_External_ARange
modifier|*
name|external
decl_stmt|;
name|DWARF2_Internal_ARange
name|arange
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ranges
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|address
decl_stmt|;
name|int
name|excess
decl_stmt|;
name|external
operator|=
operator|(
name|DWARF2_External_ARange
operator|*
operator|)
name|start
expr_stmt|;
name|arange
operator|.
name|ar_length
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|ar_length
argument_list|)
expr_stmt|;
name|arange
operator|.
name|ar_version
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|ar_version
argument_list|)
expr_stmt|;
name|arange
operator|.
name|ar_info_offset
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|ar_info_offset
argument_list|)
expr_stmt|;
name|arange
operator|.
name|ar_pointer_size
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|arange
operator|.
name|ar_segment_size
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|ar_segment_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|arange
operator|.
name|ar_version
operator|!=
literal|2
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"Only DWARF 2 aranges are currently supported.\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Length:                   %ld\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Version:                  %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Offset into .debug_info:  %lx\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_info_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Pointer Size:             %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Segment Size:             %d\n"
argument_list|)
argument_list|,
name|arange
operator|.
name|ar_segment_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n    Address  Length\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ranges
operator|=
name|start
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|external
argument_list|)
expr_stmt|;
comment|/* Must pad to an alignment boundary that is twice the pointer size.  */
name|excess
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|external
argument_list|)
operator|%
operator|(
literal|2
operator|*
name|arange
operator|.
name|ar_pointer_size
operator|)
expr_stmt|;
if|if
condition|(
name|excess
condition|)
name|ranges
operator|+=
operator|(
literal|2
operator|*
name|arange
operator|.
name|ar_pointer_size
operator|)
operator|-
name|excess
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|address
operator|=
name|byte_get
argument_list|(
name|ranges
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|ranges
operator|+=
name|arange
operator|.
name|ar_pointer_size
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|ranges
argument_list|,
name|arange
operator|.
name|ar_pointer_size
argument_list|)
expr_stmt|;
name|ranges
operator|+=
name|arange
operator|.
name|ar_pointer_size
expr_stmt|;
comment|/* A pair of zeros marks the end of the list.  */
if|if
condition|(
name|address
operator|==
literal|0
operator|&&
name|length
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"    %8.8lx %lu\n"
argument_list|,
name|address
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|start
operator|+=
name|arange
operator|.
name|ar_length
operator|+
sizeof|sizeof
argument_list|(
name|external
operator|->
name|ar_length
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|Frame_Chunk
block|{
name|struct
name|Frame_Chunk
modifier|*
name|next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|chunk_start
decl_stmt|;
name|int
name|ncols
decl_stmt|;
comment|/* DW_CFA_{undefined,same_value,offset,register,unreferenced}  */
name|short
name|int
modifier|*
name|col_type
decl_stmt|;
name|int
modifier|*
name|col_offset
decl_stmt|;
name|char
modifier|*
name|augmentation
decl_stmt|;
name|unsigned
name|int
name|code_factor
decl_stmt|;
name|int
name|data_factor
decl_stmt|;
name|unsigned
name|long
name|pc_begin
decl_stmt|;
name|unsigned
name|long
name|pc_range
decl_stmt|;
name|int
name|cfa_reg
decl_stmt|;
name|int
name|cfa_offset
decl_stmt|;
name|int
name|ra
decl_stmt|;
name|unsigned
name|char
name|fde_encoding
decl_stmt|;
block|}
name|Frame_Chunk
typedef|;
end_typedef

begin_comment
comment|/* A marker for a col_type that means this column was never referenced    in the frame info.  */
end_comment

begin_define
define|#
directive|define
name|DW_CFA_unreferenced
value|(-1)
end_define

begin_function
specifier|static
name|void
name|frame_need_space
parameter_list|(
name|fc
parameter_list|,
name|reg
parameter_list|)
name|Frame_Chunk
modifier|*
name|fc
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|int
name|prev
init|=
name|fc
operator|->
name|ncols
decl_stmt|;
if|if
condition|(
name|reg
operator|<
name|fc
operator|->
name|ncols
condition|)
return|return;
name|fc
operator|->
name|ncols
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
operator|(
name|short
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|prev
operator|<
name|fc
operator|->
name|ncols
condition|)
block|{
name|fc
operator|->
name|col_type
index|[
name|prev
index|]
operator|=
name|DW_CFA_unreferenced
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|prev
index|]
operator|=
literal|0
expr_stmt|;
name|prev
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|frame_display_row
parameter_list|(
name|fc
parameter_list|,
name|need_col_headers
parameter_list|,
name|max_regs
parameter_list|)
name|Frame_Chunk
modifier|*
name|fc
decl_stmt|;
name|int
modifier|*
name|need_col_headers
decl_stmt|;
name|int
modifier|*
name|max_regs
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|char
name|tmp
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|max_regs
operator|<
name|fc
operator|->
name|ncols
condition|)
operator|*
name|max_regs
operator|=
name|fc
operator|->
name|ncols
expr_stmt|;
if|if
condition|(
operator|*
name|need_col_headers
condition|)
block|{
operator|*
name|need_col_headers
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"   LOC   CFA      "
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
operator|*
name|max_regs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
operator|!=
name|DW_CFA_unreferenced
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|fc
operator|->
name|ra
condition|)
name|printf
argument_list|(
literal|"ra   "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"r%-4d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%08lx "
argument_list|,
name|fc
operator|->
name|pc_begin
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"r%d%+d"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-8s "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|fc
operator|->
name|ncols
condition|;
name|r
operator|++
control|)
block|{
if|if
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
operator|!=
name|DW_CFA_unreferenced
condition|)
block|{
switch|switch
condition|(
name|fc
operator|->
name|col_type
index|[
name|r
index|]
condition|)
block|{
case|case
name|DW_CFA_undefined
case|:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"c%+d"
argument_list|,
name|fc
operator|->
name|col_offset
index|[
name|r
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"r%d"
argument_list|,
name|fc
operator|->
name|col_offset
index|[
name|r
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"n/a"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%-5s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|size_of_encoded_value
parameter_list|(
name|encoding
parameter_list|)
name|int
name|encoding
decl_stmt|;
block|{
switch|switch
condition|(
name|encoding
operator|&
literal|0x7
condition|)
block|{
default|default:
comment|/* ??? */
case|case
literal|0
case|:
return|return
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
case|case
literal|3
case|:
return|return
literal|4
return|;
case|case
literal|4
case|:
return|return
literal|8
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|GET
parameter_list|(
name|N
parameter_list|)
value|byte_get (start, N); start += N
end_define

begin_define
define|#
directive|define
name|LEB
parameter_list|()
value|read_leb128 (start,& length_return, 0); start += length_return
end_define

begin_define
define|#
directive|define
name|SLEB
parameter_list|()
value|read_leb128 (start,& length_return, 1); start += length_return
end_define

begin_function
specifier|static
name|int
name|display_debug_frames
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|end
init|=
name|start
operator|+
name|section
operator|->
name|sh_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|section_start
init|=
name|start
decl_stmt|;
name|Frame_Chunk
modifier|*
name|chunks
init|=
literal|0
decl_stmt|;
name|Frame_Chunk
modifier|*
name|remembered_state
init|=
literal|0
decl_stmt|;
name|Frame_Chunk
modifier|*
name|rs
decl_stmt|;
name|int
name|is_eh
init|=
operator|(
name|strcmp
argument_list|(
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|length_return
decl_stmt|;
name|int
name|max_regs
init|=
literal|0
decl_stmt|;
name|int
name|addr_size
init|=
name|is_32bit_elf
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"The section %s contains:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|char
modifier|*
name|saved_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|block_end
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|cie_id
decl_stmt|;
name|Frame_Chunk
modifier|*
name|fc
decl_stmt|;
name|Frame_Chunk
modifier|*
name|cie
decl_stmt|;
name|int
name|need_col_headers
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|augmentation_data
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|augmentation_data_len
init|=
literal|0
decl_stmt|;
name|int
name|encoded_ptr_size
init|=
name|addr_size
decl_stmt|;
name|saved_start
operator|=
name|start
expr_stmt|;
name|length
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|block_end
operator|=
name|saved_start
operator|+
name|length
operator|+
literal|4
expr_stmt|;
name|cie_id
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|is_eh
condition|?
operator|(
name|cie_id
operator|==
literal|0
operator|)
else|:
operator|(
name|cie_id
operator|==
name|DW_CIE_ID
operator|)
condition|)
block|{
name|int
name|version
decl_stmt|;
name|fc
operator|=
operator|(
name|Frame_Chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|next
operator|=
name|chunks
expr_stmt|;
name|chunks
operator|=
name|fc
expr_stmt|;
name|fc
operator|->
name|chunk_start
operator|=
name|saved_start
expr_stmt|;
name|fc
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
operator|(
name|short
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|version
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fc
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
name|augmentation_data_len
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|augmentation_data
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|augmentation_data_len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fc
operator|->
name|augmentation
argument_list|,
literal|"eh"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|+=
name|addr_size
expr_stmt|;
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fc
operator|->
name|code_factor
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|SLEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
block|}
name|cie
operator|=
name|fc
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|,
name|fc
operator|->
name|augmentation
argument_list|,
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|data_factor
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx CIE\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Version:               %d\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Augmentation:          \"%s\"\n"
argument_list|,
name|fc
operator|->
name|augmentation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Code alignment factor: %u\n"
argument_list|,
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Data alignment factor: %d\n"
argument_list|,
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Return address column: %d\n"
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
if|if
condition|(
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  Augmentation data:    "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|augmentation_data_len
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|augmentation_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|fc
operator|->
name|augmentation
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|augmentation_data
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'L'
condition|)
name|q
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'P'
condition|)
name|q
operator|+=
literal|1
operator|+
name|size_of_encoded_value
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
name|fc
operator|->
name|fde_encoding
operator|=
operator|*
name|q
operator|++
expr_stmt|;
else|else
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|->
name|fde_encoding
condition|)
name|encoded_ptr_size
operator|=
name|size_of_encoded_value
argument_list|(
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
block|}
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|fc
operator|->
name|ra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
modifier|*
name|look_for
decl_stmt|;
specifier|static
name|Frame_Chunk
name|fde_fc
decl_stmt|;
name|fc
operator|=
operator|&
name|fde_fc
expr_stmt|;
name|memset
argument_list|(
name|fc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|look_for
operator|=
name|is_eh
condition|?
name|start
operator|-
literal|4
operator|-
name|cie_id
else|:
name|section_start
operator|+
name|cie_id
expr_stmt|;
for|for
control|(
name|cie
operator|=
name|chunks
init|;
name|cie
condition|;
name|cie
operator|=
name|cie
operator|->
name|next
control|)
if|if
condition|(
name|cie
operator|->
name|chunk_start
operator|==
name|look_for
condition|)
break|break;
if|if
condition|(
operator|!
name|cie
condition|)
block|{
name|warn
argument_list|(
literal|"Invalid CIE pointer %08lx in FDE at %08lx\n"
argument_list|,
name|cie_id
argument_list|,
name|saved_start
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
name|fc
operator|->
name|ncols
operator|=
literal|0
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
operator|(
name|short
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cie
operator|=
name|fc
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
literal|""
expr_stmt|;
name|fc
operator|->
name|fde_encoding
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fc
operator|->
name|ncols
operator|=
name|cie
operator|->
name|ncols
expr_stmt|;
name|fc
operator|->
name|col_type
operator|=
operator|(
name|short
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|cie
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|cie
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|->
name|augmentation
operator|=
name|cie
operator|->
name|augmentation
expr_stmt|;
name|fc
operator|->
name|code_factor
operator|=
name|cie
operator|->
name|code_factor
expr_stmt|;
name|fc
operator|->
name|data_factor
operator|=
name|cie
operator|->
name|data_factor
expr_stmt|;
name|fc
operator|->
name|cfa_reg
operator|=
name|cie
operator|->
name|cfa_reg
expr_stmt|;
name|fc
operator|->
name|cfa_offset
operator|=
name|cie
operator|->
name|cfa_offset
expr_stmt|;
name|fc
operator|->
name|ra
operator|=
name|cie
operator|->
name|ra
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|max_regs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fc
operator|->
name|fde_encoding
operator|=
name|cie
operator|->
name|fde_encoding
expr_stmt|;
block|}
if|if
condition|(
name|fc
operator|->
name|fde_encoding
condition|)
name|encoded_ptr_size
operator|=
name|size_of_encoded_value
argument_list|(
name|fc
operator|->
name|fde_encoding
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|encoded_ptr_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
name|fc
operator|->
name|pc_range
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|encoded_ptr_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
if|if
condition|(
name|cie
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|augmentation_data_len
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|augmentation_data
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|augmentation_data_len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%08lx %08lx %08lx FDE cie=%08x pc=%08lx..%08lx\n"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|saved_start
operator|-
name|section_start
argument_list|)
argument_list|,
name|length
argument_list|,
name|cie_id
argument_list|,
name|cie
operator|->
name|chunk_start
operator|-
name|section_start
argument_list|,
name|fc
operator|->
name|pc_begin
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|fc
operator|->
name|pc_range
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
operator|&&
name|augmentation_data_len
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"  Augmentation data:    "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|augmentation_data_len
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|augmentation_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point, fc is the current chunk, cie (if any) is set, and we're 	 about to interpret instructions for the chunk.  */
if|if
condition|(
name|do_debug_frames_interp
condition|)
block|{
comment|/* Start by making a pass over the chunk, allocating storage            and taking note of what registers are used.  */
name|unsigned
name|char
modifier|*
name|tmp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|block_end
condition|)
block|{
name|unsigned
name|op
decl_stmt|,
name|opa
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|;
name|op
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|opa
operator|=
name|op
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0xc0
condition|)
name|op
operator|&=
literal|0xc0
expr_stmt|;
comment|/* Warning: if you add any more cases to this switch, be 	       sure to add them to the corresponding switch below.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
break|break;
case|case
name|DW_CFA_offset
case|:
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_set_loc
case|:
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|start
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|start
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|start
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|DW_CFA_GNU_args_size
define|#
directive|define
name|DW_CFA_GNU_args_size
value|0x2e
endif|#
directive|endif
case|case
name|DW_CFA_GNU_args_size
case|:
name|LEB
argument_list|()
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|DW_CFA_GNU_negative_offset_extended
define|#
directive|define
name|DW_CFA_GNU_negative_offset_extended
value|0x2f
endif|#
directive|endif
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
default|default:
break|break;
block|}
block|}
name|start
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Now we know what registers are used, make a second pass over          the chunk, this time actually printing out the info.  */
while|while
condition|(
name|start
operator|<
name|block_end
condition|)
block|{
name|unsigned
name|op
decl_stmt|,
name|opa
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|,
name|reg
decl_stmt|,
name|roffs
decl_stmt|;
name|long
name|l
decl_stmt|,
name|ofs
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|op
operator|=
operator|*
name|start
operator|++
expr_stmt|;
name|opa
operator|=
name|op
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|0xc0
condition|)
name|op
operator|&=
literal|0xc0
expr_stmt|;
comment|/* Warning: if you add any more cases to this switch, be 	       sure to add them to the corresponding switch above.  */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc: %d to %08lx\n"
argument_list|,
name|opa
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|opa
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|opa
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset
case|:
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_offset: r%d at cfa%+ld\n"
argument_list|,
name|opa
argument_list|,
name|roffs
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|opa
index|]
operator|=
name|roffs
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore: r%d\n"
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|opa
index|]
operator|=
name|cie
operator|->
name|col_type
index|[
name|opa
index|]
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|opa
index|]
operator|=
name|cie
operator|->
name|col_offset
index|[
name|opa
index|]
expr_stmt|;
break|break;
case|case
name|DW_CFA_set_loc
case|:
name|vma
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
name|encoded_ptr_size
argument_list|)
expr_stmt|;
name|start
operator|+=
name|encoded_ptr_size
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_set_loc: %08lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|vma
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|=
name|vma
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc1: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc2: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|ofs
operator|=
name|byte_get
argument_list|(
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  DW_CFA_advance_loc4: %ld to %08lx\n"
argument_list|,
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|,
name|fc
operator|->
name|pc_begin
operator|+
name|ofs
operator|*
name|fc
operator|->
name|code_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|pc_begin
operator|+=
name|ofs
operator|*
name|fc
operator|->
name|code_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_offset_extended: r%ld at cfa%+ld\n"
argument_list|,
name|reg
argument_list|,
name|roffs
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|roffs
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore_extended: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|cie
operator|->
name|col_type
index|[
name|reg
index|]
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|cie
operator|->
name|col_offset
index|[
name|reg
index|]
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_undefined: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_undefined
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_same_value: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_same_value
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|roffs
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_register: r%ld\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_register
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|roffs
expr_stmt|;
break|break;
case|case
name|DW_CFA_remember_state
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_remember_state\n"
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|(
name|Frame_Chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Frame_Chunk
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|ncols
operator|=
name|fc
operator|->
name|ncols
expr_stmt|;
name|rs
operator|->
name|col_type
operator|=
operator|(
name|short
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|rs
operator|->
name|ncols
operator|*
expr|sizeof
operator|(
name|short
name|int
operator|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|col_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rs
operator|->
name|col_type
argument_list|,
name|fc
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|ncols
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rs
operator|->
name|col_offset
argument_list|,
name|fc
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|next
operator|=
name|remembered_state
expr_stmt|;
name|remembered_state
operator|=
name|rs
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_state
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_restore_state\n"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|remembered_state
expr_stmt|;
name|remembered_state
operator|=
name|rs
operator|->
name|next
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|rs
operator|->
name|ncols
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|col_type
argument_list|,
name|rs
operator|->
name|ncols
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fc
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|col_offset
argument_list|,
name|rs
operator|->
name|ncols
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
operator|->
name|col_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
operator|->
name|col_offset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rs
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|fc
operator|->
name|cfa_reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|fc
operator|->
name|cfa_offset
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa: r%d ofs %d\n"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|fc
operator|->
name|cfa_reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_reg: r%d\n"
argument_list|,
name|fc
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|fc
operator|->
name|cfa_offset
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_def_cfa_offset: %d\n"
argument_list|,
name|fc
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_nop
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_nop\n"
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|DW_CFA_GNU_window_save
define|#
directive|define
name|DW_CFA_GNU_window_save
value|0x2d
endif|#
directive|endif
case|case
name|DW_CFA_GNU_window_save
case|:
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_window_save\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|ul
operator|=
name|LEB
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_args_size: %ld\n"
argument_list|,
name|ul
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
name|reg
operator|=
name|LEB
argument_list|()
expr_stmt|;
name|l
operator|=
operator|-
name|LEB
argument_list|()
expr_stmt|;
name|frame_need_space
argument_list|(
name|fc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_debug_frames_interp
condition|)
name|printf
argument_list|(
literal|"  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n"
argument_list|,
name|reg
argument_list|,
name|l
operator|*
name|fc
operator|->
name|data_factor
argument_list|)
expr_stmt|;
name|fc
operator|->
name|col_type
index|[
name|reg
index|]
operator|=
name|DW_CFA_offset
expr_stmt|;
name|fc
operator|->
name|col_offset
index|[
name|reg
index|]
operator|=
name|l
operator|*
name|fc
operator|->
name|data_factor
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unsupported or unknown DW_CFA_%d\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_debug_frames_interp
condition|)
name|frame_display_row
argument_list|(
name|fc
argument_list|,
operator|&
name|need_col_headers
argument_list|,
operator|&
name|max_regs
argument_list|)
expr_stmt|;
name|start
operator|=
name|block_end
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|GET
end_undef

begin_undef
undef|#
directive|undef
name|LEB
end_undef

begin_undef
undef|#
directive|undef
name|SLEB
end_undef

begin_function
specifier|static
name|int
name|display_debug_not_supported
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Displaying the debug contents of section %s is not yet supported.\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Pre-scan the .debug_info section to record the size of address.    When dumping the .debug_line, we use that size information, assuming    that all compilation units have the same address size.  */
end_comment

begin_function
specifier|static
name|int
name|prescan_debug_info
parameter_list|(
name|section
parameter_list|,
name|start
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|DWARF2_External_CompUnit
modifier|*
name|external
decl_stmt|;
name|external
operator|=
operator|(
name|DWARF2_External_CompUnit
operator|*
operator|)
name|start
expr_stmt|;
name|debug_line_pointer_size
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|cu_pointer_size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A structure containing the name of a debug section and a pointer      to a function that can decode it.  The third field is a prescan      function to be run over the section before displaying any of the      sections.  */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|* display
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
name|int
argument_list|(
argument|* prescan
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|Elf32_Internal_Shdr
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
name|debug_displays
index|[]
init|=
block|{
block|{
literal|".debug_info"
block|,
name|display_debug_info
block|,
name|prescan_debug_info
block|}
block|,
block|{
literal|".debug_abbrev"
block|,
name|display_debug_abbrev
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_line"
block|,
name|display_debug_lines
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_aranges"
block|,
name|display_debug_aranges
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_pubnames"
block|,
name|display_debug_pubnames
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_frame"
block|,
name|display_debug_frames
block|,
name|NULL
block|}
block|,
block|{
literal|".eh_frame"
block|,
name|display_debug_frames
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_macinfo"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_str"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_static_func"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_static_vars"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_types"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|,
block|{
literal|".debug_weaknames"
block|,
name|display_debug_not_supported
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|display_debug_section
parameter_list|(
name|section
parameter_list|,
name|file
parameter_list|)
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' has no debugging data.\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|GET_DATA_ALLOC
argument_list|(
argument|section->sh_offset
argument_list|,
argument|length
argument_list|,
argument|start
argument_list|,
argument|unsigned char *
argument_list|,
literal|"debug section data"
argument_list|)
empty_stmt|;
comment|/* See if we know how to display the contents of this section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce.wi."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|=
literal|".debug_info"
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|debug_displays
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|debug_displays
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug_displays
index|[
name|i
index|]
operator|.
name|display
argument_list|(
name|section
argument_list|,
name|start
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Unrecognised debug section: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* If we loaded in the abbrev section at some point,      we must release it here.  */
if|if
condition|(
name|first_abbrev
operator|!=
name|NULL
condition|)
name|free_abbrevs
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_section_contents
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf32_Internal_Shdr
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|do_dump
condition|)
return|return
literal|1
return|;
comment|/* Pre-scan the debug sections to find some debug information not      present in some of them.  For the .debug_line, we must find out the      size of address (specified in .debug_info and .debug_aranges).  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
operator|&&
name|i
operator|<
name|num_dump_sects
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
name|SECTION_NAME
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|sh_size
operator|==
literal|0
condition|)
continue|continue;
comment|/* See if there is some pre-scan operation for this section.  */
for|for
control|(
name|j
operator|=
name|NUM_ELEM
argument_list|(
name|debug_displays
argument_list|)
init|;
name|j
operator|--
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|debug_displays
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug_displays
index|[
name|j
index|]
operator|.
name|prescan
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|start
decl_stmt|;
name|length
operator|=
name|section
operator|->
name|sh_size
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
argument|section->sh_offset
argument_list|,
argument|length
argument_list|,
argument|start
argument_list|,
argument|unsigned char *
argument_list|,
literal|"debug section data"
argument_list|)
empty_stmt|;
name|debug_displays
index|[
name|j
index|]
operator|.
name|prescan
argument_list|(
name|section
argument_list|,
name|start
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|section_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_shnum
operator|&&
name|i
operator|<
name|num_dump_sects
condition|;
name|i
operator|++
operator|,
name|section
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DISASS_DUMP
condition|)
name|disassemble_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|HEX_DUMP
condition|)
name|dump_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_sects
index|[
name|i
index|]
operator|&
name|DEBUG_DUMP
condition|)
name|display_debug_section
argument_list|(
name|section
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num_dump_sects
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"Some sections were not dumped because they do not exist!\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_mips_fpe_exception
parameter_list|(
name|mask
parameter_list|)
name|int
name|mask
decl_stmt|;
block|{
if|if
condition|(
name|mask
condition|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INEX
condition|)
name|fputs
argument_list|(
literal|"INEX"
argument_list|,
name|stdout
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_UFLO
condition|)
name|printf
argument_list|(
literal|"%sUFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_OFLO
condition|)
name|printf
argument_list|(
literal|"%sOFLO"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_DIV0
condition|)
name|printf
argument_list|(
literal|"%sDIV0"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
operator|,
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|OEX_FPU_INVAL
condition|)
name|printf
argument_list|(
literal|"%sINVAL"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|"|"
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_mips_specific
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf_Internal_Dyn
modifier|*
name|entry
decl_stmt|;
name|size_t
name|liblist_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|liblistno
init|=
literal|0
decl_stmt|;
name|size_t
name|conflictsno
init|=
literal|0
decl_stmt|;
name|size_t
name|options_offset
init|=
literal|0
decl_stmt|;
name|size_t
name|conflicts_offset
init|=
literal|0
decl_stmt|;
comment|/* We have a lot of special sections.  Thanks SGI!  */
if|if
condition|(
name|dynamic_segment
operator|==
name|NULL
condition|)
comment|/* No information available.  */
return|return
literal|0
return|;
for|for
control|(
name|entry
operator|=
name|dynamic_segment
init|;
name|entry
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
operator|++
name|entry
control|)
switch|switch
condition|(
name|entry
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_MIPS_LIBLIST
case|:
name|liblist_offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LIBLISTNO
case|:
name|liblistno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|options_offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICT
case|:
name|conflicts_offset
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
operator|-
name|loadaddr
expr_stmt|;
break|break;
case|case
name|DT_MIPS_CONFLICTNO
case|:
name|conflictsno
operator|=
name|entry
operator|->
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|liblist_offset
operator|!=
literal|0
operator|&&
name|liblistno
operator|!=
literal|0
operator|&&
name|do_dynamic
condition|)
block|{
name|Elf32_External_Lib
modifier|*
name|elib
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|liblist_offset
argument_list|,
name|liblistno
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Lib
argument_list|)
argument_list|,
name|elib
argument_list|,
name|Elf32_External_Lib
operator|*
argument_list|,
literal|"liblist"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSection '.liblist' contains %lu entries:\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|liblistno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"     Library              Time Stamp          Checksum   Version Flags\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|liblistno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf32_Lib
name|liblist
decl_stmt|;
name|time_t
name|time
decl_stmt|;
name|char
name|timebuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|tmp
decl_stmt|;
name|liblist
operator|.
name|l_name
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_name
argument_list|)
expr_stmt|;
name|time
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_time_stamp
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_checksum
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_checksum
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_version
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_version
argument_list|)
expr_stmt|;
name|liblist
operator|.
name|l_flags
operator|=
name|BYTE_GET
argument_list|(
name|elib
index|[
name|cnt
index|]
operator|.
name|l_flags
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gmtime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|timebuf
argument_list|,
literal|"%04u-%02u-%02uT%02u:%02u:%02u"
argument_list|,
name|tmp
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|tmp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tmp
operator|->
name|tm_mday
argument_list|,
name|tmp
operator|->
name|tm_hour
argument_list|,
name|tmp
operator|->
name|tm_min
argument_list|,
name|tmp
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3lu: %-20s %s %#10lx %-7ld"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|,
name|dynamic_strings
operator|+
name|liblist
operator|.
name|l_name
argument_list|,
name|timebuf
argument_list|,
name|liblist
operator|.
name|l_checksum
argument_list|,
name|liblist
operator|.
name|l_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|liblist
operator|.
name|l_flags
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|" NONE"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
name|l_flags_vals
index|[]
init|=
block|{
block|{
literal|" EXACT_MATCH"
block|,
name|LL_EXACT_MATCH
block|}
block|,
block|{
literal|" IGNORE_INT_VER"
block|,
name|LL_IGNORE_INT_VER
block|}
block|,
block|{
literal|" REQUIRE_MINOR"
block|,
name|LL_REQUIRE_MINOR
block|}
block|,
block|{
literal|" EXPORTS"
block|,
name|LL_EXPORTS
block|}
block|,
block|{
literal|" DELAY_LOAD"
block|,
name|LL_DELAY_LOAD
block|}
block|,
block|{
literal|" DELTA"
block|,
name|LL_DELTA
block|}
block|}
struct|;
name|int
name|flags
init|=
name|liblist
operator|.
name|l_flags
decl_stmt|;
name|size_t
name|fcnt
decl_stmt|;
for|for
control|(
name|fcnt
operator|=
literal|0
init|;
name|fcnt
operator|<
sizeof|sizeof
argument_list|(
name|l_flags_vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|l_flags_vals
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|fcnt
control|)
if|if
condition|(
operator|(
name|flags
operator|&
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
operator|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|flags
operator|^=
name|l_flags_vals
index|[
name|fcnt
index|]
operator|.
name|bit
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" %#x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|flags
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|elib
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options_offset
operator|!=
literal|0
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eopt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|sect
init|=
name|section_headers
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|iopt
decl_stmt|;
name|Elf_Internal_Options
modifier|*
name|option
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Find the section header so that we get the size.  */
while|while
condition|(
name|sect
operator|->
name|sh_type
operator|!=
name|SHT_MIPS_OPTIONS
condition|)
operator|++
name|sect
expr_stmt|;
name|GET_DATA_ALLOC
argument_list|(
name|options_offset
argument_list|,
name|sect
operator|->
name|sh_size
argument_list|,
name|eopt
argument_list|,
name|Elf_External_Options
operator|*
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
name|iopt
operator|=
operator|(
name|Elf_Internal_Options
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|sect
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|eopt
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iopt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iopt
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|offset
operator|=
name|cnt
operator|=
literal|0
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|sect
operator|->
name|sh_size
condition|)
block|{
name|Elf_External_Options
modifier|*
name|eoption
decl_stmt|;
name|eoption
operator|=
operator|(
name|Elf_External_Options
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|eopt
operator|+
name|offset
operator|)
expr_stmt|;
name|option
operator|->
name|kind
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|kind
argument_list|)
expr_stmt|;
name|option
operator|->
name|size
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|size
argument_list|)
expr_stmt|;
name|option
operator|->
name|section
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|section
argument_list|)
expr_stmt|;
name|option
operator|->
name|info
operator|=
name|BYTE_GET
argument_list|(
name|eoption
operator|->
name|info
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|option
operator|->
name|size
expr_stmt|;
operator|++
name|option
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '%s' contains %d entries:\n"
argument_list|)
argument_list|,
name|SECTION_NAME
argument_list|(
name|sect
argument_list|)
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|option
operator|=
name|iopt
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|option
operator|->
name|kind
condition|)
block|{
case|case
name|ODK_NULL
case|:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" NULL       %d %lx"
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_REGINFO
case|:
name|printf
argument_list|(
literal|" REGINFO    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_header
operator|.
name|e_machine
operator|==
name|EM_MIPS
condition|)
block|{
comment|/* 32bit form.  */
name|Elf32_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x%lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 64 bit form.  */
name|Elf64_External_RegInfo
modifier|*
name|ereg
decl_stmt|;
name|Elf64_Internal_RegInfo
name|reginfo
decl_stmt|;
name|ereg
operator|=
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|option
operator|+
literal|1
operator|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|BYTE_GET
argument_list|(
name|ereg
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gp_value
operator|=
name|BYTE_GET8
argument_list|(
name|ereg
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GPR %08lx  GP 0x"
argument_list|,
name|reginfo
operator|.
name|ri_gprmask
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|reginfo
operator|.
name|ri_gp_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|option
expr_stmt|;
continue|continue;
case|case
name|ODK_EXCEPTIONS
case|:
name|fputs
argument_list|(
literal|" EXCEPTIONS fpe_min("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MIN
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") fpe_max("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|process_mips_fpe_exception
argument_list|(
operator|(
name|option
operator|->
name|info
operator|&
name|OEX_FPU_MAX
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_PAGE0
condition|)
name|fputs
argument_list|(
literal|" PAGE0"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_SMM
condition|)
name|fputs
argument_list|(
literal|" SMM"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_FPDBUG
condition|)
name|fputs
argument_list|(
literal|" FPDBUG"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OEX_DISMISS
condition|)
name|fputs
argument_list|(
literal|" DISMISS"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_PAD
case|:
name|fputs
argument_list|(
literal|" PAD       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_PREFIX
condition|)
name|fputs
argument_list|(
literal|" PREFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_POSTFIX
condition|)
name|fputs
argument_list|(
literal|" POSTFIX"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OPAD_SYMBOL
condition|)
name|fputs
argument_list|(
literal|" SYMBOL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWPATCH
case|:
name|fputs
argument_list|(
literal|" HWPATCH   "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R4KEOP
condition|)
name|fputs
argument_list|(
literal|" R4KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R8KPFETCH
condition|)
name|fputs
argument_list|(
literal|" R8KPFETCH"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KEOP
condition|)
name|fputs
argument_list|(
literal|" R5KEOP"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHW_R5KCVTL
condition|)
name|fputs
argument_list|(
literal|" R5KCVTL"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_FILL
case|:
name|fputs
argument_list|(
literal|" FILL       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_TAGS
case|:
name|fputs
argument_list|(
literal|" TAGS       "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* XXX Print content of info word?  */
break|break;
case|case
name|ODK_HWAND
case|:
name|fputs
argument_list|(
literal|" HWAND     "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_HWOR
case|:
name|fputs
argument_list|(
literal|" HWOR      "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CHECKED
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CHECKED"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|info
operator|&
name|OHWA0_R4KEOP_CLEAN
condition|)
name|fputs
argument_list|(
literal|" R4KEOP_CLEAN"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_GP_GROUP
case|:
name|printf
argument_list|(
literal|" GP_GROUP  %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|ODK_IDENT
case|:
name|printf
argument_list|(
literal|" IDENT     %#06lx  self-contained %#06lx"
argument_list|,
name|option
operator|->
name|info
operator|&
name|OGP_GROUP
argument_list|,
operator|(
name|option
operator|->
name|info
operator|&
name|OGP_SELF
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This shouldn't happen.  */
name|printf
argument_list|(
literal|" %3d ???     %d %lx"
argument_list|,
name|option
operator|->
name|kind
argument_list|,
name|option
operator|->
name|section
argument_list|,
name|option
operator|->
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eopt
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|option
operator|->
name|size
condition|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|>=
literal|' '
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
index|]
operator|<
literal|0x7f
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|option
operator|)
index|[
name|len
operator|++
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|option
expr_stmt|;
block|}
name|free
argument_list|(
name|eopt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conflicts_offset
operator|!=
literal|0
operator|&&
name|conflictsno
operator|!=
literal|0
condition|)
block|{
name|Elf32_External_Conflict
modifier|*
name|econf32
decl_stmt|;
name|Elf64_External_Conflict
modifier|*
name|econf64
decl_stmt|;
name|Elf32_Conflict
modifier|*
name|iconf
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
if|if
condition|(
name|dynamic_symbols
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"conflict list with without table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iconf
operator|=
operator|(
name|Elf32_Conflict
operator|*
operator|)
name|malloc
argument_list|(
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iconf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iconf
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|GET_DATA_ALLOC
argument_list|(
name|conflicts_offset
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|econf32
argument_list|)
argument_list|,
name|econf32
argument_list|,
name|Elf32_External_Conflict
operator|*
argument_list|,
literal|"conflict"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf32
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_DATA_ALLOC
argument_list|(
name|conflicts_offset
argument_list|,
name|conflictsno
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|econf64
argument_list|)
argument_list|,
name|econf64
argument_list|,
name|Elf64_External_Conflict
operator|*
argument_list|,
literal|"conflict"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
name|iconf
index|[
name|cnt
index|]
operator|=
name|BYTE_GET
argument_list|(
name|econf64
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nSection '.conflict' contains %d entries:\n"
argument_list|)
argument_list|,
name|conflictsno
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Num:    Index       Value  Name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|conflictsno
condition|;
operator|++
name|cnt
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|psym
init|=
operator|&
name|dynamic_symbols
index|[
name|iconf
index|[
name|cnt
index|]
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%5lu: %8lu  "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|,
name|iconf
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|print_vma
argument_list|(
name|psym
operator|->
name|st_value
argument_list|,
name|FULL_HEX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|dynamic_strings
operator|+
name|psym
operator|->
name|st_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iconf
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_note_type
parameter_list|(
name|e_type
parameter_list|)
name|unsigned
name|e_type
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|e_type
condition|)
block|{
case|case
name|NT_PRSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PRSTATUS (prstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGSET
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGSET (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PRPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PRPSINFO (prpsinfo structure)"
argument_list|)
return|;
case|case
name|NT_TASKSTRUCT
case|:
return|return
name|_
argument_list|(
literal|"NT_TASKSTRUCT (task structure)"
argument_list|)
return|;
case|case
name|NT_PRXFPREG
case|:
return|return
name|_
argument_list|(
literal|"NT_PRXFPREG (user_xfpregs structure)"
argument_list|)
return|;
case|case
name|NT_PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_PSTATUS (pstatus structure)"
argument_list|)
return|;
case|case
name|NT_FPREGS
case|:
return|return
name|_
argument_list|(
literal|"NT_FPREGS (floating point registers)"
argument_list|)
return|;
case|case
name|NT_PSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_PSINFO (psinfo structure)"
argument_list|)
return|;
case|case
name|NT_LWPSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSTATUS (lwpstatus_t structure)"
argument_list|)
return|;
case|case
name|NT_LWPSINFO
case|:
return|return
name|_
argument_list|(
literal|"NT_LWPSINFO (lwpsinfo_t structure)"
argument_list|)
return|;
case|case
name|NT_WIN32PSTATUS
case|:
return|return
name|_
argument_list|(
literal|"NT_WIN32PSTATUS (win32_pstatus strcuture)"
argument_list|)
return|;
default|default:
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"Unknown note type: (0x%08x)"
argument_list|)
argument_list|,
name|e_type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_comment
comment|/* Note that by the ELF standard, the name field is already null byte    terminated, and namesz includes the terminating null byte.    I.E. the value of namesz for the name "FSF" is 4.     If the value of namesz is zero, there is no name present. */
end_comment

begin_function
specifier|static
name|int
name|process_note
parameter_list|(
name|pnote
parameter_list|)
name|Elf32_Internal_Note
modifier|*
name|pnote
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"  %s\t\t0x%08lx\t%s\n"
argument_list|,
name|pnote
operator|->
name|namesz
condition|?
name|pnote
operator|->
name|namedata
else|:
literal|"(NONE)"
argument_list|,
name|pnote
operator|->
name|descsz
argument_list|,
name|get_note_type
argument_list|(
name|pnote
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segment
parameter_list|(
name|file
parameter_list|,
name|offset
parameter_list|,
name|length
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|length
decl_stmt|;
block|{
name|Elf_External_Note
modifier|*
name|pnotes
decl_stmt|;
name|Elf_External_Note
modifier|*
name|external
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|GET_DATA_ALLOC
argument_list|(
name|offset
argument_list|,
name|length
argument_list|,
name|pnotes
argument_list|,
name|Elf_External_Note
operator|*
argument_list|,
literal|"notes"
argument_list|)
expr_stmt|;
name|external
operator|=
name|pnotes
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nNotes at offset 0x%08lx with length 0x%08lx:\n"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Owner\t\tData size\tDescription\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|external
operator|<
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|+
name|length
operator|)
condition|)
block|{
name|Elf32_Internal_Note
name|inote
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|NULL
decl_stmt|;
name|inote
operator|.
name|type
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|type
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namesz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|namesz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|namedata
operator|=
name|external
operator|->
name|name
expr_stmt|;
name|inote
operator|.
name|descsz
operator|=
name|BYTE_GET
argument_list|(
name|external
operator|->
name|descsz
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descdata
operator|=
name|inote
operator|.
name|namedata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|namesz
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|inote
operator|.
name|descpos
operator|=
name|offset
operator|+
operator|(
name|inote
operator|.
name|descdata
operator|-
operator|(
name|char
operator|*
operator|)
name|pnotes
operator|)
expr_stmt|;
name|external
operator|=
operator|(
name|Elf_External_Note
operator|*
operator|)
operator|(
name|inote
operator|.
name|descdata
operator|+
name|align_power
argument_list|(
name|inote
operator|.
name|descsz
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
comment|/* Verify that name is null terminated.  It appears that at least 	 one version of Linux (RedHat 6.0) generates corefiles that don't 	 comply with the ELF spec by failing to include the null byte in 	 namesz.  */
if|if
condition|(
name|inote
operator|.
name|namedata
index|[
name|inote
operator|.
name|namesz
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|temp
operator|=
name|malloc
argument_list|(
name|inote
operator|.
name|namesz
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|temp
argument_list|,
name|inote
operator|.
name|namedata
argument_list|,
name|inote
operator|.
name|namesz
argument_list|)
expr_stmt|;
name|temp
index|[
name|inote
operator|.
name|namesz
index|]
operator|=
literal|0
expr_stmt|;
comment|/* warn (_("'%s' NOTE name not properly null terminated\n"), temp);  */
name|inote
operator|.
name|namedata
operator|=
name|temp
expr_stmt|;
block|}
name|res
operator|&=
name|process_note
argument_list|(
operator|&
name|inote
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pnotes
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_note_segments
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|Elf_Internal_Phdr
modifier|*
name|program_headers
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|segment
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|res
init|=
literal|1
decl_stmt|;
name|program_headers
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|malloc
argument_list|(
name|elf_header
operator|.
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_headers
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Out of memory\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|is_32bit_elf
condition|)
name|i
operator|=
name|get_32bit_program_headers
argument_list|(
name|file
argument_list|,
name|program_headers
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|get_64bit_program_headers
argument_list|(
name|file
argument_list|,
name|program_headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|segment
operator|=
name|program_headers
init|;
name|i
operator|<
name|elf_header
operator|.
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|segment
operator|++
control|)
block|{
if|if
condition|(
name|segment
operator|->
name|p_type
operator|==
name|PT_NOTE
condition|)
name|res
operator|&=
name|process_corefile_note_segment
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_offset
argument_list|,
operator|(
name|bfd_vma
operator|)
name|segment
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|program_headers
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_corefile_contents
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
comment|/* If we have not been asked to display the notes then do nothing.  */
if|if
condition|(
operator|!
name|do_notes
condition|)
return|return
literal|1
return|;
comment|/* If file is not a core file then exit.  */
if|if
condition|(
name|elf_header
operator|.
name|e_type
operator|!=
name|ET_CORE
condition|)
return|return
literal|1
return|;
comment|/* No program headers means no NOTE segment.  */
if|if
condition|(
name|elf_header
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"No note segments present in the core file.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|process_corefile_note_segments
argument_list|(
name|file
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_arch_specific
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|do_arch
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|elf_header
operator|.
name|e_machine
condition|)
block|{
case|case
name|EM_MIPS
case|:
case|case
name|EM_MIPS_RS3_LE
case|:
return|return
name|process_mips_specific
argument_list|(
name|file
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_file_header
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
comment|/* Read in the identity array.  */
if|if
condition|(
name|fread
argument_list|(
name|elf_header
operator|.
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Determine how to read the rest of the header.  */
switch|switch
condition|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
default|default:
comment|/* fall through */
case|case
name|ELFDATANONE
case|:
comment|/* fall through */
case|case
name|ELFDATA2LSB
case|:
name|byte_get
operator|=
name|byte_get_little_endian
expr_stmt|;
break|break;
case|case
name|ELFDATA2MSB
case|:
name|byte_get
operator|=
name|byte_get_big_endian
expr_stmt|;
break|break;
block|}
comment|/* For now we only support 32 bit and 64 bit ELF files.  */
name|is_32bit_elf
operator|=
operator|(
name|elf_header
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS64
operator|)
expr_stmt|;
comment|/* Read in the rest of the header.  */
if|if
condition|(
name|is_32bit_elf
condition|)
block|{
name|Elf32_External_Ehdr
name|ehdr32
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr32
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr32
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Elf64_External_Ehdr
name|ehdr64
decl_stmt|;
comment|/* If we have been compiled with sizeof (bfd_vma) == 4, then 	 we will not be able to cope with the 64bit data found in 	 64 ELF files.  Detect this now and abort before we start 	 overwritting things.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|<
literal|8
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"This instance of readelf has been built without support for a\n"
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|_
argument_list|(
literal|"64 bit data type and so it cannot read 64 bit ELF files.\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|,
sizeof|sizeof
argument_list|(
name|ehdr64
argument_list|)
operator|-
name|EI_NIDENT
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
name|elf_header
operator|.
name|e_type
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_type
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_machine
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_machine
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_version
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_version
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_entry
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_entry
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phoff
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_phoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shoff
operator|=
name|BYTE_GET8
argument_list|(
name|ehdr64
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_flags
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_flags
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_ehsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_ehsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_phnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_phnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shentsize
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shnum
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|elf_header
operator|.
name|e_shstrndx
operator|=
name|BYTE_GET
argument_list|(
name|ehdr64
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_file
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file_name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot stat input file %s.\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Input file %s not found.\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|get_file_header
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"%s: Failed to read file header\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Initialise per file variables.  */
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|version_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|version_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ELEM
argument_list|(
name|dynamic_info
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
name|dynamic_info
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Process the file.  */
if|if
condition|(
name|show_name
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nFile: %s\n"
argument_list|)
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process_file_header
argument_list|()
condition|)
block|{
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
name|process_section_headers
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_program_headers
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_dynamic_segment
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_relocs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_unwind
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_symbol_table
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_syminfo
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_version_sections
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_section_contents
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_corefile_contents
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|process_arch_specific
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_headers
condition|)
block|{
name|free
argument_list|(
name|section_headers
argument_list|)
expr_stmt|;
name|section_headers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|string_table
condition|)
block|{
name|free
argument_list|(
name|string_table
argument_list|)
expr_stmt|;
name|string_table
operator|=
name|NULL
expr_stmt|;
name|string_table_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_strings
condition|)
block|{
name|free
argument_list|(
name|dynamic_strings
argument_list|)
expr_stmt|;
name|dynamic_strings
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_symbols
condition|)
block|{
name|free
argument_list|(
name|dynamic_symbols
argument_list|)
expr_stmt|;
name|dynamic_symbols
operator|=
name|NULL
expr_stmt|;
name|num_dynamic_syms
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dynamic_syminfo
condition|)
block|{
name|free
argument_list|(
name|dynamic_syminfo
argument_list|)
expr_stmt|;
name|dynamic_syminfo
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_DISASSEMBLY
end_ifdef

begin_comment
comment|/* Needed by the i386 disassembler.  For extra credit, someone could    fix this so that we insert symbolic addresses here, esp for GOT/PLT    symbols */
end_comment

begin_function
name|void
name|print_address
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"0x%8.8x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed by the i386 disassembler. */
end_comment

begin_function
name|void
name|db_task_printsym
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
name|show_name
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|process_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_sects
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dump_sects
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

