begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dlltool.c -- tool to generate stuff for PE style DLLs     Copyright (C) 1995, 96, 1997 Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*    This program allows you to build the files necessary to create    DLLs to run on a system which understands PE format image files.    (eg, Windows NT)     See "Peering Inside the PE: A Tour of the Win32 Portable Executable    File Format", MSJ 1994, Volume 9 for more information.    Also see "Microsoft Portable Executable and Common Object File Format,    Specification 4.1" for more information.     A DLL contains an export table which contains the information    which the runtime loader needs to tie up references from a    referencing program.      The export table is generated by this program by reading    in a .DEF file or scanning the .a and .o files which will be in the    DLL.  A .o file can contain information in special  ".drectve" sections    with export information.       A DEF file contains any number of the following commands:      NAME<name> [ ,<base> ]     The result is going to be<name>.EXE     LIBRARY<name> [ ,<base> ]        The result is going to be<name>.DLL     EXPORTS  (<name1> [ =<name2> ] [ @<integer> ] [ NONAME ] [CONSTANT] ) *    Declares name1 as an exported symbol from the    DLL, with optional ordinal number<integer>     IMPORTS  ( [<name> = ]<name> .<name> ) *    Ignored for compatibility     DESCRIPTION<string>    Puts<string> into output .exp file in the .rdata section     [STACKSIZE|HEAPSIZE]<number-reserve> [ ,<number-commit> ]    Generates --stack|--heap<number-reserve>,<number-commit>    in the output .drectve section.  The linker will    see this and act upon it.     [CODE|DATA]<attr>+    SECTIONS (<sectionname><attr>+ )*<attr> = READ | WRITE | EXECUTE | SHARED    Generates --attr<sectionname><attr> in the output    .drectve section.  The linker will see this and act    upon it.      A -export:<name> in a .drectve section in an input .o or .a    file to this program is equivalent to a EXPORTS<name>    in a .DEF file.       The program generates output files with the prefix supplied    on the command line, or in the def file, or taken from the first     supplied argument.     The .exp.s file contains the information necessary to export    the routines in the DLL.  The .lib.s file contains the information    necessary to use the DLL's routines from a referencing program.       Example:     file1.c:     asm (".section .drectve");      asm (".ascii \"-export:adef\"");     adef(char *s)    {    printf("hello from the dll %s\n",s);    }     bdef(char *s)    {    printf("hello from the dll and the other entry point %s\n",s);    }     file2.c:    asm (".section .drectve");    asm (".ascii \"-export:cdef\"");    asm (".ascii \"-export:ddef\"");    cdef(char *s)    {    printf("hello from the dll %s\n",s);    }     ddef(char *s)    {    printf("hello from the dll and the other entry point %s\n",s);    }     printf()    {    return 9;    }     main.c     main()    {    cdef();    }     thedll.def     LIBRARY thedll    HEAPSIZE 0x40000, 0x2000    EXPORTS bdef @ 20    cdef @ 30 NONAME      SECTIONS donkey READ WRITE    aardvark EXECUTE      # compile up the parts of the dll     gcc -c file1.c           gcc -c file2.c     # put them in a library (you don't have to, you    # could name all the .os on the dlltool line)     ar  qcv thedll.in file1.o file2.o    ranlib thedll.in     # run this tool over the library and the def file    ./dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a     # build the dll with the library with file1.o, file2.o and the export table    ld -o thedll.dll thedll.o thedll.in     # build the mainline    gcc -c themain.c      # link the executable with the import library    ld -e main -Tthemain.ld -o themain.exe themain.o thedll.a   */
end_comment

begin_comment
comment|/* .idata section description     The .idata section is the import table.  It is a collection of several    subsections used to keep the pieces for each dll together: .idata$[234567].    IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.     .idata$2 = Import Directory Table    = array of IMAGE_IMPORT_DESCRIPTOR's.  	DWORD   Characteristics;      - pointer to .idata$4 	DWORD   TimeDateStamp;        - currently always 0 	DWORD   ForwarderChain;       - currently always 0 	DWORD   Name;                 - pointer to dll's name 	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5     .idata$3 = null terminating entry for .idata$2.     .idata$4 = Import Lookup Table    = array of array of pointers to hint name table.    There is one for each dll being imported from, and each dll's set is    terminated by a trailing NULL.     .idata$5 = Import Address Table    = array of array of pointers to hint name table.    There is one for each dll being imported from, and each dll's set is    terminated by a trailing NULL.    Initially, this table is identical to the Import Lookup Table.  However,    at load time, the loader overwrites the entries with the address of the    function.     .idata$6 = Hint Name Table    = Array of { short, asciz } entries, one for each imported function.    The `short' is the function's ordinal number.     .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc) */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file.  */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|show_allnames
value|0
end_define

begin_define
define|#
directive|define
name|PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|PAGE_MASK
value|(-PAGE_SIZE)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|(((w)&0377) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|(((w)&0377) != 0177&& ((w)&~0377) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|((w)& 0177)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|w
parameter_list|)
value|(((w)>> 8)& 0377)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VFORK_H
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|as_name
init|=
literal|"as"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_idata4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_idata5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|exp_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|imp_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|head_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|imp_name_lab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dll_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_indirect
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dontdeltemps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|yyparse
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|def_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|killat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|output_def
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|base_file
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_ARM
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mname
init|=
literal|"arm"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_I386
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mname
init|=
literal|"i386"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mname
init|=
literal|"ppc"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PATHMAX
value|250
end_define

begin_comment
comment|/* What's the right name for this ? */
end_comment

begin_comment
comment|/* This bit of assemly does jmp * .... s set how_jtab_roff to mark where the 32bit abs branch should go */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|i386_jtab
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|arm_jtab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0xc0
block|,
literal|0x9f
block|,
literal|0xe5
block|,
literal|0x00
block|,
literal|0xf0
block|,
literal|0x9c
block|,
literal|0xe5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the glue sequence for PowerPC PE. There is a  */
end_comment

begin_comment
comment|/* tocrel16-tocdefn reloc against the first instruction. */
end_comment

begin_comment
comment|/* We also need a IMGLUE reloc against the glue function */
end_comment

begin_comment
comment|/* to restore the toc saved by the third instruction in  */
end_comment

begin_comment
comment|/* the glue. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|ppc_jtab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x62
block|,
literal|0x81
block|,
comment|/* lwz r11,0(r2)               */
comment|/*   Reloc TOCREL16 __imp_xxx  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x8B
block|,
literal|0x81
block|,
comment|/* lwz r12,0(r11)              */
literal|0x04
block|,
literal|0x00
block|,
literal|0x41
block|,
literal|0x90
block|,
comment|/* stw r2,4(r1)                */
literal|0xA6
block|,
literal|0x03
block|,
literal|0x89
block|,
literal|0x7D
block|,
comment|/* mtctr r12                   */
literal|0x04
block|,
literal|0x00
block|,
literal|0x4B
block|,
literal|0x80
block|,
comment|/* lwz r2,4(r11)               */
literal|0x20
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x4E
comment|/* bctr                        */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the glue instruction, picks up the toc from the stw in */
end_comment

begin_comment
comment|/* the above code: "lwz r2,4(r1)"                         */
end_comment

begin_decl_stmt
name|bfd_vma
name|ppc_glue_insn
init|=
literal|0x80410004
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|outfile
index|[
name|PATHMAX
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mac
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|how_byte
decl_stmt|;
name|char
modifier|*
name|how_short
decl_stmt|;
name|char
modifier|*
name|how_long
decl_stmt|;
name|char
modifier|*
name|how_asciz
decl_stmt|;
name|char
modifier|*
name|how_comment
decl_stmt|;
name|char
modifier|*
name|how_jump
decl_stmt|;
name|char
modifier|*
name|how_global
decl_stmt|;
name|char
modifier|*
name|how_space
decl_stmt|;
name|char
modifier|*
name|how_align_short
decl_stmt|;
name|char
modifier|*
name|how_align_long
decl_stmt|;
name|char
modifier|*
name|how_bfd_target
decl_stmt|;
name|enum
name|bfd_architecture
name|how_bfd_arch
decl_stmt|;
name|unsigned
name|char
modifier|*
name|how_jtab
decl_stmt|;
name|int
name|how_jtab_size
decl_stmt|;
comment|/* size of the jtab entry */
name|int
name|how_jtab_roff
decl_stmt|;
comment|/* offset into it for the ind 32 reloc into idata 5 */
block|}
name|mtable
index|[]
init|=
block|{
block|{
define|#
directive|define
name|MARM
value|0
literal|"arm"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"@"
block|,
literal|"ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"pe-arm-little"
block|,
name|bfd_arch_arm
block|,
name|arm_jtab
block|,
sizeof|sizeof
argument_list|(
name|arm_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|M386
value|1
literal|"i386"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"#"
block|,
literal|"jmp *"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"pe-i386"
block|,
name|bfd_arch_i386
block|,
name|i386_jtab
block|,
sizeof|sizeof
argument_list|(
name|i386_jtab
argument_list|)
block|,
literal|2
block|,   }
block|,
block|{
define|#
directive|define
name|MPPC
value|2
literal|"ppc"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"#"
block|,
literal|"jmp *"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"pe-powerpcle"
block|,
name|bfd_arch_powerpc
block|,
name|ppc_jtab
block|,
sizeof|sizeof
argument_list|(
name|ppc_jtab
argument_list|)
block|,
literal|0
block|,   }
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|rvaafter
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
return|return
literal|""
return|;
case|case
name|M386
case|:
return|return
literal|""
return|;
case|case
name|MPPC
case|:
return|return
literal|""
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rvabefore
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
return|return
literal|".rva\t"
return|;
case|case
name|M386
case|:
return|return
literal|".rva\t"
return|;
case|case
name|MPPC
case|:
return|return
literal|".rva\t"
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|asm_prefix
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
return|return
literal|""
return|;
case|case
name|M386
case|:
return|return
literal|"_"
return|;
case|case
name|MPPC
case|:
return|return
literal|""
return|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASM_BYTE
value|mtable[machine].how_byte
end_define

begin_define
define|#
directive|define
name|ASM_SHORT
value|mtable[machine].how_short
end_define

begin_define
define|#
directive|define
name|ASM_LONG
value|mtable[machine].how_long
end_define

begin_define
define|#
directive|define
name|ASM_TEXT
value|mtable[machine].how_asciz
end_define

begin_define
define|#
directive|define
name|ASM_C
value|mtable[machine].how_comment
end_define

begin_define
define|#
directive|define
name|ASM_JUMP
value|mtable[machine].how_jump
end_define

begin_define
define|#
directive|define
name|ASM_GLOBAL
value|mtable[machine].how_global
end_define

begin_define
define|#
directive|define
name|ASM_SPACE
value|mtable[machine].how_space
end_define

begin_define
define|#
directive|define
name|ASM_ALIGN_SHORT
value|mtable[machine].how_align_short
end_define

begin_define
define|#
directive|define
name|ASM_RVA_BEFORE
value|rvabefore(machine)
end_define

begin_define
define|#
directive|define
name|ASM_RVA_AFTER
value|rvaafter(machine)
end_define

begin_define
define|#
directive|define
name|ASM_PREFIX
value|asm_prefix(machine)
end_define

begin_define
define|#
directive|define
name|ASM_ALIGN_LONG
value|mtable[machine].how_align_long
end_define

begin_define
define|#
directive|define
name|HOW_BFD_TARGET
value|0
end_define

begin_comment
comment|/* always default*/
end_comment

begin_define
define|#
directive|define
name|HOW_BFD_ARCH
value|mtable[machine].how_bfd_arch
end_define

begin_define
define|#
directive|define
name|HOW_JTAB
value|mtable[machine].how_jtab
end_define

begin_define
define|#
directive|define
name|HOW_JTAB_SIZE
value|mtable[machine].how_jtab_size
end_define

begin_define
define|#
directive|define
name|HOW_JTAB_ROFF
value|mtable[machine].how_jtab_roff
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|oav
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* communications with flex */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|linenumber
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|process_def_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|name
argument_list|,
name|FOPEN_RT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open def file %s\n"
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|yyin
operator|=
name|f
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* Communications with the parser */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dlist
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|struct
name|dlist
modifier|*
name|next
decl_stmt|;
block|}
name|dlist_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|export
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|internal_name
decl_stmt|;
name|int
name|ordinal
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|int
name|noname
decl_stmt|;
name|int
name|hint
decl_stmt|;
name|struct
name|export
modifier|*
name|next
decl_stmt|;
block|}
name|export_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|d_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arg to NAME or LIBRARY */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_nfuncs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of functions exported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_named_nfuncs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of named functions exported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_low_ord
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest ordinal index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_high_ord
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest ordinal index */
end_comment

begin_decl_stmt
specifier|static
name|export_type
modifier|*
name|d_exports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*list of exported functions */
end_comment

begin_decl_stmt
specifier|static
name|export_type
modifier|*
modifier|*
name|d_exports_lexically
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vector of exported functions in alpha order */
end_comment

begin_decl_stmt
specifier|static
name|dlist_type
modifier|*
name|d_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptions */
end_comment

begin_decl_stmt
specifier|static
name|dlist_type
modifier|*
name|a_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff to go in directives */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_is_dll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|d_is_exe
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yyerror
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Syntax error in def file %s:%d\n"
argument_list|,
name|program_name
argument_list|,
name|def_file
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|def_exports
parameter_list|(
name|name
parameter_list|,
name|internal_name
parameter_list|,
name|ordinal
parameter_list|,
name|noname
parameter_list|,
name|constant
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|internal_name
decl_stmt|;
name|int
name|ordinal
decl_stmt|;
name|int
name|noname
decl_stmt|;
name|int
name|constant
decl_stmt|;
block|{
name|struct
name|export
modifier|*
name|p
init|=
operator|(
expr|struct
name|export
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|internal_name
operator|=
name|internal_name
condition|?
name|internal_name
else|:
name|name
expr_stmt|;
name|p
operator|->
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constant
expr_stmt|;
name|p
operator|->
name|noname
operator|=
name|noname
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|d_exports
expr_stmt|;
name|d_exports
operator|=
name|p
expr_stmt|;
name|d_nfuncs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_name
parameter_list|(
name|name
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s NAME %s base %x\n"
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_is_dll
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't have LIBRARY and NAME\n"
argument_list|)
expr_stmt|;
block|}
name|d_name
operator|=
name|name
expr_stmt|;
name|d_is_exe
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_library
parameter_list|(
name|name
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: LIBRARY %s base %x\n"
argument_list|,
name|program_name
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_is_exe
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't have LIBRARY and NAME\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
name|d_name
operator|=
name|name
expr_stmt|;
name|d_is_dll
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_description
parameter_list|(
name|desc
parameter_list|)
name|char
modifier|*
name|desc
decl_stmt|;
block|{
name|dlist_type
modifier|*
name|d
init|=
operator|(
name|dlist_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dlist_type
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|text
operator|=
name|strdup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|d_list
expr_stmt|;
name|d_list
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
name|void
name|new_directive
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|dlist_type
modifier|*
name|d
init|=
operator|(
name|dlist_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dlist_type
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|text
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|a_list
expr_stmt|;
name|a_list
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_stacksize
parameter_list|(
name|reserve
parameter_list|,
name|commit
parameter_list|)
name|int
name|reserve
decl_stmt|;
name|int
name|commit
decl_stmt|;
block|{
name|char
name|b
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|commit
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-stack 0x%x,0x%x "
argument_list|,
name|reserve
argument_list|,
name|commit
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-stack 0x%x "
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|strdup
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_heapsize
parameter_list|(
name|reserve
parameter_list|,
name|commit
parameter_list|)
name|int
name|reserve
decl_stmt|;
name|int
name|commit
decl_stmt|;
block|{
name|char
name|b
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|commit
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-heap 0x%x,0x%x "
argument_list|,
name|reserve
argument_list|,
name|commit
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-heap 0x%x "
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|strdup
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_import
parameter_list|(
name|internal
parameter_list|,
name|module
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|internal
decl_stmt|;
name|char
modifier|*
name|module
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: IMPORTS are ignored"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_version
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
name|int
name|major
decl_stmt|;
name|int
name|minor
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"VERSION %d.%d\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_section
parameter_list|(
name|name
parameter_list|,
name|attr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|attr
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|char
name|atts
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|atts
decl_stmt|;
if|if
condition|(
name|attr
operator|&
literal|1
condition|)
operator|*
name|d
operator|++
operator|=
literal|'R'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|2
condition|)
operator|*
name|d
operator|++
operator|=
literal|'W'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
literal|'X'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|8
condition|)
operator|*
name|d
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-attr %s %s"
argument_list|,
name|name
argument_list|,
name|atts
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|strdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_code
parameter_list|(
name|attr
parameter_list|)
name|int
name|attr
decl_stmt|;
block|{
name|def_section
argument_list|(
literal|"CODE"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_data
parameter_list|(
name|attr
parameter_list|)
name|int
name|attr
decl_stmt|;
block|{
name|def_section
argument_list|(
literal|"DATA"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
name|void
name|run
parameter_list|(
name|what
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|what
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Count the args */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|args
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|argv
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|what
expr_stmt|;
name|s
operator|=
name|args
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|0
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|argv
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|execvp
argument_list|(
name|what
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't exec %s\n"
argument_list|,
name|program_name
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: vfork failed, %d\n"
argument_list|,
name|program_name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|status
decl_stmt|;
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %s terminated with signal %d\n"
argument_list|,
name|program_name
argument_list|,
name|what
argument_list|,
name|args
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s %s terminated with exit status %d\n"
argument_list|,
name|program_name
argument_list|,
name|what
argument_list|,
name|args
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* read in and block out the base relocations */
end_comment

begin_function
specifier|static
name|void
name|basenames
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{     }
end_function

begin_function
name|void
name|scan_open_obj_file
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Look for .drectve's */
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".drectve"
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|int
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Sucking in info from %s\n"
argument_list|,
name|program_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search for -export: strings */
name|p
operator|=
name|buf
expr_stmt|;
name|e
operator|=
name|buf
operator|+
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-export:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|name
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|c
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|c
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: The 5th arg is for the `constant' field. 		 What should it be?  Not that it matters since it's not 		 currently useful.  */
name|def_exports
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|basenames
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Done readin\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scan_obj_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd
modifier|*
name|f
init|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unable to open object file %s\n"
argument_list|,
name|program_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|f
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|arfile
init|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|arfile
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|arfile
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|scan_open_obj_file
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bfd_check_format
argument_list|(
name|f
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|scan_open_obj_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|bfd_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
name|void
name|dump_def_info
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oav
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|oav
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s  %d = %s %s @ %d %s%s\n"
argument_list|,
name|ASM_C
argument_list|,
name|i
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|exp
operator|->
name|noname
condition|?
literal|"NONAME "
else|:
literal|""
argument_list|,
name|exp
operator|->
name|constant
condition|?
literal|"CONSTANT"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the .exp file */
end_comment

begin_function
name|int
name|sfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|long
modifier|*
name|a
decl_stmt|;
name|long
modifier|*
name|b
decl_stmt|;
block|{
return|return
operator|*
name|a
operator|-
operator|*
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_page
parameter_list|(
name|f
parameter_list|,
name|need
parameter_list|,
name|page_addr
parameter_list|,
name|on_page
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
modifier|*
name|need
decl_stmt|;
name|int
name|page_addr
decl_stmt|;
name|int
name|on_page
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Flush this page */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%08x\t%s Starting RVA for chunk\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|page_addr
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%x\t%s Size of block\n"
argument_list|,
name|ASM_LONG
argument_list|,
operator|(
name|on_page
operator|*
literal|2
operator|)
operator|+
operator|(
name|on_page
operator|&
literal|1
operator|)
operator|*
literal|2
operator|+
literal|8
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|on_page
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%x\n"
argument_list|,
name|ASM_SHORT
argument_list|,
operator|(
name|need
index|[
name|i
index|]
operator|-
name|page_addr
operator|)
operator||
literal|0x3000
argument_list|)
expr_stmt|;
block|}
comment|/* And padding */
if|if
condition|(
name|on_page
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%x\n"
argument_list|,
name|ASM_SHORT
argument_list|,
literal|0
operator||
literal|0x0000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gen_def_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oav
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|" %s"
argument_list|,
name|oav
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|"\nEXPORTS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|quote
init|=
name|strchr
argument_list|(
name|exp
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
condition|?
literal|"\""
else|:
literal|""
decl_stmt|;
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|"\t%s%s%s @ %d%s ; %s\n"
argument_list|,
name|quote
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|quote
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|exp
operator|->
name|noname
condition|?
literal|" NONAME"
else|:
literal|""
argument_list|,
name|cplus_demangle
argument_list|(
name|exp
operator|->
name|internal_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gen_exp_file
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|dlist_type
modifier|*
name|dl
decl_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"t%s"
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Generate exp file %s\n"
argument_list|,
name|program_name
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unable to open output file %s\n"
argument_list|,
name|program_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Opened file %s\n"
argument_list|,
name|program_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|dump_def_info
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_exports
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.edata\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0	%s Allways 0\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0x%x	%s Time and date\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|time
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0	%s Major and Minor version\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sname%s	%s Ptr to name of dll\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Starting ordinal of exports\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|d_low_ord
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Number of functions\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|d_high_ord
operator|-
name|d_low_ord
operator|+
literal|1
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s named funcs %d, low ord %d, high ord %d\n"
argument_list|,
name|ASM_C
argument_list|,
name|d_named_nfuncs
argument_list|,
name|d_low_ord
argument_list|,
name|d_high_ord
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Number of names\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|show_allnames
condition|?
name|d_high_ord
operator|-
name|d_low_ord
operator|+
literal|1
else|:
name|d_named_nfuncs
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%safuncs%s  %s Address of functions\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sanames%s	%s Address of Name Pointer Table\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sanords%s	%s Address of ordinals\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"name:	%s	\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export address Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ASM_ALIGN_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"afuncs:\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|d_low_ord
expr_stmt|;
for|for
control|(
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|exp
operator|->
name|ordinal
operator|!=
name|i
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (f, "\t%s\t%d\t%s %d..%d missing\n", 		       ASM_SPACE, 		       (exp->ordinal - i) * 4, 		       ASM_C, 		       i, exp->ordinal - 1); 	      i = exp->ordinal;
endif|#
directive|endif
while|while
condition|(
name|i
operator|<
name|exp
operator|->
name|ordinal
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s%s%s%s\t%s %d\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_PREFIX
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Name Pointer Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"anames:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sn%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Oridinal Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"anords:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d\n"
argument_list|,
name|ASM_SHORT
argument_list|,
name|exp
operator|->
name|ordinal
operator|-
name|d_low_ord
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Name Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"n%d:	%s	\"%s\"\n"
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_TEXT
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section .drectve\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|a_list
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|dl
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section .rdata\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|d_list
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
comment|/* We dont output as ascii 'cause there can 	         be quote characters in the string */
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dl
operator|->
name|text
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t"
argument_list|,
name|ASM_BYTE
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|",0\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|l
operator|==
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Add to the output file a way of getting to the exported names      without using the import library. */
if|if
condition|(
name|add_indirect
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.rdata\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t__imp_%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"__imp_%s:\n"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dump the reloc section if a base file is provided */
if|if
condition|(
name|base_file
condition|)
block|{
name|int
name|addr
decl_stmt|;
name|long
name|need
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|long
name|page_addr
decl_stmt|;
name|int
name|numbytes
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
name|long
modifier|*
name|copy
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|on_page
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.init\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"lab:\n"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|base_file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|numbytes
operator|=
name|ftell
argument_list|(
name|base_file
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|base_file
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
name|numbytes
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
name|base_file
argument_list|)
expr_stmt|;
name|num_entries
operator|=
name|numbytes
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.reloc\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_entries
condition|)
block|{
name|int
name|src
decl_stmt|;
name|int
name|dst
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|qsort
argument_list|(
name|copy
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|sfunc
argument_list|)
expr_stmt|;
comment|/* Delete duplcates */
for|for
control|(
name|src
operator|=
literal|0
init|;
name|src
operator|<
name|num_entries
condition|;
name|src
operator|++
control|)
block|{
if|if
condition|(
name|last
operator|!=
name|copy
index|[
name|src
index|]
condition|)
name|last
operator|=
name|copy
index|[
name|dst
operator|++
index|]
operator|=
name|copy
index|[
name|src
index|]
expr_stmt|;
block|}
name|num_entries
operator|=
name|dst
expr_stmt|;
name|addr
operator|=
name|copy
index|[
literal|0
index|]
expr_stmt|;
name|page_addr
operator|=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
comment|/* work out the page addr */
name|on_page
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
name|addr
operator|=
name|copy
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
operator|!=
name|page_addr
condition|)
block|{
name|flush_page
argument_list|(
name|f
argument_list|,
name|need
argument_list|,
name|page_addr
argument_list|,
name|on_page
argument_list|)
expr_stmt|;
name|on_page
operator|=
literal|0
expr_stmt|;
name|page_addr
operator|=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
block|}
name|need
index|[
name|on_page
operator|++
index|]
operator|=
name|addr
expr_stmt|;
block|}
name|flush_page
argument_list|(
name|f
argument_list|,
name|need
argument_list|,
name|page_addr
argument_list|,
name|on_page
argument_list|)
expr_stmt|;
comment|/*	  fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* assemble the file */
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"-o %s t%s"
argument_list|,
name|exp_name
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|as_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"t%s"
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xlate
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|add_underscore
condition|)
block|{
name|char
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|copy
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|copy
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|copy
expr_stmt|;
block|}
if|if
condition|(
name|killat
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dump_iat
parameter_list|(
name|f
parameter_list|,
name|exp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|exp
operator|->
name|noname
operator|&&
operator|!
name|show_allnames
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%08x\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|exp
operator|->
name|ordinal
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
comment|/* hint or orindal ?? */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sID%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|align
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
block|}
name|sinfo
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|DLLTOOL_PPC
end_ifndef

begin_define
define|#
directive|define
name|TEXT
value|0
end_define

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_define
define|#
directive|define
name|BSS
value|2
end_define

begin_define
define|#
directive|define
name|IDATA7
value|3
end_define

begin_define
define|#
directive|define
name|IDATA5
value|4
end_define

begin_define
define|#
directive|define
name|IDATA4
value|5
end_define

begin_define
define|#
directive|define
name|IDATA6
value|6
end_define

begin_define
define|#
directive|define
name|PDATA
value|7
end_define

begin_define
define|#
directive|define
name|RDATA
value|8
end_define

begin_define
define|#
directive|define
name|NSECS
value|7
end_define

begin_decl_stmt
specifier|static
name|sinfo
name|secdata
index|[
name|NSECS
index|]
init|=
block|{
block|{
name|TEXT
block|,
literal|".text"
block|,
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|DATA
block|,
literal|".data"
block|,
name|SEC_DATA
block|,
literal|2
block|}
block|,
block|{
name|BSS
block|,
literal|".bss"
block|,
literal|0
block|,
literal|2
block|}
block|,
block|{
name|IDATA7
block|,
literal|".idata$7"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA5
block|,
literal|".idata$5"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA4
block|,
literal|".idata$4"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA6
block|,
literal|".idata$6"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Sections numbered to make the order the same as other PowerPC NT    */
end_comment

begin_comment
comment|/* compilers. This also keeps funny alignment thingies from happening. */
end_comment

begin_define
define|#
directive|define
name|TEXT
value|0
end_define

begin_define
define|#
directive|define
name|PDATA
value|1
end_define

begin_define
define|#
directive|define
name|RDATA
value|2
end_define

begin_define
define|#
directive|define
name|IDATA5
value|3
end_define

begin_define
define|#
directive|define
name|IDATA4
value|4
end_define

begin_define
define|#
directive|define
name|IDATA6
value|5
end_define

begin_define
define|#
directive|define
name|IDATA7
value|6
end_define

begin_define
define|#
directive|define
name|DATA
value|7
end_define

begin_define
define|#
directive|define
name|BSS
value|8
end_define

begin_define
define|#
directive|define
name|NSECS
value|9
end_define

begin_decl_stmt
specifier|static
name|sinfo
name|secdata
index|[
name|NSECS
index|]
init|=
block|{
block|{
name|TEXT
block|,
literal|".text"
block|,
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
block|,
literal|3
block|}
block|,
block|{
name|PDATA
block|,
literal|".pdata"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|RDATA
block|,
literal|".reldata"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA5
block|,
literal|".idata$5"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA4
block|,
literal|".idata$4"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA6
block|,
literal|".idata$6"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|1
block|}
block|,
block|{
name|IDATA7
block|,
literal|".idata$7"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|DATA
block|,
literal|".data"
block|,
name|SEC_DATA
block|,
literal|2
block|}
block|,
block|{
name|BSS
block|,
literal|".bss"
block|,
literal|0
block|,
literal|2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is what we're trying to make  	.text 	.global	_GetFileVersionInfoSizeW@8 	.global	__imp_GetFileVersionInfoSizeW@8 _GetFileVersionInfoSizeW@8: 	jmp *	__imp_GetFileVersionInfoSizeW@8 	.section	.idata$7	# To force loading of head 	.long	__version_a_head # Import Address Table 	.section	.idata$5 __imp_GetFileVersionInfoSizeW@8: 	.rva	ID2  # Import Lookup Table 	.section	.idata$4 	.rva	ID2 # Hint/Name table 	.section	.idata$6 ID2:	.short	2 	.asciz	"GetFileVersionInfoSizeW"   For the PowerPC, here's the variation on the above scheme:  # Rather than a simple "jmp *", the code to get to the dll function  # looks like:          .text          lwz	r11,[tocv]__imp_function_name(r2) #		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name          lwz	r12,0(r11) 	 stw	r2,4(r1) 	 mtctr	r12 	 lwz	r2,4(r11) 	 bctr */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_label
parameter_list|(
name|prefix
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|ASM_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|ASM_PREFIX
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_one_lib_file
parameter_list|(
name|exp
parameter_list|,
name|i
parameter_list|)
name|export_type
modifier|*
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
literal|0
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|prefix
init|=
literal|"d"
decl_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ss%d.s"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.text\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|ASM_PREFIX
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t__imp_%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s%s:\n\t%s\t__imp_%s\n"
argument_list|,
name|ASM_PREFIX
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|ASM_JUMP
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.idata$7\t%s To force loading of head\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|head_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Import Address Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"__imp_%s:\n"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|dump_iat
argument_list|(
name|f
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%s Import Lookup Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$4\n"
argument_list|)
expr_stmt|;
name|dump_iat
argument_list|(
name|f
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Hint/Name table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$6\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"ID%d:\t%s\t%d\n"
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_SHORT
argument_list|,
name|exp
operator|->
name|hint
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"-o %ss%d.o %ss%d.s"
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|as_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|exp_label
decl_stmt|;
name|asymbol
modifier|*
name|iname
decl_stmt|;
name|asymbol
modifier|*
name|iname_lab
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|iname_lab_pp
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|iname_pp
decl_stmt|;
comment|/* Extra Symbols for PPC */
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
define|#
directive|define
name|EXTRA
value|2
else|#
directive|else
define|#
directive|define
name|EXTRA
value|0
endif|#
directive|endif
name|asymbol
modifier|*
name|function_name
decl_stmt|;
comment|/* ".." functionName */
name|asymbol
modifier|*
modifier|*
name|fn_pp
decl_stmt|;
name|asymbol
modifier|*
name|toc_symbol
decl_stmt|;
comment|/* The .toc symbol */
name|asymbol
modifier|*
modifier|*
name|toc_pp
decl_stmt|;
comment|/* one symbol for each section, 2 extra + a null */
name|asymbol
modifier|*
name|ptrs
index|[
name|NSECS
operator|+
literal|3
operator|+
name|EXTRA
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|outname
init|=
name|xmalloc
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|oidx
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|outname
argument_list|,
literal|"ds%d.o"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|outname
argument_list|,
name|HOW_BFD_TARGET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bfd_open failed open output file %s\n"
argument_list|,
name|program_name
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|HOW_BFD_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First make symbols for the sections */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|id
operator|!=
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
name|si
operator|->
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|flags
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|align
argument_list|)
expr_stmt|;
name|si
operator|->
name|sec
operator|->
name|output_section
operator|=
name|si
operator|->
name|sec
expr_stmt|;
name|si
operator|->
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|name
operator|=
name|si
operator|->
name|sec
operator|->
name|name
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|section
operator|=
name|si
operator|->
name|sec
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ptrs
index|[
name|oidx
index|]
operator|=
name|si
operator|->
name|sym
expr_stmt|;
name|si
operator|->
name|sympp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|oidx
operator|++
expr_stmt|;
block|}
name|exp_label
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exp_label
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|""
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* On PowerPC, the function name points to a descriptor in the 	 rdata section, the first element of which is a pointer to the 	 code (..function_name), and the second points to the .toc       */
if|if
condition|(
name|machine
operator|==
name|MPPC
condition|)
name|exp_label
operator|->
name|section
operator|=
name|secdata
index|[
name|RDATA
index|]
operator|.
name|sec
expr_stmt|;
else|else
name|exp_label
operator|->
name|section
operator|=
name|secdata
index|[
name|TEXT
index|]
operator|.
name|sec
expr_stmt|;
name|exp_label
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|exp_label
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|exp_label
expr_stmt|;
name|iname
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|iname
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|"__imp_"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|iname
operator|->
name|section
operator|=
name|secdata
index|[
name|IDATA5
index|]
operator|.
name|sec
expr_stmt|;
name|iname
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|iname
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|iname_lab
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|iname_lab
operator|->
name|name
operator|=
name|head_label
expr_stmt|;
name|iname_lab
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
operator|&
name|bfd_und_section
expr_stmt|;
name|iname_lab
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iname_lab
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|iname_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|iname
expr_stmt|;
name|iname_lab_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|iname_lab
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* The symbol refering to the code (.text) */
name|function_name
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|function_name
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|".."
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|function_name
operator|->
name|section
operator|=
name|secdata
index|[
name|TEXT
index|]
operator|.
name|sec
expr_stmt|;
name|function_name
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|function_name
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|fn_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|function_name
expr_stmt|;
comment|/* The .toc symbol */
name|toc_symbol
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|toc_symbol
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|"."
argument_list|,
literal|"toc"
argument_list|)
expr_stmt|;
name|toc_symbol
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
operator|&
name|bfd_und_section
expr_stmt|;
name|toc_symbol
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|toc_symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|toc_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|toc_symbol
expr_stmt|;
endif|#
directive|endif
name|ptrs
index|[
name|oidx
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|si
operator|->
name|sec
decl_stmt|;
name|arelent
modifier|*
name|rel
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|rpp
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|TEXT
case|:
name|si
operator|->
name|size
operator|=
name|HOW_JTAB_SIZE
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|HOW_JTAB_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|si
operator|->
name|data
argument_list|,
name|HOW_JTAB
argument_list|,
name|HOW_JTAB_SIZE
argument_list|)
expr_stmt|;
comment|/* add the reloc into idata$5 */
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|HOW_JTAB_ROFF
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|machine
operator|==
name|MPPC
condition|)
block|{
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_16_GOTOFF
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|iname_pp
expr_stmt|;
block|}
else|else
block|{
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|secdata
index|[
name|IDATA5
index|]
operator|.
name|sympp
expr_stmt|;
block|}
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IDATA4
case|:
case|case
name|IDATA5
case|:
comment|/* An idata$4 or idata$5 is one word long, and has an 		 rva to idata$6 */
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|si
operator|->
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|noname
condition|)
block|{
name|si
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|2
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|16
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_RVA
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|secdata
index|[
name|IDATA6
index|]
operator|.
name|sympp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
block|}
break|break;
case|case
name|IDATA6
case|:
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
condition|)
block|{
name|int
name|idx
init|=
name|exp
operator|->
name|hint
operator|+
literal|1
decl_stmt|;
name|si
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
operator|+
literal|3
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|idx
operator|&
literal|0xff
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|idx
operator|>>
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|si
operator|->
name|data
operator|+
literal|2
argument_list|,
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IDATA7
case|:
name|si
operator|->
name|size
operator|=
literal|4
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_RVA
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|iname_lab_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PDATA
case|:
block|{
comment|/* The .pdata section is 5 words long. */
comment|/* Think of it as:                     */
comment|/* struct                              */
comment|/* {                                   */
comment|/*   bfd_vma BeginAddress,     [0x00]  */
comment|/*           EndAddress,       [0x04]  */
comment|/*	     ExceptionHandler, [0x08]  */
comment|/*	     HandlerData,      [0x0c]  */
comment|/*	     PrologEndAddress; [0x10]  */
comment|/* };                                  */
comment|/* So this pdata section setups up this as a glue linkage to 		   a dll routine. There are a number of house keeping things 		   we need to do:  		   1. In the name of glue trickery, the ADDR32 relocs for 0,  		      4, and 0x10 are set to point to the same place:  		      "..function_name".  		   2. There is one more reloc needed in the pdata section.  		      The actual glue instruction to restore the toc on  		      return is saved as the offset in an IMGLUE reloc. 		      So we need a total of four relocs for this section.  		   3. Lastly, the HandlerData field is set to 0x03, to indicate 		      that this is a glue routine. 		*/
name|arelent
modifier|*
name|imglue
decl_stmt|,
modifier|*
name|ba_rel
decl_stmt|,
modifier|*
name|ea_rel
decl_stmt|,
modifier|*
name|pea_rel
decl_stmt|;
comment|/* alignment must be set to 2**2 or you get extra stuff */
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|si
operator|->
name|size
operator|=
literal|4
operator|*
literal|5
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
operator|*
literal|5
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|imglue
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
name|ba_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|2
index|]
operator|=
name|ea_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|3
index|]
operator|=
name|pea_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* stick the toc reload instruction in the glue reloc */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ppc_glue_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|imglue
operator|->
name|address
argument_list|)
expr_stmt|;
name|imglue
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|imglue
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32_GOTOFF
argument_list|)
expr_stmt|;
name|imglue
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|ba_rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|ba_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|ba_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|ba_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x18
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x04
argument_list|)
expr_stmt|;
name|ea_rel
operator|->
name|address
operator|=
literal|4
expr_stmt|;
name|ea_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|ea_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|ea_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
comment|/* mark it as glue */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x03
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* mark the prolog end address */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x0D
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|pea_rel
operator|->
name|address
operator|=
literal|0x10
expr_stmt|;
name|pea_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|pea_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|pea_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|4
expr_stmt|;
break|break;
block|}
case|case
name|RDATA
case|:
comment|/* Each external function in a PowerPC PE file has a two word 		 descriptor consisting of: 		 1. The address of the code. 		 2. The address of the appropriate .toc 	         We use relocs to build this. 	      */
name|si
operator|->
name|size
operator|=
literal|8
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|rel
operator|=
name|rpp
index|[
literal|1
index|]
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|4
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|toc_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|{
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
comment|/* Size up all the sections */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
comment|/*	    vma += si->size;*/
block|}
block|}
comment|/* Write them out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|IDATA5
operator|&&
name|no_idata5
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|IDATA4
operator|&&
name|no_idata4
condition|)
continue|continue;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|ptrs
argument_list|,
name|oidx
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|outname
argument_list|,
name|HOW_BFD_TARGET
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_head
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
literal|"dh.s"
argument_list|,
name|FOPEN_WT
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s IMAGE_IMPORT_DESCRIPTOR\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|head_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:\n"
argument_list|,
name|head_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%shname%s\t%sPtr to image import by name list\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sthis should be the timestamp, but NT sometimes\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sdoesn't load DLLs when this is set.\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\t%s loaded time\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\t%s Forwarder chain\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s__%s_iname%s\t%s imported dll's name\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|imp_name_lab
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sfthunk%s\t%s pointer to firstthunk\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sStuff for compatibility\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_idata5
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.idata$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"fthunk:\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_idata4
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"hname:\n"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"-o dh.o dh.s"
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|as_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
return|return
name|bfd_openr
argument_list|(
literal|"dh.o"
argument_list|,
name|HOW_BFD_TARGET
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_tail
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
literal|"dt.s"
argument_list|,
name|FOPEN_WT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|no_idata4
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_idata5
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* Normally, we need to see a null descriptor built in idata$3 to      act as the terminator for the list. The ideal way, I suppose,      would be to mark this section as a comdat type 2 section, so      only one would appear in the final .exe (if our linker supported      comdat, that is) or cause it to be inserted by something else (say      crt0)   */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$3\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* Other PowerPC NT compilers use idata$6 for the dllname, so I      do too. Original, huh? */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$6\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$7\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t__%s_iname\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|imp_name_lab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"__%s_iname:\t%s\t\"%s\"\n"
argument_list|,
name|imp_name_lab
argument_list|,
name|ASM_TEXT
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"-o dt.o dt.s"
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|as_name
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
return|return
name|bfd_openr
argument_list|(
literal|"dt.o"
argument_list|,
name|HOW_BFD_TARGET
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_lib_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|bfd
modifier|*
name|ar_head
decl_stmt|;
name|bfd
modifier|*
name|ar_tail
decl_stmt|;
name|bfd
modifier|*
name|outarch
decl_stmt|;
name|bfd
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|unlink
argument_list|(
name|imp_name
argument_list|)
expr_stmt|;
name|outarch
operator|=
name|bfd_openw
argument_list|(
name|imp_name
argument_list|,
name|HOW_BFD_TARGET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outarch
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open .lib file %s\n"
argument_list|,
name|program_name
argument_list|,
name|imp_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bfd_set_format
argument_list|(
name|outarch
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|outarch
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
comment|/* Work out a reasonable size of things to put onto one line. */
name|ar_head
operator|=
name|make_head
argument_list|()
expr_stmt|;
name|ar_tail
operator|=
name|make_tail
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bfd
modifier|*
name|n
init|=
name|make_one_lib_file
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
comment|/* Now stick them all into the archive */
name|ar_head
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|ar_tail
operator|->
name|next
operator|=
name|ar_head
expr_stmt|;
name|head
operator|=
name|ar_tail
expr_stmt|;
name|bfd_set_archive_head
argument_list|(
name|outarch
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|outarch
argument_list|)
expr_stmt|;
comment|/* Delete all the temp files */
if|if
condition|(
name|dontdeltemps
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"dh.o"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"dh.s"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"dt.o"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"dt.s"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dontdeltemps
operator|<
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|outfile
argument_list|,
literal|"ds%d.o"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* Run through the information gathered from the .o files and the    .def file and work out the best stuff */
end_comment

begin_function
name|int
name|pfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|void
modifier|*
name|a
decl_stmt|;
name|void
modifier|*
name|b
decl_stmt|;
block|{
name|export_type
modifier|*
name|ap
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|export_type
modifier|*
name|bp
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|ordinal
operator|==
name|bp
operator|->
name|ordinal
condition|)
return|return
literal|0
return|;
comment|/* unset ordinals go to the bottom */
if|if
condition|(
name|ap
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bp
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ap
operator|->
name|ordinal
operator|-
name|bp
operator|->
name|ordinal
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|void
modifier|*
name|a
decl_stmt|;
name|void
modifier|*
name|b
decl_stmt|;
block|{
name|export_type
modifier|*
name|ap
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|export_type
modifier|*
name|bp
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|b
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|ap
operator|->
name|name
argument_list|,
name|bp
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_null_names
parameter_list|(
name|ptr
parameter_list|)
name|export_type
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|src
decl_stmt|;
name|int
name|dst
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|src
operator|=
literal|0
init|;
name|src
operator|<
name|d_nfuncs
condition|;
name|src
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|src
index|]
condition|)
block|{
name|ptr
index|[
name|dst
index|]
operator|=
name|ptr
index|[
name|src
index|]
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|d_nfuncs
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtab
parameter_list|(
name|ptr
parameter_list|)
name|export_type
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SACDEBUG
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%d %s @ %d %s%s\n"
argument_list|,
name|i
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|ordinal
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|noname
condition|?
literal|"NONAME "
else|:
literal|""
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|constant
condition|?
literal|"CONSTANT"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"empty\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|process_duplicates
parameter_list|(
name|d_export_vec
parameter_list|)
name|export_type
modifier|*
modifier|*
name|d_export_vec
decl_stmt|;
block|{
name|int
name|more
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|more
condition|)
block|{
name|more
operator|=
literal|0
expr_stmt|;
comment|/* Remove duplicates */
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|nfunc
argument_list|)
expr_stmt|;
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|d_export_vec
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|export_type
modifier|*
name|a
init|=
name|d_export_vec
index|[
name|i
index|]
decl_stmt|;
name|export_type
modifier|*
name|b
init|=
name|d_export_vec
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|more
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning, ignoring duplicate EXPORT %s %d,%d\n"
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|ordinal
argument_list|,
name|b
operator|->
name|ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|b
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, duplicate EXPORT with oridinals %s\n"
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Merge attributes */
name|b
operator|->
name|ordinal
operator|=
name|a
operator|->
name|ordinal
operator|>
literal|0
condition|?
name|a
operator|->
name|ordinal
else|:
name|b
operator|->
name|ordinal
expr_stmt|;
name|b
operator|->
name|constant
operator||=
name|a
operator|->
name|constant
expr_stmt|;
name|b
operator|->
name|noname
operator||=
name|a
operator|->
name|noname
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|remove_null_names
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Count the names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d_export_vec
index|[
name|i
index|]
operator|->
name|noname
condition|)
name|d_named_nfuncs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_ordinals
parameter_list|(
name|d_export_vec
parameter_list|)
name|export_type
modifier|*
modifier|*
name|d_export_vec
decl_stmt|;
block|{
name|int
name|lowest
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
init|=
literal|65536
decl_stmt|;
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|pfunc
argument_list|)
expr_stmt|;
comment|/* fill in the unset ordinals with ones from our range */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mark in our large vector all the numbers that are taken */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|ptr
index|[
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lowest
operator|==
operator|-
literal|1
operator|||
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|<
name|lowest
condition|)
block|{
name|lowest
operator|=
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
expr_stmt|;
block|}
block|}
block|}
comment|/* Start at 1 for compatibility with MS toolchain.  */
if|if
condition|(
name|lowest
operator|==
operator|-
literal|1
condition|)
name|lowest
operator|=
literal|1
expr_stmt|;
comment|/* Now fill in ordinals where the user wants us to choose. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
comment|/* First try within or after any user supplied range. */
for|for
control|(
name|j
operator|=
name|lowest
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|=
name|j
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Then try before the range. */
for|for
control|(
name|j
operator|=
name|lowest
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|ptr
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|=
name|j
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
empty_stmt|;
block|}
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* And resort */
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|pfunc
argument_list|)
expr_stmt|;
comment|/* Work out the lowest and highest ordinal numbers.  */
if|if
condition|(
name|d_nfuncs
condition|)
block|{
if|if
condition|(
name|d_export_vec
index|[
literal|0
index|]
condition|)
name|d_low_ord
operator|=
name|d_export_vec
index|[
literal|0
index|]
operator|->
name|ordinal
expr_stmt|;
if|if
condition|(
name|d_export_vec
index|[
name|d_nfuncs
operator|-
literal|1
index|]
condition|)
name|d_high_ord
operator|=
name|d_export_vec
index|[
name|d_nfuncs
operator|-
literal|1
index|]
operator|->
name|ordinal
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|alphafunc
parameter_list|(
name|av
parameter_list|,
name|bv
parameter_list|)
name|void
modifier|*
name|av
decl_stmt|;
name|void
modifier|*
name|bv
decl_stmt|;
block|{
name|export_type
modifier|*
modifier|*
name|a
init|=
name|av
decl_stmt|;
name|export_type
modifier|*
modifier|*
name|b
init|=
name|bv
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mangle_defs
parameter_list|()
block|{
comment|/* First work out the minimum ordinal chosen */
name|export_type
modifier|*
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hint
init|=
literal|0
decl_stmt|;
name|export_type
modifier|*
modifier|*
name|d_export_vec
init|=
operator|(
name|export_type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
operator|*
name|d_nfuncs
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|d_export_vec
index|[
name|i
index|]
operator|=
name|exp
expr_stmt|;
block|}
name|process_duplicates
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|fill_ordinals
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
comment|/* Put back the list in the new order */
name|d_exports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|d_nfuncs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|d_export_vec
index|[
name|i
index|]
operator|->
name|next
operator|=
name|d_exports
expr_stmt|;
name|d_exports
operator|=
name|d_export_vec
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Build list in alpha order */
name|d_exports_lexically
operator|=
operator|(
name|export_type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
operator|*
operator|(
name|d_nfuncs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|d_exports_lexically
index|[
name|i
index|]
operator|=
name|exp
expr_stmt|;
block|}
name|d_exports_lexically
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|d_exports_lexically
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|alphafunc
argument_list|)
expr_stmt|;
comment|/* Fill exp entries with their hint values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d_exports_lexically
index|[
name|i
index|]
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|d_exports_lexically
index|[
name|i
index|]
operator|->
name|hint
operator|=
name|hint
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|file
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Usage %s<options><object-files>\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --machine<machine>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --output-exp<outname> Generate export file.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --output-lib<outname> Generate input library.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --add-indirect         Add dll indirects to export file.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --dllname<name>       Name of input dll to put into output lib.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --def<deffile>        Name input .def file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --output-def<deffile> Name output .def file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --base-file<basefile> Read linker generated base file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --no-idata4           Don't generate idata$4 section\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --no-idata5           Don't generate idata$5 section\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   -v                     Verbose\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   -U                     Add underscores to .lib\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   -k                     Kill @<n> from exported names\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --as<name>            Use<name> for assembler\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"   --nodelete             Keep temp files.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OPTION_NO_IDATA4
value|'x'
end_define

begin_define
define|#
directive|define
name|OPTION_NO_IDATA5
value|'c'
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"nodelete"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"dllname"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"no-idata4"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_IDATA4
block|}
block|,
block|{
literal|"no-idata5"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_IDATA5
block|}
block|,
block|{
literal|"output-exp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"output-def"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"output-lib"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"def"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"add-underscore"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"killat"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"machine"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"add-indirect"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"base-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"as"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|firstarg
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
name|oav
operator|=
name|av
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"xcz:S:R:A:puaD:l:e:nkvbUh?m:yd:"
argument_list|,
name|long_options
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_NO_IDATA4
case|:
name|no_idata4
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_NO_IDATA5
case|:
name|no_idata5
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|as_name
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* ignored for compatibility */
case|case
literal|'u'
case|:
break|break;
case|case
literal|'a'
case|:
name|add_indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|output_def
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dll_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|imp_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|exp_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|yydebug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|add_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|killat
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|def_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dontdeltemps
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|base_file
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unable to open base-file %s\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mtable
index|[
name|i
index|]
operator|.
name|type
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|mtable
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|mtable
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Machine not supported\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|machine
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|dll_name
operator|&&
name|exp_name
condition|)
block|{
name|char
name|len
init|=
name|strlen
argument_list|(
name|exp_name
argument_list|)
operator|+
literal|5
decl_stmt|;
name|dll_name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dll_name
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dll_name
argument_list|,
literal|".dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|def_file
condition|)
block|{
name|process_def_file
argument_list|(
name|def_file
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optind
operator|<
name|ac
condition|)
block|{
if|if
condition|(
operator|!
name|firstarg
condition|)
name|firstarg
operator|=
name|av
index|[
name|optind
index|]
expr_stmt|;
name|scan_obj_file
argument_list|(
name|av
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
name|mangle_defs
argument_list|()
expr_stmt|;
if|if
condition|(
name|exp_name
condition|)
name|gen_exp_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|imp_name
condition|)
block|{
comment|/* Make imp_name safe for use as a label. */
name|char
modifier|*
name|p
decl_stmt|;
name|imp_name_lab
operator|=
name|strdup
argument_list|(
name|imp_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|imp_name_lab
init|;
operator|*
name|p
condition|;
operator|*
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
name|head_label
operator|=
name|make_label
argument_list|(
literal|"_head_"
argument_list|,
name|imp_name_lab
argument_list|)
expr_stmt|;
name|gen_lib_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_def
condition|)
name|gen_def_file
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

