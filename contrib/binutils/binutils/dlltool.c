begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dlltool.c -- tool to generate stuff for PE style DLLs    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/*    This program allows you to build the files necessary to create    DLLs to run on a system which understands PE format image files.    (eg, Windows NT)     See "Peering Inside the PE: A Tour of the Win32 Portable Executable    File Format", MSJ 1994, Volume 9 for more information.    Also see "Microsoft Portable Executable and Common Object File Format,    Specification 4.1" for more information.     A DLL contains an export table which contains the information    which the runtime loader needs to tie up references from a    referencing program.     The export table is generated by this program by reading    in a .DEF file or scanning the .a and .o files which will be in the    DLL.  A .o file can contain information in special  ".drectve" sections    with export information.     A DEF file contains any number of the following commands:      NAME<name> [ ,<base> ]    The result is going to be<name>.EXE     LIBRARY<name> [ ,<base> ]    The result is going to be<name>.DLL     EXPORTS  ( (  (<name1> [ =<name2> ] )                | (<name1> =<module-name> .<external-name>))             [ @<integer> ] [ NONAME ] [CONSTANT] [DATA] ) *    Declares name1 as an exported symbol from the    DLL, with optional ordinal number<integer>.    Or declares name1 as an alias (forward) of the function<external-name>    in the DLL<module-name>.     IMPORTS  (  (<internal-name> =<module-name> .<integer> )              | ( [<internal-name> = ]<module-name> .<external-name> )) *    Declares that<external-name> or the exported function whoes ordinal number    is<integer> is to be imported from the file<module-name>.  If<internal-name> is specified then this is the name that the imported    function will be refered to in the body of the DLL.     DESCRIPTION<string>    Puts<string> into output .exp file in the .rdata section     [STACKSIZE|HEAPSIZE]<number-reserve> [ ,<number-commit> ]    Generates --stack|--heap<number-reserve>,<number-commit>    in the output .drectve section.  The linker will    see this and act upon it.     [CODE|DATA]<attr>+    SECTIONS (<sectionname><attr>+ )*<attr> = READ | WRITE | EXECUTE | SHARED    Generates --attr<sectionname><attr> in the output    .drectve section.  The linker will see this and act    upon it.      A -export:<name> in a .drectve section in an input .o or .a    file to this program is equivalent to a EXPORTS<name>    in a .DEF file.       The program generates output files with the prefix supplied    on the command line, or in the def file, or taken from the first    supplied argument.     The .exp.s file contains the information necessary to export    the routines in the DLL.  The .lib.s file contains the information    necessary to use the DLL's routines from a referencing program.       Example:   file1.c:    asm (".section .drectve");    asm (".ascii \"-export:adef\"");     void adef (char * s)    {      printf ("hello from the dll %s\n", s);    }     void bdef (char * s)    {      printf ("hello from the dll and the other entry point %s\n", s);    }   file2.c:    asm (".section .drectve");    asm (".ascii \"-export:cdef\"");    asm (".ascii \"-export:ddef\"");     void cdef (char * s)    {      printf ("hello from the dll %s\n", s);    }     void ddef (char * s)    {      printf ("hello from the dll and the other entry point %s\n", s);    }     int printf (void)    {      return 9;    }   themain.c:    int main (void)    {      cdef ();      return 0;    }   thedll.def     LIBRARY thedll    HEAPSIZE 0x40000, 0x2000    EXPORTS bdef @ 20            cdef @ 30 NONAME     SECTIONS donkey READ WRITE    aardvark EXECUTE   # Compile up the parts of the dll and the program     gcc -c file1.c file2.c themain.c   # Optional: put the dll objects into a library  # (you don't have to, you could name all the object  # files on the dlltool line)     ar  qcv thedll.in file1.o file2.o    ranlib thedll.in   # Run this tool over the DLL's .def file and generate an exports  # file (thedll.o) and an imports file (thedll.a).  # (You may have to use -S to tell dlltool where to find the assembler).     dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a   # Build the dll with the library and the export table     ld -o thedll.dll thedll.o thedll.in   # Link the executable with the import library     gcc -o themain.exe themain.o thedll.a   This example can be extended if relocations are needed in the DLL:   # Compile up the parts of the dll and the program     gcc -c file1.c file2.c themain.c   # Run this tool over the DLL's .def file and generate an imports file.     dlltool --def thedll.def --output-lib thedll.lib   # Link the executable with the import library and generate a base file  # at the same time     gcc -o themain.exe themain.o thedll.lib -Wl,--base-file -Wl,themain.base   # Run this tool over the DLL's .def file and generate an exports file  # which includes the relocations from the base file.     dlltool --def thedll.def --base-file themain.base --output-exp thedll.exp   # Build the dll with file1.o, file2.o and the export table     ld -o thedll.dll thedll.exp file1.o file2.o  */
end_comment

begin_comment
comment|/* .idata section description     The .idata section is the import table.  It is a collection of several    subsections used to keep the pieces for each dll together: .idata$[234567].    IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.     .idata$2 = Import Directory Table    = array of IMAGE_IMPORT_DESCRIPTOR's.  	DWORD   Import Lookup Table;  - pointer to .idata$4 	DWORD   TimeDateStamp;        - currently always 0 	DWORD   ForwarderChain;       - currently always 0 	DWORD   Name;                 - pointer to dll's name 	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5     .idata$3 = null terminating entry for .idata$2.     .idata$4 = Import Lookup Table    = array of array of pointers to hint name table.    There is one for each dll being imported from, and each dll's set is    terminated by a trailing NULL.     .idata$5 = Import Address Table    = array of array of pointers to hint name table.    There is one for each dll being imported from, and each dll's set is    terminated by a trailing NULL.    Initially, this table is identical to the Import Lookup Table.  However,    at load time, the loader overwrites the entries with the address of the    function.     .idata$6 = Hint Name Table    = Array of { short, asciz } entries, one for each imported function.    The `short' is the function's ordinal number.     .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc) */
end_comment

begin_comment
comment|/* AIX requires this to be the first thing in the file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|show_allnames
value|0
end_define

begin_define
define|#
directive|define
name|PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|PAGE_MASK
value|(-PAGE_SIZE)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_include
include|#
directive|include
file|"dlltool.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_ARM
end_ifdef

begin_include
include|#
directive|include
file|"coff/arm.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward references.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|look_for_prog
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|deduce_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
end_ifdef

begin_function_decl
specifier|static
name|void
name|mcore_elf_cache_filename
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcore_elf_gen_out_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! HAVE_SYS_WAIT_H */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|(((w)&0377) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|(((w)&0377) != 0177&& ((w)&~0377) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|((w)& 0177)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|w
parameter_list|)
value|(((w)>> 8)& 0377)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined (_WIN32)&& ! defined (__CYGWIN32__) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|(((w)& 0xff) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|(((w)& 0xff) != 0&& ((w)& 0xff) != 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|w
parameter_list|)
value|((w)& 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|w
parameter_list|)
value|(((w)& 0xff00)>> 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (_WIN32)&& ! defined (__CYGWIN32__) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_SYS_WAIT_H */
end_comment

begin_comment
comment|/* ifunc and ihead data structures: ttk@cygnus.com 1997     When IMPORT declarations are encountered in a .def file the    function import information is stored in a structure referenced by    the global variable IMPORT_LIST.  The structure is a linked list    containing the names of the dll files each function is imported    from and a linked list of functions being imported from that dll    file.  This roughly parallels the structure of the .idata section    in the PE object file.     The contents of .def file are interpreted from within the    process_def_file function.  Every time an IMPORT declaration is    encountered, it is broken up into its component parts and passed to    def_import.  IMPORT_LIST is initialized to NULL in function main.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ifunct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of function being imported */
name|int
name|ord
decl_stmt|;
comment|/* two-byte ordinal value associated with function */
name|struct
name|ifunct
modifier|*
name|next
decl_stmt|;
block|}
name|ifunctype
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|iheadt
block|{
name|char
modifier|*
name|dllname
decl_stmt|;
comment|/* name of dll file imported from */
name|long
name|nfuncs
decl_stmt|;
comment|/* number of functions in list */
name|struct
name|ifunct
modifier|*
name|funchead
decl_stmt|;
comment|/* first function in list */
name|struct
name|ifunct
modifier|*
name|functail
decl_stmt|;
comment|/* last  function in list */
name|struct
name|iheadt
modifier|*
name|next
decl_stmt|;
comment|/* next dll file in list */
block|}
name|iheadtype
typedef|;
end_typedef

begin_comment
comment|/* Structure containing all import information as defined in .def file    (qv "ihead structure").  */
end_comment

begin_decl_stmt
specifier|static
name|iheadtype
modifier|*
name|import_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|as_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|as_flags
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_idata4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|no_idata5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|exp_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|imp_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|head_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|imp_name_lab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dll_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_indirect
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dontdeltemps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should export all symbols.  Otherwise, we only export    symbols listed in .drectve sections or in the def file.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|export_all_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should exclude the symbols in DEFAULT_EXCLUDES when    exporting all symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|do_default_excludes
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default symbols to exclude when exporting all the symbols.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_excludes
init|=
literal|"DllMain@12,DllEntryPoint@0,impure_ptr"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should add __imp_<SYMBOL> to import libraries for backward    compatibility to old Cygwin releases.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|create_compat_implib
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|def_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|killat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_stdcall_alias
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output_def
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|base_file
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_ARM
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_ARM_EPOC
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"arm-epoc"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"arm"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_I386
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"i386"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"ppc"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_SH
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"sh"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_MIPS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"mips"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"mcore-le"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mname
init|=
literal|"mcore-elf"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mcore_elf_out_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mcore_elf_linker
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mcore_elf_linker_flags
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DRECTVE_SECTION_NAME
value|((machine == MMCORE_ELF || machine == MMCORE_ELF_LE) ? ".exports" : ".drectve")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DRECTVE_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|DRECTVE_SECTION_NAME
value|".drectve"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PATHMAX
value|250
end_define

begin_comment
comment|/* What's the right name for this ? */
end_comment

begin_define
define|#
directive|define
name|TMP_ASM
value|"dc.s"
end_define

begin_define
define|#
directive|define
name|TMP_HEAD_S
value|"dh.s"
end_define

begin_define
define|#
directive|define
name|TMP_HEAD_O
value|"dh.o"
end_define

begin_define
define|#
directive|define
name|TMP_TAIL_S
value|"dt.s"
end_define

begin_define
define|#
directive|define
name|TMP_TAIL_O
value|"dt.o"
end_define

begin_define
define|#
directive|define
name|TMP_STUB
value|"ds"
end_define

begin_comment
comment|/* This bit of assemly does jmp * ....  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|i386_jtab
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|arm_jtab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0xc0
block|,
literal|0x9f
block|,
literal|0xe5
block|,
comment|/* ldr  ip, [pc] */
literal|0x00
block|,
literal|0xf0
block|,
literal|0x9c
block|,
literal|0xe5
block|,
comment|/* ldr  pc, [ip] */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|arm_interwork_jtab
index|[]
init|=
block|{
literal|0x04
block|,
literal|0xc0
block|,
literal|0x9f
block|,
literal|0xe5
block|,
comment|/* ldr  ip, [pc] */
literal|0x00
block|,
literal|0xc0
block|,
literal|0x9c
block|,
literal|0xe5
block|,
comment|/* ldr  ip, [ip] */
literal|0x1c
block|,
literal|0xff
block|,
literal|0x2f
block|,
literal|0xe1
block|,
comment|/* bx   ip       */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|thumb_jtab
index|[]
init|=
block|{
literal|0x40
block|,
literal|0xb4
block|,
comment|/* push {r6}         */
literal|0x02
block|,
literal|0x4e
block|,
comment|/* ldr  r6, [pc, #8] */
literal|0x36
block|,
literal|0x68
block|,
comment|/* ldr  r6, [r6]     */
literal|0xb4
block|,
literal|0x46
block|,
comment|/* mov  ip, r6       */
literal|0x40
block|,
literal|0xbc
block|,
comment|/* pop  {r6}         */
literal|0x60
block|,
literal|0x47
block|,
comment|/* bx   ip           */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|mcore_be_jtab
index|[]
init|=
block|{
literal|0x71
block|,
literal|0x02
block|,
comment|/* lrw r1,2       */
literal|0x81
block|,
literal|0x01
block|,
comment|/* ld.w r1,(r1,0) */
literal|0x00
block|,
literal|0xC1
block|,
comment|/* jmp r1         */
literal|0x12
block|,
literal|0x00
block|,
comment|/* nop            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
comment|/*<address>      */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|mcore_le_jtab
index|[]
init|=
block|{
literal|0x02
block|,
literal|0x71
block|,
comment|/* lrw r1,2       */
literal|0x01
block|,
literal|0x81
block|,
comment|/* ld.w r1,(r1,0) */
literal|0xC1
block|,
literal|0x00
block|,
comment|/* jmp r1         */
literal|0x00
block|,
literal|0x12
block|,
comment|/* nop            */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
comment|/*<address>      */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the glue sequence for PowerPC PE. There is a  */
end_comment

begin_comment
comment|/* tocrel16-tocdefn reloc against the first instruction.  */
end_comment

begin_comment
comment|/* We also need a IMGLUE reloc against the glue function */
end_comment

begin_comment
comment|/* to restore the toc saved by the third instruction in  */
end_comment

begin_comment
comment|/* the glue.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|ppc_jtab
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x62
block|,
literal|0x81
block|,
comment|/* lwz r11,0(r2)               */
comment|/*   Reloc TOCREL16 __imp_xxx  */
literal|0x00
block|,
literal|0x00
block|,
literal|0x8B
block|,
literal|0x81
block|,
comment|/* lwz r12,0(r11)              */
literal|0x04
block|,
literal|0x00
block|,
literal|0x41
block|,
literal|0x90
block|,
comment|/* stw r2,4(r1)                */
literal|0xA6
block|,
literal|0x03
block|,
literal|0x89
block|,
literal|0x7D
block|,
comment|/* mtctr r12                   */
literal|0x04
block|,
literal|0x00
block|,
literal|0x4B
block|,
literal|0x80
block|,
comment|/* lwz r2,4(r11)               */
literal|0x20
block|,
literal|0x04
block|,
literal|0x80
block|,
literal|0x4E
comment|/* bctr                        */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
end_ifdef

begin_comment
comment|/* the glue instruction, picks up the toc from the stw in */
end_comment

begin_comment
comment|/* the above code: "lwz r2,4(r1)"                         */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|ppc_glue_insn
init|=
literal|0x80410004
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mac
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_byte
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_short
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_long
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_asciz
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_comment
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_jump
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_global
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_space
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_align_short
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_align_long
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_default_as_switches
decl_stmt|;
specifier|const
name|char
modifier|*
name|how_bfd_target
decl_stmt|;
name|enum
name|bfd_architecture
name|how_bfd_arch
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|how_jtab
decl_stmt|;
name|int
name|how_jtab_size
decl_stmt|;
comment|/* size of the jtab entry */
name|int
name|how_jtab_roff
decl_stmt|;
comment|/* offset into it for the ind 32 reloc into idata 5 */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mac
name|mtable
index|[]
init|=
block|{
block|{
define|#
directive|define
name|MARM
value|0
literal|"arm"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"@"
block|,
literal|"ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"-mapcs-32"
block|,
literal|"pe-arm-little"
block|,
name|bfd_arch_arm
block|,
name|arm_jtab
block|,
sizeof|sizeof
argument_list|(
name|arm_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|M386
value|1
literal|"i386"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"#"
block|,
literal|"jmp *"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|""
block|,
literal|"pe-i386"
block|,
name|bfd_arch_i386
block|,
name|i386_jtab
block|,
sizeof|sizeof
argument_list|(
name|i386_jtab
argument_list|)
block|,
literal|2
block|}
block|,
block|{
define|#
directive|define
name|MPPC
value|2
literal|"ppc"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"#"
block|,
literal|"jmp *"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|""
block|,
literal|"pe-powerpcle"
block|,
name|bfd_arch_powerpc
block|,
name|ppc_jtab
block|,
sizeof|sizeof
argument_list|(
name|ppc_jtab
argument_list|)
block|,
literal|0
block|}
block|,
block|{
define|#
directive|define
name|MTHUMB
value|3
literal|"thumb"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"@"
block|,
literal|"push\t{r6}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tmov\tip, r6\n\tpop\t{r6}\n\tbx\tip"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"-mthumb-interwork"
block|,
literal|"pe-arm-little"
block|,
name|bfd_arch_arm
block|,
name|thumb_jtab
block|,
sizeof|sizeof
argument_list|(
name|thumb_jtab
argument_list|)
block|,
literal|12
block|}
block|,
define|#
directive|define
name|MARM_INTERWORK
value|4
block|{
literal|"arm_interwork"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"@"
block|,
literal|"ldr\tip,[pc]\n\tldr\tip,[ip]\n\tbx\tip\n\t.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"-mthumb-interwork"
block|,
literal|"pe-arm-little"
block|,
name|bfd_arch_arm
block|,
name|arm_interwork_jtab
block|,
sizeof|sizeof
argument_list|(
name|arm_interwork_jtab
argument_list|)
block|,
literal|12
block|}
block|,
block|{
define|#
directive|define
name|MMCORE_BE
value|5
literal|"mcore-be"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"//"
block|,
literal|"lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|""
block|,
literal|"pe-mcore-big"
block|,
name|bfd_arch_mcore
block|,
name|mcore_be_jtab
block|,
sizeof|sizeof
argument_list|(
name|mcore_be_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|MMCORE_LE
value|6
literal|"mcore-le"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"//"
block|,
literal|"lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"-EL"
block|,
literal|"pe-mcore-little"
block|,
name|bfd_arch_mcore
block|,
name|mcore_le_jtab
block|,
sizeof|sizeof
argument_list|(
name|mcore_le_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|MMCORE_ELF
value|7
literal|"mcore-elf-be"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"//"
block|,
literal|"lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|""
block|,
literal|"elf32-mcore-big"
block|,
name|bfd_arch_mcore
block|,
name|mcore_be_jtab
block|,
sizeof|sizeof
argument_list|(
name|mcore_be_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|MMCORE_ELF_LE
value|8
literal|"mcore-elf-le"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"//"
block|,
literal|"lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|"-EL"
block|,
literal|"elf32-mcore-little"
block|,
name|bfd_arch_mcore
block|,
name|mcore_le_jtab
block|,
sizeof|sizeof
argument_list|(
name|mcore_le_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
define|#
directive|define
name|MARM_EPOC
value|9
literal|"arm-epoc"
block|,
literal|".byte"
block|,
literal|".short"
block|,
literal|".long"
block|,
literal|".asciz"
block|,
literal|"@"
block|,
literal|"ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long"
block|,
literal|".global"
block|,
literal|".space"
block|,
literal|".align\t2"
block|,
literal|".align\t4"
block|,
literal|""
block|,
literal|"epoc-pe-arm-little"
block|,
name|bfd_arch_arm
block|,
name|arm_jtab
block|,
sizeof|sizeof
argument_list|(
name|arm_jtab
argument_list|)
block|,
literal|8
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|dlist
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|struct
name|dlist
modifier|*
name|next
decl_stmt|;
block|}
name|dlist_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|export
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|internal_name
decl_stmt|;
name|int
name|ordinal
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|int
name|noname
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|hint
decl_stmt|;
name|int
name|forward
decl_stmt|;
comment|/* number of forward label, 0 means no forward */
name|struct
name|export
modifier|*
name|next
decl_stmt|;
block|}
name|export_type
typedef|;
end_typedef

begin_comment
comment|/* A list of symbols which we should not export.  */
end_comment

begin_struct
struct|struct
name|string_list
block|{
name|struct
name|string_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|string_list
modifier|*
name|excludes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rvaafter
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rvabefore
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|asm_prefix
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_def_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|new_directive
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_import
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|run
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_drectve_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_filtered_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_excludes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|match_exclude
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_default_excludes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|filter_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_all_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_open_obj_file
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_obj_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_def_info
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sfunc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_page
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|long
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_def_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generate_idata_ofile
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assemble_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_exp_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|xlate
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_iat PARAMS ((FILE *, export_type *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|make_label
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|make_one_lib_file
name|PARAMS
argument_list|(
operator|(
name|export_type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|make_head
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|make_tail
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_lib_file
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pfunc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfunc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_null_names
name|PARAMS
argument_list|(
operator|(
name|export_type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dtab
name|PARAMS
argument_list|(
operator|(
name|export_type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_duplicates
name|PARAMS
argument_list|(
operator|(
name|export_type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_ordinals
name|PARAMS
argument_list|(
operator|(
name|export_type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alphafunc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mangle_defs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inform
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inform
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|message
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
return|return;
name|report
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rvaafter
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
case|case
name|M386
case|:
case|case
name|MPPC
case|:
case|case
name|MTHUMB
case|:
case|case
name|MARM_INTERWORK
case|:
case|case
name|MMCORE_BE
case|:
case|case
name|MMCORE_LE
case|:
case|case
name|MMCORE_ELF
case|:
case|case
name|MMCORE_ELF_LE
case|:
case|case
name|MARM_EPOC
case|:
break|break;
default|default:
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error: Unknown machine type: %d"
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rvabefore
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
case|case
name|M386
case|:
case|case
name|MPPC
case|:
case|case
name|MTHUMB
case|:
case|case
name|MARM_INTERWORK
case|:
case|case
name|MMCORE_BE
case|:
case|case
name|MMCORE_LE
case|:
case|case
name|MMCORE_ELF
case|:
case|case
name|MMCORE_ELF_LE
case|:
case|case
name|MARM_EPOC
case|:
return|return
literal|".rva\t"
return|;
default|default:
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error: Unknown machine type: %d"
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|asm_prefix
parameter_list|(
name|machine
parameter_list|)
name|int
name|machine
decl_stmt|;
block|{
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|MARM
case|:
case|case
name|MPPC
case|:
case|case
name|MTHUMB
case|:
case|case
name|MARM_INTERWORK
case|:
case|case
name|MMCORE_BE
case|:
case|case
name|MMCORE_LE
case|:
case|case
name|MMCORE_ELF
case|:
case|case
name|MMCORE_ELF_LE
case|:
case|case
name|MARM_EPOC
case|:
break|break;
case|case
name|M386
case|:
return|return
literal|"_"
return|;
default|default:
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Internal error: Unknown machine type: %d"
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASM_BYTE
value|mtable[machine].how_byte
end_define

begin_define
define|#
directive|define
name|ASM_SHORT
value|mtable[machine].how_short
end_define

begin_define
define|#
directive|define
name|ASM_LONG
value|mtable[machine].how_long
end_define

begin_define
define|#
directive|define
name|ASM_TEXT
value|mtable[machine].how_asciz
end_define

begin_define
define|#
directive|define
name|ASM_C
value|mtable[machine].how_comment
end_define

begin_define
define|#
directive|define
name|ASM_JUMP
value|mtable[machine].how_jump
end_define

begin_define
define|#
directive|define
name|ASM_GLOBAL
value|mtable[machine].how_global
end_define

begin_define
define|#
directive|define
name|ASM_SPACE
value|mtable[machine].how_space
end_define

begin_define
define|#
directive|define
name|ASM_ALIGN_SHORT
value|mtable[machine].how_align_short
end_define

begin_define
define|#
directive|define
name|ASM_RVA_BEFORE
value|rvabefore(machine)
end_define

begin_define
define|#
directive|define
name|ASM_RVA_AFTER
value|rvaafter(machine)
end_define

begin_define
define|#
directive|define
name|ASM_PREFIX
value|asm_prefix(machine)
end_define

begin_define
define|#
directive|define
name|ASM_ALIGN_LONG
value|mtable[machine].how_align_long
end_define

begin_define
define|#
directive|define
name|HOW_BFD_READ_TARGET
value|0
end_define

begin_comment
comment|/* always default*/
end_comment

begin_define
define|#
directive|define
name|HOW_BFD_WRITE_TARGET
value|mtable[machine].how_bfd_target
end_define

begin_define
define|#
directive|define
name|HOW_BFD_ARCH
value|mtable[machine].how_bfd_arch
end_define

begin_define
define|#
directive|define
name|HOW_JTAB
value|mtable[machine].how_jtab
end_define

begin_define
define|#
directive|define
name|HOW_JTAB_SIZE
value|mtable[machine].how_jtab_size
end_define

begin_define
define|#
directive|define
name|HOW_JTAB_ROFF
value|mtable[machine].how_jtab_roff
end_define

begin_define
define|#
directive|define
name|ASM_SWITCHES
value|mtable[machine].how_default_as_switches
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|oav
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|process_def_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|name
argument_list|,
name|FOPEN_RT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Can't open def file: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|f
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Processing def file: %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|inform
argument_list|(
name|_
argument_list|(
literal|"Processed def file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* Communications with the parser */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|d_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arg to NAME or LIBRARY */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_nfuncs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of functions exported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_named_nfuncs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of named functions exported */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_low_ord
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest ordinal index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_high_ord
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest ordinal index */
end_comment

begin_decl_stmt
specifier|static
name|export_type
modifier|*
name|d_exports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*list of exported functions */
end_comment

begin_decl_stmt
specifier|static
name|export_type
modifier|*
modifier|*
name|d_exports_lexically
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vector of exported functions in alpha order */
end_comment

begin_decl_stmt
specifier|static
name|dlist_type
modifier|*
name|d_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptions */
end_comment

begin_decl_stmt
specifier|static
name|dlist_type
modifier|*
name|a_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff to go in directives */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_nforwards
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of forwarded exports */
end_comment

begin_decl_stmt
specifier|static
name|int
name|d_is_dll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|d_is_exe
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yyerror
parameter_list|(
name|err
parameter_list|)
specifier|const
name|char
modifier|*
name|err
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Syntax error in def file %s:%d"
argument_list|)
argument_list|,
name|def_file
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|def_exports
parameter_list|(
name|name
parameter_list|,
name|internal_name
parameter_list|,
name|ordinal
parameter_list|,
name|noname
parameter_list|,
name|constant
parameter_list|,
name|data
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|internal_name
decl_stmt|;
name|int
name|ordinal
decl_stmt|;
name|int
name|noname
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
name|struct
name|export
modifier|*
name|p
init|=
operator|(
expr|struct
name|export
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|internal_name
operator|=
name|internal_name
condition|?
name|internal_name
else|:
name|name
expr_stmt|;
name|p
operator|->
name|ordinal
operator|=
name|ordinal
expr_stmt|;
name|p
operator|->
name|constant
operator|=
name|constant
expr_stmt|;
name|p
operator|->
name|noname
operator|=
name|noname
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|d_exports
expr_stmt|;
name|d_exports
operator|=
name|p
expr_stmt|;
name|d_nfuncs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|internal_name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|internal_name
argument_list|,
literal|'.'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|p
operator|->
name|forward
operator|=
operator|++
name|d_nforwards
expr_stmt|;
else|else
name|p
operator|->
name|forward
operator|=
literal|0
expr_stmt|;
comment|/* no forward */
block|}
end_function

begin_function
name|void
name|def_name
parameter_list|(
name|name
parameter_list|,
name|base
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"NAME: %s base: %x"
argument_list|)
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_is_dll
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't have LIBRARY and NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|d_name
operator|=
name|name
expr_stmt|;
comment|/* if --dllname not provided, use the one in the DEF file.      FIXME: Is this appropriate for executables? */
if|if
condition|(
operator|!
name|dll_name
condition|)
name|dll_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d_is_exe
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_library
parameter_list|(
name|name
parameter_list|,
name|base
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"LIBRARY: %s base: %x"
argument_list|)
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_is_exe
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't have LIBRARY and NAME"
argument_list|)
argument_list|)
expr_stmt|;
name|d_name
operator|=
name|name
expr_stmt|;
comment|/* if --dllname not provided, use the one in the DEF file.  */
if|if
condition|(
operator|!
name|dll_name
condition|)
name|dll_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d_is_dll
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_description
parameter_list|(
name|desc
parameter_list|)
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|{
name|dlist_type
modifier|*
name|d
init|=
operator|(
name|dlist_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dlist_type
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|text
operator|=
name|xstrdup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|d_list
expr_stmt|;
name|d_list
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_directive
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|dlist_type
modifier|*
name|d
init|=
operator|(
name|dlist_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dlist_type
argument_list|)
argument_list|)
decl_stmt|;
name|d
operator|->
name|text
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|d
operator|->
name|next
operator|=
name|a_list
expr_stmt|;
name|a_list
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_heapsize
parameter_list|(
name|reserve
parameter_list|,
name|commit
parameter_list|)
name|int
name|reserve
decl_stmt|;
name|int
name|commit
decl_stmt|;
block|{
name|char
name|b
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|commit
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-heap 0x%x,0x%x "
argument_list|,
name|reserve
argument_list|,
name|commit
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-heap 0x%x "
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|xstrdup
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_stacksize
parameter_list|(
name|reserve
parameter_list|,
name|commit
parameter_list|)
name|int
name|reserve
decl_stmt|;
name|int
name|commit
decl_stmt|;
block|{
name|char
name|b
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|commit
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-stack 0x%x,0x%x "
argument_list|,
name|reserve
argument_list|,
name|commit
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"-stack 0x%x "
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|xstrdup
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* append_import simply adds the given import definition to the global    import_list.  It is used by def_import.  */
end_comment

begin_function
specifier|static
name|void
name|append_import
parameter_list|(
name|symbol_name
parameter_list|,
name|dll_name
parameter_list|,
name|func_ordinal
parameter_list|)
specifier|const
name|char
modifier|*
name|symbol_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dll_name
decl_stmt|;
name|int
name|func_ordinal
decl_stmt|;
block|{
name|iheadtype
modifier|*
modifier|*
name|pq
decl_stmt|;
name|iheadtype
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|pq
operator|=
operator|&
name|import_list
init|;
operator|*
name|pq
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
operator|(
operator|*
name|pq
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pq
operator|)
operator|->
name|dllname
argument_list|,
name|dll_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|q
operator|=
operator|*
name|pq
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|next
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ifunctype
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|functail
operator|=
name|q
operator|->
name|functail
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|ord
operator|=
name|func_ordinal
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|nfuncs
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|q
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|iheadtype
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|dllname
operator|=
name|xstrdup
argument_list|(
name|dll_name
argument_list|)
expr_stmt|;
name|q
operator|->
name|nfuncs
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|funchead
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ifunctype
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|functail
operator|=
name|q
operator|->
name|funchead
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|ord
operator|=
name|func_ordinal
expr_stmt|;
name|q
operator|->
name|functail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pq
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_comment
comment|/* def_import is called from within defparse.y when an IMPORT    declaration is encountered.  Depending on the form of the    declaration, the module name may or may not need ".dll" to be    appended to it, the name of the function may be stored in internal    or entry, and there may or may not be an ordinal value associated    with it.  */
end_comment

begin_comment
comment|/* A note regarding the parse modes:    In defparse.y we have to accept import declarations which follow    any one of the following forms:<func_name_in_app> =<dll_name>.<func_name_in_dll><func_name_in_app> =<dll_name>.<number><dll_name>.<func_name_in_dll><dll_name>.<number>    Furthermore, the dll's name may or may not end with ".dll", which    complicates the parsing a little.  Normally the dll's name is    passed to def_import() in the "module" parameter, but when it ends    with ".dll" it gets passed in "module" sans ".dll" and that needs    to be reappended.    def_import gets five parameters:   APP_NAME - the name of the function in the application, if              present, or NULL if not present.   MODULE   - the name of the dll, possibly sans extension (ie, '.dll').   DLLEXT   - the extension of the dll, if present, NULL if not present.   ENTRY    - the name of the function in the dll, if present, or NULL.   ORD_VAL  - the numerical tag of the function in the dll, if present,              or NULL.  Exactly one of<entry> or<ord_val> must be              present (i.e., not NULL).  */
end_comment

begin_function
name|void
name|def_import
parameter_list|(
name|app_name
parameter_list|,
name|module
parameter_list|,
name|dllext
parameter_list|,
name|entry
parameter_list|,
name|ord_val
parameter_list|)
specifier|const
name|char
modifier|*
name|app_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|module
decl_stmt|;
specifier|const
name|char
modifier|*
name|dllext
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
name|int
name|ord_val
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|application_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
name|application_name
operator|=
name|entry
expr_stmt|;
else|else
block|{
if|if
condition|(
name|app_name
operator|!=
name|NULL
condition|)
name|application_name
operator|=
name|app_name
expr_stmt|;
else|else
name|application_name
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|dllext
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|module
argument_list|)
operator|+
name|strlen
argument_list|(
name|dllext
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%s"
argument_list|,
name|module
argument_list|,
name|dllext
argument_list|)
expr_stmt|;
name|module
operator|=
name|buf
expr_stmt|;
block|}
name|append_import
argument_list|(
name|application_name
argument_list|,
name|module
argument_list|,
name|ord_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_version
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
name|int
name|major
decl_stmt|;
name|int
name|minor
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"VERSION %d.%d\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_section
parameter_list|(
name|name
parameter_list|,
name|attr
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|attr
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|char
name|atts
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|atts
decl_stmt|;
if|if
condition|(
name|attr
operator|&
literal|1
condition|)
operator|*
name|d
operator|++
operator|=
literal|'R'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|2
condition|)
operator|*
name|d
operator|++
operator|=
literal|'W'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|4
condition|)
operator|*
name|d
operator|++
operator|=
literal|'X'
expr_stmt|;
if|if
condition|(
name|attr
operator|&
literal|8
condition|)
operator|*
name|d
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-attr %s %s"
argument_list|,
name|name
argument_list|,
name|atts
argument_list|)
expr_stmt|;
name|new_directive
argument_list|(
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_code
parameter_list|(
name|attr
parameter_list|)
name|int
name|attr
decl_stmt|;
block|{
name|def_section
argument_list|(
literal|"CODE"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|def_data
parameter_list|(
name|attr
parameter_list|)
name|int
name|attr
decl_stmt|;
block|{
name|def_section
argument_list|(
literal|"DATA"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|run
parameter_list|(
name|what
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|wait_status
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|errmsg_fmt
decl_stmt|,
modifier|*
name|errmsg_arg
decl_stmt|;
name|char
modifier|*
name|temp_base
init|=
name|choose_temp_base
argument_list|()
decl_stmt|;
name|inform
argument_list|(
literal|"run: %s %s"
argument_list|,
name|what
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Count the args */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|args
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|i
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|argv
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|what
expr_stmt|;
name|s
operator|=
name|args
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|++
name|s
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|0
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
break|break;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|pid
operator|=
name|pexecute
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
name|program_name
argument_list|,
name|temp_base
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
name|PEXECUTE_ONE
operator||
name|PEXECUTE_SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|inform
argument_list|(
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|pwait
argument_list|(
name|pid
argument_list|,
operator|&
name|wait_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"wait: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"subprocess got fatal signal %d"
argument_list|)
argument_list|,
name|WTERMSIG
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|wait_status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
operator|!=
literal|0
condition|)
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s exited with status %d"
argument_list|)
argument_list|,
name|what
argument_list|,
name|WEXITSTATUS
argument_list|(
name|wait_status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for a list of symbols to export in the .drectve section of    ABFD.  Pass each one to def_exports.  */
end_comment

begin_function
specifier|static
name|void
name|scan_drectve_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
comment|/* Look for .drectve's */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|DRECTVE_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Sucking in info from %s section in %s"
argument_list|)
argument_list|,
name|DRECTVE_SECTION_NAME
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Search for -export: strings. The exported symbols can optionally      have type tags (eg., -export:foo,data), so handle those as well.      Currently only data tag is supported.  */
name|p
operator|=
name|buf
expr_stmt|;
name|e
operator|=
name|buf
operator|+
name|size
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|e
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-export:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|flagword
name|flags
init|=
name|BSF_FUNCTION
decl_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|name
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|c
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|c
index|[
name|p
operator|-
name|name
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|==
literal|','
condition|)
comment|/* found type tag.  */
block|{
name|char
modifier|*
name|tag_start
init|=
operator|++
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|e
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tag_start
argument_list|,
literal|"data"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator|&=
operator|~
name|BSF_FUNCTION
expr_stmt|;
block|}
comment|/* FIXME: The 5th arg is for the `constant' field. 	     What should it be?  Not that it matters since it's not 	     currently useful.  */
name|def_exports
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|!
operator|(
name|flags
operator|&
name|BSF_FUNCTION
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_stdcall_alias
operator|&&
name|strchr
argument_list|(
name|c
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|exported_name
init|=
name|xstrdup
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|char
modifier|*
name|atsym
init|=
name|strchr
argument_list|(
name|exported_name
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
operator|*
name|atsym
operator|=
literal|'\0'
expr_stmt|;
comment|/* Note: stdcall alias symbols can never be data.  */
name|def_exports
argument_list|(
name|exported_name
argument_list|,
name|xstrdup
argument_list|(
name|c
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the symbols in MINISYMS, and add each one to list of    symbols to export.  */
end_comment

begin_function
specifier|static
name|void
name|scan_filtered_symbols
parameter_list|(
name|abfd
parameter_list|,
name|minisyms
parameter_list|,
name|symcount
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|minisyms
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|asymbol
modifier|*
name|store
decl_stmt|;
name|bfd_byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|;
name|store
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
operator|*
name|size
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|+=
name|size
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|,
name|from
argument_list|,
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
name|symbol_name
index|[
literal|0
index|]
condition|)
operator|++
name|symbol_name
expr_stmt|;
name|def_exports
argument_list|(
name|xstrdup
argument_list|(
name|symbol_name
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|!
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_stdcall_alias
operator|&&
name|strchr
argument_list|(
name|symbol_name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|exported_name
init|=
name|xstrdup
argument_list|(
name|symbol_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|atsym
init|=
name|strchr
argument_list|(
name|exported_name
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
operator|*
name|atsym
operator|=
literal|'\0'
expr_stmt|;
comment|/* Note: stdcall alias symbols can never be data.  */
name|def_exports
argument_list|(
name|exported_name
argument_list|,
name|xstrdup
argument_list|(
name|symbol_name
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a list of symbols to exclude.  */
end_comment

begin_function
specifier|static
name|void
name|add_excludes
parameter_list|(
name|new_excludes
parameter_list|)
specifier|const
name|char
modifier|*
name|new_excludes
decl_stmt|;
block|{
name|char
modifier|*
name|local_copy
decl_stmt|;
name|char
modifier|*
name|exclude_string
decl_stmt|;
name|local_copy
operator|=
name|xstrdup
argument_list|(
name|new_excludes
argument_list|)
expr_stmt|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|local_copy
argument_list|,
literal|",:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|exclude_string
condition|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|",:"
argument_list|)
control|)
block|{
name|struct
name|string_list
modifier|*
name|new_exclude
decl_stmt|;
name|new_exclude
operator|=
operator|(
operator|(
expr|struct
name|string_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new_exclude
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|exclude_string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* FIXME: Is it always right to add a leading underscore?  */
name|sprintf
argument_list|(
name|new_exclude
operator|->
name|string
argument_list|,
literal|"_%s"
argument_list|,
name|exclude_string
argument_list|)
expr_stmt|;
name|new_exclude
operator|->
name|next
operator|=
name|excludes
expr_stmt|;
name|excludes
operator|=
name|new_exclude
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Excluding symbol: %s"
argument_list|)
argument_list|,
name|exclude_string
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|local_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See if STRING is on the list of symbols to exclude.  */
end_comment

begin_function
specifier|static
name|boolean
name|match_exclude
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|string_list
modifier|*
name|excl_item
decl_stmt|;
for|for
control|(
name|excl_item
operator|=
name|excludes
init|;
name|excl_item
condition|;
name|excl_item
operator|=
name|excl_item
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|excl_item
operator|->
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add the default list of symbols to exclude.  */
end_comment

begin_function
specifier|static
name|void
name|set_default_excludes
parameter_list|(
name|void
parameter_list|)
block|{
name|add_excludes
argument_list|(
name|default_excludes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Choose which symbols to export.  */
end_comment

begin_function
specifier|static
name|long
name|filter_symbols
parameter_list|(
name|abfd
parameter_list|,
name|minisyms
parameter_list|,
name|symcount
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|minisyms
decl_stmt|;
name|long
name|symcount
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|asymbol
modifier|*
name|store
decl_stmt|;
name|store
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
operator|*
name|size
expr_stmt|;
name|to
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|+=
name|size
control|)
block|{
name|int
name|keep
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|,
operator|(
specifier|const
name|PTR
operator|)
name|from
argument_list|,
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for external and defined only symbols.  */
name|keep
operator|=
operator|(
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|)
expr_stmt|;
name|keep
operator|=
name|keep
operator|&&
operator|!
name|match_exclude
argument_list|(
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|to
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|to
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
operator|)
operator|/
name|size
return|;
block|}
end_function

begin_comment
comment|/* Export all symbols in ABFD, except for ones we were told not to    export.  */
end_comment

begin_function
specifier|static
name|void
name|scan_all_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|symcount
decl_stmt|;
name|PTR
name|minisyms
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Ignore bfds with an import descriptor table.  We assume that any      such BFD contains symbols which are exported from another DLL,      and we don't want to reexport them from here.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
block|{
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|symcount
operator|=
name|bfd_read_minisymbols
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|,
operator|&
name|minisyms
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
block|{
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Discard the symbols we don't want to export.  It's OK to do this      in place; we'll free the storage anyway.  */
name|symcount
operator|=
name|filter_symbols
argument_list|(
name|abfd
argument_list|,
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|scan_filtered_symbols
argument_list|(
name|abfd
argument_list|,
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|minisyms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look at the object file to decide which symbols to export.  */
end_comment

begin_function
specifier|static
name|void
name|scan_open_obj_file
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|export_all_symbols
condition|)
name|scan_all_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|scan_drectve_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME: we ought to read in and block out the base relocations */
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Done reading %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_obj_file
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd
modifier|*
name|f
init|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to open object file: %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Scanning object file %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|f
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|arfile
init|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|arfile
condition|)
block|{
if|if
condition|(
name|bfd_check_format
argument_list|(
name|arfile
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|scan_open_obj_file
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
if|if
condition|(
name|mcore_elf_out_file
condition|)
name|inform
argument_list|(
name|_
argument_list|(
literal|"Cannot produce mcore-elf dll from archive file: %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bfd_check_format
argument_list|(
name|f
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|scan_open_obj_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
if|if
condition|(
name|mcore_elf_out_file
condition|)
name|mcore_elf_cache_filename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bfd_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dump_def_info
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oav
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|oav
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s  %d = %s %s @ %d %s%s%s\n"
argument_list|,
name|ASM_C
argument_list|,
name|i
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|exp
operator|->
name|noname
condition|?
literal|"NONAME "
else|:
literal|""
argument_list|,
name|exp
operator|->
name|constant
condition|?
literal|"CONSTANT"
else|:
literal|""
argument_list|,
name|exp
operator|->
name|data
condition|?
literal|"DATA"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the .exp file */
end_comment

begin_function
specifier|static
name|int
name|sfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
return|return
operator|*
operator|(
specifier|const
name|long
operator|*
operator|)
name|a
operator|-
operator|*
operator|(
specifier|const
name|long
operator|*
operator|)
name|b
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_page
parameter_list|(
name|f
parameter_list|,
name|need
parameter_list|,
name|page_addr
parameter_list|,
name|on_page
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
modifier|*
name|need
decl_stmt|;
name|int
name|page_addr
decl_stmt|;
name|int
name|on_page
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Flush this page */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%08x\t%s Starting RVA for chunk\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|page_addr
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%x\t%s Size of block\n"
argument_list|,
name|ASM_LONG
argument_list|,
operator|(
name|on_page
operator|*
literal|2
operator|)
operator|+
operator|(
name|on_page
operator|&
literal|1
operator|)
operator|*
literal|2
operator|+
literal|8
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|on_page
condition|;
name|i
operator|++
control|)
block|{
name|long
name|needed
init|=
name|need
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|needed
condition|)
name|needed
operator|=
operator|(
operator|(
name|needed
operator|-
name|page_addr
operator|)
operator||
literal|0x3000
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%lx\n"
argument_list|,
name|ASM_SHORT
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
comment|/* And padding */
if|if
condition|(
name|on_page
operator|&
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0x%x\n"
argument_list|,
name|ASM_SHORT
argument_list|,
literal|0
operator||
literal|0x0000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_def_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|inform
argument_list|(
name|_
argument_list|(
literal|"Adding exports to output file"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|oav
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|" %s"
argument_list|,
name|oav
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|"\nEXPORTS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|quote
init|=
name|strchr
argument_list|(
name|exp
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
condition|?
literal|"\""
else|:
literal|""
decl_stmt|;
name|char
modifier|*
name|res
init|=
name|cplus_demangle
argument_list|(
name|exp
operator|->
name|internal_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|exp
operator|->
name|name
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|"\t%s%s%s @ %d%s%s ; %s\n"
argument_list|,
name|quote
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|quote
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|exp
operator|->
name|noname
condition|?
literal|" NONAME"
else|:
literal|""
argument_list|,
name|exp
operator|->
name|data
condition|?
literal|" DATA"
else|:
literal|""
argument_list|,
name|res
condition|?
name|res
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|quote1
init|=
name|strchr
argument_list|(
name|exp
operator|->
name|internal_name
argument_list|,
literal|'.'
argument_list|)
condition|?
literal|"\""
else|:
literal|""
decl_stmt|;
comment|/* char *alias =  */
name|fprintf
argument_list|(
name|output_def
argument_list|,
literal|"\t%s%s%s = %s%s%s @ %d%s%s ; %s\n"
argument_list|,
name|quote
argument_list|,
name|exp
operator|->
name|name
argument_list|,
name|quote
argument_list|,
name|quote1
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
name|quote1
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|exp
operator|->
name|noname
condition|?
literal|" NONAME"
else|:
literal|""
argument_list|,
name|exp
operator|->
name|data
condition|?
literal|" DATA"
else|:
literal|""
argument_list|,
name|res
condition|?
name|res
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
name|inform
argument_list|(
name|_
argument_list|(
literal|"Added exports to output file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generate_idata_ofile generates the portable assembly source code    for the idata sections.  It appends the source code to the end of    the file.  */
end_comment

begin_function
specifier|static
name|void
name|generate_idata_ofile
parameter_list|(
name|filvar
parameter_list|)
name|FILE
modifier|*
name|filvar
decl_stmt|;
block|{
name|iheadtype
modifier|*
name|headptr
decl_stmt|;
name|ifunctype
modifier|*
name|funcptr
decl_stmt|;
name|int
name|headindex
decl_stmt|;
name|int
name|funcindex
decl_stmt|;
name|int
name|nheads
decl_stmt|;
if|if
condition|(
name|import_list
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"%s Import data sections\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\n\t.section\t.idata$2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\tdoi_idata\n"
argument_list|,
name|ASM_GLOBAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"doi_idata:\n"
argument_list|)
expr_stmt|;
name|nheads
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|headptr
operator|=
name|import_list
init|;
name|headptr
operator|!=
name|NULL
condition|;
name|headptr
operator|=
name|headptr
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%slistone%d%s\t%s %s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|nheads
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|,
name|headptr
operator|->
name|dllname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%sdllname%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|nheads
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%slisttwo%d%s\n\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|nheads
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
name|nheads
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
comment|/* NULL record at */
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
comment|/* end of idata$2 */
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
comment|/* section        */
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\n\t.section\t.idata$4\n"
argument_list|)
expr_stmt|;
name|headindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|headptr
operator|=
name|import_list
init|;
name|headptr
operator|!=
name|NULL
condition|;
name|headptr
operator|=
name|headptr
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"listone%d:\n"
argument_list|,
name|headindex
argument_list|)
expr_stmt|;
for|for
control|(
name|funcindex
operator|=
literal|0
init|;
name|funcindex
operator|<
name|headptr
operator|->
name|nfuncs
condition|;
name|funcindex
operator|++
control|)
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%sfuncptr%d_%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|headindex
argument_list|,
name|funcindex
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
comment|/* NULL terminating list */
name|headindex
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\n\t.section\t.idata$5\n"
argument_list|)
expr_stmt|;
name|headindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|headptr
operator|=
name|import_list
init|;
name|headptr
operator|!=
name|NULL
condition|;
name|headptr
operator|=
name|headptr
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"listtwo%d:\n"
argument_list|,
name|headindex
argument_list|)
expr_stmt|;
for|for
control|(
name|funcindex
operator|=
literal|0
init|;
name|funcindex
operator|<
name|headptr
operator|->
name|nfuncs
condition|;
name|funcindex
operator|++
control|)
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%sfuncptr%d_%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|headindex
argument_list|,
name|funcindex
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
comment|/* NULL terminating list */
name|headindex
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\n\t.section\t.idata$6\n"
argument_list|)
expr_stmt|;
name|headindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|headptr
operator|=
name|import_list
init|;
name|headptr
operator|!=
name|NULL
condition|;
name|headptr
operator|=
name|headptr
operator|->
name|next
control|)
block|{
name|funcindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|funcptr
operator|=
name|headptr
operator|->
name|funchead
init|;
name|funcptr
operator|!=
name|NULL
condition|;
name|funcptr
operator|=
name|funcptr
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"funcptr%d_%d:\n"
argument_list|,
name|headindex
argument_list|,
name|funcindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t%d\n"
argument_list|,
name|ASM_SHORT
argument_list|,
operator|(
operator|(
name|funcptr
operator|->
name|ord
operator|)
operator|&
literal|0xFFFF
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|funcptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_BYTE
argument_list|)
expr_stmt|;
name|funcindex
operator|++
expr_stmt|;
block|}
name|headindex
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\n\t.section\t.idata$7\n"
argument_list|)
expr_stmt|;
name|headindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|headptr
operator|=
name|import_list
init|;
name|headptr
operator|!=
name|NULL
condition|;
name|headptr
operator|=
name|headptr
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"dllname%d:\n"
argument_list|,
name|headindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|headptr
operator|->
name|dllname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|filvar
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_BYTE
argument_list|)
expr_stmt|;
name|headindex
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assemble the specified file.  */
end_comment

begin_function
specifier|static
name|void
name|assemble_file
parameter_list|(
name|source
parameter_list|,
name|dest
parameter_list|)
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|dest
decl_stmt|;
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ASM_SWITCHES
argument_list|)
operator|+
name|strlen
argument_list|(
name|as_flags
argument_list|)
operator|+
name|strlen
argument_list|(
name|source
argument_list|)
operator|+
name|strlen
argument_list|(
name|dest
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s %s -o %s %s"
argument_list|,
name|ASM_SWITCHES
argument_list|,
name|as_flags
argument_list|,
name|dest
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|as_name
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_exp_file
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|dlist_type
modifier|*
name|dl
decl_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Generating export file: %s"
argument_list|)
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|TMP_ASM
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to open temporary assembler file: %s"
argument_list|)
argument_list|,
name|TMP_ASM
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Opened temporary file: %s"
argument_list|)
argument_list|,
name|TMP_ASM
argument_list|)
expr_stmt|;
name|dump_def_info
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_exports
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.edata\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0	%s Allways 0\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0x%lx	%s Time and date\n"
argument_list|,
name|ASM_LONG
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	0	%s Major and Minor version\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sname%s	%s Ptr to name of dll\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Starting ordinal of exports\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|d_low_ord
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Number of functions\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|d_high_ord
operator|-
name|d_low_ord
operator|+
literal|1
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s named funcs %d, low ord %d, high ord %d\n"
argument_list|,
name|ASM_C
argument_list|,
name|d_named_nfuncs
argument_list|,
name|d_low_ord
argument_list|,
name|d_high_ord
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d	%s Number of names\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|show_allnames
condition|?
name|d_high_ord
operator|-
name|d_low_ord
operator|+
literal|1
else|:
name|d_named_nfuncs
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%safuncs%s  %s Address of functions\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sanames%s	%s Address of Name Pointer Table\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sanords%s	%s Address of ordinals\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"name:	%s	\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export address Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\n"
argument_list|,
name|ASM_ALIGN_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"afuncs:\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|d_low_ord
expr_stmt|;
for|for
control|(
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|exp
operator|->
name|ordinal
operator|!=
name|i
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (f, "\t%s\t%d\t%s %d..%d missing\n", 		       ASM_SPACE, 		       (exp->ordinal - i) * 4, 		       ASM_C, 		       i, exp->ordinal - 1); 	      i = exp->ordinal;
endif|#
directive|endif
while|while
condition|(
name|i
operator|<
name|exp
operator|->
name|ordinal
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|exp
operator|->
name|forward
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s%s%s%s\t%s %d\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_PREFIX
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sf%d%s\t%s %d\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|exp
operator|->
name|forward
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Name Pointer Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"anames:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sn%d%s\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_RVA_AFTER
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Oridinal Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"anords:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s	%d\n"
argument_list|,
name|ASM_SHORT
argument_list|,
name|exp
operator|->
name|ordinal
operator|-
name|d_low_ord
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s Export Name Table\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"n%d:	%s	\"%s\"\n"
argument_list|,
name|exp
operator|->
name|ordinal
argument_list|,
name|ASM_TEXT
argument_list|,
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|forward
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"f%d:	%s	\"%s\"\n"
argument_list|,
name|exp
operator|->
name|forward
argument_list|,
name|ASM_TEXT
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section %s\n"
argument_list|,
name|DRECTVE_SECTION_NAME
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|a_list
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t\"%s\"\n"
argument_list|,
name|ASM_TEXT
argument_list|,
name|dl
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section .rdata\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|d_list
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|l
decl_stmt|;
comment|/* We don't output as ascii because there can 	         be quote characters in the string.  */
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dl
operator|->
name|text
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t"
argument_list|,
name|ASM_BYTE
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|",0\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|l
operator|==
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Add to the output file a way of getting to the exported names      without using the import library.  */
if|if
condition|(
name|add_indirect
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.rdata\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
operator|||
name|show_allnames
condition|)
block|{
comment|/* We use a single underscore for MS compatibility, and a                double underscore for backward compatibility with old                cygwin releases.  */
if|if
condition|(
name|create_compat_implib
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t__imp_%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t_imp__%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|create_compat_implib
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"__imp_%s:\n"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_imp__%s:\n"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dump the reloc section if a base file is provided */
if|if
condition|(
name|base_file
condition|)
block|{
name|int
name|addr
decl_stmt|;
name|long
name|need
index|[
name|PAGE_SIZE
index|]
decl_stmt|;
name|long
name|page_addr
decl_stmt|;
name|int
name|numbytes
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
name|long
modifier|*
name|copy
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|on_page
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.init\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"lab:\n"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|base_file
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|numbytes
operator|=
name|ftell
argument_list|(
name|base_file
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|base_file
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
name|numbytes
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|copy
argument_list|,
literal|1
argument_list|,
name|numbytes
argument_list|,
name|base_file
argument_list|)
expr_stmt|;
name|num_entries
operator|=
name|numbytes
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.reloc\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_entries
condition|)
block|{
name|int
name|src
decl_stmt|;
name|int
name|dst
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
operator|-
literal|1
decl_stmt|;
name|qsort
argument_list|(
name|copy
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|sfunc
argument_list|)
expr_stmt|;
comment|/* Delete duplcates */
for|for
control|(
name|src
operator|=
literal|0
init|;
name|src
operator|<
name|num_entries
condition|;
name|src
operator|++
control|)
block|{
if|if
condition|(
name|last
operator|!=
name|copy
index|[
name|src
index|]
condition|)
name|last
operator|=
name|copy
index|[
name|dst
operator|++
index|]
operator|=
name|copy
index|[
name|src
index|]
expr_stmt|;
block|}
name|num_entries
operator|=
name|dst
expr_stmt|;
name|addr
operator|=
name|copy
index|[
literal|0
index|]
expr_stmt|;
name|page_addr
operator|=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
comment|/* work out the page addr */
name|on_page
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
name|addr
operator|=
name|copy
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
name|PAGE_MASK
operator|)
operator|!=
name|page_addr
condition|)
block|{
name|flush_page
argument_list|(
name|f
argument_list|,
name|need
argument_list|,
name|page_addr
argument_list|,
name|on_page
argument_list|)
expr_stmt|;
name|on_page
operator|=
literal|0
expr_stmt|;
name|page_addr
operator|=
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
block|}
name|need
index|[
name|on_page
operator|++
index|]
operator|=
name|addr
expr_stmt|;
block|}
name|flush_page
argument_list|(
name|f
argument_list|,
name|need
argument_list|,
name|page_addr
argument_list|,
name|on_page
argument_list|)
expr_stmt|;
comment|/*	  fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
block|}
block|}
name|generate_idata_ofile
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* assemble the file */
name|assemble_file
argument_list|(
name|TMP_ASM
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|TMP_ASM
argument_list|)
expr_stmt|;
name|inform
argument_list|(
name|_
argument_list|(
literal|"Generated exports file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xlate
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|add_underscore
condition|)
block|{
name|char
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|copy
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|copy
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|copy
expr_stmt|;
block|}
if|if
condition|(
name|killat
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void dump_iat (f, exp)      FILE *f;      export_type *exp; {   if (exp->noname&& !show_allnames )     {       fprintf (f, "\t%s\t0x%08x\n", 	       ASM_LONG, 	       exp->ordinal | 0x80000000);
comment|/* hint or orindal ?? */
end_comment

begin_endif
unit|}   else     {       fprintf (f, "\t%sID%d%s\n", ASM_RVA_BEFORE, 	       exp->ordinal, 	       ASM_RVA_AFTER);     } }
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|align
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sympp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
block|}
name|sinfo
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|DLLTOOL_PPC
end_ifndef

begin_define
define|#
directive|define
name|TEXT
value|0
end_define

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_define
define|#
directive|define
name|BSS
value|2
end_define

begin_define
define|#
directive|define
name|IDATA7
value|3
end_define

begin_define
define|#
directive|define
name|IDATA5
value|4
end_define

begin_define
define|#
directive|define
name|IDATA4
value|5
end_define

begin_define
define|#
directive|define
name|IDATA6
value|6
end_define

begin_define
define|#
directive|define
name|NSECS
value|7
end_define

begin_define
define|#
directive|define
name|TEXT_SEC_FLAGS
define|\
value|(SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
end_define

begin_define
define|#
directive|define
name|DATA_SEC_FLAGS
value|(SEC_ALLOC | SEC_LOAD | SEC_DATA)
end_define

begin_define
define|#
directive|define
name|BSS_SEC_FLAGS
value|SEC_ALLOC
end_define

begin_define
define|#
directive|define
name|INIT_SEC_DATA
parameter_list|(
name|id
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|align
parameter_list|)
define|\
value|{ id, name, flags, align, NULL, NULL, NULL, 0, NULL }
end_define

begin_decl_stmt
specifier|static
name|sinfo
name|secdata
index|[
name|NSECS
index|]
init|=
block|{
name|INIT_SEC_DATA
argument_list|(
name|TEXT
argument_list|,
literal|".text"
argument_list|,
name|TEXT_SEC_FLAGS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
name|DATA
argument_list|,
literal|".data"
argument_list|,
name|DATA_SEC_FLAGS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
name|BSS
argument_list|,
literal|".bss"
argument_list|,
name|BSS_SEC_FLAGS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
name|IDATA7
argument_list|,
literal|".idata$7"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
name|IDATA5
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
name|IDATA4
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
block|,
name|INIT_SEC_DATA
argument_list|(
argument|IDATA6
argument_list|,
literal|".idata$6"
argument_list|,
argument|SEC_HAS_CONTENTS
argument_list|,
literal|1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Sections numbered to make the order the same as other PowerPC NT    */
end_comment

begin_comment
comment|/* compilers. This also keeps funny alignment thingies from happening.  */
end_comment

begin_define
define|#
directive|define
name|TEXT
value|0
end_define

begin_define
define|#
directive|define
name|PDATA
value|1
end_define

begin_define
define|#
directive|define
name|RDATA
value|2
end_define

begin_define
define|#
directive|define
name|IDATA5
value|3
end_define

begin_define
define|#
directive|define
name|IDATA4
value|4
end_define

begin_define
define|#
directive|define
name|IDATA6
value|5
end_define

begin_define
define|#
directive|define
name|IDATA7
value|6
end_define

begin_define
define|#
directive|define
name|DATA
value|7
end_define

begin_define
define|#
directive|define
name|BSS
value|8
end_define

begin_define
define|#
directive|define
name|NSECS
value|9
end_define

begin_decl_stmt
specifier|static
name|sinfo
name|secdata
index|[
name|NSECS
index|]
init|=
block|{
block|{
name|TEXT
block|,
literal|".text"
block|,
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
block|,
literal|3
block|}
block|,
block|{
name|PDATA
block|,
literal|".pdata"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|RDATA
block|,
literal|".reldata"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA5
block|,
literal|".idata$5"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA4
block|,
literal|".idata$4"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|IDATA6
block|,
literal|".idata$6"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|1
block|}
block|,
block|{
name|IDATA7
block|,
literal|".idata$7"
block|,
name|SEC_HAS_CONTENTS
block|,
literal|2
block|}
block|,
block|{
name|DATA
block|,
literal|".data"
block|,
name|SEC_DATA
block|,
literal|2
block|}
block|,
block|{
name|BSS
block|,
literal|".bss"
block|,
literal|0
block|,
literal|2
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is what we're trying to make.  We generate the imp symbols with both single and double underscores, for compatibility.  	.text 	.global	_GetFileVersionInfoSizeW@8 	.global	__imp_GetFileVersionInfoSizeW@8 _GetFileVersionInfoSizeW@8: 	jmp *	__imp_GetFileVersionInfoSizeW@8 	.section	.idata$7	# To force loading of head 	.long	__version_a_head # Import Address Table 	.section	.idata$5 __imp_GetFileVersionInfoSizeW@8: 	.rva	ID2  # Import Lookup Table 	.section	.idata$4 	.rva	ID2 # Hint/Name table 	.section	.idata$6 ID2:	.short	2 	.asciz	"GetFileVersionInfoSizeW"   For the PowerPC, here's the variation on the above scheme:  # Rather than a simple "jmp *", the code to get to the dll function # looks like:          .text          lwz	r11,[tocv]__imp_function_name(r2) #		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name          lwz	r12,0(r11) 	 stw	r2,4(r1) 	 mtctr	r12 	 lwz	r2,4(r11) 	 bctr */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|make_label
parameter_list|(
name|prefix
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|ASM_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|copy
argument_list|,
name|ASM_PREFIX
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|copy
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_one_lib_file
parameter_list|(
name|exp
parameter_list|,
name|i
parameter_list|)
name|export_type
modifier|*
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|{       char *name;       FILE *f;       const char *prefix = "d";       char *dest;        name = (char *) alloca (strlen (prefix) + 10);       sprintf (name, "%ss%05d.s", prefix, i);       f = fopen (name, FOPEN_WT);       fprintf (f, "\t.text\n");       fprintf (f, "\t%s\t%s%s\n", ASM_GLOBAL, ASM_PREFIX, exp->name);       if (create_compat_implib) 	fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);       fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);       if (create_compat_implib) 	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX, 		 exp->name, ASM_JUMP, exp->name);        fprintf (f, "\t.section\t.idata$7\t%s To force loading of head\n", ASM_C);       fprintf (f, "\t%s\t%s\n", ASM_LONG, head_label);         fprintf (f,"%s Import Address Table\n", ASM_C);        fprintf (f, "\t.section	.idata$5\n");       if (create_compat_implib) 	fprintf (f, "__imp_%s:\n", exp->name);       fprintf (f, "_imp__%s:\n", exp->name);        dump_iat (f, exp);        fprintf (f, "\n%s Import Lookup Table\n", ASM_C);       fprintf (f, "\t.section	.idata$4\n");        dump_iat (f, exp);        if(!exp->noname || show_allnames) 	{ 	  fprintf (f, "%s Hint/Name table\n", ASM_C); 	  fprintf (f, "\t.section	.idata$6\n"); 	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint); 	  fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, xlate (exp->name)); 	}        fclose (f);        dest = (char *) alloca (strlen (prefix) + 10);       sprintf (dest, "%ss%05d.o", prefix, i);       assemble_file (name, dest);     }
else|#
directive|else
comment|/* if 0 */
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|exp_label
decl_stmt|;
name|asymbol
modifier|*
name|iname
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
name|iname2
decl_stmt|;
name|asymbol
modifier|*
name|iname_lab
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|iname_lab_pp
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|iname_pp
decl_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
name|asymbol
modifier|*
modifier|*
name|fn_pp
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|toc_pp
decl_stmt|;
define|#
directive|define
name|EXTRA
value|2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EXTRA
define|#
directive|define
name|EXTRA
value|0
endif|#
directive|endif
name|asymbol
modifier|*
name|ptrs
index|[
name|NSECS
operator|+
literal|4
operator|+
name|EXTRA
operator|+
literal|1
index|]
decl_stmt|;
name|flagword
name|applicable
decl_stmt|;
name|char
modifier|*
name|outname
init|=
name|xmalloc
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|int
name|oidx
init|=
literal|0
decl_stmt|;
name|sprintf
argument_list|(
name|outname
argument_list|,
literal|"%s%05d.o"
argument_list|,
name|TMP_STUB
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|outname
argument_list|,
name|HOW_BFD_WRITE_TARGET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"bfd_open failed open stub file: %s"
argument_list|)
argument_list|,
name|outname
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Creating stub file: %s"
argument_list|)
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|HOW_BFD_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_ARM
if|if
condition|(
name|machine
operator|==
name|MARM_INTERWORK
operator|||
name|machine
operator|==
name|MTHUMB
condition|)
name|bfd_set_private_flags
argument_list|(
name|abfd
argument_list|,
name|F_INTERWORK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|applicable
operator|=
name|bfd_applicable_section_flags
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* First make symbols for the sections */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|id
operator|!=
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
name|si
operator|->
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|flags
operator|&
name|applicable
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|align
argument_list|)
expr_stmt|;
name|si
operator|->
name|sec
operator|->
name|output_section
operator|=
name|si
operator|->
name|sec
expr_stmt|;
name|si
operator|->
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|name
operator|=
name|si
operator|->
name|sec
operator|->
name|name
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|section
operator|=
name|si
operator|->
name|sec
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|si
operator|->
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ptrs
index|[
name|oidx
index|]
operator|=
name|si
operator|->
name|sym
expr_stmt|;
name|si
operator|->
name|sympp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|si
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|oidx
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exp
operator|->
name|data
condition|)
block|{
name|exp_label
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exp_label
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|""
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* On PowerPC, the function name points to a descriptor in 	     the rdata section, the first element of which is a 	     pointer to the code (..function_name), and the second 	     points to the .toc */
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
if|if
condition|(
name|machine
operator|==
name|MPPC
condition|)
name|exp_label
operator|->
name|section
operator|=
name|secdata
index|[
name|RDATA
index|]
operator|.
name|sec
expr_stmt|;
else|else
endif|#
directive|endif
name|exp_label
operator|->
name|section
operator|=
name|secdata
index|[
name|TEXT
index|]
operator|.
name|sec
expr_stmt|;
name|exp_label
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|exp_label
operator|->
name|value
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_ARM
if|if
condition|(
name|machine
operator|==
name|MTHUMB
condition|)
name|bfd_coff_set_symbol_class
argument_list|(
name|abfd
argument_list|,
name|exp_label
argument_list|,
name|C_THUMBEXTFUNC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|exp_label
expr_stmt|;
block|}
comment|/* Generate imp symbols with one underscore for Microsoft          compatibility, and with two underscores for backward          compatibility with old versions of cygwin.  */
if|if
condition|(
name|create_compat_implib
condition|)
block|{
name|iname
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|iname
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|"__imp_"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|iname
operator|->
name|section
operator|=
name|secdata
index|[
name|IDATA5
index|]
operator|.
name|sec
expr_stmt|;
name|iname
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|iname
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|iname2
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|iname2
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|"_imp__"
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|iname2
operator|->
name|section
operator|=
name|secdata
index|[
name|IDATA5
index|]
operator|.
name|sec
expr_stmt|;
name|iname2
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|iname2
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|iname_lab
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|iname_lab
operator|->
name|name
operator|=
name|head_label
expr_stmt|;
name|iname_lab
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
operator|&
name|bfd_und_section
expr_stmt|;
name|iname_lab
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iname_lab
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|iname_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
if|if
condition|(
name|create_compat_implib
condition|)
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|iname
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|iname2
expr_stmt|;
name|iname_lab_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|iname_lab
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* The symbol refering to the code (.text) */
block|{
name|asymbol
modifier|*
name|function_name
decl_stmt|;
name|function_name
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|function_name
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|".."
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
name|function_name
operator|->
name|section
operator|=
name|secdata
index|[
name|TEXT
index|]
operator|.
name|sec
expr_stmt|;
name|function_name
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|function_name
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|fn_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|function_name
expr_stmt|;
block|}
comment|/* The .toc symbol */
block|{
name|asymbol
modifier|*
name|toc_symbol
decl_stmt|;
comment|/* The .toc symbol */
name|toc_symbol
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|toc_symbol
operator|->
name|name
operator|=
name|make_label
argument_list|(
literal|"."
argument_list|,
literal|"toc"
argument_list|)
expr_stmt|;
name|toc_symbol
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
operator|&
name|bfd_und_section
expr_stmt|;
name|toc_symbol
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|toc_symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|toc_pp
operator|=
name|ptrs
operator|+
name|oidx
expr_stmt|;
name|ptrs
index|[
name|oidx
operator|++
index|]
operator|=
name|toc_symbol
expr_stmt|;
block|}
endif|#
directive|endif
name|ptrs
index|[
name|oidx
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|si
operator|->
name|sec
decl_stmt|;
name|arelent
modifier|*
name|rel
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|rpp
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|TEXT
case|:
if|if
condition|(
operator|!
name|exp
operator|->
name|data
condition|)
block|{
name|si
operator|->
name|size
operator|=
name|HOW_JTAB_SIZE
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|HOW_JTAB_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|si
operator|->
name|data
argument_list|,
name|HOW_JTAB
argument_list|,
name|HOW_JTAB_SIZE
argument_list|)
expr_stmt|;
comment|/* add the reloc into idata$5 */
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
name|HOW_JTAB_ROFF
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|machine
operator|==
name|MPPC
condition|)
block|{
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_16_GOTOFF
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|iname_pp
expr_stmt|;
block|}
else|else
block|{
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|secdata
index|[
name|IDATA5
index|]
operator|.
name|sympp
expr_stmt|;
block|}
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IDATA4
case|:
case|case
name|IDATA5
case|:
comment|/* An idata$4 or idata$5 is one word long, and has an 		 rva to idata$6 */
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|si
operator|->
name|size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|noname
condition|)
block|{
name|si
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|2
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|16
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_RVA
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|secdata
index|[
name|IDATA6
index|]
operator|.
name|sympp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
block|}
break|break;
case|case
name|IDATA6
case|:
if|if
condition|(
operator|!
name|exp
operator|->
name|noname
condition|)
block|{
comment|/* This used to add 1 to exp->hint.  I don't know                      why it did that, and it does not match what I see                      in programs compiled with the MS tools.  */
name|int
name|idx
init|=
name|exp
operator|->
name|hint
decl_stmt|;
name|si
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
operator|+
literal|3
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|idx
operator|&
literal|0xff
expr_stmt|;
name|si
operator|->
name|data
index|[
literal|1
index|]
operator|=
name|idx
operator|>>
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|si
operator|->
name|data
operator|+
literal|2
argument_list|,
name|xlate
argument_list|(
name|exp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IDATA7
case|:
name|si
operator|->
name|size
operator|=
literal|4
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_RVA
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|iname_lab_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
case|case
name|PDATA
case|:
block|{
comment|/* The .pdata section is 5 words long.  */
comment|/* Think of it as:                     */
comment|/* struct                              */
comment|/* {                                   */
comment|/*   bfd_vma BeginAddress,     [0x00]  */
comment|/*           EndAddress,       [0x04]  */
comment|/*	     ExceptionHandler, [0x08]  */
comment|/*	     HandlerData,      [0x0c]  */
comment|/*	     PrologEndAddress; [0x10]  */
comment|/* };                                  */
comment|/* So this pdata section setups up this as a glue linkage to 		   a dll routine. There are a number of house keeping things 		   we need to do:  		   1. In the name of glue trickery, the ADDR32 relocs for 0, 		      4, and 0x10 are set to point to the same place: 		      "..function_name". 		   2. There is one more reloc needed in the pdata section. 		      The actual glue instruction to restore the toc on 		      return is saved as the offset in an IMGLUE reloc. 		      So we need a total of four relocs for this section.  		   3. Lastly, the HandlerData field is set to 0x03, to indicate 		      that this is a glue routine. 		*/
name|arelent
modifier|*
name|imglue
decl_stmt|,
modifier|*
name|ba_rel
decl_stmt|,
modifier|*
name|ea_rel
decl_stmt|,
modifier|*
name|pea_rel
decl_stmt|;
comment|/* alignment must be set to 2**2 or you get extra stuff */
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|si
operator|->
name|size
operator|=
literal|4
operator|*
literal|5
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|4
operator|*
literal|5
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|imglue
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
name|ba_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|2
index|]
operator|=
name|ea_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|3
index|]
operator|=
name|pea_rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* stick the toc reload instruction in the glue reloc */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ppc_glue_insn
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|imglue
operator|->
name|address
argument_list|)
expr_stmt|;
name|imglue
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|imglue
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32_GOTOFF
argument_list|)
expr_stmt|;
name|imglue
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|ba_rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|ba_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|ba_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|ba_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x18
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x04
argument_list|)
expr_stmt|;
name|ea_rel
operator|->
name|address
operator|=
literal|4
expr_stmt|;
name|ea_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|ea_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|ea_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
comment|/* mark it as glue */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x03
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* mark the prolog end address */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
literal|0x0D
argument_list|,
name|si
operator|->
name|data
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|pea_rel
operator|->
name|address
operator|=
literal|0x10
expr_stmt|;
name|pea_rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|pea_rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|pea_rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|4
expr_stmt|;
break|break;
block|}
case|case
name|RDATA
case|:
comment|/* Each external function in a PowerPC PE file has a two word 		 descriptor consisting of: 		 1. The address of the code. 		 2. The address of the appropriate .toc 	         We use relocs to build this. 	      */
name|si
operator|->
name|size
operator|=
literal|8
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|rpp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|0
index|]
operator|=
name|rel
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|1
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
name|rpp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|fn_pp
expr_stmt|;
name|rel
operator|=
name|rpp
index|[
literal|1
index|]
expr_stmt|;
name|rel
operator|->
name|address
operator|=
literal|4
expr_stmt|;
name|rel
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_32
argument_list|)
expr_stmt|;
name|rel
operator|->
name|sym_ptr_ptr
operator|=
name|toc_pp
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|rpp
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
literal|2
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DLLTOOL_PPC */
block|}
block|}
block|{
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
comment|/* Size up all the sections */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
comment|/*	    vma += si->size;*/
block|}
block|}
comment|/* Write them out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSECS
condition|;
name|i
operator|++
control|)
block|{
name|sinfo
modifier|*
name|si
init|=
name|secdata
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|IDATA5
operator|&&
name|no_idata5
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
name|IDATA4
operator|&&
name|no_idata4
condition|)
continue|continue;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|->
name|sec
argument_list|,
name|si
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|si
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|ptrs
argument_list|,
name|oidx
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|outname
argument_list|,
name|HOW_BFD_READ_TARGET
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_head
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|TMP_HEAD_S
argument_list|,
name|FOPEN_WT
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"failed to open temporary head file: %s"
argument_list|)
argument_list|,
name|TMP_HEAD_S
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s IMAGE_IMPORT_DESCRIPTOR\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|head_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s:\n"
argument_list|,
name|head_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%shname%s\t%sPtr to image import by name list\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sthis should be the timestamp, but NT sometimes\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sdoesn't load DLLs when this is set.\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\t%s loaded time\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\t%s Forwarder chain\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s__%s_iname%s\t%s imported dll's name\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|imp_name_lab
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%sfthunk%s\t%s pointer to firstthunk\n"
argument_list|,
name|ASM_RVA_BEFORE
argument_list|,
name|ASM_RVA_AFTER
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%sStuff for compatibility\n"
argument_list|,
name|ASM_C
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_idata5
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.idata$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"fthunk:\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_idata4
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section\t.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"hname:\n"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|assemble_file
argument_list|(
name|TMP_HEAD_S
argument_list|,
name|TMP_HEAD_O
argument_list|)
expr_stmt|;
return|return
name|bfd_openr
argument_list|(
name|TMP_HEAD_O
argument_list|,
name|HOW_BFD_READ_TARGET
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_tail
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|TMP_TAIL_S
argument_list|,
name|FOPEN_WT
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"failed to open temporary tail file: %s"
argument_list|)
argument_list|,
name|TMP_TAIL_S
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|no_idata4
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_idata5
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$5\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* Normally, we need to see a null descriptor built in idata$3 to      act as the terminator for the list. The ideal way, I suppose,      would be to mark this section as a comdat type 2 section, so      only one would appear in the final .exe (if our linker supported      comdat, that is) or cause it to be inserted by something else (say      crt0)   */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$3\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLLTOOL_PPC
comment|/* Other PowerPC NT compilers use idata$6 for the dllname, so I      do too. Original, huh? */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$6\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.section	.idata$7\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t__%s_iname\n"
argument_list|,
name|ASM_GLOBAL
argument_list|,
name|imp_name_lab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"__%s_iname:\t%s\t\"%s\"\n"
argument_list|,
name|imp_name_lab
argument_list|,
name|ASM_TEXT
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|assemble_file
argument_list|(
name|TMP_TAIL_S
argument_list|,
name|TMP_TAIL_O
argument_list|)
expr_stmt|;
return|return
name|bfd_openr
argument_list|(
name|TMP_TAIL_O
argument_list|,
name|HOW_BFD_READ_TARGET
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_lib_file
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|export_type
modifier|*
name|exp
decl_stmt|;
name|bfd
modifier|*
name|ar_head
decl_stmt|;
name|bfd
modifier|*
name|ar_tail
decl_stmt|;
name|bfd
modifier|*
name|outarch
decl_stmt|;
name|bfd
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|unlink
argument_list|(
name|imp_name
argument_list|)
expr_stmt|;
name|outarch
operator|=
name|bfd_openw
argument_list|(
name|imp_name
argument_list|,
name|HOW_BFD_WRITE_TARGET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outarch
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Can't open .lib file: %s"
argument_list|)
argument_list|,
name|imp_name
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Creating library file: %s"
argument_list|)
argument_list|,
name|imp_name
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|outarch
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|outarch
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
comment|/* Work out a reasonable size of things to put onto one line.  */
name|ar_head
operator|=
name|make_head
argument_list|()
expr_stmt|;
name|ar_tail
operator|=
name|make_tail
argument_list|()
expr_stmt|;
if|if
condition|(
name|ar_head
operator|==
name|NULL
operator|||
name|ar_tail
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|exp
operator|=
name|d_exports_lexically
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bfd
modifier|*
name|n
init|=
name|make_one_lib_file
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
comment|/* Now stick them all into the archive */
name|ar_head
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|ar_tail
operator|->
name|next
operator|=
name|ar_head
expr_stmt|;
name|head
operator|=
name|ar_tail
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_archive_head
argument_list|(
name|outarch
argument_list|,
name|head
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_set_archive_head"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|outarch
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|imp_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|n
init|=
name|head
operator|->
name|next
decl_stmt|;
name|bfd_close
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
comment|/* Delete all the temp files */
if|if
condition|(
name|dontdeltemps
operator|==
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|TMP_HEAD_O
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMP_HEAD_S
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMP_TAIL_O
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|TMP_TAIL_S
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dontdeltemps
operator|<
literal|2
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
name|TMP_STUB
operator|+
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%05d.o"
argument_list|,
name|TMP_STUB
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
comment|/* xgettext:c-format */
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"cannot delete %s: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|inform
argument_list|(
name|_
argument_list|(
literal|"Created lib file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* Run through the information gathered from the .o files and the    .def file and work out the best stuff */
end_comment

begin_function
specifier|static
name|int
name|pfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
name|export_type
modifier|*
name|ap
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|export_type
modifier|*
name|bp
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|ordinal
operator|==
name|bp
operator|->
name|ordinal
condition|)
return|return
literal|0
return|;
comment|/* unset ordinals go to the bottom */
if|if
condition|(
name|ap
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bp
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|ap
operator|->
name|ordinal
operator|-
name|bp
operator|->
name|ordinal
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfunc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|void
modifier|*
name|a
decl_stmt|;
specifier|const
name|void
modifier|*
name|b
decl_stmt|;
block|{
name|export_type
modifier|*
name|ap
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|export_type
modifier|*
name|bp
init|=
operator|*
operator|(
name|export_type
operator|*
operator|*
operator|)
name|b
decl_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|ap
operator|->
name|name
argument_list|,
name|bp
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_null_names
parameter_list|(
name|ptr
parameter_list|)
name|export_type
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
name|int
name|src
decl_stmt|;
name|int
name|dst
decl_stmt|;
for|for
control|(
name|dst
operator|=
name|src
operator|=
literal|0
init|;
name|src
operator|<
name|d_nfuncs
condition|;
name|src
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|src
index|]
condition|)
block|{
name|ptr
index|[
name|dst
index|]
operator|=
name|ptr
index|[
name|src
index|]
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
block|}
name|d_nfuncs
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtab
parameter_list|(
name|ptr
parameter_list|)
name|export_type
modifier|*
modifier|*
name|ptr
ifndef|#
directive|ifndef
name|SACDEBUG
name|ATTRIBUTE_UNUSED
endif|#
directive|endif
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SACDEBUG
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%d %s @ %d %s%s%s\n"
argument_list|,
name|i
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|ordinal
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|noname
condition|?
literal|"NONAME "
else|:
literal|""
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|constant
condition|?
literal|"CONSTANT"
else|:
literal|""
argument_list|,
name|ptr
index|[
name|i
index|]
operator|->
name|data
condition|?
literal|"DATA"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"empty\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|process_duplicates
parameter_list|(
name|d_export_vec
parameter_list|)
name|export_type
modifier|*
modifier|*
name|d_export_vec
decl_stmt|;
block|{
name|int
name|more
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|more
condition|)
block|{
name|more
operator|=
literal|0
expr_stmt|;
comment|/* Remove duplicates */
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|nfunc
argument_list|)
expr_stmt|;
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|d_export_vec
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|export_type
modifier|*
name|a
init|=
name|d_export_vec
index|[
name|i
index|]
decl_stmt|;
name|export_type
modifier|*
name|b
init|=
name|d_export_vec
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|more
operator|=
literal|1
expr_stmt|;
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Warning, ignoring duplicate EXPORT %s %d,%d"
argument_list|)
argument_list|,
name|a
operator|->
name|name
argument_list|,
name|a
operator|->
name|ordinal
argument_list|,
name|b
operator|->
name|ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|b
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Error, duplicate EXPORT with oridinals: %s"
argument_list|)
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Merge attributes */
name|b
operator|->
name|ordinal
operator|=
name|a
operator|->
name|ordinal
operator|>
literal|0
condition|?
name|a
operator|->
name|ordinal
else|:
name|b
operator|->
name|ordinal
expr_stmt|;
name|b
operator|->
name|constant
operator||=
name|a
operator|->
name|constant
expr_stmt|;
name|b
operator|->
name|noname
operator||=
name|a
operator|->
name|noname
expr_stmt|;
name|b
operator|->
name|data
operator||=
name|a
operator|->
name|data
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|remove_null_names
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|dtab
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Count the names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d_export_vec
index|[
name|i
index|]
operator|->
name|noname
condition|)
name|d_named_nfuncs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_ordinals
parameter_list|(
name|d_export_vec
parameter_list|)
name|export_type
modifier|*
modifier|*
name|d_export_vec
decl_stmt|;
block|{
name|int
name|lowest
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
init|=
literal|65536
decl_stmt|;
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|pfunc
argument_list|)
expr_stmt|;
comment|/* fill in the unset ordinals with ones from our range */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Mark in our large vector all the numbers that are taken */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|ptr
index|[
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lowest
operator|==
operator|-
literal|1
operator|||
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|<
name|lowest
condition|)
block|{
name|lowest
operator|=
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
expr_stmt|;
block|}
block|}
block|}
comment|/* Start at 1 for compatibility with MS toolchain.  */
if|if
condition|(
name|lowest
operator|==
operator|-
literal|1
condition|)
name|lowest
operator|=
literal|1
expr_stmt|;
comment|/* Now fill in ordinals where the user wants us to choose.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|==
operator|-
literal|1
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
comment|/* First try within or after any user supplied range.  */
for|for
control|(
name|j
operator|=
name|lowest
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|=
name|j
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Then try before the range.  */
for|for
control|(
name|j
operator|=
name|lowest
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|ptr
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|d_export_vec
index|[
name|i
index|]
operator|->
name|ordinal
operator|=
name|j
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|done
label|:
empty_stmt|;
block|}
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* And resort */
name|qsort
argument_list|(
name|d_export_vec
argument_list|,
name|d_nfuncs
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|pfunc
argument_list|)
expr_stmt|;
comment|/* Work out the lowest and highest ordinal numbers.  */
if|if
condition|(
name|d_nfuncs
condition|)
block|{
if|if
condition|(
name|d_export_vec
index|[
literal|0
index|]
condition|)
name|d_low_ord
operator|=
name|d_export_vec
index|[
literal|0
index|]
operator|->
name|ordinal
expr_stmt|;
if|if
condition|(
name|d_export_vec
index|[
name|d_nfuncs
operator|-
literal|1
index|]
condition|)
name|d_high_ord
operator|=
name|d_export_vec
index|[
name|d_nfuncs
operator|-
literal|1
index|]
operator|->
name|ordinal
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|alphafunc
parameter_list|(
name|av
parameter_list|,
name|bv
parameter_list|)
specifier|const
name|void
modifier|*
name|av
decl_stmt|;
specifier|const
name|void
modifier|*
name|bv
decl_stmt|;
block|{
specifier|const
name|export_type
modifier|*
modifier|*
name|a
init|=
operator|(
specifier|const
name|export_type
operator|*
operator|*
operator|)
name|av
decl_stmt|;
specifier|const
name|export_type
modifier|*
modifier|*
name|b
init|=
operator|(
specifier|const
name|export_type
operator|*
operator|*
operator|)
name|bv
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|b
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mangle_defs
parameter_list|()
block|{
comment|/* First work out the minimum ordinal chosen */
name|export_type
modifier|*
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hint
init|=
literal|0
decl_stmt|;
name|export_type
modifier|*
modifier|*
name|d_export_vec
init|=
operator|(
name|export_type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
operator|*
name|d_nfuncs
argument_list|)
decl_stmt|;
name|inform
argument_list|(
name|_
argument_list|(
literal|"Processing definitions"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|d_export_vec
index|[
name|i
index|]
operator|=
name|exp
expr_stmt|;
block|}
name|process_duplicates
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
name|fill_ordinals
argument_list|(
name|d_export_vec
argument_list|)
expr_stmt|;
comment|/* Put back the list in the new order */
name|d_exports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|d_nfuncs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|d_export_vec
index|[
name|i
index|]
operator|->
name|next
operator|=
name|d_exports
expr_stmt|;
name|d_exports
operator|=
name|d_export_vec
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Build list in alpha order */
name|d_exports_lexically
operator|=
operator|(
name|export_type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
operator|*
operator|(
name|d_nfuncs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|exp
operator|=
name|d_exports
init|;
name|exp
condition|;
name|i
operator|++
operator|,
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|d_exports_lexically
index|[
name|i
index|]
operator|=
name|exp
expr_stmt|;
block|}
name|d_exports_lexically
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|d_exports_lexically
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|export_type
operator|*
argument_list|)
argument_list|,
name|alphafunc
argument_list|)
expr_stmt|;
comment|/* Fill exp entries with their hint values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d_nfuncs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|d_exports_lexically
index|[
name|i
index|]
operator|->
name|noname
operator|||
name|show_allnames
condition|)
name|d_exports_lexically
index|[
name|i
index|]
operator|->
name|hint
operator|=
name|hint
operator|++
expr_stmt|;
block|}
name|inform
argument_list|(
name|_
argument_list|(
literal|"Processed definitions"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|file
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
comment|/* xgetext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"Usage %s<option(s)><object-file(s)>\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
comment|/* xgetext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -m --machine<machine>    Create as DLL for<machine>.  [default: %s]\n"
argument_list|)
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"        possible<machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -e --output-exp<outname> Generate an export file.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -l --output-lib<outname> Generate an interface library.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -a --add-indirect         Add dll indirects to export file.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -D --dllname<name>       Name of input dll to put into interface lib.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -d --input-def<deffile>  Name of .def file to be read in.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -z --output-def<deffile> Name of .def file to be created.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"      --export-all-symbols   Export all symbols to .def\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"      --no-export-all-symbols  Only export listed symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"      --exclude-symbols<list> Don't export<list>\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"      --no-default-excludes  Clear default exclude symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -b --base-file<basefile> Read linker generated base file.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -x --no-idata4            Don't generate idata$4 section.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -c --no-idata5            Don't generate idata$5 section.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -U --add-underscore       Add underscores to symbols in interface library.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -k --kill-at              Kill @<n> from exported names.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -A --add-stdcall-alias    Add aliases without @<n>.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -S --as<name>            Use<name> for assembler.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -f --as-flags<flags>     Pass<flags> to the assembler.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -C --compat-implib        Create backward compatible import library.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -n --no-delete            Keep temp files (repeat for extra preservation).\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -v --verbose              Be verbose.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -V --version              Display the program version.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -h --help                 Display this information.\n"
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -M --mcore-elf<outname>  Process mcore-elf object files into<outname>.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -L --linker<name>        Use<name> as the linker.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"   -F --linker-flags<flags> Pass<flags> to the linker.\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OPTION_EXPORT_ALL_SYMS
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_NO_EXPORT_ALL_SYMS
value|(OPTION_EXPORT_ALL_SYMS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EXCLUDE_SYMS
value|(OPTION_NO_EXPORT_ALL_SYMS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_DEFAULT_EXCLUDES
value|(OPTION_EXCLUDE_SYMS + 1)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"no-delete"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"dllname"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"no-idata4"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"no-idata5"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"output-exp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"output-def"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"export-all-symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EXPORT_ALL_SYMS
block|}
block|,
block|{
literal|"no-export-all-symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_EXPORT_ALL_SYMS
block|}
block|,
block|{
literal|"exclude-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_EXCLUDE_SYMS
block|}
block|,
block|{
literal|"no-default-excludes"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DEFAULT_EXCLUDES
block|}
block|,
block|{
literal|"output-lib"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"def"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
comment|/* for compatiblity with older versions */
block|{
literal|"input-def"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"add-underscore"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"kill-at"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"add-stdcall-alias"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"machine"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"add-indirect"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"base-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"as"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"as-flags"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"mcore-elf"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"compat-implib"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|firstarg
init|=
literal|0
decl_stmt|;
name|program_name
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
name|oav
operator|=
name|av
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
literal|"m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:"
argument_list|,
else|#
directive|else
literal|"m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh"
argument_list|,
endif|#
directive|endif
name|long_options
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|OPTION_EXPORT_ALL_SYMS
case|:
name|export_all_symbols
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_EXPORT_ALL_SYMS
case|:
name|export_all_symbols
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_EXCLUDE_SYMS
case|:
name|add_excludes
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DEFAULT_EXCLUDES
case|:
name|do_default_excludes
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|no_idata4
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|no_idata5
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|as_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|as_flags
operator|=
name|optarg
expr_stmt|;
break|break;
comment|/* ignored for compatibility */
case|case
literal|'u'
case|:
break|break;
case|case
literal|'a'
case|:
name|add_indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|output_def
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dll_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|imp_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|exp_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|print_version
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|add_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|killat
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|add_stdcall_alias
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|def_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|dontdeltemps
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|base_file
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_file
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Unable to open base-file: %s"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
case|case
literal|'M'
case|:
name|mcore_elf_out_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|mcore_elf_linker
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|mcore_elf_linker_flags
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'C'
case|:
name|create_compat_implib
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mtable
index|[
name|i
index|]
operator|.
name|type
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|mtable
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|mname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|mtable
index|[
name|i
index|]
operator|.
name|type
condition|)
comment|/* xgettext:c-format */
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Machine '%s' not supported"
argument_list|)
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|machine
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|dll_name
operator|&&
name|exp_name
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|exp_name
argument_list|)
operator|+
literal|5
decl_stmt|;
name|dll_name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dll_name
argument_list|,
name|exp_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dll_name
argument_list|,
literal|".dll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|as_name
operator|==
name|NULL
condition|)
name|as_name
operator|=
name|deduce_name
argument_list|(
literal|"as"
argument_list|)
expr_stmt|;
comment|/* Don't use the default exclude list if we're reading only the      symbols in the .drectve section.  The default excludes are meant      to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */
if|if
condition|(
operator|!
name|export_all_symbols
condition|)
name|do_default_excludes
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|do_default_excludes
condition|)
name|set_default_excludes
argument_list|()
expr_stmt|;
if|if
condition|(
name|def_file
condition|)
name|process_def_file
argument_list|(
name|def_file
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|ac
condition|)
block|{
if|if
condition|(
operator|!
name|firstarg
condition|)
name|firstarg
operator|=
name|av
index|[
name|optind
index|]
expr_stmt|;
name|scan_obj_file
argument_list|(
name|av
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
name|mangle_defs
argument_list|()
expr_stmt|;
if|if
condition|(
name|exp_name
condition|)
name|gen_exp_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|imp_name
condition|)
block|{
comment|/* Make imp_name safe for use as a label.  */
name|char
modifier|*
name|p
decl_stmt|;
name|imp_name_lab
operator|=
name|xstrdup
argument_list|(
name|imp_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|imp_name_lab
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
name|head_label
operator|=
name|make_label
argument_list|(
literal|"_head_"
argument_list|,
name|imp_name_lab
argument_list|)
expr_stmt|;
name|gen_lib_file
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_def
condition|)
name|gen_def_file
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
if|if
condition|(
name|mcore_elf_out_file
condition|)
name|mcore_elf_gen_out_file
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for the program formed by concatenating PROG_NAME and the    string running from PREFIX to END_PREFIX.  If the concatenated    string contains a '/', try appending EXECUTABLE_SUFFIX if it is    appropriate.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|look_for_prog
parameter_list|(
name|prog_name
parameter_list|,
name|prefix
parameter_list|,
name|end_prefix
parameter_list|)
specifier|const
name|char
modifier|*
name|prog_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|end_prefix
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|prog_name
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_EXECUTABLE_SUFFIX
operator|+
name|strlen
argument_list|(
name|EXECUTABLE_SUFFIX
argument_list|)
endif|#
directive|endif
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
operator|+
name|end_prefix
argument_list|,
literal|"%s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cmd
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|found
decl_stmt|;
name|found
operator|=
operator|(
name|stat
argument_list|(
name|cmd
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|HAVE_EXECUTABLE_SUFFIX
operator|||
name|stat
argument_list|(
name|strcat
argument_list|(
name|cmd
argument_list|,
name|EXECUTABLE_SUFFIX
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
endif|#
directive|endif
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Tried file: %s"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* xgettext:c-format */
name|inform
argument_list|(
name|_
argument_list|(
literal|"Using file: %s"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_comment
comment|/* Deduce the name of the program we are want to invoke.    PROG_NAME is the basic name of the program we want to run,    eg "as" or "ld".  The catch is that we might want actually    run "i386-pe-as" or "ppc-pe-ld".     If argv[0] contains the full path, then try to find the program    in the same place, with and then without a target-like prefix.     Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,    deduce_name("as") uses the following search order:       /usr/local/bin/i586-cygwin32-as      /usr/local/bin/as      as     If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each    name, it'll try without and then with EXECUTABLE_SUFFIX.     Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"    as the fallback, but rather return i586-cygwin32-as.     Oh, and given, argv[0] = dlltool, it'll return "as".     Returns a dynamically allocated string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|deduce_name
parameter_list|(
name|prog_name
parameter_list|)
specifier|const
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|dash
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|dash
operator|=
name|NULL
expr_stmt|;
name|slash
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|program_name
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|dash
operator|=
name|cp
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|*
name|cp
operator|==
literal|':'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
endif|#
directive|endif
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|slash
operator|=
name|cp
expr_stmt|;
name|dash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|cmd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dash
operator|!=
name|NULL
condition|)
block|{
comment|/* First, try looking for a prefixed PROG_NAME in the          PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
name|cmd
operator|=
name|look_for_prog
argument_list|(
name|prog_name
argument_list|,
name|program_name
argument_list|,
name|dash
operator|-
name|program_name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slash
operator|!=
name|NULL
operator|&&
name|cmd
operator|==
name|NULL
condition|)
block|{
comment|/* Next, try looking for a PROG_NAME in the same directory as          that of this program.  */
name|cmd
operator|=
name|look_for_prog
argument_list|(
name|prog_name
argument_list|,
name|program_name
argument_list|,
name|slash
operator|-
name|program_name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
comment|/* Just return PROG_NAME as is.  */
name|cmd
operator|=
name|xstrdup
argument_list|(
name|prog_name
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DLLTOOL_MCORE_ELF
end_ifdef

begin_typedef
typedef|typedef
struct|struct
name|fname_cache
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|fname_cache
modifier|*
name|next
decl_stmt|;
block|}
name|fname_cache
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|fname_cache
name|fnames
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mcore_elf_cache_filename
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|fname_cache
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|&
name|fnames
expr_stmt|;
while|while
condition|(
name|ptr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|ptr
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
operator|(
name|fname_cache
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fname_cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|next
operator|!=
name|NULL
condition|)
name|ptr
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MCORE_ELF_TMP_OBJ
value|"mcoreelf.o"
end_define

begin_define
define|#
directive|define
name|MCORE_ELF_TMP_EXP
value|"mcoreelf.exp"
end_define

begin_define
define|#
directive|define
name|MCORE_ELF_TMP_LIB
value|"mcoreelf.lib"
end_define

begin_function
specifier|static
name|void
name|mcore_elf_gen_out_file
parameter_list|(
name|void
parameter_list|)
block|{
name|fname_cache
modifier|*
name|ptr
decl_stmt|;
name|dyn_string_t
name|ds
decl_stmt|;
comment|/* Step one.  Run 'ld -r' on the input object files in order to resolve      any internal references and to generate a single .exports section.  */
name|ptr
operator|=
operator|&
name|fnames
expr_stmt|;
name|ds
operator|=
name|dyn_string_new
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|"-r "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcore_elf_linker_flags
operator|!=
name|NULL
condition|)
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|mcore_elf_linker_flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|"-o "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_OBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcore_elf_linker
operator|==
name|NULL
condition|)
name|mcore_elf_linker
operator|=
name|deduce_name
argument_list|(
literal|"ld"
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|mcore_elf_linker
argument_list|,
name|ds
operator|->
name|s
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/* Step two. Create a .exp file and a .lib file from the temporary file.      Do this by recursively invoking dlltool....*/
name|ds
operator|=
name|dyn_string_new
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|"-S "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|as_name
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -e "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_EXP
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -l "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_LIB
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_OBJ
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -v"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
condition|)
block|{
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
operator|>
literal|1
condition|)
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -n"
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - FIME: ought to check/copy other command line options as well.  */
name|run
argument_list|(
name|program_name
argument_list|,
name|ds
operator|->
name|s
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/* Step four. Feed the .exp and object files to ld -shared to create the dll.  */
name|ds
operator|=
name|dyn_string_new
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|"-shared "
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcore_elf_linker_flags
condition|)
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|mcore_elf_linker_flags
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_EXP
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|MCORE_ELF_TMP_OBJ
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
literal|" -o "
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|ds
argument_list|,
name|mcore_elf_out_file
argument_list|)
expr_stmt|;
name|run
argument_list|(
name|mcore_elf_linker
argument_list|,
name|ds
operator|->
name|s
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|MCORE_ELF_TMP_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontdeltemps
operator|<
literal|2
condition|)
name|unlink
argument_list|(
name|MCORE_ELF_TMP_OBJ
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DLLTOOL_MCORE_ELF */
end_comment

end_unit

