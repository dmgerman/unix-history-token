begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stabs.c -- Parse stabs debugging information    Copyright (C) 1995, 1996 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains code which parses stabs debugging information.    The organization of this code is based on the gdb stabs reading    code.  The job it does is somewhat different, because it is not    trying to identify the correct address for anything.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_comment
comment|/* Meaningless definition needs by aout64.h.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_comment
comment|/* The number of predefined XCOFF types.  */
end_comment

begin_define
define|#
directive|define
name|XCOFF_TYPE_COUNT
value|34
end_define

begin_comment
comment|/* This structure is used as a handle so that the stab parsing doesn't    need to use any static variables.  */
end_comment

begin_struct
struct|struct
name|stab_handle
block|{
comment|/* The BFD.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* True if this is stabs in sections.  */
name|boolean
name|sections
decl_stmt|;
comment|/* The symbol table.  */
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* The number of symbols.  */
name|long
name|symcount
decl_stmt|;
comment|/* The accumulated file name string.  */
name|char
modifier|*
name|so_string
decl_stmt|;
comment|/* The value of the last N_SO symbol.  */
name|bfd_vma
name|so_value
decl_stmt|;
comment|/* The value of the start of the file, so that we can handle file      relative N_LBRAC and N_RBRAC symbols.  */
name|bfd_vma
name|file_start_offset
decl_stmt|;
comment|/* The offset of the start of the function, so that we can handle      function relative N_LBRAC and N_RBRAC symbols.  */
name|bfd_vma
name|function_start_offset
decl_stmt|;
comment|/* The version number of gcc which compiled the current compilation      unit, 0 if not compiled by gcc.  */
name|int
name|gcc_compiled
decl_stmt|;
comment|/* Whether an N_OPT symbol was seen that was not generated by gcc,      so that we can detect the SunPRO compiler.  */
name|boolean
name|n_opt_found
decl_stmt|;
comment|/* The main file name.  */
name|char
modifier|*
name|main_filename
decl_stmt|;
comment|/* A stack of unfinished N_BINCL files.  */
name|struct
name|bincl_file
modifier|*
name|bincl_stack
decl_stmt|;
comment|/* A list of finished N_BINCL files.  */
name|struct
name|bincl_file
modifier|*
name|bincl_list
decl_stmt|;
comment|/* Whether we are inside a function or not.  */
name|boolean
name|within_function
decl_stmt|;
comment|/* The address of the end of the function, used if we have seen an      N_FUN symbol while in a function.  This is -1 if we have not seen      an N_FUN (the normal case).  */
name|bfd_vma
name|function_end
decl_stmt|;
comment|/* The depth of block nesting.  */
name|int
name|block_depth
decl_stmt|;
comment|/* List of pending variable definitions.  */
name|struct
name|stab_pending_var
modifier|*
name|pending
decl_stmt|;
comment|/* Number of files for which we have types.  */
name|unsigned
name|int
name|files
decl_stmt|;
comment|/* Lists of types per file.  */
name|struct
name|stab_types
modifier|*
modifier|*
name|file_types
decl_stmt|;
comment|/* Predefined XCOFF types.  */
name|debug_type
name|xcoff_types
index|[
name|XCOFF_TYPE_COUNT
index|]
decl_stmt|;
comment|/* Undefined tags.  */
name|struct
name|stab_tag
modifier|*
name|tags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of these structures is used to hold pending variable    definitions seen before the N_LBRAC of a block.  */
end_comment

begin_struct
struct|struct
name|stab_pending_var
block|{
comment|/* Next pending variable definition.  */
name|struct
name|stab_pending_var
modifier|*
name|next
decl_stmt|;
comment|/* Name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Kind.  */
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
comment|/* Value.  */
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A list of these structures is used to hold the types for a single    file.  */
end_comment

begin_struct
struct|struct
name|stab_types
block|{
comment|/* Next set of slots for this file.  */
name|struct
name|stab_types
modifier|*
name|next
decl_stmt|;
comment|/* Types indexed by type number.  */
define|#
directive|define
name|STAB_TYPES_SLOTS
value|(16)
name|debug_type
name|types
index|[
name|STAB_TYPES_SLOTS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We keep a list of undefined tags that we encounter, so that we can    fill them in if the tag is later defined.  */
end_comment

begin_struct
struct|struct
name|stab_tag
block|{
comment|/* Next undefined tag.  */
name|struct
name|stab_tag
modifier|*
name|next
decl_stmt|;
comment|/* Tag name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Type kind.  */
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
comment|/* Slot to hold real type when we discover it.  If we don't, we fill      in an undefined tag type.  */
name|debug_type
name|slot
decl_stmt|;
comment|/* Indirect type we have created to point at slot.  */
name|debug_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savestring
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|parse_number
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_stab
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_stab
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_string
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_type_number
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_range_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_sun_builtin_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_sun_floating_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_enum_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_struct_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|boolean
operator|,
specifier|const
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_baseclasses
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_baseclass
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_struct_fields
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_field
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_cpp_abbrev
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_field
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_one_struct_field
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|debug_field
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_members
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|int
operator|*
operator|,
name|debug_method
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_argtypes
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
name|debug_type
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|debug_type
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|parse_stab_tilde_field
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|int
operator|*
operator|,
name|debug_type
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|parse_stab_array_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_bincl
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pop_bincl
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|find_excl
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_record_variable
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|debug_type
operator|,
expr|enum
name|debug_var_kind
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_emit_pending_vars
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
modifier|*
name|stab_find_slot
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|stab_find_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_record_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|int
operator|*
operator|,
name|debug_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|stab_xcoff_builtin_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
name|stab_find_tagged_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|enum
name|debug_type_kind
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|debug_type
modifier|*
name|stab_demangle_argtypes
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
expr|struct
name|stab_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save a string in memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Read a number from a string.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|parse_number
parameter_list|(
name|pp
parameter_list|,
name|poverflow
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|boolean
modifier|*
name|poverflow
decl_stmt|;
block|{
name|unsigned
name|long
name|ul
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
if|if
condition|(
name|poverflow
operator|!=
name|NULL
condition|)
operator|*
name|poverflow
operator|=
name|false
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
operator|*
name|pp
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|+
literal|1
operator|!=
literal|0
operator|||
name|errno
operator|==
literal|0
condition|)
return|return
operator|(
name|bfd_vma
operator|)
name|ul
return|;
comment|/* Note that even though strtoul overflowed, it should have set *pp      to the end of the number, which is where we want it.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|>
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|boolean
name|neg
decl_stmt|;
name|int
name|base
decl_stmt|;
name|bfd_vma
name|over
decl_stmt|,
name|lastdig
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
name|bfd_vma
name|v
decl_stmt|;
comment|/* Our own version of strtoul, for a bfd_vma.  */
name|p
operator|=
name|orig
expr_stmt|;
name|neg
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
name|true
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
literal|8
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
block|}
name|over
operator|=
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|bfd_vma
operator|)
name|base
expr_stmt|;
name|lastdig
operator|=
operator|(
call|(
name|bfd_vma
call|)
argument_list|(
name|bfd_signed_vma
argument_list|)
operator|-
literal|1
operator|)
operator|%
operator|(
name|bfd_vma
operator|)
name|base
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|d
decl_stmt|;
name|d
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|d
argument_list|)
condition|)
name|d
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|d
argument_list|)
condition|)
name|d
operator|-=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|d
argument_list|)
condition|)
name|d
operator|-=
literal|'a'
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|d
operator|>=
name|base
condition|)
break|break;
if|if
condition|(
name|v
operator|>
name|over
operator|||
operator|(
name|v
operator|==
name|over
operator|&&
operator|(
name|bfd_vma
operator|)
name|d
operator|>
name|lastdig
operator|)
condition|)
block|{
name|overflow
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|overflow
condition|)
block|{
if|if
condition|(
name|neg
condition|)
name|v
operator|=
operator|-
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/* If we get here, the number is too large to represent in a      bfd_vma.  */
if|if
condition|(
name|poverflow
operator|!=
name|NULL
condition|)
operator|*
name|poverflow
operator|=
name|true
expr_stmt|;
else|else
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"numeric overflow"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Give an error for a bad stab string.  */
end_comment

begin_function
specifier|static
name|void
name|bad_stab
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad stab: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Warn about something in a stab string.  */
end_comment

begin_function
specifier|static
name|void
name|warn_stab
parameter_list|(
name|p
parameter_list|,
name|err
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s: %s\n"
argument_list|,
name|err
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a handle to parse stabs symbols with.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|PTR
name|start_stab
parameter_list|(
name|dhandle
parameter_list|,
name|abfd
parameter_list|,
name|sections
parameter_list|,
name|syms
parameter_list|,
name|symcount
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|sections
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
name|long
name|symcount
decl_stmt|;
block|{
name|struct
name|stab_handle
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|stab_handle
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|ret
operator|->
name|sections
operator|=
name|sections
expr_stmt|;
name|ret
operator|->
name|syms
operator|=
name|syms
expr_stmt|;
name|ret
operator|->
name|symcount
operator|=
name|symcount
expr_stmt|;
name|ret
operator|->
name|files
operator|=
literal|1
expr_stmt|;
name|ret
operator|->
name|file_types
operator|=
operator|(
expr|struct
name|stab_types
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
operator|->
name|file_types
argument_list|)
expr_stmt|;
name|ret
operator|->
name|file_types
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|function_end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* When we have processed all the stabs information, we need to go    through and fill in all the undefined tags.  */
end_comment

begin_function
name|boolean
name|finish_stab
parameter_list|(
name|dhandle
parameter_list|,
name|handle
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|PTR
name|handle
decl_stmt|;
block|{
name|struct
name|stab_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|stab_tag
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|within_function
condition|)
block|{
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|debug_end_function
argument_list|(
name|dhandle
argument_list|,
name|info
operator|->
name|function_end
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|within_function
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|function_end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|st
operator|=
name|info
operator|->
name|tags
init|;
name|st
operator|!=
name|NULL
condition|;
name|st
operator|=
name|st
operator|->
name|next
control|)
block|{
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
name|kind
operator|=
name|st
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
condition|)
name|kind
operator|=
name|DEBUG_KIND_STRUCT
expr_stmt|;
name|st
operator|->
name|slot
operator|=
name|debug_make_undefined_tagged_type
argument_list|(
name|dhandle
argument_list|,
name|st
operator|->
name|name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|slot
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a single stabs symbol.  */
end_comment

begin_function
name|boolean
name|parse_stab
parameter_list|(
name|dhandle
parameter_list|,
name|handle
parameter_list|,
name|type
parameter_list|,
name|desc
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|PTR
name|handle
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|stab_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|stab_handle
operator|*
operator|)
name|handle
decl_stmt|;
comment|/* gcc will emit two N_SO strings per compilation unit, one for the      directory name and one for the file name.  We just collect N_SO      strings as we see them, and start the new compilation unit when      we see a non N_SO symbol.  */
if|if
condition|(
name|info
operator|->
name|so_string
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|!=
name|N_SO
operator|||
operator|*
name|string
operator|==
literal|'\0'
operator|||
name|value
operator|!=
name|info
operator|->
name|so_value
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|debug_set_filename
argument_list|(
name|dhandle
argument_list|,
name|info
operator|->
name|so_string
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|main_filename
operator|=
name|info
operator|->
name|so_string
expr_stmt|;
name|info
operator|->
name|gcc_compiled
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|n_opt_found
operator|=
name|false
expr_stmt|;
comment|/* Generally, for stabs in the symbol table, the N_LBRAC and 	 N_RBRAC symbols are relative to the N_SO symbol value.  */
if|if
condition|(
operator|!
name|info
operator|->
name|sections
condition|)
name|info
operator|->
name|file_start_offset
operator|=
name|info
operator|->
name|so_value
expr_stmt|;
comment|/* We need to reset the mapping from type numbers to types.  We 	 can't free the old mapping, because of the use of 	 debug_make_indirect_type.  */
name|info
operator|->
name|files
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|file_types
operator|=
operator|(
operator|(
expr|struct
name|stab_types
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|info
operator|->
name|file_types
argument_list|)
operator|)
expr_stmt|;
name|info
operator|->
name|file_types
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|so_string
operator|=
name|NULL
expr_stmt|;
comment|/* Now process whatever type we just got.  */
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
break|break;
case|case
name|N_LBRAC
case|:
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|info
operator|->
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|info
operator|->
name|within_function
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"N_LBRAC not within function\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Start an inner lexical block.  */
if|if
condition|(
operator|!
name|debug_start_block
argument_list|(
name|dhandle
argument_list|,
operator|(
name|value
operator|+
name|info
operator|->
name|file_start_offset
operator|+
name|info
operator|->
name|function_start_offset
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Emit any pending variable definitions.  */
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|info
operator|->
name|block_depth
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
comment|/* Ignore extra outermost context from SunPRO cc and acc.  */
if|if
condition|(
name|info
operator|->
name|n_opt_found
operator|&&
name|desc
operator|==
literal|1
condition|)
break|break;
comment|/* We shouldn't have any pending variable definitions here, but,          if we do, we probably need to emit them before closing the          block.  */
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* End an inner lexical block.  */
if|if
condition|(
operator|!
name|debug_end_block
argument_list|(
name|dhandle
argument_list|,
operator|(
name|value
operator|+
name|info
operator|->
name|file_start_offset
operator|+
name|info
operator|->
name|function_start_offset
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
operator|--
name|info
operator|->
name|block_depth
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|block_depth
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many N_RBRACs\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
name|N_SO
case|:
comment|/* This always ends a function.  */
if|if
condition|(
name|info
operator|->
name|within_function
condition|)
block|{
name|bfd_vma
name|endval
decl_stmt|;
name|endval
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
name|info
operator|->
name|function_end
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|info
operator|->
name|function_end
operator|<
name|endval
condition|)
name|endval
operator|=
name|info
operator|->
name|function_end
expr_stmt|;
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|debug_end_function
argument_list|(
name|dhandle
argument_list|,
name|endval
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|within_function
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|function_end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* An empty string is emitted by gcc at the end of a compilation          unit.  */
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
name|true
return|;
comment|/* Just accumulate strings until we see a non N_SO symbol.  If          the string starts with '/', we discard the previously          accumulated strings.  */
if|if
condition|(
name|info
operator|->
name|so_string
operator|==
name|NULL
condition|)
name|info
operator|->
name|so_string
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|info
operator|->
name|so_string
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'/'
condition|)
name|info
operator|->
name|so_string
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|so_string
operator|=
name|concat
argument_list|(
name|info
operator|->
name|so_string
argument_list|,
name|string
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|so_value
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* Start an include file.  */
if|if
condition|(
operator|!
name|debug_start_source
argument_list|(
name|dhandle
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_BINCL
case|:
comment|/* Start an include file which may be replaced.  */
name|push_bincl
argument_list|(
name|info
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|debug_start_source
argument_list|(
name|dhandle
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_EINCL
case|:
comment|/* End an N_BINCL include.  */
if|if
condition|(
operator|!
name|debug_start_source
argument_list|(
name|dhandle
argument_list|,
name|pop_bincl
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_EXCL
case|:
comment|/* This is a duplicate of a header file named by N_BINCL which          was eliminated by the linker.  */
if|if
condition|(
operator|!
name|find_excl
argument_list|(
name|info
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_SLINE
case|:
if|if
condition|(
operator|!
name|debug_record_line
argument_list|(
name|dhandle
argument_list|,
name|desc
argument_list|,
name|value
operator|+
name|info
operator|->
name|function_start_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_BCOMM
case|:
if|if
condition|(
operator|!
name|debug_start_common_block
argument_list|(
name|dhandle
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_ECOMM
case|:
if|if
condition|(
operator|!
name|debug_end_common_block
argument_list|(
name|dhandle
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|N_FUN
case|:
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|within_function
condition|)
block|{
comment|/* This always marks the end of a function; we don't                  need to worry about info->function_end.  */
if|if
condition|(
name|info
operator|->
name|sections
condition|)
name|value
operator|+=
name|info
operator|->
name|function_start_offset
expr_stmt|;
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|debug_end_function
argument_list|(
name|dhandle
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|within_function
operator|=
name|false
expr_stmt|;
name|info
operator|->
name|function_end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* A const static symbol in the .text section will have an N_FUN          entry.  We need to use these to mark the end of the function,          in case we are looking at gcc output before it was changed to          always emit an empty N_FUN.  We can't call debug_end_function          here, because it might be a local static symbol.  */
if|if
condition|(
name|info
operator|->
name|within_function
operator|&&
operator|(
name|info
operator|->
name|function_end
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|value
operator|<
name|info
operator|->
name|function_end
operator|)
condition|)
name|info
operator|->
name|function_end
operator|=
name|value
expr_stmt|;
comment|/* Fall through.  */
comment|/* FIXME: gdb checks the string for N_STSYM, N_LCSYM or N_ROSYM          symbols, and if it does not start with :S, gdb relocates the          value to the start of the section.  gcc always seems to use          :S, so we don't worry about this.  */
comment|/* Fall through.  */
default|default:
block|{
specifier|const
name|char
modifier|*
name|colon
decl_stmt|;
name|colon
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
name|NULL
operator|&&
operator|(
name|colon
index|[
literal|1
index|]
operator|==
literal|'f'
operator|||
name|colon
index|[
literal|1
index|]
operator|==
literal|'F'
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|within_function
condition|)
block|{
name|bfd_vma
name|endval
decl_stmt|;
name|endval
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|function_end
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|info
operator|->
name|function_end
operator|<
name|endval
condition|)
name|endval
operator|=
name|info
operator|->
name|function_end
expr_stmt|;
if|if
condition|(
operator|!
name|stab_emit_pending_vars
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|)
operator|||
operator|!
name|debug_end_function
argument_list|(
name|dhandle
argument_list|,
name|endval
argument_list|)
condition|)
return|return
name|false
return|;
name|info
operator|->
name|function_end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* For stabs in sections, line numbers and block addresses                are offsets from the start of the function.  */
if|if
condition|(
name|info
operator|->
name|sections
condition|)
name|info
operator|->
name|function_start_offset
operator|=
name|value
expr_stmt|;
name|info
operator|->
name|within_function
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parse_stab_string
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|type
argument_list|,
name|desc
argument_list|,
name|value
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|N_OPT
case|:
if|if
condition|(
name|string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"gcc2_compiled."
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|gcc_compiled
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|string
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"gcc_compiled."
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|gcc_compiled
operator|=
literal|1
expr_stmt|;
else|else
name|info
operator|->
name|n_opt_found
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|N_OBJ
case|:
case|case
name|N_ENDM
case|:
case|case
name|N_MAIN
case|:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse the stabs string.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_string
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|stabtype
parameter_list|,
name|desc
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
name|int
name|stabtype
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|debug_type
name|dtype
decl_stmt|;
name|boolean
name|synonym
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|debug_type
modifier|*
name|slot
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|true
return|;
while|while
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* GCC 2.x puts the line number in desc.  SunOS apparently puts in      the number of bytes occupied by a type or object, which we      ignore.  */
if|if
condition|(
name|info
operator|->
name|gcc_compiled
operator|>=
literal|2
condition|)
name|lineno
operator|=
name|desc
expr_stmt|;
else|else
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: Sometimes the special C++ names start with '.'.  */
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
switch|switch
condition|(
name|string
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
name|name
operator|=
literal|"this"
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Was: name = "vptr"; */
break|break;
case|case
literal|'e'
case|:
name|name
operator|=
literal|"eh_throw"
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* This was an anonymous type that was never fixed up.  */
break|break;
case|case
literal|'X'
case|:
comment|/* SunPRO (3.0 at least) static variable encoding.  */
break|break;
default|default:
name|warn_stab
argument_list|(
name|string
argument_list|,
literal|"unknown C++ encoded name"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|string
operator|||
operator|(
name|string
index|[
literal|0
index|]
operator|==
literal|' '
operator|&&
name|p
operator|==
name|string
operator|+
literal|1
operator|)
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
else|else
name|name
operator|=
name|savestring
argument_list|(
name|string
argument_list|,
name|p
operator|-
name|string
argument_list|)
expr_stmt|;
block|}
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|type
operator|=
literal|'l'
expr_stmt|;
else|else
name|type
operator|=
operator|*
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* c is a special case, not followed by a type-number. 	 SYMBOL:c=iVALUE for an integer constant symbol. 	 SYMBOL:c=rVALUE for a floating constant symbol. 	 SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol. 	 e.g. "b:c=e6,0" for "const b = blob1" 	 (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|bad_stab
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* Floating point constant.  */
if|if
condition|(
operator|!
name|debug_record_float_const
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|atof
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'i'
case|:
comment|/* Integer constant.  */
comment|/* Defining integer constants this way is kind of silly, 	     since 'e' constants allows the compiler to give not only 	     the value, but the type as well.  C has at least int, 	     long, unsigned int, and long long as constant types; 	     other languages probably should have at least unsigned as 	     well as signed constants.  */
if|if
condition|(
operator|!
name|debug_record_int_const
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'e'
case|:
comment|/* SYMBOL:c=eTYPE,INTVALUE for a constant symbol whose value 	     can be represented as integral. 	     e.g. "b:c=e6,0" for "const b = blob1" 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|debug_record_typed_const
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
name|bad_stab
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* The name of a caught exception.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_label
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
comment|/* A function definition.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_function
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|type
operator|==
literal|'F'
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Sun acc puts declared types of arguments here.  We don't care 	 about their actual types (FIXME -- we should remember the whole 	 function prototype), but the list may define some new types 	 that we have to remember, so we must scan it now.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'G'
case|:
block|{
name|char
name|leading
decl_stmt|;
name|long
name|c
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|;
comment|/* A global symbol.  The value must be extracted from the 	   symbol table.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
name|leading
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|info
operator|->
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|info
operator|->
name|symcount
operator|,
name|ps
operator|=
name|info
operator|->
name|syms
init|;
name|c
operator|>
literal|0
condition|;
operator|--
name|c
operator|,
operator|++
name|ps
control|)
block|{
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|leading
operator|!=
literal|'\0'
operator|&&
operator|*
name|n
operator|==
name|leading
condition|)
operator|++
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|n
operator|==
operator|*
name|name
operator|&&
name|strcmp
argument_list|(
name|n
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|value
operator|=
name|bfd_asymbol_value
argument_list|(
operator|*
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_GLOBAL
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
comment|/* This case is faked by a conditional above, when there is no 	 code letter in the dbx data.  Dbx data never actually 	 contains 'l'.  */
case|case
literal|'l'
case|:
case|case
literal|'s'
case|:
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_LOCAL
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'p'
case|:
comment|/* A function parameter.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'F'
condition|)
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* pF is a two-letter code that means a function parameter in 	   Fortran.  The type-number specifies the type of the return 	   value.  Translate it into a pointer-to-function type.  */
operator|++
name|p
expr_stmt|;
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DEBUG_TYPE_NULL
condition|)
block|{
name|debug_type
name|ftype
decl_stmt|;
name|ftype
operator|=
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|dtype
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|debug_make_pointer_type
argument_list|(
name|dhandle
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_PARM_STACK
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: At this point gdb considers rearranging the parameter 	 address on a big endian machine if it is smaller than an int. 	 We have no way to do that, since we don't really know much 	 about the target.  */
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|stabtype
operator|==
name|N_FUN
condition|)
block|{
comment|/* Prototype of a function referenced by this file.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
break|break;
block|}
comment|/* Fall through.  */
case|case
literal|'R'
case|:
comment|/* Parameter which is in a register.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_PARM_REG
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'r'
case|:
comment|/* Register variable (either global or local).  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_REGISTER
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME: At this point gdb checks to combine pairs of 'p' and 	 'r' stabs into a single 'P' stab.  */
break|break;
case|case
literal|'S'
case|:
comment|/* Static symbol at top level of file */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_STATIC
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'t'
case|:
comment|/* A typedef.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* A nameless type.  Nothing to do.  */
return|return
name|true
return|;
block|}
name|dtype
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|slot
operator|!=
name|NULL
condition|)
operator|*
name|slot
operator|=
name|dtype
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Struct, union, or enum tag.  For GNU C++, this can be be followed 	 by 't' which means we are typedef'ing it as well.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'t'
condition|)
block|{
name|synonym
operator|=
name|false
expr_stmt|;
comment|/* FIXME: gdb sets synonym to true if the current language              is C++.  */
block|}
else|else
block|{
name|synonym
operator|=
name|true
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|dtype
operator|=
name|debug_tag_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|slot
operator|!=
name|NULL
condition|)
operator|*
name|slot
operator|=
name|dtype
expr_stmt|;
comment|/* See if we have a cross reference to this tag which we can now          fill in.  */
block|{
specifier|register
name|struct
name|stab_tag
modifier|*
modifier|*
name|pst
decl_stmt|;
for|for
control|(
name|pst
operator|=
operator|&
name|info
operator|->
name|tags
init|;
operator|*
name|pst
operator|!=
name|NULL
condition|;
name|pst
operator|=
operator|&
operator|(
operator|*
name|pst
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pst
operator|)
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
operator|(
operator|*
name|pst
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|pst
operator|)
operator|->
name|slot
operator|=
name|dtype
expr_stmt|;
operator|*
name|pst
operator|=
operator|(
operator|*
name|pst
operator|)
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|synonym
condition|)
block|{
name|dtype
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|slot
operator|!=
name|NULL
condition|)
operator|*
name|slot
operator|=
name|dtype
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
comment|/* Static symbol of local scope */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
comment|/* FIXME: gdb checks os9k_stabs here.  */
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_LOCAL_STATIC
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'v'
case|:
comment|/* Reference parameter.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_PARM_REFERENCE
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'a'
case|:
comment|/* Reference parameter which is in a register.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_record_parameter
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_PARM_REF_REG
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used by Sun FORTRAN for "function result value". 	 Sun claims ("dbx and dbxtool interfaces", 2nd ed) 	 that Pascal uses it too, but when I tried it Pascal used 	 "x:3" (local symbol) instead.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|stab_record_variable
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|dtype
argument_list|,
name|DEBUG_LOCAL
argument_list|,
name|value
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
name|bad_stab
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FIXME: gdb converts structure values to structure pointers in a      couple of cases, depending upon the target.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a stabs type.  The typename argument is non-NULL if this is a    typedef or a tag definition.  The pp argument points to the stab    string, and is updated.  The slotp argument points to a place to    store the slot used if the type is being defined.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|typename
parameter_list|,
name|pp
parameter_list|,
name|slotp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
modifier|*
name|slotp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|boolean
name|stringp
decl_stmt|;
name|int
name|descriptor
decl_stmt|;
name|debug_type
name|dtype
decl_stmt|;
if|if
condition|(
name|slotp
operator|!=
name|NULL
condition|)
operator|*
name|slotp
operator|=
name|NULL
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|stringp
operator|=
name|false
expr_stmt|;
comment|/* Read type number if present.  The type number may be omitted.      for instance in a two-dimensional array declared with type      "ar1;1;10;ar1;1;10;4".  */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'('
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
comment|/* 'typenums=' not present, type is anonymous.  Read and return 	 the definition, but don't put it in the type vector.  */
name|typenums
index|[
literal|0
index|]
operator|=
name|typenums
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|parse_stab_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
block|{
comment|/* Type is not being defined here.  Either it already 	     exists, or this is a forward reference to it.  */
return|return
name|stab_find_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typenums
argument_list|)
return|;
block|}
comment|/* Only set the slot if the type is being defined.  This means          that the mapping from type numbers to types will only record          the name of the typedef which defines a type.  If we don't do          this, then something like 	     typedef int foo; 	     int i; 	 will record that i is of type foo.  Unfortunately, stabs 	 information is ambiguous about variable types.  For this code, 	     typedef int foo; 	     int i; 	     foo j; 	 the stabs information records both i and j as having the same 	 type.  This could be fixed by patching the compiler.  */
if|if
condition|(
name|slotp
operator|!=
name|NULL
operator|&&
name|typenums
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
name|typenums
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
operator|*
name|slotp
operator|=
name|stab_find_slot
argument_list|(
name|info
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
comment|/* Type is being defined here.  */
comment|/* Skip the '='.  */
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'@'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pp
operator|+
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Member type.  */
break|break;
block|}
comment|/* Type attributes.  */
name|attr
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|';'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
block|}
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|attr
condition|)
block|{
case|case
literal|'s'
case|:
name|size
operator|=
name|atoi
argument_list|(
name|attr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
name|size
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
default|default:
comment|/* Ignore unrecognized type attributes, so future 		 compilers can invent new ones.  */
break|break;
block|}
block|}
block|}
name|descriptor
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
name|descriptor
condition|)
block|{
case|case
literal|'x'
case|:
block|{
name|enum
name|debug_type_kind
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* A cross reference to another type.  */
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'s'
case|:
name|code
operator|=
name|DEBUG_KIND_STRUCT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code
operator|=
name|DEBUG_KIND_UNION
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|code
operator|=
name|DEBUG_KIND_ENUM
expr_stmt|;
break|break;
default|default:
comment|/* Complain and keep going, so compilers can invent new 	       cross-reference types.  */
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unrecognized cross reference type"
argument_list|)
expr_stmt|;
name|code
operator|=
name|DEBUG_KIND_STRUCT
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|q1
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
while|while
condition|(
name|q1
operator|!=
name|NULL
operator|&&
name|p
operator|>
name|q1
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|q2
operator|=
name|strchr
argument_list|(
name|q1
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q2
operator|==
name|NULL
operator|||
name|q2
operator|<
name|p
condition|)
break|break;
name|p
operator|+=
literal|2
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
block|}
name|dtype
operator|=
name|stab_find_tagged_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|,
name|code
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'('
case|:
block|{
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
name|int
name|xtypenums
index|[
literal|2
index|]
decl_stmt|;
comment|/* This type is defined as another type.  */
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Peek ahead at the number to detect void.  */
if|if
condition|(
operator|!
name|parse_stab_type_number
argument_list|(
name|pp
argument_list|,
name|xtypenums
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
name|xtypenums
index|[
literal|0
index|]
operator|&&
name|typenums
index|[
literal|1
index|]
operator|==
name|xtypenums
index|[
literal|1
index|]
condition|)
block|{
comment|/* This type is being defined as itself, which means that                it is void.  */
name|dtype
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pp
operator|=
name|hold
expr_stmt|;
comment|/* Go back to the number and have parse_stab_type get it. 	       This means that we can deal with something like 	       t(1,2)=(3,4)=... which the Lucid compiler uses.  */
name|dtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|stab_record_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typenums
argument_list|,
name|dtype
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
break|break;
block|}
case|case
literal|'*'
case|:
name|dtype
operator|=
name|debug_make_pointer_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Reference to another type.  */
name|dtype
operator|=
operator|(
name|debug_make_reference_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Function returning another type.  */
comment|/* FIXME: gdb checks os9k_stabs here.  */
name|dtype
operator|=
operator|(
name|debug_make_function_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* Const qualifier on some type (Sun).  */
comment|/* FIXME: gdb accepts 'c' here if os9k_stabs.  */
name|dtype
operator|=
name|debug_make_const_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Volatile qual on some type (Sun).  */
comment|/* FIXME: gdb accepts 'i' here if os9k_stabs.  */
name|dtype
operator|=
operator|(
name|debug_make_volatile_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Offset (class& variable) type.  This is used for a pointer          relative to an object.  */
block|{
name|debug_type
name|domain
decl_stmt|;
name|debug_type
name|memtype
decl_stmt|;
comment|/* Member type.  */
name|domain
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|memtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|memtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|dtype
operator|=
name|debug_make_offset_type
argument_list|(
name|dhandle
argument_list|,
name|domain
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* Method (class& fn) type.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'#'
condition|)
block|{
name|debug_type
name|return_type
decl_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
name|return_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|dtype
operator|=
name|debug_make_method_type
argument_list|(
name|dhandle
argument_list|,
name|return_type
argument_list|,
name|DEBUG_TYPE_NULL
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug_type
name|domain
decl_stmt|;
name|debug_type
name|return_type
decl_stmt|;
name|debug_type
modifier|*
name|args
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
name|domain
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|return_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|args
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|args
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|args
operator|=
operator|(
operator|(
name|debug_type
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|args
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|args
argument_list|)
operator|)
expr_stmt|;
block|}
name|args
index|[
name|n
index|]
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|n
index|]
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
operator|++
name|n
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* If the last type is not void, then this function takes a 	     variable number of arguments.  Otherwise, we must strip 	     the void type.  */
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|args
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|DEBUG_KIND_VOID
condition|)
name|varargs
operator|=
name|true
expr_stmt|;
else|else
block|{
operator|--
name|n
expr_stmt|;
name|varargs
operator|=
name|false
expr_stmt|;
block|}
name|args
index|[
name|n
index|]
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|dtype
operator|=
name|debug_make_method_type
argument_list|(
name|dhandle
argument_list|,
name|return_type
argument_list|,
name|domain
argument_list|,
name|args
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* Range type.  */
name|dtype
operator|=
name|parse_stab_range_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typename
argument_list|,
name|pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* FIXME: gdb checks os9k_stabs here.  */
comment|/* Sun ACC builtin int type.  */
name|dtype
operator|=
name|parse_stab_sun_builtin_type
argument_list|(
name|dhandle
argument_list|,
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Sun ACC builtin float type.  */
name|dtype
operator|=
name|parse_stab_sun_floating_type
argument_list|(
name|dhandle
argument_list|,
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Enumeration type.  */
name|dtype
operator|=
name|parse_stab_enum_type
argument_list|(
name|dhandle
argument_list|,
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
comment|/* Struct or union type.  */
name|dtype
operator|=
name|parse_stab_struct_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typename
argument_list|,
name|pp
argument_list|,
name|descriptor
operator|==
literal|'s'
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Array type.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'r'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|dtype
operator|=
name|parse_stab_array_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
name|stringp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|dtype
operator|=
name|debug_make_set_type
argument_list|(
name|dhandle
argument_list|,
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|stringp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|dtype
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|stab_record_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typenums
argument_list|,
name|dtype
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|size
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|debug_record_type_size
argument_list|(
name|dhandle
argument_list|,
name|dtype
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|size
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|dtype
return|;
block|}
end_function

begin_comment
comment|/* Read a number by which a type is referred to in dbx data, or    perhaps read a pair (FILENUM, TYPENUM) in parentheses.  Just a    single number N is equivalent to (0,N).  Return the two numbers by    storing them in the vector TYPENUMS.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_type_number
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'('
condition|)
block|{
name|typenums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
operator|*
name|pp
expr_stmt|;
name|typenums
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|')'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a range type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_range_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|typename
parameter_list|,
name|pp
parameter_list|,
name|typenums
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|int
name|rangenums
index|[
literal|2
index|]
decl_stmt|;
name|boolean
name|self_subrange
decl_stmt|;
name|debug_type
name|index_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|bfd_signed_vma
name|n2
decl_stmt|,
name|n3
decl_stmt|;
name|boolean
name|ov2
decl_stmt|,
name|ov3
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|index_type
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
comment|/* First comes a type we are a subrange of.      In C it is usually 0, 1 or the type being defined.  */
if|if
condition|(
operator|!
name|parse_stab_type_number
argument_list|(
name|pp
argument_list|,
name|rangenums
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|self_subrange
operator|=
operator|(
name|rangenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|rangenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
condition|)
block|{
operator|*
name|pp
operator|=
name|orig
expr_stmt|;
name|index_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* The remaining two operands are usually lower and upper bounds of      the range.  But in some special cases they mean something else.  */
name|s2
operator|=
operator|*
name|pp
expr_stmt|;
name|n2
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|&
name|ov2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|s3
operator|=
operator|*
name|pp
expr_stmt|;
name|n3
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|&
name|ov3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|ov2
operator|||
name|ov3
condition|)
block|{
comment|/* gcc will emit range stabs for long long types.  Handle this          as a special case.  FIXME: This needs to be more general.  */
define|#
directive|define
name|LLLOW
value|"01000000000000000000000;"
define|#
directive|define
name|LLHIGH
value|"0777777777777777777777;"
define|#
directive|define
name|ULLHIGH
value|"01777777777777777777777;"
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s2
argument_list|,
name|LLLOW
argument_list|,
sizeof|sizeof
name|LLLOW
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|s3
argument_list|,
name|LLHIGH
argument_list|,
sizeof|sizeof
name|LLHIGH
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
operator|!
name|ov2
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|s3
argument_list|,
name|ULLHIGH
argument_list|,
sizeof|sizeof
name|ULLHIGH
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|true
argument_list|)
return|;
block|}
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"numeric overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
comment|/* A type defined as a subrange of itself, with both bounds 0,          is void.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|0
condition|)
return|return
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
return|;
comment|/* A type defined as a subrange of itself, with n2 positive and 	 n3 zero, is a complex type, and n2 is the number of bytes.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
return|return
name|debug_make_complex_type
argument_list|(
name|dhandle
argument_list|,
name|n2
argument_list|)
return|;
comment|/* If n3 is zero and n2 is positive, this is a floating point          type, and n2 is the number of bytes.  */
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
return|return
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
name|n2
argument_list|)
return|;
comment|/* If the upper bound is -1, this is an unsigned int.  */
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* When gcc is used with -gstabs, but not -gstabs+, it will emit 	         long long int:t6=r1;0;-1; 		 long long unsigned int:t7=r1;0;-1; 	     We hack here to handle this reasonably.  */
if|if
condition|(
name|typename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"long long int"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|typename
argument_list|,
literal|"long long unsigned int"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/* FIXME: The size here really depends upon the target.  */
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
return|;
block|}
comment|/* A range of 0 to 127 is char.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|127
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
return|;
comment|/* FIXME: gdb checks for the language CHILL here.  */
if|if
condition|(
name|n2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n3
operator|<
literal|0
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
operator|-
name|n3
argument_list|,
name|true
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0xff
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0xffff
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
return|;
comment|/* -1 is used for the upper bound of (4 byte) "unsigned int" 	     and "unsigned long", and we already checked for that, so 	     don't need to test for it here.  */
block|}
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|<
literal|0
operator|&&
operator|(
name|self_subrange
operator|||
name|n2
operator|==
operator|-
literal|8
operator|)
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
operator|-
name|n2
argument_list|,
name|true
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n2
operator|==
operator|-
name|n3
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|n3
operator|==
literal|0x7f
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0x7fff
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0x7fffffff
condition|)
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
return|;
block|}
block|}
comment|/* At this point I don't have the faintest idea how to deal with a      self_subrange type; I'm going to assume that this is used as an      idiom, and that all of them are special cases.  So . . .  */
if|if
condition|(
name|self_subrange
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|index_type
operator|=
name|stab_find_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|rangenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
comment|/* Does this actually ever happen?  Is that why we are worrying          about dealing with it rather than just calling error_type?  */
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"missing index type"
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
return|return
name|debug_make_range_type
argument_list|(
name|dhandle
argument_list|,
name|index_type
argument_list|,
name|n2
argument_list|,
name|n3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sun's ACC uses a somewhat saner method for specifying the builtin    typedefs in every file (for int, long, etc):  	type = b<signed><width>;<offset>;<nbits> 	signed = u or s.  Possible c in addition to u or s (for char?). 	offset = offset from high order bit to start bit of type. 	width is # bytes in object of this type, nbits is # bits in type.     The width/offset stuff appears to be for small objects stored in    larger ones (e.g. `shorts' in `int' registers).  We ignore it for now,    FIXME.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_sun_builtin_type
parameter_list|(
name|dhandle
parameter_list|,
name|pp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
name|bfd_vma
name|bits
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'s'
case|:
name|unsignedp
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unsignedp
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* For some odd reason, all forms of char put a c here.  This is strange      because no other type has this honor.  We can safely ignore this because      we actually determine 'char'acterness by the number of bits specified in      the descriptor.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'c'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* The first number appears to be the number of bytes occupied      by this type, except that unsigned short is 4 instead of 2.      Since this information is redundant with the third number,      we will ignore it.  */
operator|(
name|void
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* The second number is always 0, so ignore it too. */
operator|(
name|void
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* The third number is the number of bits for this type. */
name|bits
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* The type *should* end with a semicolon.  If it are embedded      in a larger type the semicolon may be the only way to know where      the type ends.  If this type is at the end of the stabstring we      can deal with the omitted semicolon (but we don't have to like      it).  Don't bother to complain(), Sun's compiler omits the semicolon      for "void".  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
return|return
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
return|;
return|return
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
name|bits
operator|/
literal|8
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a builtin floating type generated by the Sun compiler.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_sun_floating_type
parameter_list|(
name|dhandle
parameter_list|,
name|pp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|bfd_vma
name|details
decl_stmt|;
name|bfd_vma
name|bytes
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* The first number has more details about the type, for example      FN_COMPLEX.  */
name|details
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
comment|/* The second number is the number of bytes occupied by this type */
name|bytes
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|details
operator|==
name|NF_COMPLEX
operator|||
name|details
operator|==
name|NF_COMPLEX16
operator|||
name|details
operator|==
name|NF_COMPLEX32
condition|)
return|return
name|debug_make_complex_type
argument_list|(
name|dhandle
argument_list|,
name|bytes
argument_list|)
return|;
return|return
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
name|bytes
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle an enum type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_enum_type
parameter_list|(
name|dhandle
parameter_list|,
name|pp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|values
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* FIXME: gdb checks os9k_stabs here.  */
comment|/* The aix4 compiler emits an extra field before the enum members;      my guess is it's a type of some sort.  Just ignore it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
comment|/* Read the value-names and their values.      The input syntax is NAME:VALUE,NAME:VALUE, and so on.      A semicolon or comma instead of a NAME means the end.  */
name|alloc
operator|=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|values
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|values
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
operator|++
name|p
expr_stmt|;
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|val
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|names
operator|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|names
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
operator|)
expr_stmt|;
name|values
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|values
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|values
argument_list|)
operator|)
expr_stmt|;
block|}
name|names
index|[
name|n
index|]
operator|=
name|name
expr_stmt|;
name|values
index|[
name|n
index|]
operator|=
name|val
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
name|names
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
name|values
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
return|return
name|debug_make_enum_type
argument_list|(
name|dhandle
argument_list|,
name|names
argument_list|,
name|values
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the description of a structure (or union type) and return an object    describing the type.     PP points to a character pointer that points to the next unconsumed token    in the the stabs string.  For example, given stabs "A:T4=s4a:1,0,32;;",    *PP will point to "4a:1,0,32;;".  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_struct_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|tagname
parameter_list|,
name|pp
parameter_list|,
name|structp
parameter_list|,
name|typenums
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|tagname
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|debug_baseclass
modifier|*
name|baseclasses
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|boolean
name|statics
decl_stmt|;
name|debug_method
modifier|*
name|methods
decl_stmt|;
name|debug_type
name|vptrbase
decl_stmt|;
name|boolean
name|ownvptr
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Get the size.  */
name|size
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the other information.  */
if|if
condition|(
operator|!
name|parse_stab_baseclasses
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|baseclasses
argument_list|)
operator|||
operator|!
name|parse_stab_struct_fields
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
operator|&
name|fields
argument_list|,
operator|&
name|statics
argument_list|)
operator|||
operator|!
name|parse_stab_members
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|tagname
argument_list|,
name|pp
argument_list|,
name|typenums
argument_list|,
operator|&
name|methods
argument_list|)
operator|||
operator|!
name|parse_stab_tilde_field
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
name|typenums
argument_list|,
operator|&
name|vptrbase
argument_list|,
operator|&
name|ownvptr
argument_list|)
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|!
name|statics
operator|&&
name|baseclasses
operator|==
name|NULL
operator|&&
name|methods
operator|==
name|NULL
operator|&&
name|vptrbase
operator|==
name|DEBUG_TYPE_NULL
operator|&&
operator|!
name|ownvptr
condition|)
return|return
name|debug_make_struct_type
argument_list|(
name|dhandle
argument_list|,
name|structp
argument_list|,
name|size
argument_list|,
name|fields
argument_list|)
return|;
return|return
name|debug_make_object_type
argument_list|(
name|dhandle
argument_list|,
name|structp
argument_list|,
name|size
argument_list|,
name|fields
argument_list|,
name|baseclasses
argument_list|,
name|methods
argument_list|,
name|vptrbase
argument_list|,
name|ownvptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The stabs for C++ derived classes contain baseclass information which    is marked by a '!' character after the total size.  This function is    called when we encounter the baseclass marker, and slurps up all the    baseclass information.     Immediately following the '!' marker is the number of base classes that    the class is derived from, followed by information for each base class.    For each base class, there are two visibility specifiers, a bit offset    to the base class information within the derived class, a reference to    the type for the base class, and a terminating semicolon.     A typical example, with two base classes, would be "!2,020,19;0264,21;".    						       ^^ ^ ^ ^  ^ ^  ^ 	Baseclass information marker __________________|| | | |  | |  | 	Number of baseclasses __________________________| | | |  | |  | 	Visibility specifiers (2) ________________________| | |  | |  | 	Offset in bits from start of class _________________| |  | |  | 	Type number for base class ___________________________|  | |  | 	Visibility specifiers (2) _______________________________| |  | 	Offset in bits from start of class ________________________|  | 	Type number of base class ____________________________________|    Return true for success, false for failure.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_baseclasses
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|retp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_baseclass
modifier|*
modifier|*
name|retp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|debug_baseclass
modifier|*
name|classes
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'!'
condition|)
block|{
comment|/* No base classes.  */
return|return
name|true
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|int
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|classes
operator|=
operator|(
name|debug_baseclass
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|c
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|retp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|virtual
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|virtual
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|virtual
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unknown virtual character for baseclass"
argument_list|)
expr_stmt|;
name|virtual
operator|=
name|false
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PROTECTED
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unknown visibility character for baseclass"
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* The remaining value is the bit offset of the portion of the 	 object corresponding to this baseclass.  Always zero in the 	 absence of multiple inheritance.  */
name|bitpos
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
name|classes
index|[
name|i
index|]
operator|=
name|debug_make_baseclass
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|,
name|bitpos
argument_list|,
name|virtual
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|DEBUG_BASECLASS_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
return|return
name|false
return|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
name|classes
index|[
name|i
index|]
operator|=
name|DEBUG_BASECLASS_NULL
expr_stmt|;
operator|*
name|retp
operator|=
name|classes
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read struct or class data fields.  They have the form:     	NAME : [VISIBILITY] TYPENUM , BITPOS , BITSIZE ;     At the end, we see a semicolon instead of a field.     In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for    a static field.     The optional VISIBILITY is one of:     	'/0'	(VISIBILITY_PRIVATE) 	'/1'	(VISIBILITY_PROTECTED) 	'/2'	(VISIBILITY_PUBLIC) 	'/9'	(VISIBILITY_IGNORE)     or nothing, for C style fields with public visibility.     Returns 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_struct_fields
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|retp
parameter_list|,
name|staticsp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_field
modifier|*
modifier|*
name|retp
decl_stmt|;
name|boolean
modifier|*
name|staticsp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
operator|*
name|staticsp
operator|=
name|false
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|alloc
operator|=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
comment|/* FIXME: gdb checks os9k_stabs here.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* Add 1 to c to leave room for NULL pointer at end.  */
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|fields
operator|=
operator|(
operator|(
name|debug_field
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|fields
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|fields
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* If it starts with CPLUS_MARKER it is a special abbreviation, 	 unless the CPLUS_MARKER is followed by an underscore, in 	 which case it is just the name of an anonymous type, which we 	 should handle like any other type name.  We accept either '$' 	 or '.', because a field name can never contain one of these 	 characters except as a CPLUS_MARKER.  */
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'$'
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
block|{
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|parse_stab_cpp_abbrev
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
name|fields
operator|+
name|c
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* Look for the ':' that separates the field name from the field 	 values.  Data members are delimited by a single ':', while member 	 functions are delimited by a pair of ':'s.  When we hit the member 	 functions (if any), terminate scan loop and return. */
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
break|break;
if|if
condition|(
operator|!
name|parse_stab_one_struct_field
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|pp
argument_list|,
name|p
argument_list|,
name|fields
operator|+
name|c
argument_list|,
name|staticsp
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|c
expr_stmt|;
block|}
name|fields
index|[
name|c
index|]
operator|=
name|DEBUG_FIELD_NULL
expr_stmt|;
operator|*
name|retp
operator|=
name|fields
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Special GNU C++ name.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_cpp_abbrev
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|retp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_field
modifier|*
name|retp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|int
name|cpp_abbrev
decl_stmt|;
name|debug_type
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|typename
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
operator|*
name|retp
operator|=
name|DEBUG_FIELD_NULL
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'v'
condition|)
block|{
name|bad_stab
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|cpp_abbrev
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* At this point, *pp points to something like "22:23=*22...", where      the type number before the ':' is the "context" and everything      after is a regular type definition.  Lookup the type, find it's      name, and construct the field name.  */
name|context
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|cpp_abbrev
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* $vf -- a virtual function table pointer.  */
name|name
operator|=
literal|"_vptr$"
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* $vb -- a virtual bsomethingorother */
name|typename
operator|=
name|debug_get_type_name
argument_list|(
name|dhandle
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unnamed $vb type"
argument_list|)
expr_stmt|;
name|typename
operator|=
literal|"FOO"
expr_stmt|;
block|}
name|name
operator|=
name|concat
argument_list|(
literal|"_vb$"
argument_list|,
name|typename
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unrecognized C++ abbreviation"
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"INVALID_CPLUSPLUS_ABBREV"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|bitpos
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
operator|*
name|retp
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|bitpos
argument_list|,
literal|0
argument_list|,
name|DEBUG_VISIBILITY_PRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|retp
operator|==
name|DEBUG_FIELD_NULL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a single field in a struct or union.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_one_struct_field
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|p
parameter_list|,
name|retp
parameter_list|,
name|staticsp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|debug_field
modifier|*
name|retp
decl_stmt|;
name|boolean
modifier|*
name|staticsp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|bfd_vma
name|bitsize
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* FIXME: gdb checks ARM_DEMANGLING here.  */
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'/'
condition|)
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
else|else
block|{
operator|++
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PROTECTED
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"unknown visibility character for field"
argument_list|)
expr_stmt|;
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
block|}
name|type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|varname
decl_stmt|;
comment|/* This is a static class member.  */
operator|++
operator|*
name|pp
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|varname
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|retp
operator|=
name|debug_make_static_member
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|varname
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
operator|*
name|staticsp
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|bitpos
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|bitsize
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|bitpos
operator|==
literal|0
operator|&&
name|bitsize
operator|==
literal|0
condition|)
block|{
comment|/* This can happen in two cases: (1) at least for gcc 2.4.5 or 	 so, it is a field which has been optimized out.  The correct 	 stab for this case is to use VISIBILITY_IGNORE, but that is a 	 recent invention.  (2) It is a 0-size array.  For example 	 union { int num; char str[0]; } foo.  Printing "<no value>" 	 for str in "p foo" is OK, since foo.str (and thus foo.str[3]) 	 will continue to work, and a 0-size array as a whole doesn't 	 have any contents to print.  	 I suspect this probably could also happen with gcc -gstabs 	 (not -gstabs+) for static fields, and perhaps other C++ 	 extensions.  Hopefully few people use -gstabs with gdb, since 	 it is intended for dbx compatibility.  */
name|visibility
operator|=
name|DEBUG_VISIBILITY_IGNORE
expr_stmt|;
block|}
comment|/* FIXME: gdb does some stuff here to mark fields as unpacked.  */
operator|*
name|retp
operator|=
name|debug_make_field
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|visibility
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read member function stabs info for C++ classes.  The form of each member    function data is:  	NAME :: TYPENUM[=type definition] ARGS : PHYSNAME ;     An example with two member functions is:  	afunc1::20=##15;:i;2A.;afunc2::20:i;2A.;     For the case of overloaded operators, the format is op$::*.funcs, where    $ is the CPLUS_MARKER (usually '$'), `*' holds the place for an operator    name (such as `+=') and `.' marks the end of the operator name.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_members
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|tagname
parameter_list|,
name|pp
parameter_list|,
name|typenums
parameter_list|,
name|retp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|tagname
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
name|debug_method
modifier|*
modifier|*
name|retp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|debug_method
modifier|*
name|methods
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|alloc
operator|=
literal|0
expr_stmt|;
name|methods
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|debug_method_variant
modifier|*
name|variants
decl_stmt|;
name|unsigned
name|int
name|cvars
decl_stmt|;
name|unsigned
name|int
name|allocvars
decl_stmt|;
name|debug_type
name|look_ahead_type
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
break|break;
comment|/* FIXME: Some systems use something other than '$' here.  */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|!=
literal|'o'
operator|||
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|!=
literal|'p'
operator|||
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
operator|!=
literal|'$'
condition|)
block|{
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a completely wierd case.  In order to stuff in the 	     names that might contain colons (the usual name delimiter), 	     Mike Tiemann defined a different name format which is 	     signalled if the identifier is "op$".  In that case, the 	     format is "op$::XXXX." where XXXX is the name.  This is 	     used for names like "+" or "=".  YUUUUUUUK!  FIXME!  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
name|allocvars
operator|=
literal|10
expr_stmt|;
name|variants
operator|=
operator|(
operator|(
name|debug_method_variant
operator|*
operator|)
name|xmalloc
argument_list|(
name|allocvars
operator|*
sizeof|sizeof
expr|*
name|variants
argument_list|)
operator|)
expr_stmt|;
name|cvars
operator|=
literal|0
expr_stmt|;
name|look_ahead_type
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
do|do
block|{
name|debug_type
name|type
decl_stmt|;
name|boolean
name|stub
decl_stmt|;
name|char
modifier|*
name|argtypes
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|,
name|volatilep
decl_stmt|,
name|staticp
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|debug_type
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
if|if
condition|(
name|look_ahead_type
operator|!=
name|DEBUG_TYPE_NULL
condition|)
block|{
comment|/* g++ version 1 kludge */
name|type
operator|=
name|look_ahead_type
expr_stmt|;
name|look_ahead_type
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|stub
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|debug_get_type_kind
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|)
operator|==
name|DEBUG_KIND_METHOD
operator|&&
name|debug_get_parameter_types
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|,
operator|&
name|varargs
argument_list|)
operator|==
name|NULL
condition|)
name|stub
operator|=
name|true
expr_stmt|;
name|argtypes
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PRIVATE
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PROTECTED
expr_stmt|;
break|break;
default|default:
name|visibility
operator|=
name|DEBUG_VISIBILITY_PUBLIC
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|constp
operator|=
name|false
expr_stmt|;
name|volatilep
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Normal function.  */
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* const member function.  */
name|constp
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* volatile member function.  */
name|volatilep
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* const volatile member function.  */
name|constp
operator|=
name|true
expr_stmt|;
name|volatilep
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'.'
case|:
comment|/* File compiled with g++ version 1; no information.  */
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"const/volatile indicator missing"
argument_list|)
expr_stmt|;
break|break;
block|}
name|staticp
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* virtual member function, followed by index.  The sign 		 bit is supposedly set to distinguish 		 pointers-to-methods from virtual function indicies.  */
operator|++
operator|*
name|pp
expr_stmt|;
name|voffset
operator|=
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|voffset
operator|&=
literal|0x7fffffff
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
operator|||
operator|*
name|pp
operator|==
literal|'\0'
condition|)
block|{
comment|/* Must be g++ version 1.  */
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Figure out from whence this virtual function 		     came.  It may belong to virtual function table of 		     one of its baseclasses.  */
name|look_ahead_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
comment|/* g++ version 1 overloaded methods.  */
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
block|}
else|else
block|{
name|context
operator|=
name|look_ahead_type
expr_stmt|;
name|look_ahead_type
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'?'
case|:
comment|/* static member function.  */
operator|++
operator|*
name|pp
expr_stmt|;
name|staticp
operator|=
name|true
expr_stmt|;
name|voffset
operator|=
literal|0
expr_stmt|;
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|argtypes
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|stub
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|warn_stab
argument_list|(
name|orig
argument_list|,
literal|"member function type missing"
argument_list|)
expr_stmt|;
name|voffset
operator|=
literal|0
expr_stmt|;
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
operator|++
operator|*
name|pp
expr_stmt|;
name|voffset
operator|=
literal|0
expr_stmt|;
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
break|break;
block|}
comment|/* If the type is not a stub, then the argtypes string is              the physical name of the function.  Otherwise the              argtypes string is the mangled form of the argument              types, and the full type and the physical name must be              extracted from them.  */
if|if
condition|(
operator|!
name|stub
condition|)
name|physname
operator|=
name|argtypes
expr_stmt|;
else|else
block|{
name|debug_type
name|class_type
decl_stmt|,
name|return_type
decl_stmt|;
name|class_type
operator|=
name|stab_find_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
name|return_type
operator|=
name|debug_get_return_type
argument_list|(
name|dhandle
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|type
operator|=
name|parse_stab_argtypes
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|class_type
argument_list|,
name|name
argument_list|,
name|tagname
argument_list|,
name|return_type
argument_list|,
name|argtypes
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
operator|&
name|physname
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|cvars
operator|+
literal|1
operator|>=
name|allocvars
condition|)
block|{
name|allocvars
operator|+=
literal|10
expr_stmt|;
name|variants
operator|=
operator|(
operator|(
name|debug_method_variant
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|variants
argument_list|,
name|allocvars
operator|*
sizeof|sizeof
expr|*
name|variants
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|staticp
condition|)
name|variants
index|[
name|cvars
index|]
operator|=
name|debug_make_method_variant
argument_list|(
name|dhandle
argument_list|,
name|physname
argument_list|,
name|type
argument_list|,
name|visibility
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|,
name|voffset
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|variants
index|[
name|cvars
index|]
operator|=
name|debug_make_static_method_variant
argument_list|(
name|dhandle
argument_list|,
name|physname
argument_list|,
name|type
argument_list|,
name|visibility
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|variants
index|[
name|cvars
index|]
operator|==
name|DEBUG_METHOD_VARIANT_NULL
condition|)
return|return
name|false
return|;
operator|++
name|cvars
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
do|;
name|variants
index|[
name|cvars
index|]
operator|=
name|DEBUG_METHOD_VARIANT_NULL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|c
operator|+
literal|1
operator|>=
name|alloc
condition|)
block|{
name|alloc
operator|+=
literal|10
expr_stmt|;
name|methods
operator|=
operator|(
operator|(
name|debug_method
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|methods
argument_list|,
name|alloc
operator|*
sizeof|sizeof
expr|*
name|methods
argument_list|)
operator|)
expr_stmt|;
block|}
name|methods
index|[
name|c
index|]
operator|=
name|debug_make_method
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|variants
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|!=
name|NULL
condition|)
name|methods
index|[
name|c
index|]
operator|=
name|DEBUG_METHOD_NULL
expr_stmt|;
operator|*
name|retp
operator|=
name|methods
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Parse a string representing argument types for a method.  Stabs    tries to save space by packing argument types into a mangled    string.  This string should give us enough information to extract    both argument types and the physical name of the function, given    the tag name.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_argtypes
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|class_type
parameter_list|,
name|fieldname
parameter_list|,
name|tagname
parameter_list|,
name|return_type
parameter_list|,
name|argtypes
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|pphysname
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
name|debug_type
name|class_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|fieldname
decl_stmt|;
specifier|const
name|char
modifier|*
name|tagname
decl_stmt|;
name|debug_type
name|return_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|argtypes
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pphysname
decl_stmt|;
block|{
name|boolean
name|is_full_physname_constructor
decl_stmt|;
name|boolean
name|is_constructor
decl_stmt|;
name|boolean
name|is_destructor
decl_stmt|;
name|debug_type
modifier|*
name|args
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
comment|/* Constructors are sometimes handled specially.  */
name|is_full_physname_constructor
operator|=
operator|(
operator|(
name|argtypes
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|argtypes
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|argtypes
index|[
literal|2
index|]
argument_list|)
operator|||
name|argtypes
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|||
name|argtypes
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|)
operator|||
name|strncmp
argument_list|(
name|argtypes
argument_list|,
literal|"__ct"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|is_constructor
operator|=
operator|(
name|is_full_physname_constructor
operator|||
operator|(
name|tagname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|fieldname
argument_list|,
name|tagname
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|is_destructor
operator|=
operator|(
operator|(
name|argtypes
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|argtypes
index|[
literal|1
index|]
operator|==
literal|'$'
operator|||
name|argtypes
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|argtypes
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
operator|||
name|strncmp
argument_list|(
name|argtypes
argument_list|,
literal|"__dt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_destructor
operator|||
name|is_full_physname_constructor
condition|)
operator|*
name|pphysname
operator|=
name|argtypes
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|const_prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|volatile_prefix
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|int
name|mangled_name_len
decl_stmt|;
name|char
modifier|*
name|physname
decl_stmt|;
name|len
operator|=
name|tagname
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|tagname
argument_list|)
expr_stmt|;
name|const_prefix
operator|=
name|constp
condition|?
literal|"C"
else|:
literal|""
expr_stmt|;
name|volatile_prefix
operator|=
name|volatilep
condition|?
literal|"V"
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tagname
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|tagname
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Template methods are fully mangled.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|)
expr_stmt|;
name|tagname
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s%s%d"
argument_list|,
name|const_prefix
argument_list|,
name|volatile_prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mangled_name_len
operator|=
operator|(
operator|(
name|is_constructor
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|fieldname
argument_list|)
operator|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|len
operator|+
name|strlen
argument_list|(
name|argtypes
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fieldname
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|fieldname
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
operator|(
name|fieldname
index|[
literal|2
index|]
operator|==
literal|'$'
operator|||
name|fieldname
index|[
literal|2
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|opname
operator|=
name|cplus_mangle_opname
argument_list|(
name|fieldname
operator|+
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opname
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No mangling for \"%s\"\n"
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|mangled_name_len
operator|+=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|physname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|physname
argument_list|,
name|fieldname
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|physname
operator|+
literal|3
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|physname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|mangled_name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_constructor
condition|)
name|physname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|physname
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|physname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tagname
operator|!=
name|NULL
condition|)
name|strcat
argument_list|(
name|physname
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|physname
argument_list|,
name|argtypes
argument_list|)
expr_stmt|;
operator|*
name|pphysname
operator|=
name|physname
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argtypes
operator|==
literal|'\0'
condition|)
block|{
name|args
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|args
argument_list|)
expr_stmt|;
operator|*
name|args
operator|=
name|NULL
expr_stmt|;
return|return
name|debug_make_method_type
argument_list|(
name|dhandle
argument_list|,
name|return_type
argument_list|,
name|class_type
argument_list|,
name|args
argument_list|,
name|false
argument_list|)
return|;
block|}
name|args
operator|=
name|stab_demangle_argtypes
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|*
name|pphysname
argument_list|,
operator|&
name|varargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
return|return
name|debug_make_method_type
argument_list|(
name|dhandle
argument_list|,
name|return_type
argument_list|,
name|class_type
argument_list|,
name|args
argument_list|,
name|varargs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The tail end of stabs for C++ classes that contain a virtual function    pointer contains a tilde, a %, and a type number.    The type number refers to the base class (possibly this class itself) which    contains the vtable pointer for the current class.     This function is called when we have parsed all the method declarations,    so we can look for the vptr base class info.  */
end_comment

begin_function
specifier|static
name|boolean
name|parse_stab_tilde_field
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|typenums
parameter_list|,
name|retvptrbase
parameter_list|,
name|retownvptr
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
name|debug_type
modifier|*
name|retvptrbase
decl_stmt|;
name|boolean
modifier|*
name|retownvptr
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
name|int
name|vtypenums
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|retvptrbase
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
operator|*
name|retownvptr
operator|=
name|false
expr_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* If we are positioned at a ';', then skip it. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'~'
condition|)
return|return
name|true
return|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'+'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
comment|/* Obsolete flags that used to indicate the presence of 	 constructors and/or destructors. */
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'%'
condition|)
return|return
name|true
return|;
operator|++
operator|*
name|pp
expr_stmt|;
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* The next number is the type number of the base class (possibly      our own class) which supplies the vtable for this class.  */
if|if
condition|(
operator|!
name|parse_stab_type_number
argument_list|(
name|pp
argument_list|,
name|vtypenums
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vtypenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|vtypenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
condition|)
operator|*
name|retownvptr
operator|=
name|true
expr_stmt|;
else|else
block|{
name|debug_type
name|vtype
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
operator|*
name|pp
operator|=
name|hold
expr_stmt|;
name|vtype
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|retvptrbase
operator|=
name|vtype
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an array type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|parse_stab_array_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|pp
parameter_list|,
name|stringp
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|boolean
name|stringp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|debug_type
name|index_type
decl_stmt|;
name|boolean
name|adjustable
decl_stmt|;
name|bfd_signed_vma
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|debug_type
name|element_type
decl_stmt|;
comment|/* Format of an array type:      "ar<index type>;lower;upper;<array_contents_type>".      OS9000: "arlower,upper;<array_contents_type>".       Fortran adjustable arrays use Adigits or Tdigits for lower or upper;      for these, produce a type like float[][].  */
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* FIXME: gdb checks os9k_stabs here.  */
comment|/* If the index type is type 0, we take it as int.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|parse_stab_type_number
argument_list|(
operator|&
name|p
argument_list|,
name|typenums
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|typenums
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
block|{
name|index_type
operator|=
name|debug_find_named_type
argument_list|(
name|dhandle
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
name|index_type
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|index_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|adjustable
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|++
operator|*
name|pp
expr_stmt|;
name|adjustable
operator|=
name|true
expr_stmt|;
block|}
name|lower
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
operator|++
operator|*
name|pp
expr_stmt|;
name|adjustable
operator|=
name|true
expr_stmt|;
block|}
name|upper
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|parse_number
argument_list|(
name|pp
argument_list|,
operator|(
name|boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|bad_stab
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
name|element_type
operator|=
name|parse_stab_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|element_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|adjustable
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|debug_make_array_type
argument_list|(
name|dhandle
argument_list|,
name|element_type
argument_list|,
name|index_type
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|stringp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This struct holds information about files we have seen using    N_BINCL.  */
end_comment

begin_struct
struct|struct
name|bincl_file
block|{
comment|/* The next N_BINCL file.  */
name|struct
name|bincl_file
modifier|*
name|next
decl_stmt|;
comment|/* The next N_BINCL on the stack.  */
name|struct
name|bincl_file
modifier|*
name|next_stack
decl_stmt|;
comment|/* The file name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The hash value.  */
name|bfd_vma
name|hash
decl_stmt|;
comment|/* The file index.  */
name|unsigned
name|int
name|file
decl_stmt|;
comment|/* The list of types defined in this file.  */
name|struct
name|stab_types
modifier|*
name|file_types
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Start a new N_BINCL file, pushing it onto the stack.  */
end_comment

begin_function
specifier|static
name|void
name|push_bincl
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|hash
parameter_list|)
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|hash
decl_stmt|;
block|{
name|struct
name|bincl_file
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|bincl_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|info
operator|->
name|bincl_list
expr_stmt|;
name|n
operator|->
name|next_stack
operator|=
name|info
operator|->
name|bincl_stack
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
name|n
operator|->
name|file
operator|=
name|info
operator|->
name|files
expr_stmt|;
name|n
operator|->
name|file_types
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|bincl_list
operator|=
name|n
expr_stmt|;
name|info
operator|->
name|bincl_stack
operator|=
name|n
expr_stmt|;
operator|++
name|info
operator|->
name|files
expr_stmt|;
name|info
operator|->
name|file_types
operator|=
operator|(
operator|(
expr|struct
name|stab_types
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|info
operator|->
name|file_types
argument_list|,
operator|(
name|info
operator|->
name|files
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|file_types
operator|)
argument_list|)
operator|)
expr_stmt|;
name|info
operator|->
name|file_types
index|[
name|n
operator|->
name|file
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an N_BINCL file, at an N_EINCL, popping the name off the    stack.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pop_bincl
parameter_list|(
name|info
parameter_list|)
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|bincl_file
modifier|*
name|o
decl_stmt|;
name|o
operator|=
name|info
operator|->
name|bincl_stack
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
return|return
name|info
operator|->
name|main_filename
return|;
name|info
operator|->
name|bincl_stack
operator|=
name|o
operator|->
name|next_stack
expr_stmt|;
name|o
operator|->
name|file_types
operator|=
name|info
operator|->
name|file_types
index|[
name|o
operator|->
name|file
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bincl_stack
operator|==
name|NULL
condition|)
return|return
name|info
operator|->
name|main_filename
return|;
return|return
name|info
operator|->
name|bincl_stack
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Handle an N_EXCL: get the types from the corresponding N_BINCL.  */
end_comment

begin_function
specifier|static
name|boolean
name|find_excl
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|hash
parameter_list|)
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|hash
decl_stmt|;
block|{
name|struct
name|bincl_file
modifier|*
name|l
decl_stmt|;
operator|++
name|info
operator|->
name|files
expr_stmt|;
name|info
operator|->
name|file_types
operator|=
operator|(
operator|(
expr|struct
name|stab_types
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|PTR
operator|)
name|info
operator|->
name|file_types
argument_list|,
operator|(
name|info
operator|->
name|files
operator|*
sizeof|sizeof
expr|*
name|info
operator|->
name|file_types
operator|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|info
operator|->
name|bincl_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|l
operator|->
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|l
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
block|{
name|warn_stab
argument_list|(
name|name
argument_list|,
literal|"Undefined N_EXCL"
argument_list|)
expr_stmt|;
name|info
operator|->
name|file_types
index|[
name|info
operator|->
name|files
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
name|info
operator|->
name|file_types
index|[
name|info
operator|->
name|files
operator|-
literal|1
index|]
operator|=
name|l
operator|->
name|file_types
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a variable definition.  gcc emits variable definitions for a    block before the N_LBRAC, so we must hold onto them until we see    it.  The SunPRO compiler emits variable definitions after the    N_LBRAC, so we can call debug_record_variable immediately.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_record_variable
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|stab_pending_var
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|kind
operator|==
name|DEBUG_GLOBAL
operator|||
name|kind
operator|==
name|DEBUG_STATIC
operator|)
operator|||
operator|!
name|info
operator|->
name|within_function
operator|||
operator|(
name|info
operator|->
name|gcc_compiled
operator|==
literal|0
operator|&&
name|info
operator|->
name|n_opt_found
operator|)
condition|)
return|return
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|kind
argument_list|,
name|val
argument_list|)
return|;
name|v
operator|=
operator|(
expr|struct
name|stab_pending_var
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|v
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|next
operator|=
name|info
operator|->
name|pending
expr_stmt|;
name|v
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|info
operator|->
name|pending
operator|=
name|v
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Emit pending variable definitions.  This is called after we see the    N_LBRAC that starts the block.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_emit_pending_vars
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|stab_pending_var
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|info
operator|->
name|pending
expr_stmt|;
while|while
condition|(
name|v
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stab_pending_var
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|debug_record_variable
argument_list|(
name|dhandle
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|type
argument_list|,
name|v
operator|->
name|kind
argument_list|,
name|v
operator|->
name|val
argument_list|)
condition|)
return|return
name|false
return|;
name|next
operator|=
name|v
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|next
expr_stmt|;
block|}
name|info
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find the slot for a type in the database.  */
end_comment

begin_function
specifier|static
name|debug_type
modifier|*
name|stab_find_slot
parameter_list|(
name|info
parameter_list|,
name|typenums
parameter_list|)
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
name|int
name|filenum
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|stab_types
modifier|*
modifier|*
name|ps
decl_stmt|;
name|filenum
operator|=
name|typenums
index|[
literal|0
index|]
expr_stmt|;
name|index
operator|=
name|typenums
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|filenum
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|int
operator|)
name|filenum
operator|>=
name|info
operator|->
name|files
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type file number %d out of range\n"
argument_list|,
name|filenum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type index number %d out of range\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ps
operator|=
name|info
operator|->
name|file_types
operator|+
name|filenum
expr_stmt|;
while|while
condition|(
name|index
operator|>=
name|STAB_TYPES_SLOTS
condition|)
block|{
if|if
condition|(
operator|*
name|ps
operator|==
name|NULL
condition|)
block|{
operator|*
name|ps
operator|=
operator|(
expr|struct
name|stab_types
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|ps
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|ps
argument_list|)
expr_stmt|;
block|}
name|ps
operator|=
operator|&
operator|(
operator|*
name|ps
operator|)
operator|->
name|next
expr_stmt|;
name|index
operator|-=
name|STAB_TYPES_SLOTS
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ps
operator|==
name|NULL
condition|)
block|{
operator|*
name|ps
operator|=
operator|(
expr|struct
name|stab_types
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|ps
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|*
name|ps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|ps
operator|)
operator|->
name|types
operator|+
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a type given a type number.  If the type has not been    allocated yet, create an indirect type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|stab_find_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|typenums
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
name|debug_type
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|typenums
index|[
literal|1
index|]
operator|<
literal|0
condition|)
block|{
comment|/* A negative type number indicates an XCOFF builtin type.  */
return|return
name|stab_xcoff_builtin_type
argument_list|(
name|dhandle
argument_list|,
name|info
argument_list|,
name|typenums
index|[
literal|1
index|]
argument_list|)
return|;
block|}
name|slot
operator|=
name|stab_find_slot
argument_list|(
name|info
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
operator|*
name|slot
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
name|slot
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
return|return
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Record that a given type number refers to a given type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_record_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|typenums
parameter_list|,
name|type
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|int
modifier|*
name|typenums
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|debug_type
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|stab_find_slot
argument_list|(
name|info
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return
name|false
return|;
comment|/* gdb appears to ignore type redefinitions, so we do as well.  */
operator|*
name|slot
operator|=
name|type
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return an XCOFF builtin type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|stab_xcoff_builtin_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|typenum
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
name|int
name|typenum
decl_stmt|;
block|{
name|debug_type
name|rettype
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|typenum
operator|>=
literal|0
operator|||
name|typenum
operator|<
operator|-
name|XCOFF_TYPE_COUNT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized XCOFF type %d\n"
argument_list|,
name|typenum
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|info
operator|->
name|xcoff_types
index|[
operator|-
name|typenum
index|]
operator|!=
name|NULL
condition|)
return|return
name|info
operator|->
name|xcoff_types
index|[
operator|-
name|typenum
index|]
return|;
switch|switch
condition|(
operator|-
name|typenum
condition|)
block|{
case|case
literal|1
case|:
comment|/* The size of this and all the other types are fixed, defined 	 by the debugging format.  */
name|name
operator|=
literal|"int"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|name
operator|=
literal|"char"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|name
operator|=
literal|"short"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|name
operator|=
literal|"long"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|name
operator|=
literal|"unsigned char"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|name
operator|=
literal|"signed char"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|name
operator|=
literal|"unsigned short"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|name
operator|=
literal|"unsigned int"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|name
operator|=
literal|"unsigned"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
name|name
operator|=
literal|"unsigned long"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|name
operator|=
literal|"void"
expr_stmt|;
name|rettype
operator|=
name|debug_make_void_type
argument_list|(
name|dhandle
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* IEEE single precision (32 bit).  */
name|name
operator|=
literal|"float"
expr_stmt|;
name|rettype
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* IEEE double precision (64 bit).  */
name|name
operator|=
literal|"double"
expr_stmt|;
name|rettype
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* This is an IEEE double on the RS/6000, and different machines 	 with different sizes for "long double" should use different 	 negative type numbers.  See stabs.texinfo.  */
name|name
operator|=
literal|"long double"
expr_stmt|;
name|rettype
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|name
operator|=
literal|"integer"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|name
operator|=
literal|"boolean"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|name
operator|=
literal|"short real"
expr_stmt|;
name|rettype
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|name
operator|=
literal|"real"
expr_stmt|;
name|rettype
operator|=
name|debug_make_float_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
comment|/* FIXME */
name|name
operator|=
literal|"stringptr"
expr_stmt|;
name|rettype
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|20
case|:
comment|/* FIXME */
name|name
operator|=
literal|"character"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|21
case|:
name|name
operator|=
literal|"logical*1"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|name
operator|=
literal|"logical*2"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|23
case|:
name|name
operator|=
literal|"logical*4"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|name
operator|=
literal|"logical"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|25
case|:
comment|/* Complex type consisting of two IEEE single precision values.  */
name|name
operator|=
literal|"complex"
expr_stmt|;
name|rettype
operator|=
name|debug_make_complex_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|26
case|:
comment|/* Complex type consisting of two IEEE double precision values.  */
name|name
operator|=
literal|"double complex"
expr_stmt|;
name|rettype
operator|=
name|debug_make_complex_type
argument_list|(
name|dhandle
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|27
case|:
name|name
operator|=
literal|"integer*1"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|1
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|28
case|:
name|name
operator|=
literal|"integer*2"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|29
case|:
name|name
operator|=
literal|"integer*4"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
comment|/* FIXME */
name|name
operator|=
literal|"wchar"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|2
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|31
case|:
name|name
operator|=
literal|"long long"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|name
operator|=
literal|"unsigned long long"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|name
operator|=
literal|"logical*8"
expr_stmt|;
name|rettype
operator|=
name|debug_make_bool_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|34
case|:
name|name
operator|=
literal|"integer*8"
expr_stmt|;
name|rettype
operator|=
name|debug_make_int_type
argument_list|(
name|dhandle
argument_list|,
literal|8
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|rettype
operator|=
name|debug_name_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|rettype
argument_list|)
expr_stmt|;
name|info
operator|->
name|xcoff_types
index|[
operator|-
name|typenum
index|]
operator|=
name|rettype
expr_stmt|;
return|return
name|rettype
return|;
block|}
end_function

begin_comment
comment|/* Find or create a tagged type.  */
end_comment

begin_function
specifier|static
name|debug_type
name|stab_find_tagged_type
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|,
name|kind
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|dtype
decl_stmt|;
name|struct
name|stab_tag
modifier|*
name|st
decl_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* We pass DEBUG_KIND_ILLEGAL because we want all tags in the same      namespace.  This is right for C, and I don't know how to handle      other languages.  FIXME.  */
name|dtype
operator|=
name|debug_find_tagged_type
argument_list|(
name|dhandle
argument_list|,
name|name
argument_list|,
name|DEBUG_KIND_ILLEGAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|DEBUG_TYPE_NULL
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|dtype
return|;
block|}
comment|/* We need to allocate an entry on the undefined tag list.  */
for|for
control|(
name|st
operator|=
name|info
operator|->
name|tags
init|;
name|st
operator|!=
name|NULL
condition|;
name|st
operator|=
name|st
operator|->
name|next
control|)
block|{
if|if
condition|(
name|st
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|st
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
condition|)
name|st
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
name|st
operator|=
operator|(
expr|struct
name|stab_tag
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|next
operator|=
name|info
operator|->
name|tags
expr_stmt|;
name|st
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|st
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|st
operator|->
name|slot
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
name|st
operator|->
name|type
operator|=
name|debug_make_indirect_type
argument_list|(
name|dhandle
argument_list|,
operator|&
name|st
operator|->
name|slot
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|tags
operator|=
name|st
expr_stmt|;
block|}
return|return
name|st
operator|->
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In order to get the correct argument types for a stubbed method, we    need to extract the argument types from a C++ mangled string.    Since the argument types can refer back to the return type, this    means that we must demangle the entire physical name.  In gdb this    is done by calling cplus_demangle and running the results back    through the C++ expression parser.  Since we have no expression    parser, we must duplicate much of the work of cplus_demangle here.     We assume that GNU style demangling is used, since this is only    done for method stubs, and only g++ should output that form of    debugging information.  */
end_comment

begin_comment
comment|/* This structure is used to hold a pointer to type information which    demangling a string.  */
end_comment

begin_struct
struct|struct
name|stab_demangle_typestring
block|{
comment|/* The start of the type.  This is not null terminated.  */
specifier|const
name|char
modifier|*
name|typestring
decl_stmt|;
comment|/* The length of the type.  */
name|unsigned
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold information while demangling a    string.  */
end_comment

begin_struct
struct|struct
name|stab_demangle_info
block|{
comment|/* The debugging information handle.  */
name|PTR
name|dhandle
decl_stmt|;
comment|/* The stab information handle.  */
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
comment|/* The array of arguments we are building.  */
name|debug_type
modifier|*
name|args
decl_stmt|;
comment|/* Whether the method takes a variable number of arguments.  */
name|boolean
name|varargs
decl_stmt|;
comment|/* The array of types we have remembered.  */
name|struct
name|stab_demangle_typestring
modifier|*
name|typestrings
decl_stmt|;
comment|/* The number of typestrings.  */
name|unsigned
name|int
name|typestring_count
decl_stmt|;
comment|/* The number of typestring slots we have allocated.  */
name|unsigned
name|int
name|typestring_alloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|stab_bad_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|stab_demangle_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_get_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_function_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_signature
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_qualified
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_class
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_fund_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|stab_demangle_remember_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stab_demangle_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about a bad demangling.  */
end_comment

begin_function
specifier|static
name|void
name|stab_bad_demangle
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad mangled name `%s'\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a count from a stab string.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|stab_demangle_count
parameter_list|(
name|pp
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
operator|*
operator|*
name|pp
operator|-
literal|'0'
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Require a count in a string.  The count may be multiple digits, in    which case it must end in an underscore.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_get_count
parameter_list|(
name|pp
parameter_list|,
name|pi
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pi
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pi
operator|=
operator|*
operator|*
name|pp
operator|-
literal|'0'
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|count
operator|=
operator|*
name|pi
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
do|do
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|pi
operator|=
name|count
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This function demangles a physical name, returning a NULL    terminated array of argument types.  */
end_comment

begin_function
specifier|static
name|debug_type
modifier|*
name|stab_demangle_argtypes
parameter_list|(
name|dhandle
parameter_list|,
name|info
parameter_list|,
name|physname
parameter_list|,
name|pvarargs
parameter_list|)
name|PTR
name|dhandle
decl_stmt|;
name|struct
name|stab_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|boolean
modifier|*
name|pvarargs
decl_stmt|;
block|{
name|struct
name|stab_demangle_info
name|minfo
decl_stmt|;
name|minfo
operator|.
name|dhandle
operator|=
name|dhandle
expr_stmt|;
name|minfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|minfo
operator|.
name|args
operator|=
name|NULL
expr_stmt|;
name|minfo
operator|.
name|varargs
operator|=
name|false
expr_stmt|;
name|minfo
operator|.
name|typestring_alloc
operator|=
literal|10
expr_stmt|;
name|minfo
operator|.
name|typestrings
operator|=
operator|(
operator|(
expr|struct
name|stab_demangle_typestring
operator|*
operator|)
name|xmalloc
argument_list|(
name|minfo
operator|.
name|typestring_alloc
operator|*
sizeof|sizeof
expr|*
name|minfo
operator|.
name|typestrings
argument_list|)
operator|)
expr_stmt|;
name|minfo
operator|.
name|typestring_count
operator|=
literal|0
expr_stmt|;
comment|/* cplus_demangle checks for special GNU mangled forms, but we can't      see any of them in mangled method argument types.  */
if|if
condition|(
operator|!
name|stab_demangle_prefix
argument_list|(
operator|&
name|minfo
argument_list|,
operator|&
name|physname
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|*
name|physname
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|stab_demangle_signature
argument_list|(
operator|&
name|minfo
argument_list|,
operator|&
name|physname
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|minfo
operator|.
name|typestrings
argument_list|)
expr_stmt|;
name|minfo
operator|.
name|typestrings
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minfo
operator|.
name|args
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no argument types in mangled string\n"
argument_list|)
expr_stmt|;
operator|*
name|pvarargs
operator|=
name|minfo
operator|.
name|varargs
expr_stmt|;
return|return
name|minfo
operator|.
name|args
return|;
name|error_return
label|:
if|if
condition|(
name|minfo
operator|.
name|typestrings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|minfo
operator|.
name|typestrings
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Demangle the prefix of the mangled name.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_prefix
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* cplus_demangle checks for global constructors and destructors,      but we can't see them in mangled argument types.  */
comment|/* Look for `__'.  */
name|scan
operator|=
operator|*
name|pp
expr_stmt|;
do|do
block|{
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|scan
operator|!=
literal|'_'
condition|)
do|;
if|if
condition|(
name|scan
operator|==
name|NULL
condition|)
block|{
name|stab_bad_demangle
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|--
name|scan
expr_stmt|;
comment|/* We found `__'; move ahead to the last contiguous `__' pair.  */
name|i
operator|=
name|strspn
argument_list|(
name|scan
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
name|scan
operator|+=
name|i
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|scan
operator|==
operator|*
name|pp
operator|&&
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|2
index|]
argument_list|)
operator|||
name|scan
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|||
name|scan
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
condition|)
block|{
comment|/* This is a GNU style constructor name.  */
operator|*
name|pp
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|scan
operator|==
operator|*
name|pp
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|2
index|]
argument_list|)
operator|&&
name|scan
index|[
literal|2
index|]
operator|!=
literal|'t'
condition|)
block|{
comment|/* Look for the `__' that separates the prefix from the          signature.  */
while|while
condition|(
operator|*
name|scan
operator|==
literal|'_'
condition|)
operator|++
name|scan
expr_stmt|;
name|scan
operator|=
name|strstr
argument_list|(
name|scan
argument_list|,
literal|"__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|NULL
operator|||
name|scan
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|stab_demangle_function_name
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|scan
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|scan
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* The name doesn't start with `__', but it does contain `__'.  */
return|return
name|stab_demangle_function_name
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|scan
argument_list|)
return|;
block|}
else|else
block|{
name|stab_bad_demangle
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Demangle a function name prefix.  The scan argument points to the    double underscore which separates the function name from the    signature.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_function_name
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|scan
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The string from *pp to scan is the name of the function.  We      don't care about the name, since we just looking for argument      types.  However, for conversion operators, the name may include a      type which we must remember in order to handle backreferences.  */
name|name
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|-
name|name
operator|>=
literal|5
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|name
index|[
literal|4
index|]
operator|==
literal|'$'
operator|||
name|name
index|[
literal|4
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* This is a type conversion operator.  */
name|tem
operator|=
name|name
operator|+
literal|5
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
operator|&
name|tem
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* This is a type conversion operator.  */
name|tem
operator|=
name|name
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
operator|&
name|tem
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle the signature.  This is where the argument types are    found.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_signature
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|boolean
name|expect_func
decl_stmt|,
name|func_done
decl_stmt|;
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|expect_func
operator|=
name|false
expr_stmt|;
name|func_done
operator|=
name|false
expr_stmt|;
name|hold
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'Q'
case|:
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_qualified
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|stab_demangle_remember_type
argument_list|(
name|minfo
argument_list|,
name|hold
argument_list|,
operator|*
name|pp
operator|-
name|hold
argument_list|)
condition|)
return|return
name|false
return|;
name|expect_func
operator|=
name|true
expr_stmt|;
name|hold
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static member function.  FIXME: Can this happen?  */
if|if
condition|(
name|hold
operator|==
name|NULL
condition|)
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Const member function.  */
if|if
condition|(
name|hold
operator|==
name|NULL
condition|)
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|hold
operator|==
name|NULL
condition|)
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_class
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|stab_demangle_remember_type
argument_list|(
name|minfo
argument_list|,
name|hold
argument_list|,
operator|*
name|pp
operator|-
name|hold
argument_list|)
condition|)
return|return
name|false
return|;
name|expect_func
operator|=
name|true
expr_stmt|;
name|hold
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Function.  I don't know if this actually happens with g++              output.  */
name|hold
operator|=
name|NULL
expr_stmt|;
name|func_done
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|&
name|minfo
operator|->
name|args
argument_list|,
operator|&
name|minfo
operator|->
name|varargs
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'t'
case|:
comment|/* Template.  */
if|if
condition|(
name|hold
operator|==
name|NULL
condition|)
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_template
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|)
operator|||
operator|!
name|stab_demangle_remember_type
argument_list|(
name|minfo
argument_list|,
name|hold
argument_list|,
operator|*
name|pp
operator|-
name|hold
argument_list|)
condition|)
return|return
name|false
return|;
name|hold
operator|=
name|NULL
expr_stmt|;
name|expect_func
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* At the outermost level, we cannot have a return type 	     specified, so if we run into another '_' at this point we 	     are dealing with a mangled name that is either bogus, or 	     has been mangled by some algorithm we don't know how to 	     deal with.  So just reject the entire demangling.  */
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
default|default:
comment|/* Assume we have stumbled onto the first outermost function 	     argument token, and start processing args.  */
name|func_done
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|&
name|minfo
operator|->
name|args
argument_list|,
operator|&
name|minfo
operator|->
name|varargs
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
if|if
condition|(
name|expect_func
condition|)
block|{
name|func_done
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|&
name|minfo
operator|->
name|args
argument_list|,
operator|&
name|minfo
operator|->
name|varargs
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|func_done
condition|)
block|{
comment|/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and 	 bar__3fooi is 'foo::bar(int)'.  We get here when we find the 	 first case, and need to ensure that the '(void)' gets added 	 to the current declp.  */
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|&
name|minfo
operator|->
name|args
argument_list|,
operator|&
name|minfo
operator|->
name|varargs
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a qualified name, such as "Q25Outer5Inner" which is the    mangled form of "Outer::Inner".  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_qualified
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|ptype
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
name|ptype
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|qualifiers
decl_stmt|;
name|debug_type
name|context
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'_'
case|:
comment|/* GNU mangled name with more than 9 classes.  The count is 	 preceded by an underscore (to distinguish it from the<= 9 	 case) and followed by an underscore.  */
name|p
operator|=
operator|*
name|pp
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|qualifiers
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'_'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|qualifiers
operator|=
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* Skip an optional underscore after the count.  */
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
default|default:
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
comment|/* Pick off the names.  */
while|while
condition|(
name|qualifiers
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'_'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'t'
condition|)
block|{
comment|/* FIXME: I don't know how to handle the ptype != NULL case              here.  */
if|if
condition|(
operator|!
name|stab_demangle_template
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|<
name|len
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|fields
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|context
operator|!=
name|DEBUG_TYPE_NULL
condition|)
name|fields
operator|=
name|debug_get_fields
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|context
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
if|if
condition|(
name|fields
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Try to find the type by looking through the                      fields of context until we find a field with the                      same type.  This ought to work for a class                      defined within a class, but it won't work for,                      e.g., an enum defined within a class.  stabs does                      not give us enough information to figure out the                      latter case.  */
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|fields
operator|!=
name|DEBUG_FIELD_NULL
condition|;
name|fields
operator|++
control|)
block|{
name|debug_type
name|ft
decl_stmt|;
specifier|const
name|char
modifier|*
name|dn
decl_stmt|;
name|ft
operator|=
name|debug_get_field_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|fields
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|dn
operator|=
name|debug_get_type_name
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dn
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|context
operator|=
name|ft
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
comment|/* We have to fall back on finding the type by name.                      If there are more types to come, then this must                      be a class.  Otherwise, it could be anything.  */
if|if
condition|(
name|qualifiers
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|context
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
name|context
operator|=
name|stab_find_tagged_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|minfo
operator|->
name|info
argument_list|,
operator|*
name|pp
argument_list|,
name|len
argument_list|,
operator|(
name|qualifiers
operator|==
literal|0
condition|?
name|DEBUG_KIND_ILLEGAL
else|:
name|DEBUG_KIND_CLASS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
operator|*
name|pp
operator|+=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|context
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a template.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_template
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
comment|/* Skip the template name.  */
name|r
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|<
name|r
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pp
operator|+=
name|r
expr_stmt|;
comment|/* Get the size of the parameter list.  */
if|if
condition|(
name|stab_demangle_get_count
argument_list|(
name|pp
argument_list|,
operator|&
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'Z'
condition|)
block|{
comment|/* This is a type parameter.  */
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|old_p
decl_stmt|;
name|boolean
name|pointerp
decl_stmt|,
name|realp
decl_stmt|,
name|integralp
decl_stmt|,
name|charp
decl_stmt|,
name|boolp
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|old_p
operator|=
operator|*
name|pp
expr_stmt|;
name|pointerp
operator|=
name|false
expr_stmt|;
name|realp
operator|=
name|false
expr_stmt|;
name|integralp
operator|=
name|false
expr_stmt|;
name|charp
operator|=
name|false
expr_stmt|;
name|boolp
operator|=
name|false
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
comment|/* This is a value parameter.  */
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
name|debug_type
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
while|while
condition|(
operator|*
name|old_p
operator|!=
literal|'\0'
operator|&&
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|old_p
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
case|case
literal|'R'
case|:
name|pointerp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Const.  */
case|case
literal|'S'
case|:
comment|/* Signed.  */
case|case
literal|'U'
case|:
comment|/* Unsigned.  */
case|case
literal|'V'
case|:
comment|/* Volatile.  */
case|case
literal|'F'
case|:
comment|/* Function.  */
case|case
literal|'M'
case|:
comment|/* Member function.  */
case|case
literal|'O'
case|:
comment|/* ??? */
operator|++
name|old_p
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* Qualified name.  */
name|integralp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Remembered type.  */
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'v'
case|:
comment|/* Void.  */
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'x'
case|:
comment|/* Long long.  */
case|case
literal|'l'
case|:
comment|/* Long.  */
case|case
literal|'i'
case|:
comment|/* Int.  */
case|case
literal|'s'
case|:
comment|/* Short.  */
case|case
literal|'w'
case|:
comment|/* Wchar_t.  */
name|integralp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Bool.  */
name|boolp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Char.  */
name|charp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Long double.  */
case|case
literal|'d'
case|:
comment|/* Double.  */
case|case
literal|'f'
case|:
comment|/* Float.  */
name|realp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
default|default:
comment|/* Assume it's a user defined integral type.  */
name|integralp
operator|=
name|true
expr_stmt|;
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|integralp
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'m'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charp
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'m'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
name|val
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|boolp
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|val
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|val
operator|!=
literal|1
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|realp
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'m'
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'.'
condition|)
block|{
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'e'
condition|)
block|{
operator|++
operator|*
name|pp
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pointerp
condition|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_get_count
argument_list|(
name|pp
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|pp
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a class name.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_class
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|pstart
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pstart
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|n
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|<
name|n
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|pstart
operator|!=
name|NULL
condition|)
operator|*
name|pstart
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|+=
name|n
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle function arguments.  If the pargs argument is not NULL, it    is set to a NULL terminated array holding the arguments.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_args
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|pargs
parameter_list|,
name|pvarargs
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
modifier|*
name|pargs
decl_stmt|;
name|boolean
modifier|*
name|pvarargs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|,
name|count
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|alloc
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|pargs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pargs
operator|=
operator|(
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc
operator|*
sizeof|sizeof
expr|*
operator|*
name|pargs
argument_list|)
expr_stmt|;
operator|*
name|pvarargs
operator|=
name|false
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'e'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'N'
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'T'
condition|)
block|{
name|char
name|temptype
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|,
name|t
decl_stmt|;
name|temptype
operator|=
operator|*
operator|*
name|pp
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|temptype
operator|==
literal|'T'
condition|)
name|r
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|stab_demangle_get_count
argument_list|(
name|pp
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|stab_demangle_get_count
argument_list|(
name|pp
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|t
operator|>=
name|minfo
operator|->
name|typestring_count
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
while|while
condition|(
name|r
operator|--
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|minfo
operator|->
name|typestrings
index|[
name|t
index|]
operator|.
name|typestring
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_arg
argument_list|(
name|minfo
argument_list|,
operator|&
name|tem
argument_list|,
name|pargs
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|alloc
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|stab_demangle_arg
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|pargs
argument_list|,
operator|&
name|count
argument_list|,
operator|&
name|alloc
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|pargs
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|pargs
operator|)
index|[
name|count
index|]
operator|=
name|DEBUG_TYPE_NULL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|pargs
operator|!=
name|NULL
condition|)
operator|*
name|pvarargs
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a single argument.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_arg
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|pargs
parameter_list|,
name|pcount
parameter_list|,
name|palloc
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
modifier|*
name|pargs
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pcount
decl_stmt|;
name|unsigned
name|int
modifier|*
name|palloc
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|start
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|pargs
operator|==
name|NULL
condition|?
operator|(
name|debug_type
operator|*
operator|)
name|NULL
else|:
operator|&
name|type
argument_list|)
operator|||
operator|!
name|stab_demangle_remember_type
argument_list|(
name|minfo
argument_list|,
name|start
argument_list|,
operator|*
name|pp
operator|-
name|start
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|pargs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|pcount
operator|+
literal|1
operator|>=
operator|*
name|palloc
condition|)
block|{
operator|*
name|palloc
operator|+=
literal|10
expr_stmt|;
operator|*
name|pargs
operator|=
operator|(
operator|(
name|debug_type
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|pargs
argument_list|,
operator|*
name|palloc
operator|*
sizeof|sizeof
expr|*
operator|*
name|pargs
argument_list|)
operator|)
expr_stmt|;
block|}
operator|(
operator|*
name|pargs
operator|)
index|[
operator|*
name|pcount
index|]
operator|=
name|type
expr_stmt|;
operator|++
operator|*
name|pcount
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a type.  If the ptype argument is not NULL, *ptype is set    to the newly allocated type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_type
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|ptype
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
name|ptype
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
comment|/* A pointer type.  */
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_pointer_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* A reference type.  */
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_reference_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* An array.  */
block|{
name|unsigned
name|long
name|high
decl_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|high
operator|*=
literal|10
expr_stmt|;
name|high
operator|+=
operator|*
operator|*
name|pp
operator|-
literal|'0'
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'_'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
name|debug_type
name|int_type
decl_stmt|;
name|int_type
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_type
operator|==
name|NULL
condition|)
name|int_type
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|4
argument_list|,
name|false
argument_list|)
expr_stmt|;
operator|*
name|ptype
operator|=
name|debug_make_array_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|,
name|int_type
argument_list|,
literal|0
argument_list|,
name|high
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* A back reference to a remembered type.  */
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_get_count
argument_list|(
name|pp
argument_list|,
operator|&
name|i
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|i
operator|>=
name|minfo
operator|->
name|typestring_count
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|p
operator|=
name|minfo
operator|->
name|typestrings
index|[
name|i
index|]
operator|.
name|typestring
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
operator|&
name|p
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* A function.  */
block|{
name|debug_type
modifier|*
name|args
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
name|ptype
operator|==
name|NULL
condition|?
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
else|:
operator|&
name|args
operator|)
argument_list|,
operator|(
name|ptype
operator|==
name|NULL
condition|?
operator|(
name|boolean
operator|*
operator|)
name|NULL
else|:
operator|&
name|varargs
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'_'
condition|)
block|{
comment|/* cplus_demangle will accept a function without a return 	       type, but I don't know when that will happen, or what 	       to do if it does.  */
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_function_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|,
name|args
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
case|case
literal|'O'
case|:
block|{
name|boolean
name|memberp
decl_stmt|,
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
name|debug_type
modifier|*
name|args
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|memberp
operator|=
operator|*
operator|*
name|pp
operator|==
literal|'M'
expr_stmt|;
name|constp
operator|=
name|false
expr_stmt|;
name|volatilep
operator|=
name|false
expr_stmt|;
name|args
operator|=
name|NULL
expr_stmt|;
name|varargs
operator|=
name|false
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|n
operator|=
name|stab_demangle_count
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|<
name|n
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|name
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|memberp
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'C'
condition|)
block|{
name|constp
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'V'
condition|)
block|{
name|volatilep
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'F'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_args
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|(
name|ptype
operator|==
name|NULL
condition|?
operator|(
name|debug_type
operator|*
operator|*
operator|)
name|NULL
else|:
operator|&
name|args
operator|)
argument_list|,
operator|(
name|ptype
operator|==
name|NULL
condition|?
operator|(
name|boolean
operator|*
operator|)
name|NULL
else|:
operator|&
name|varargs
operator|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'_'
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
name|debug_type
name|class_type
decl_stmt|;
name|class_type
operator|=
name|stab_find_tagged_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|minfo
operator|->
name|info
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|DEBUG_KIND_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_type
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|memberp
condition|)
operator|*
name|ptype
operator|=
name|debug_make_offset_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|class_type
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* FIXME: We have no way to record constp or                    volatilep.  */
operator|*
name|ptype
operator|=
name|debug_make_method_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|,
name|class_type
argument_list|,
name|args
argument_list|,
name|varargs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'G'
case|:
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
literal|'C'
case|:
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_const_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
block|{
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
name|hold
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_qualified
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|stab_demangle_fund_type
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
name|ptype
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Demangle a fundamental type.  If the ptype argument is not NULL,    *ptype is set to the newly allocated type.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_fund_type
parameter_list|(
name|minfo
parameter_list|,
name|pp
parameter_list|,
name|ptype
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|debug_type
modifier|*
name|ptype
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|orig
decl_stmt|;
name|boolean
name|constp
decl_stmt|,
name|volatilep
decl_stmt|,
name|unsignedp
decl_stmt|,
name|signedp
decl_stmt|;
name|boolean
name|done
decl_stmt|;
name|orig
operator|=
operator|*
name|pp
expr_stmt|;
name|constp
operator|=
name|false
expr_stmt|;
name|volatilep
operator|=
name|false
expr_stmt|;
name|unsignedp
operator|=
name|false
expr_stmt|;
name|signedp
operator|=
name|false
expr_stmt|;
name|done
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'C'
case|:
name|constp
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|unsignedp
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|signedp
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|volatilep
operator|=
name|true
expr_stmt|;
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
default|default:
name|done
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
operator|*
operator|*
name|pp
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'_'
case|:
comment|/* cplus_demangle permits this, but I don't know what it means.  */
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* void */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_void_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* long long */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|(
name|unsignedp
condition|?
literal|"long long unsigned int"
else|:
literal|"long long int"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|8
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* long */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|(
name|unsignedp
condition|?
literal|"long unsigned int"
else|:
literal|"long int"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|4
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* int */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|(
name|unsignedp
condition|?
literal|"unsigned int"
else|:
literal|"int"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|4
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* short */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|(
name|unsignedp
condition|?
literal|"short unsigned int"
else|:
literal|"short int"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|2
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* bool */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_bool_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* char */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|(
name|unsignedp
condition|?
literal|"unsigned char"
else|:
operator|(
name|signedp
condition|?
literal|"signed char"
else|:
literal|"char"
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* wchar_t */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"__wchar_t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_int_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|2
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* long double */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"long double"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_float_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* double */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_float_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* float */
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
operator|*
name|ptype
operator|=
name|debug_make_float_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pp
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|pp
argument_list|)
condition|)
block|{
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fall through.  */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
specifier|const
name|char
modifier|*
name|hold
decl_stmt|;
if|if
condition|(
operator|!
name|stab_demangle_class
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|,
operator|&
name|hold
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|hold
argument_list|,
operator|*
name|pp
operator|-
name|hold
argument_list|)
expr_stmt|;
operator|*
name|ptype
operator|=
name|debug_find_named_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptype
operator|==
name|DEBUG_TYPE_NULL
condition|)
block|{
comment|/* FIXME: It is probably incorrect to assume that                    undefined types are tagged types.  */
operator|*
name|ptype
operator|=
name|stab_find_tagged_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|minfo
operator|->
name|info
argument_list|,
name|hold
argument_list|,
operator|*
name|pp
operator|-
name|hold
argument_list|,
name|DEBUG_KIND_ILLEGAL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|stab_demangle_template
argument_list|(
name|minfo
argument_list|,
name|pp
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
name|debug_type
name|t
decl_stmt|;
comment|/* FIXME: I really don't know how a template should be              represented in the current type system.  Perhaps the              template should be demangled into a string, and the type              should be represented as a named type.  However, I don't              know what the base type of the named type should be.  */
name|t
operator|=
name|debug_make_void_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|)
expr_stmt|;
name|t
operator|=
name|debug_make_pointer_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|debug_name_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
literal|"TEMPLATE"
argument_list|,
name|t
argument_list|)
expr_stmt|;
operator|*
name|ptype
operator|=
name|t
expr_stmt|;
block|}
break|break;
default|default:
name|stab_bad_demangle
argument_list|(
name|orig
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|ptype
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|constp
condition|)
operator|*
name|ptype
operator|=
name|debug_make_const_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
operator|*
name|ptype
operator|=
name|debug_make_volatile_type
argument_list|(
name|minfo
operator|->
name|dhandle
argument_list|,
operator|*
name|ptype
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Remember a type string in a demangled string.  */
end_comment

begin_function
specifier|static
name|boolean
name|stab_demangle_remember_type
parameter_list|(
name|minfo
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|struct
name|stab_demangle_info
modifier|*
name|minfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|minfo
operator|->
name|typestring_count
operator|>=
name|minfo
operator|->
name|typestring_alloc
condition|)
block|{
name|minfo
operator|->
name|typestring_alloc
operator|+=
literal|10
expr_stmt|;
name|minfo
operator|->
name|typestrings
operator|=
operator|(
operator|(
expr|struct
name|stab_demangle_typestring
operator|*
operator|)
name|xrealloc
argument_list|(
name|minfo
operator|->
name|typestrings
argument_list|,
operator|(
name|minfo
operator|->
name|typestring_alloc
operator|*
sizeof|sizeof
expr|*
name|minfo
operator|->
name|typestrings
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|minfo
operator|->
name|typestrings
index|[
name|minfo
operator|->
name|typestring_count
index|]
operator|.
name|typestring
operator|=
name|p
expr_stmt|;
name|minfo
operator|->
name|typestrings
index|[
name|minfo
operator|->
name|typestring_count
index|]
operator|.
name|len
operator|=
operator|(
name|unsigned
name|int
operator|)
name|len
expr_stmt|;
operator|++
name|minfo
operator|->
name|typestring_count
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

