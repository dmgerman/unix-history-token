begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* size.c -- report size of various sections of an executable file.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Extensions/incompatibilities:    o - BSD output has filenames at the end.    o - BSD output can appear in different radicies.    o - SysV output has less redundant whitespace.  Filename comes at end.    o - SysV output doesn't show VMA which is always the same as the PMA.    o - We also handle core files.    o - We also handle archives.    If you write shell scripts which manipulate this info then you may be    out of luck; there's no --compatibility or --pedantic option.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|BSD_DEFAULT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Program options.  */
end_comment

begin_enum
enum|enum
block|{
name|decimal
block|,
name|octal
block|,
name|hex
block|}
name|radix
init|=
name|decimal
enum|;
end_enum

begin_decl_stmt
name|int
name|berkeley_format
init|=
name|BSD_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means use AT&T-style output.  */
end_comment

begin_decl_stmt
name|int
name|show_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|show_help
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|show_totals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|total_bsssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|total_datasize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|total_textsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Program exit status.  */
end_comment

begin_decl_stmt
name|int
name|return_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_bfd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_archive
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|size_number
name|PARAMS
argument_list|(
operator|(
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void lprint_number         PARAMS ((int, bfd_size_type));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|rprint_number
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_berkeley_format
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sysv_internal_sizer
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sysv_internal_printer
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_sysv_format
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_sizes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|berkeley_sum
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [file(s)]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Displays the sizes of sections inside binary files\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" If no input file(s) are specified, a.out is assumed\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -A|-B     --format={sysv|berkeley}  Select output style (default is %s)\n\   -o|-d|-h  --radix={8|10|16}         Display numbers in octal, decimal or hex\n\   -t        --totals                  Display the total sizes (Berkeley only)\n\             --target=<bfdname>        Set the binary file format\n\   -h        --help                    Display this information\n\   -v        --version                 Display the program's version\n\ \n"
argument_list|)
argument_list|,
if|#
directive|if
name|BSD_DEFAULT
literal|"berkeley"
else|#
directive|else
literal|"sysv"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|200
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
literal|0
block|,
literal|201
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
literal|202
block|}
block|,
block|{
literal|"totals"
block|,
name|no_argument
block|,
operator|&
name|show_totals
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|show_version
block|,
literal|1
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|show_help
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|temp
decl_stmt|;
name|int
name|c
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
operator|*
name|argv
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ABHhVvdfotx"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|200
case|:
comment|/* --format */
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|berkeley_format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|berkeley_format
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"invalid argument to --format: %s"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|202
case|:
comment|/* --target */
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|201
case|:
comment|/* --radix */
ifdef|#
directive|ifdef
name|ANSI_LIBRARIES
name|temp
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|10
case|:
name|radix
operator|=
name|decimal
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|radix
operator|=
name|octal
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|radix
operator|=
name|hex
expr_stmt|;
break|break;
default|default:
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Invalid radix: %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
name|berkeley_format
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|berkeley_format
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|show_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|radix
operator|=
name|decimal
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|radix
operator|=
name|hex
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|radix
operator|=
name|octal
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|show_totals
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* FIXME : For sysv68, `-f' means `full format', i.e. 		   `[fname:] M(.text) + N(.data) + O(.bss) + P(.comment) = Q' 		   where `fname: ' appears only if there are>= 2 input files, 		   and M, N, O, P, Q are expressed in decimal by default, 		   hexa or octal if requested by `-x' or `-o'. 		   Just to make things interesting, Solaris also accepts -f, 		   which prints out the size of each allocatable section, the 		   name of the section, and the total of the section sizes.  */
comment|/* For the moment, accept `-f' silently, and ignore it.  */
break|break;
case|case
literal|0
case|:
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_help
condition|)
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|display_file
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
control|)
name|display_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_totals
operator|&&
name|berkeley_format
condition|)
block|{
name|bfd_size_type
name|total
init|=
name|total_textsize
operator|+
name|total_datasize
operator|+
name|total_bsssize
decl_stmt|;
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|total_textsize
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|total_datasize
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|total_bsssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
operator|(
operator|(
name|radix
operator|==
name|octal
operator|)
condition|?
literal|"\t%7lo\t%7lx\t"
else|:
literal|"\t%7lu\t%7lx\t"
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|total
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|total
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(TOTALS)\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|return_code
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display stats on file or archive member ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|display_bfd
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
comment|/* An archive within an archive.  */
return|return;
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|print_sizes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|3
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_core
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|core_cmd
decl_stmt|;
name|print_sizes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" (core file"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|core_cmd
operator|=
name|bfd_core_file_failing_command
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_cmd
condition|)
name|printf
argument_list|(
literal|" invoked as %s"
argument_list|,
name|core_cmd
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|return_code
operator|=
literal|3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_archive
parameter_list|(
name|file
parameter_list|)
name|bfd
modifier|*
name|file
decl_stmt|;
block|{
name|bfd
modifier|*
name|arfile
init|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|file
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_more_archived_files
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|2
expr_stmt|;
block|}
break|break;
block|}
name|display_bfd
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
comment|/* Don't close the archive elements; we need them for next_archive.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd
modifier|*
name|file
init|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_archive
argument_list|)
operator|==
name|true
condition|)
name|display_archive
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|display_bfd
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_close
argument_list|(
name|file
argument_list|)
operator|==
name|false
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is what lexical functions are for.  */
end_comment

begin_function
specifier|static
name|int
name|size_number
parameter_list|(
name|num
parameter_list|)
name|bfd_size_type
name|num
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
operator|(
name|radix
operator|==
name|decimal
condition|?
literal|"%lu"
else|:
operator|(
operator|(
name|radix
operator|==
name|octal
operator|)
condition|?
literal|"0%lo"
else|:
literal|"0x%lx"
operator|)
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|num
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not used.  */
end_comment

begin_endif
unit|static void lprint_number (width, num)      int width;      bfd_size_type num; {   char buffer[40];    sprintf (buffer, 	   (radix == decimal ? "%lu" : 	   ((radix == octal) ? "0%lo" : "0x%lx")), 	   (unsigned long) num);    printf ("%-*s", width, buffer); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|rprint_number
parameter_list|(
name|width
parameter_list|,
name|num
parameter_list|)
name|int
name|width
decl_stmt|;
name|bfd_size_type
name|num
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|40
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
operator|(
name|radix
operator|==
name|decimal
condition|?
literal|"%lu"
else|:
operator|(
operator|(
name|radix
operator|==
name|octal
operator|)
condition|?
literal|"0%lo"
else|:
literal|"0x%lx"
operator|)
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|width
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_size_type
name|bsssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|datasize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|textsize
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|berkeley_sum
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sec_ptr
name|sec
decl_stmt|;
name|PTR
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|textsize
operator|+=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
name|datasize
operator|+=
name|size
expr_stmt|;
else|else
name|bsssize
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_berkeley_format
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|static
name|int
name|files_seen
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|total
decl_stmt|;
name|bsssize
operator|=
literal|0
expr_stmt|;
name|datasize
operator|=
literal|0
expr_stmt|;
name|textsize
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|berkeley_sum
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|files_seen
operator|++
operator|==
literal|0
condition|)
if|#
directive|if
literal|0
comment|/* Intel doesn't like bss/stk because they don't have core files.  */
then|puts ((radix == octal) ? "   text\t   data\tbss/stk\t    oct\t    hex\tfilename" : 	  "   text\t   data\tbss/stk\t    dec\t    hex\tfilename");
else|#
directive|else
name|puts
argument_list|(
operator|(
name|radix
operator|==
name|octal
operator|)
condition|?
literal|"   text\t   data\t    bss\t    oct\t    hex\tfilename"
else|:
literal|"   text\t   data\t    bss\t    dec\t    hex\tfilename"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|total
operator|=
name|textsize
operator|+
name|datasize
operator|+
name|bsssize
expr_stmt|;
if|if
condition|(
name|show_totals
condition|)
block|{
name|total_textsize
operator|+=
name|textsize
expr_stmt|;
name|total_datasize
operator|+=
name|datasize
expr_stmt|;
name|total_bsssize
operator|+=
name|bsssize
expr_stmt|;
block|}
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|textsize
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
literal|7
argument_list|,
name|bsssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
operator|(
operator|(
name|radix
operator|==
name|octal
operator|)
condition|?
literal|"\t%7lo\t%7lx\t"
else|:
literal|"\t%7lu\t%7lx\t"
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|total
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|total
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (ex %s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I REALLY miss lexical functions! */
end_comment

begin_decl_stmt
name|bfd_size_type
name|svi_total
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|svi_maxvma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|svi_namelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|svi_vmalen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|svi_sizelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sysv_internal_sizer
parameter_list|(
name|file
parameter_list|,
name|sec
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sec_ptr
name|sec
decl_stmt|;
name|PTR
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_size_type
name|size
init|=
name|bfd_section_size
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|bfd_section_name
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|>
name|svi_namelen
condition|)
name|svi_namelen
operator|=
name|namelen
expr_stmt|;
name|svi_total
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|bfd_section_vma
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
operator|>
name|svi_maxvma
condition|)
name|svi_maxvma
operator|=
name|bfd_section_vma
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sysv_internal_printer
parameter_list|(
name|file
parameter_list|,
name|sec
parameter_list|,
name|ignore
parameter_list|)
name|bfd
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sec_ptr
name|sec
decl_stmt|;
name|PTR
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_size_type
name|size
init|=
name|bfd_section_size
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|svi_total
operator|+=
name|size
expr_stmt|;
name|printf
argument_list|(
literal|"%-*s   "
argument_list|,
name|svi_namelen
argument_list|,
name|bfd_section_name
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
name|svi_sizelen
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
name|svi_vmalen
argument_list|,
name|bfd_section_vma
argument_list|(
name|file
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_sysv_format
parameter_list|(
name|file
parameter_list|)
name|bfd
modifier|*
name|file
decl_stmt|;
block|{
comment|/* Size all of the columns.  */
name|svi_total
operator|=
literal|0
expr_stmt|;
name|svi_maxvma
operator|=
literal|0
expr_stmt|;
name|svi_namelen
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|file
argument_list|,
name|sysv_internal_sizer
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|svi_vmalen
operator|=
name|size_number
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|svi_maxvma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|svi_vmalen
operator|<
sizeof|sizeof
argument_list|(
literal|"addr"
argument_list|)
operator|-
literal|1
condition|)
name|svi_vmalen
operator|=
sizeof|sizeof
argument_list|(
literal|"addr"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|svi_sizelen
operator|=
name|size_number
argument_list|(
name|svi_total
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|svi_sizelen
operator|<
sizeof|sizeof
argument_list|(
literal|"size"
argument_list|)
operator|-
literal|1
condition|)
name|svi_sizelen
operator|=
sizeof|sizeof
argument_list|(
literal|"size"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|svi_total
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s  "
argument_list|,
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|file
argument_list|)
condition|)
name|printf
argument_list|(
literal|" (ex %s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n%-*s   %*s   %*s\n"
argument_list|,
name|svi_namelen
argument_list|,
literal|"section"
argument_list|,
name|svi_sizelen
argument_list|,
literal|"size"
argument_list|,
name|svi_vmalen
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|file
argument_list|,
name|sysv_internal_printer
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-*s   "
argument_list|,
name|svi_namelen
argument_list|,
literal|"Total"
argument_list|)
expr_stmt|;
name|rprint_number
argument_list|(
name|svi_sizelen
argument_list|,
name|svi_total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_sizes
parameter_list|(
name|file
parameter_list|)
name|bfd
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|berkeley_format
condition|)
name|print_berkeley_format
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|print_sysv_format
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

