begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* debug.c -- Handle generic debugging information.    Copyright (C) 1995, 1996 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements a generic debugging format.  We may eventually    have readers which convert different formats into this generic    format, and writers which write it out.  The initial impetus for    this was writing a convertor from stabs to HP IEEE-695 debugging    format.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_comment
comment|/* Global information we keep for debugging.  A pointer to this    structure is the debugging handle passed to all the routines.  */
end_comment

begin_struct
struct|struct
name|debug_handle
block|{
comment|/* A linked list of compilation units.  */
name|struct
name|debug_unit
modifier|*
name|units
decl_stmt|;
comment|/* The current compilation unit.  */
name|struct
name|debug_unit
modifier|*
name|current_unit
decl_stmt|;
comment|/* The current source file.  */
name|struct
name|debug_file
modifier|*
name|current_file
decl_stmt|;
comment|/* The current function.  */
name|struct
name|debug_function
modifier|*
name|current_function
decl_stmt|;
comment|/* The current block.  */
name|struct
name|debug_block
modifier|*
name|current_block
decl_stmt|;
comment|/* The current line number information for the current unit.  */
name|struct
name|debug_lineno
modifier|*
name|current_lineno
decl_stmt|;
comment|/* Mark.  This is used by debug_write.  */
name|unsigned
name|int
name|mark
decl_stmt|;
comment|/* A struct/class ID used by debug_write.  */
name|unsigned
name|int
name|class_id
decl_stmt|;
comment|/* The base for class_id for this call to debug_write.  */
name|unsigned
name|int
name|base_id
decl_stmt|;
comment|/* The current line number in debug_write.  */
name|struct
name|debug_lineno
modifier|*
name|current_write_lineno
decl_stmt|;
name|unsigned
name|int
name|current_write_lineno_index
decl_stmt|;
comment|/* A list of classes which have assigned ID's during debug_write.      This is linked through the next_id field of debug_class_type.  */
name|struct
name|debug_class_id
modifier|*
name|id_list
decl_stmt|;
comment|/* A list used to avoid recursion during debug_type_samep.  */
name|struct
name|debug_type_compare_list
modifier|*
name|compare_list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information we keep for a single compilation unit.  */
end_comment

begin_struct
struct|struct
name|debug_unit
block|{
comment|/* The next compilation unit.  */
name|struct
name|debug_unit
modifier|*
name|next
decl_stmt|;
comment|/* A list of files included in this compilation unit.  The first      file is always the main one, and that is where the main file name      is stored.  */
name|struct
name|debug_file
modifier|*
name|files
decl_stmt|;
comment|/* Line number information for this compilation unit.  This is not      stored by function, because assembler code may have line number      information without function information.  */
name|struct
name|debug_lineno
modifier|*
name|linenos
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a single source file.  */
end_comment

begin_struct
struct|struct
name|debug_file
block|{
comment|/* The next source file in this compilation unit.  */
name|struct
name|debug_file
modifier|*
name|next
decl_stmt|;
comment|/* The name of the source file.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Global functions, variables, types, etc.  */
name|struct
name|debug_namespace
modifier|*
name|globals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A type.  */
end_comment

begin_struct
struct|struct
name|debug_type
block|{
comment|/* Kind of type.  */
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
comment|/* Size of type (0 if not known).  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Type which is a pointer to this type.  */
name|debug_type
name|pointer
decl_stmt|;
comment|/* Tagged union with additional information about the type.  */
union|union
block|{
comment|/* DEBUG_KIND_INDIRECT.  */
name|struct
name|debug_indirect_type
modifier|*
name|kindirect
decl_stmt|;
comment|/* DEBUG_KIND_INT.  */
comment|/* Whether the integer is unsigned.  */
name|boolean
name|kint
decl_stmt|;
comment|/* DEBUG_KIND_STRUCT, DEBUG_KIND_UNION, DEBUG_KIND_CLASS,          DEBUG_KIND_UNION_CLASS.  */
name|struct
name|debug_class_type
modifier|*
name|kclass
decl_stmt|;
comment|/* DEBUG_KIND_ENUM.  */
name|struct
name|debug_enum_type
modifier|*
name|kenum
decl_stmt|;
comment|/* DEBUG_KIND_POINTER.  */
name|struct
name|debug_type
modifier|*
name|kpointer
decl_stmt|;
comment|/* DEBUG_KIND_FUNCTION.  */
name|struct
name|debug_function_type
modifier|*
name|kfunction
decl_stmt|;
comment|/* DEBUG_KIND_REFERENCE.  */
name|struct
name|debug_type
modifier|*
name|kreference
decl_stmt|;
comment|/* DEBUG_KIND_RANGE.  */
name|struct
name|debug_range_type
modifier|*
name|krange
decl_stmt|;
comment|/* DEBUG_KIND_ARRAY.  */
name|struct
name|debug_array_type
modifier|*
name|karray
decl_stmt|;
comment|/* DEBUG_KIND_SET.  */
name|struct
name|debug_set_type
modifier|*
name|kset
decl_stmt|;
comment|/* DEBUG_KIND_OFFSET.  */
name|struct
name|debug_offset_type
modifier|*
name|koffset
decl_stmt|;
comment|/* DEBUG_KIND_METHOD.  */
name|struct
name|debug_method_type
modifier|*
name|kmethod
decl_stmt|;
comment|/* DEBUG_KIND_CONST.  */
name|struct
name|debug_type
modifier|*
name|kconst
decl_stmt|;
comment|/* DEBUG_KIND_VOLATILE.  */
name|struct
name|debug_type
modifier|*
name|kvolatile
decl_stmt|;
comment|/* DEBUG_KIND_NAMED, DEBUG_KIND_TAGGED.  */
name|struct
name|debug_named_type
modifier|*
name|knamed
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for an indirect type.  */
end_comment

begin_struct
struct|struct
name|debug_indirect_type
block|{
comment|/* Slot where the final type will appear.  */
name|debug_type
modifier|*
name|slot
decl_stmt|;
comment|/* Tag.  */
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a struct, union, or class.  */
end_comment

begin_struct
struct|struct
name|debug_class_type
block|{
comment|/* NULL terminated array of fields.  */
name|debug_field
modifier|*
name|fields
decl_stmt|;
comment|/* A mark field which indicates whether the struct has already been      printed.  */
name|unsigned
name|int
name|mark
decl_stmt|;
comment|/* This is used to uniquely identify unnamed structs when printing.  */
name|unsigned
name|int
name|id
decl_stmt|;
comment|/* The remaining fields are only used for DEBUG_KIND_CLASS and      DEBUG_KIND_UNION_CLASS.  */
comment|/* NULL terminated array of base classes.  */
name|debug_baseclass
modifier|*
name|baseclasses
decl_stmt|;
comment|/* NULL terminated array of methods.  */
name|debug_method
modifier|*
name|methods
decl_stmt|;
comment|/* The type of the class providing the virtual function table for      this class.  This may point to the type itself.  */
name|debug_type
name|vptrbase
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for an enum.  */
end_comment

begin_struct
struct|struct
name|debug_enum_type
block|{
comment|/* NULL terminated array of names.  */
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Array of corresponding values.  */
name|bfd_signed_vma
modifier|*
name|values
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a function.  FIXME: We should be able to    record the parameter types.  */
end_comment

begin_struct
struct|struct
name|debug_function_type
block|{
comment|/* Return type.  */
name|debug_type
name|return_type
decl_stmt|;
comment|/* NULL terminated array of argument types.  */
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
comment|/* Whether the function takes a variable number of arguments.  */
name|boolean
name|varargs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a range.  */
end_comment

begin_struct
struct|struct
name|debug_range_type
block|{
comment|/* Range base type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Lower bound.  */
name|bfd_signed_vma
name|lower
decl_stmt|;
comment|/* Upper bound.  */
name|bfd_signed_vma
name|upper
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for an array.  */
end_comment

begin_struct
struct|struct
name|debug_array_type
block|{
comment|/* Element type.  */
name|debug_type
name|element_type
decl_stmt|;
comment|/* Range type.  */
name|debug_type
name|range_type
decl_stmt|;
comment|/* Lower bound.  */
name|bfd_signed_vma
name|lower
decl_stmt|;
comment|/* Upper bound.  */
name|bfd_signed_vma
name|upper
decl_stmt|;
comment|/* Whether this array is really a string.  */
name|boolean
name|stringp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a set.  */
end_comment

begin_struct
struct|struct
name|debug_set_type
block|{
comment|/* Base type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Whether this set is really a bitstring.  */
name|boolean
name|bitstringp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for an offset type (a based pointer).  */
end_comment

begin_struct
struct|struct
name|debug_offset_type
block|{
comment|/* The type the pointer is an offset from.  */
name|debug_type
name|base_type
decl_stmt|;
comment|/* The type the pointer points to.  */
name|debug_type
name|target_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a method type.  */
end_comment

begin_struct
struct|struct
name|debug_method_type
block|{
comment|/* The return type.  */
name|debug_type
name|return_type
decl_stmt|;
comment|/* The object type which this method is for.  */
name|debug_type
name|domain_type
decl_stmt|;
comment|/* A NULL terminated array of argument types.  */
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
comment|/* Whether the method takes a variable number of arguments.  */
name|boolean
name|varargs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information kept for a named type.  */
end_comment

begin_struct
struct|struct
name|debug_named_type
block|{
comment|/* Name.  */
name|struct
name|debug_name
modifier|*
name|name
decl_stmt|;
comment|/* Real type.  */
name|debug_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A field in a struct or union.  */
end_comment

begin_struct
struct|struct
name|debug_field
block|{
comment|/* Name of the field.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Type of the field.  */
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
comment|/* Visibility of the field.  */
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
comment|/* Whether this is a static member.  */
name|boolean
name|static_member
decl_stmt|;
union|union
block|{
comment|/* If static_member is false.  */
struct|struct
block|{
comment|/* Bit position of the field in the struct.  */
name|unsigned
name|int
name|bitpos
decl_stmt|;
comment|/* Size of the field in bits.  */
name|unsigned
name|int
name|bitsize
decl_stmt|;
block|}
name|f
struct|;
comment|/* If static_member is true.  */
struct|struct
block|{
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
block|}
name|s
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* A base class for an object.  */
end_comment

begin_struct
struct|struct
name|debug_baseclass
block|{
comment|/* Type of the base class.  */
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
comment|/* Bit position of the base class in the object.  */
name|unsigned
name|int
name|bitpos
decl_stmt|;
comment|/* Whether the base class is virtual.  */
name|boolean
name|virtual
decl_stmt|;
comment|/* Visibility of the base class.  */
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A method of an object.  */
end_comment

begin_struct
struct|struct
name|debug_method
block|{
comment|/* The name of the method.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* A NULL terminated array of different types of variants.  */
name|struct
name|debug_method_variant
modifier|*
modifier|*
name|variants
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The variants of a method function of an object.  These indicate    which method to run.  */
end_comment

begin_struct
struct|struct
name|debug_method_variant
block|{
comment|/* The physical name of the function.  */
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
comment|/* The type of the function.  */
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
comment|/* The visibility of the function.  */
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
comment|/* Whether the function is const.  */
name|boolean
name|constp
decl_stmt|;
comment|/* Whether the function is volatile.  */
name|boolean
name|volatilep
decl_stmt|;
comment|/* The offset to the function in the virtual function table.  */
name|bfd_vma
name|voffset
decl_stmt|;
comment|/* If voffset is VOFFSET_STATIC_METHOD, this is a static method.  */
define|#
directive|define
name|VOFFSET_STATIC_METHOD
value|((bfd_vma) -1)
comment|/* Context of a virtual method function.  */
name|struct
name|debug_type
modifier|*
name|context
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A variable.  This is the information we keep for a variable object.    This has no name; a name is associated with a variable in a    debug_name structure.  */
end_comment

begin_struct
struct|struct
name|debug_variable
block|{
comment|/* Kind of variable.  */
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Value.  The interpretation of the value depends upon kind.  */
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A function.  This has no name; a name is associated with a function    in a debug_name structure.  */
end_comment

begin_struct
struct|struct
name|debug_function
block|{
comment|/* Return type.  */
name|debug_type
name|return_type
decl_stmt|;
comment|/* Parameter information.  */
name|struct
name|debug_parameter
modifier|*
name|parameters
decl_stmt|;
comment|/* Block information.  The first structure on the list is the main      block of the function, and describes function local variables.  */
name|struct
name|debug_block
modifier|*
name|blocks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A function parameter.  */
end_comment

begin_struct
struct|struct
name|debug_parameter
block|{
comment|/* Next parameter.  */
name|struct
name|debug_parameter
modifier|*
name|next
decl_stmt|;
comment|/* Name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Kind.  */
name|enum
name|debug_parm_kind
name|kind
decl_stmt|;
comment|/* Value (meaning depends upon kind).  */
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A typed constant.  */
end_comment

begin_struct
struct|struct
name|debug_typed_constant
block|{
comment|/* Type.  */
name|debug_type
name|type
decl_stmt|;
comment|/* Value.  FIXME: We may eventually need to support non-integral      values.  */
name|bfd_vma
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Information about a block within a function.  */
end_comment

begin_struct
struct|struct
name|debug_block
block|{
comment|/* Next block with the same parent.  */
name|struct
name|debug_block
modifier|*
name|next
decl_stmt|;
comment|/* Parent block.  */
name|struct
name|debug_block
modifier|*
name|parent
decl_stmt|;
comment|/* List of child blocks.  */
name|struct
name|debug_block
modifier|*
name|children
decl_stmt|;
comment|/* Start address of the block.  */
name|bfd_vma
name|start
decl_stmt|;
comment|/* End address of the block.  */
name|bfd_vma
name|end
decl_stmt|;
comment|/* Local variables.  */
name|struct
name|debug_namespace
modifier|*
name|locals
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Line number information we keep for a compilation unit.  FIXME:    This structure is easy to create, but can be very space    inefficient.  */
end_comment

begin_struct
struct|struct
name|debug_lineno
block|{
comment|/* More line number information for this block.  */
name|struct
name|debug_lineno
modifier|*
name|next
decl_stmt|;
comment|/* Source file.  */
name|struct
name|debug_file
modifier|*
name|file
decl_stmt|;
comment|/* Line numbers, terminated by a -1 or the end of the array.  */
define|#
directive|define
name|DEBUG_LINENO_COUNT
value|10
name|unsigned
name|long
name|linenos
index|[
name|DEBUG_LINENO_COUNT
index|]
decl_stmt|;
comment|/* Addresses for the line numbers.  */
name|bfd_vma
name|addrs
index|[
name|DEBUG_LINENO_COUNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A namespace.  This is a mapping from names to objects.  FIXME: This    should be implemented as a hash table.  */
end_comment

begin_struct
struct|struct
name|debug_namespace
block|{
comment|/* List of items in this namespace.  */
name|struct
name|debug_name
modifier|*
name|list
decl_stmt|;
comment|/* Pointer to where the next item in this namespace should go.  */
name|struct
name|debug_name
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Kinds of objects that appear in a namespace.  */
end_comment

begin_enum
enum|enum
name|debug_object_kind
block|{
comment|/* A type.  */
name|DEBUG_OBJECT_TYPE
block|,
comment|/* A tagged type (really a different sort of namespace).  */
name|DEBUG_OBJECT_TAG
block|,
comment|/* A variable.  */
name|DEBUG_OBJECT_VARIABLE
block|,
comment|/* A function.  */
name|DEBUG_OBJECT_FUNCTION
block|,
comment|/* An integer constant.  */
name|DEBUG_OBJECT_INT_CONSTANT
block|,
comment|/* A floating point constant.  */
name|DEBUG_OBJECT_FLOAT_CONSTANT
block|,
comment|/* A typed constant.  */
name|DEBUG_OBJECT_TYPED_CONSTANT
block|}
enum|;
end_enum

begin_comment
comment|/* Linkage of an object that appears in a namespace.  */
end_comment

begin_enum
enum|enum
name|debug_object_linkage
block|{
comment|/* Local variable.  */
name|DEBUG_LINKAGE_AUTOMATIC
block|,
comment|/* Static--either file static or function static, depending upon the      namespace is.  */
name|DEBUG_LINKAGE_STATIC
block|,
comment|/* Global.  */
name|DEBUG_LINKAGE_GLOBAL
block|,
comment|/* No linkage.  */
name|DEBUG_LINKAGE_NONE
block|}
enum|;
end_enum

begin_comment
comment|/* A name in a namespace.  */
end_comment

begin_struct
struct|struct
name|debug_name
block|{
comment|/* Next name in this namespace.  */
name|struct
name|debug_name
modifier|*
name|next
decl_stmt|;
comment|/* Name.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Mark.  This is used by debug_write.  */
name|unsigned
name|int
name|mark
decl_stmt|;
comment|/* Kind of object.  */
name|enum
name|debug_object_kind
name|kind
decl_stmt|;
comment|/* Linkage of object.  */
name|enum
name|debug_object_linkage
name|linkage
decl_stmt|;
comment|/* Tagged union with additional information about the object.  */
union|union
block|{
comment|/* DEBUG_OBJECT_TYPE.  */
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
comment|/* DEBUG_OBJECT_TAG.  */
name|struct
name|debug_type
modifier|*
name|tag
decl_stmt|;
comment|/* DEBUG_OBJECT_VARIABLE.  */
name|struct
name|debug_variable
modifier|*
name|variable
decl_stmt|;
comment|/* DEBUG_OBJECT_FUNCTION.  */
name|struct
name|debug_function
modifier|*
name|function
decl_stmt|;
comment|/* DEBUG_OBJECT_INT_CONSTANT.  */
name|bfd_vma
name|int_constant
decl_stmt|;
comment|/* DEBUG_OBJECT_FLOAT_CONSTANT.  */
name|double
name|float_constant
decl_stmt|;
comment|/* DEBUG_OBJECT_TYPED_CONSTANT.  */
name|struct
name|debug_typed_constant
modifier|*
name|typed_constant
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* During debug_write, a linked list of these structures is used to    keep track of ID numbers that have been assigned to classes.  */
end_comment

begin_struct
struct|struct
name|debug_class_id
block|{
comment|/* Next ID number.  */
name|struct
name|debug_class_id
modifier|*
name|next
decl_stmt|;
comment|/* The type with the ID.  */
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
comment|/* The tag; NULL if no tag.  */
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* During debug_type_samep, a linked list of these structures is kept    on the stack to avoid infinite recursion.  */
end_comment

begin_struct
struct|struct
name|debug_type_compare_list
block|{
comment|/* Next type on list.  */
name|struct
name|debug_type_compare_list
modifier|*
name|next
decl_stmt|;
comment|/* The types we are comparing.  */
name|struct
name|debug_type
modifier|*
name|t1
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t2
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|debug_error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debug_name
modifier|*
name|debug_add_to_namespace
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
expr|struct
name|debug_namespace
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_object_kind
operator|,
expr|enum
name|debug_object_linkage
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debug_name
modifier|*
name|debug_add_to_current_namespace
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_object_kind
operator|,
expr|enum
name|debug_object_linkage
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debug_type
modifier|*
name|debug_make_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
expr|enum
name|debug_type_kind
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|debug_type
modifier|*
name|debug_get_real_type
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|debug_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|debug_name
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|debug_type
operator|*
operator|,
expr|struct
name|debug_name
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_class_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|debug_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_function
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
expr|enum
name|debug_object_linkage
operator|,
expr|struct
name|debug_function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
expr|struct
name|debug_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_write_linenos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
expr|struct
name|debug_write_fns
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_set_class_id
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_type_samep
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
expr|struct
name|debug_type
operator|*
operator|,
expr|struct
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|debug_class_type_samep
name|PARAMS
argument_list|(
operator|(
expr|struct
name|debug_handle
operator|*
operator|,
expr|struct
name|debug_type
operator|*
operator|,
expr|struct
name|debug_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Issue an error message.  */
end_comment

begin_function
specifier|static
name|void
name|debug_error
parameter_list|(
name|message
parameter_list|)
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an object to a namespace.  */
end_comment

begin_function
specifier|static
name|struct
name|debug_name
modifier|*
name|debug_add_to_namespace
parameter_list|(
name|info
parameter_list|,
name|nsp
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|linkage
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
name|struct
name|debug_namespace
modifier|*
modifier|*
name|nsp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_object_kind
name|kind
decl_stmt|;
name|enum
name|debug_object_linkage
name|linkage
decl_stmt|;
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_namespace
modifier|*
name|ns
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|n
operator|->
name|linkage
operator|=
name|linkage
expr_stmt|;
name|ns
operator|=
operator|*
name|nsp
expr_stmt|;
if|if
condition|(
name|ns
operator|==
name|NULL
condition|)
block|{
name|ns
operator|=
operator|(
expr|struct
name|debug_namespace
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ns
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ns
argument_list|)
expr_stmt|;
name|ns
operator|->
name|tail
operator|=
operator|&
name|ns
operator|->
name|list
expr_stmt|;
operator|*
name|nsp
operator|=
name|ns
expr_stmt|;
block|}
operator|*
name|ns
operator|->
name|tail
operator|=
name|n
expr_stmt|;
name|ns
operator|->
name|tail
operator|=
operator|&
name|n
operator|->
name|next
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Add an object to the current namespace.  */
end_comment

begin_function
specifier|static
name|struct
name|debug_name
modifier|*
name|debug_add_to_current_namespace
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|,
name|linkage
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_object_kind
name|kind
decl_stmt|;
name|enum
name|debug_object_linkage
name|linkage
decl_stmt|;
block|{
name|struct
name|debug_namespace
modifier|*
modifier|*
name|nsp
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_file
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_add_to_current_namespace: no current file"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|info
operator|->
name|current_block
operator|!=
name|NULL
condition|)
name|nsp
operator|=
operator|&
name|info
operator|->
name|current_block
operator|->
name|locals
expr_stmt|;
else|else
name|nsp
operator|=
operator|&
name|info
operator|->
name|current_file
operator|->
name|globals
expr_stmt|;
return|return
name|debug_add_to_namespace
argument_list|(
name|info
argument_list|,
name|nsp
argument_list|,
name|name
argument_list|,
name|kind
argument_list|,
name|linkage
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a handle for debugging information.  */
end_comment

begin_function
name|PTR
name|debug_init
parameter_list|()
block|{
name|struct
name|debug_handle
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Set the source filename.  This implicitly starts a new compilation    unit.  */
end_comment

begin_function
name|boolean
name|debug_set_filename
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_file
modifier|*
name|nfile
decl_stmt|;
name|struct
name|debug_unit
modifier|*
name|nunit
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
name|nfile
operator|=
operator|(
expr|struct
name|debug_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nfile
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nfile
argument_list|)
expr_stmt|;
name|nfile
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|nunit
operator|=
operator|(
expr|struct
name|debug_unit
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nunit
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nunit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|nunit
argument_list|)
expr_stmt|;
name|nunit
operator|->
name|files
operator|=
name|nfile
expr_stmt|;
name|info
operator|->
name|current_file
operator|=
name|nfile
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|!=
name|NULL
condition|)
name|info
operator|->
name|current_unit
operator|->
name|next
operator|=
name|nunit
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|info
operator|->
name|units
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|info
operator|->
name|units
operator|=
name|nunit
expr_stmt|;
block|}
name|info
operator|->
name|current_unit
operator|=
name|nunit
expr_stmt|;
name|info
operator|->
name|current_function
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|current_block
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|current_lineno
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Change source files to the given file name.  This is used for    include files in a single compilation unit.  */
end_comment

begin_function
name|boolean
name|debug_start_source
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_file
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|pf
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_start_source: no debug_set_filename call"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|f
operator|=
name|info
operator|->
name|current_unit
operator|->
name|files
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|filename
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|f
operator|->
name|filename
index|[
literal|1
index|]
operator|==
name|name
index|[
literal|1
index|]
operator|&&
name|strcmp
argument_list|(
name|f
operator|->
name|filename
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|current_file
operator|=
name|f
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
name|f
operator|=
operator|(
expr|struct
name|debug_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|filename
operator|=
name|name
expr_stmt|;
for|for
control|(
name|pf
operator|=
operator|&
name|info
operator|->
name|current_file
operator|->
name|next
init|;
operator|*
name|pf
operator|!=
name|NULL
condition|;
name|pf
operator|=
operator|&
operator|(
operator|*
name|pf
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
name|info
operator|->
name|current_file
operator|=
name|f
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a function definition.  This implicitly starts a function    block.  The debug_type argument is the type of the return value.    The boolean indicates whether the function is globally visible.    The bfd_vma is the address of the start of the function.  Currently    the parameter types are specified by calls to    debug_record_parameter.  FIXME: There is no way to specify nested    functions.  */
end_comment

begin_function
name|boolean
name|debug_record_function
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|return_type
parameter_list|,
name|global
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|return_type
decl_stmt|;
name|boolean
name|global
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_function
modifier|*
name|f
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|b
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_record_function: no debug_set_filename call"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|f
operator|=
operator|(
expr|struct
name|debug_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|return_type
operator|=
name|return_type
expr_stmt|;
name|b
operator|=
operator|(
expr|struct
name|debug_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|start
operator|=
name|addr
expr_stmt|;
name|b
operator|->
name|end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|f
operator|->
name|blocks
operator|=
name|b
expr_stmt|;
name|info
operator|->
name|current_function
operator|=
name|f
expr_stmt|;
name|info
operator|->
name|current_block
operator|=
name|b
expr_stmt|;
comment|/* FIXME: If we could handle nested functions, this would be the      place: we would want to use a different namespace.  */
name|n
operator|=
name|debug_add_to_namespace
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|current_file
operator|->
name|globals
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_FUNCTION
argument_list|,
operator|(
name|global
condition|?
name|DEBUG_LINKAGE_GLOBAL
else|:
name|DEBUG_LINKAGE_STATIC
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|->
name|u
operator|.
name|function
operator|=
name|f
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a parameter for the current function.  */
end_comment

begin_function
name|boolean
name|debug_record_parameter
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_parm_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_parameter
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_function
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_record_parameter: no current function"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|p
operator|=
operator|(
expr|struct
name|debug_parameter
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|val
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|info
operator|->
name|current_function
operator|->
name|parameters
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* End a function.  FIXME: This should handle function nesting.  */
end_comment

begin_function
name|boolean
name|debug_end_function
parameter_list|(
name|handle
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_block
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_function
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_end_function: no current function"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|current_block
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_end_function: some blocks were not closed"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|info
operator|->
name|current_block
operator|->
name|end
operator|=
name|addr
expr_stmt|;
name|info
operator|->
name|current_function
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|current_block
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a block in a function.  All local information will be    recorded in this block, until the matching call to debug_end_block.    debug_start_block and debug_end_block may be nested.  The bfd_vma    argument is the address at which this block starts.  */
end_comment

begin_function
name|boolean
name|debug_start_block
parameter_list|(
name|handle
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|b
decl_stmt|,
modifier|*
modifier|*
name|pb
decl_stmt|;
comment|/* We must always have a current block: debug_record_function sets      one up.  */
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_block
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_start_block: no current block"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|b
operator|=
operator|(
expr|struct
name|debug_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|parent
operator|=
name|info
operator|->
name|current_block
expr_stmt|;
name|b
operator|->
name|start
operator|=
name|addr
expr_stmt|;
name|b
operator|->
name|end
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* This new block is a child of the current block.  */
for|for
control|(
name|pb
operator|=
operator|&
name|info
operator|->
name|current_block
operator|->
name|children
init|;
operator|*
name|pb
operator|!=
name|NULL
condition|;
name|pb
operator|=
operator|&
operator|(
operator|*
name|pb
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pb
operator|=
name|b
expr_stmt|;
name|info
operator|->
name|current_block
operator|=
name|b
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish a block in a function.  This matches the call to    debug_start_block.  The argument is the address at which this block    ends.  */
end_comment

begin_function
name|boolean
name|debug_end_block
parameter_list|(
name|handle
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_block
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_end_block: no current block"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|parent
operator|=
name|info
operator|->
name|current_block
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_end_block: attempt to close top level block"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|info
operator|->
name|current_block
operator|->
name|end
operator|=
name|addr
expr_stmt|;
name|info
operator|->
name|current_block
operator|=
name|parent
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Associate a line number in the current source file and function    with a given address.  */
end_comment

begin_function
name|boolean
name|debug_record_line
parameter_list|(
name|handle
parameter_list|,
name|lineno
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|unsigned
name|long
name|lineno
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_lineno
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_record_line: no current unit"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|l
operator|=
name|info
operator|->
name|current_lineno
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|file
operator|==
name|info
operator|->
name|current_file
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEBUG_LINENO_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|->
name|linenos
index|[
name|i
index|]
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|l
operator|->
name|linenos
index|[
name|i
index|]
operator|=
name|lineno
expr_stmt|;
name|l
operator|->
name|addrs
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
comment|/* If we get here, then either 1) there is no current_lineno      structure, which means this is the first line number in this      compilation unit, 2) the current_lineno structure is for a      different file, or 3) the current_lineno structure is full.      Regardless, we want to allocate a new debug_lineno structure, put      it in the right place, and make it the new current_lineno      structure.  */
name|l
operator|=
operator|(
expr|struct
name|debug_lineno
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|l
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|file
operator|=
name|info
operator|->
name|current_file
expr_stmt|;
name|l
operator|->
name|linenos
index|[
literal|0
index|]
operator|=
name|lineno
expr_stmt|;
name|l
operator|->
name|addrs
index|[
literal|0
index|]
operator|=
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|DEBUG_LINENO_COUNT
condition|;
name|i
operator|++
control|)
name|l
operator|->
name|linenos
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|current_lineno
operator|!=
name|NULL
condition|)
name|info
operator|->
name|current_lineno
operator|->
name|next
operator|=
name|l
expr_stmt|;
else|else
name|info
operator|->
name|current_unit
operator|->
name|linenos
operator|=
name|l
expr_stmt|;
name|info
operator|->
name|current_lineno
operator|=
name|l
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Start a named common block.  This is a block of variables that may    move in memory.  */
end_comment

begin_function
name|boolean
name|debug_start_common_block
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* FIXME */
name|debug_error
argument_list|(
literal|"debug_start_common_block: not implemented"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* End a named common block.  */
end_comment

begin_function
name|boolean
name|debug_end_common_block
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* FIXME */
name|debug_error
argument_list|(
literal|"debug_end_common_block: not implemented"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Record a named integer constant.  */
end_comment

begin_function
name|boolean
name|debug_record_int_const
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|=
name|debug_add_to_current_namespace
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_INT_CONSTANT
argument_list|,
name|DEBUG_LINKAGE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|->
name|u
operator|.
name|int_constant
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a named floating point constant.  */
end_comment

begin_function
name|boolean
name|debug_record_float_const
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|double
name|val
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|=
name|debug_add_to_current_namespace
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_FLOAT_CONSTANT
argument_list|,
name|DEBUG_LINKAGE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|->
name|u
operator|.
name|float_constant
operator|=
name|val
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a typed constant with an integral value.  */
end_comment

begin_function
name|boolean
name|debug_record_typed_const
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_typed_constant
modifier|*
name|tc
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|n
operator|=
name|debug_add_to_current_namespace
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_TYPED_CONSTANT
argument_list|,
name|DEBUG_LINKAGE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|tc
operator|=
operator|(
expr|struct
name|debug_typed_constant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|tc
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|typed_constant
operator|=
name|tc
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Record a label.  */
end_comment

begin_function
name|boolean
name|debug_record_label
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|addr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
comment|/* FIXME.  */
name|debug_error
argument_list|(
literal|"debug_record_label not implemented"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Record a variable.  */
end_comment

begin_function
name|boolean
name|debug_record_variable
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|kind
parameter_list|,
name|val
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_var_kind
name|kind
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_namespace
modifier|*
modifier|*
name|nsp
decl_stmt|;
name|enum
name|debug_object_linkage
name|linkage
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_variable
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|type
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_file
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_record_variable: no current file"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|DEBUG_GLOBAL
operator|||
name|kind
operator|==
name|DEBUG_STATIC
condition|)
block|{
name|nsp
operator|=
operator|&
name|info
operator|->
name|current_file
operator|->
name|globals
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|DEBUG_GLOBAL
condition|)
name|linkage
operator|=
name|DEBUG_LINKAGE_GLOBAL
expr_stmt|;
else|else
name|linkage
operator|=
name|DEBUG_LINKAGE_STATIC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|current_block
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_record_variable: no current block"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|nsp
operator|=
operator|&
name|info
operator|->
name|current_block
operator|->
name|locals
expr_stmt|;
name|linkage
operator|=
name|DEBUG_LINKAGE_AUTOMATIC
expr_stmt|;
block|}
name|n
operator|=
name|debug_add_to_namespace
argument_list|(
name|info
argument_list|,
name|nsp
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_VARIABLE
argument_list|,
name|linkage
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|v
operator|=
operator|(
expr|struct
name|debug_variable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|v
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|v
argument_list|)
expr_stmt|;
name|v
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|v
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|n
operator|->
name|u
operator|.
name|variable
operator|=
name|v
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make a type with a given kind and size.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|struct
name|debug_type
modifier|*
name|debug_make_type
parameter_list|(
name|info
parameter_list|,
name|kind
parameter_list|,
name|size
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|debug_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|t
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make an indirect type which may be used as a placeholder for a type    which is referenced before it is defined.  */
end_comment

begin_function
name|debug_type
name|debug_make_indirect_type
parameter_list|(
name|handle
parameter_list|,
name|slot
parameter_list|,
name|tag
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
modifier|*
name|slot
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_indirect_type
modifier|*
name|i
decl_stmt|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_INDIRECT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|i
operator|=
operator|(
expr|struct
name|debug_indirect_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|i
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|i
argument_list|)
expr_stmt|;
name|i
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
name|i
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kindirect
operator|=
name|i
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a void type.  There is only one of these.  */
end_comment

begin_function
name|debug_type
name|debug_make_void_type
parameter_list|(
name|handle
parameter_list|)
name|PTR
name|handle
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_VOID
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an integer type of a given size.  The boolean argument is true    if the integer is unsigned.  */
end_comment

begin_function
name|debug_type
name|debug_make_int_type
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|,
name|unsignedp
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|boolean
name|unsignedp
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_INT
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|->
name|u
operator|.
name|kint
operator|=
name|unsignedp
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a floating point type of a given size.  FIXME: On some    platforms, like an Alpha, you probably need to be able to specify    the format.  */
end_comment

begin_function
name|debug_type
name|debug_make_float_type
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_FLOAT
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a boolean type of a given size.  */
end_comment

begin_function
name|debug_type
name|debug_make_bool_type
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_BOOL
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a complex type of a given size.  */
end_comment

begin_function
name|debug_type
name|debug_make_complex_type
parameter_list|(
name|handle
parameter_list|,
name|size
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
return|return
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_COMPLEX
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a structure type.  The second argument is true for a struct,    false for a union.  The third argument is the size of the struct.    The fourth argument is a NULL terminated array of fields.  */
end_comment

begin_function
name|debug_type
name|debug_make_struct_type
parameter_list|(
name|handle
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|,
name|fields
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_class_type
modifier|*
name|c
decl_stmt|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|structp
condition|?
name|DEBUG_KIND_STRUCT
else|:
name|DEBUG_KIND_UNION
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|c
operator|=
operator|(
expr|struct
name|debug_class_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|fields
operator|=
name|fields
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kclass
operator|=
name|c
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make an object type.  The first three arguments after the handle    are the same as for debug_make_struct_type.  The next arguments are    a NULL terminated array of base classes, a NULL terminated array of    methods, the type of the object holding the virtual function table    if it is not this object, and a boolean which is true if this    object has its own virtual function table.  */
end_comment

begin_function
name|debug_type
name|debug_make_object_type
parameter_list|(
name|handle
parameter_list|,
name|structp
parameter_list|,
name|size
parameter_list|,
name|fields
parameter_list|,
name|baseclasses
parameter_list|,
name|methods
parameter_list|,
name|vptrbase
parameter_list|,
name|ownvptr
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|boolean
name|structp
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|debug_field
modifier|*
name|fields
decl_stmt|;
name|debug_baseclass
modifier|*
name|baseclasses
decl_stmt|;
name|debug_method
modifier|*
name|methods
decl_stmt|;
name|debug_type
name|vptrbase
decl_stmt|;
name|boolean
name|ownvptr
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_class_type
modifier|*
name|c
decl_stmt|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|structp
condition|?
name|DEBUG_KIND_CLASS
else|:
name|DEBUG_KIND_UNION_CLASS
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|c
operator|=
operator|(
expr|struct
name|debug_class_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|fields
operator|=
name|fields
expr_stmt|;
name|c
operator|->
name|baseclasses
operator|=
name|baseclasses
expr_stmt|;
name|c
operator|->
name|methods
operator|=
name|methods
expr_stmt|;
if|if
condition|(
name|ownvptr
condition|)
name|c
operator|->
name|vptrbase
operator|=
name|t
expr_stmt|;
else|else
name|c
operator|->
name|vptrbase
operator|=
name|vptrbase
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kclass
operator|=
name|c
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make an enumeration type.  The arguments are a null terminated    array of strings, and an array of corresponding values.  */
end_comment

begin_function
name|debug_type
name|debug_make_enum_type
parameter_list|(
name|handle
parameter_list|,
name|names
parameter_list|,
name|values
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|values
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_enum_type
modifier|*
name|e
decl_stmt|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_ENUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|e
operator|=
operator|(
expr|struct
name|debug_enum_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|names
operator|=
name|names
expr_stmt|;
name|e
operator|->
name|values
operator|=
name|values
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kenum
operator|=
name|e
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a pointer to a given type.  */
end_comment

begin_function
name|debug_type
name|debug_make_pointer_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|type
operator|->
name|pointer
operator|!=
name|DEBUG_TYPE_NULL
condition|)
return|return
name|type
operator|->
name|pointer
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_POINTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|->
name|u
operator|.
name|kpointer
operator|=
name|type
expr_stmt|;
name|type
operator|->
name|pointer
operator|=
name|t
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a function returning a given type.  FIXME: We should be able    to record the parameter types.  */
end_comment

begin_function
name|debug_type
name|debug_make_function_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|arg_types
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_function_type
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_FUNCTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|f
operator|=
operator|(
expr|struct
name|debug_function_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|return_type
operator|=
name|type
expr_stmt|;
name|f
operator|->
name|arg_types
operator|=
name|arg_types
expr_stmt|;
name|f
operator|->
name|varargs
operator|=
name|varargs
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kfunction
operator|=
name|f
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a reference to a given type.  */
end_comment

begin_function
name|debug_type
name|debug_make_reference_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_REFERENCE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|->
name|u
operator|.
name|kreference
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a range of a given type from a lower to an upper bound.  */
end_comment

begin_function
name|debug_type
name|debug_make_range_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_signed_vma
name|lower
decl_stmt|;
name|bfd_signed_vma
name|upper
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_range_type
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|r
operator|=
operator|(
expr|struct
name|debug_range_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|r
operator|->
name|lower
operator|=
name|lower
expr_stmt|;
name|r
operator|->
name|upper
operator|=
name|upper
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|krange
operator|=
name|r
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make an array type.  The second argument is the type of an element    of the array.  The third argument is the type of a range of the    array.  The fourth and fifth argument are the lower and upper    bounds, respectively.  The sixth argument is true if this array is    actually a string, as in C.  */
end_comment

begin_function
name|debug_type
name|debug_make_array_type
parameter_list|(
name|handle
parameter_list|,
name|element_type
parameter_list|,
name|range_type
parameter_list|,
name|lower
parameter_list|,
name|upper
parameter_list|,
name|stringp
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|element_type
decl_stmt|;
name|debug_type
name|range_type
decl_stmt|;
name|bfd_signed_vma
name|lower
decl_stmt|;
name|bfd_signed_vma
name|upper
decl_stmt|;
name|boolean
name|stringp
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_array_type
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|element_type
operator|==
name|NULL
operator|||
name|range_type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_ARRAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|a
operator|=
operator|(
expr|struct
name|debug_array_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|element_type
operator|=
name|element_type
expr_stmt|;
name|a
operator|->
name|range_type
operator|=
name|range_type
expr_stmt|;
name|a
operator|->
name|lower
operator|=
name|lower
expr_stmt|;
name|a
operator|->
name|upper
operator|=
name|upper
expr_stmt|;
name|a
operator|->
name|stringp
operator|=
name|stringp
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|karray
operator|=
name|a
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a set of a given type.  For example, a Pascal set type.  The    boolean argument is true if this set is actually a bitstring, as in    CHILL.  */
end_comment

begin_function
name|debug_type
name|debug_make_set_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|bitstringp
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|boolean
name|bitstringp
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_set_type
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_SET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|s
operator|=
operator|(
expr|struct
name|debug_set_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|s
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|s
operator|->
name|bitstringp
operator|=
name|bitstringp
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kset
operator|=
name|s
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a type for a pointer which is relative to an object.  The    second argument is the type of the object to which the pointer is    relative.  The third argument is the type that the pointer points    to.  */
end_comment

begin_function
name|debug_type
name|debug_make_offset_type
parameter_list|(
name|handle
parameter_list|,
name|base_type
parameter_list|,
name|target_type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|base_type
decl_stmt|;
name|debug_type
name|target_type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_offset_type
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|base_type
operator|==
name|NULL
operator|||
name|target_type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|o
operator|=
operator|(
expr|struct
name|debug_offset_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|o
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|o
argument_list|)
expr_stmt|;
name|o
operator|->
name|base_type
operator|=
name|base_type
expr_stmt|;
name|o
operator|->
name|target_type
operator|=
name|target_type
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|koffset
operator|=
name|o
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a type for a method function.  The second argument is the    return type, the third argument is the domain, and the fourth    argument is a NULL terminated array of argument types.  */
end_comment

begin_function
name|debug_type
name|debug_make_method_type
parameter_list|(
name|handle
parameter_list|,
name|return_type
parameter_list|,
name|domain_type
parameter_list|,
name|arg_types
parameter_list|,
name|varargs
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|return_type
decl_stmt|;
name|debug_type
name|domain_type
decl_stmt|;
name|debug_type
modifier|*
name|arg_types
decl_stmt|;
name|boolean
name|varargs
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_method_type
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|return_type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_METHOD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|m
operator|=
operator|(
expr|struct
name|debug_method_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|return_type
operator|=
name|return_type
expr_stmt|;
name|m
operator|->
name|domain_type
operator|=
name|domain_type
expr_stmt|;
name|m
operator|->
name|arg_types
operator|=
name|arg_types
expr_stmt|;
name|m
operator|->
name|varargs
operator|=
name|varargs
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|kmethod
operator|=
name|m
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a const qualified version of a given type.  */
end_comment

begin_function
name|debug_type
name|debug_make_const_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_CONST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|->
name|u
operator|.
name|kconst
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make a volatile qualified version of a given type.  */
end_comment

begin_function
name|debug_type
name|debug_make_volatile_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_VOLATILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|t
operator|->
name|u
operator|.
name|kvolatile
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Make an undefined tagged type.  For example, a struct which has    been mentioned, but not defined.  */
end_comment

begin_function
name|debug_type
name|debug_make_undefined_tagged_type
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|DEBUG_KIND_STRUCT
case|:
case|case
name|DEBUG_KIND_UNION
case|:
case|case
name|DEBUG_KIND_CLASS
case|:
case|case
name|DEBUG_KIND_UNION_CLASS
case|:
case|case
name|DEBUG_KIND_ENUM
case|:
break|break;
default|default:
name|debug_error
argument_list|(
literal|"debug_make_undefined_type: unsupported kind"
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|kind
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
return|return
name|debug_tag_type
argument_list|(
name|handle
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a base class for an object.  The second argument is the base    class type.  The third argument is the bit position of this base    class in the object (always 0 unless doing multiple inheritance).    The fourth argument is whether this is a virtual class.  The fifth    argument is the visibility of the base class.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_baseclass
name|debug_make_baseclass
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|bitpos
parameter_list|,
name|virtual
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|boolean
name|virtual
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|debug_baseclass
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|debug_baseclass
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|bitpos
operator|=
name|bitpos
expr_stmt|;
name|b
operator|->
name|virtual
operator|=
name|virtual
expr_stmt|;
name|b
operator|->
name|visibility
operator|=
name|visibility
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Make a field for a struct.  The second argument is the name.  The    third argument is the type of the field.  The fourth argument is    the bit position of the field.  The fifth argument is the size of    the field (it may be zero).  The sixth argument is the visibility    of the field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_field
name|debug_make_field
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|bfd_vma
name|bitpos
decl_stmt|;
name|bfd_vma
name|bitsize
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|debug_field
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|f
operator|->
name|static_member
operator|=
name|false
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
operator|=
name|bitpos
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
operator|=
name|bitsize
expr_stmt|;
name|f
operator|->
name|visibility
operator|=
name|visibility
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Make a static member of an object.  The second argument is the    name.  The third argument is the type of the member.  The fourth    argument is the physical name of the member (i.e., the name as a    global variable).  The fifth argument is the visibility of the    member.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_field
name|debug_make_static_member
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|,
name|physname
parameter_list|,
name|visibility
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
block|{
name|struct
name|debug_field
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|debug_field
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|f
argument_list|)
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|f
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|f
operator|->
name|static_member
operator|=
name|true
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|s
operator|.
name|physname
operator|=
name|physname
expr_stmt|;
name|f
operator|->
name|visibility
operator|=
name|visibility
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Make a method.  The second argument is the name, and the third    argument is a NULL terminated array of method variants.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_method
name|debug_make_method
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|variants
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_method_variant
modifier|*
name|variants
decl_stmt|;
block|{
name|struct
name|debug_method
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|debug_method
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|m
operator|->
name|variants
operator|=
name|variants
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Make a method argument.  The second argument is the real name of    the function.  The third argument is the type of the function.  The    fourth argument is the visibility.  The fifth argument is whether    this is a const function.  The sixth argument is whether this is a    volatile function.  The seventh argument is the offset in the    virtual function table, if any.  The eighth argument is the virtual    function context.  FIXME: Are the const and volatile arguments    necessary?  Could we just use debug_make_const_type?  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_method_variant
name|debug_make_method_variant
parameter_list|(
name|handle
parameter_list|,
name|physname
parameter_list|,
name|type
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|,
name|voffset
parameter_list|,
name|context
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
name|bfd_vma
name|voffset
decl_stmt|;
name|debug_type
name|context
decl_stmt|;
block|{
name|struct
name|debug_method_variant
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|debug_method_variant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|physname
operator|=
name|physname
expr_stmt|;
name|m
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|m
operator|->
name|visibility
operator|=
name|visibility
expr_stmt|;
name|m
operator|->
name|constp
operator|=
name|constp
expr_stmt|;
name|m
operator|->
name|volatilep
operator|=
name|volatilep
expr_stmt|;
name|m
operator|->
name|voffset
operator|=
name|voffset
expr_stmt|;
name|m
operator|->
name|context
operator|=
name|context
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Make a static method argument.  The arguments are the same as for    debug_make_method_variant, except that the last two are omitted    since a static method can not also be virtual.  */
end_comment

begin_function
name|debug_method_variant
name|debug_make_static_method_variant
parameter_list|(
name|handle
parameter_list|,
name|physname
parameter_list|,
name|type
parameter_list|,
name|visibility
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|physname
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|enum
name|debug_visibility
name|visibility
decl_stmt|;
name|boolean
name|constp
decl_stmt|;
name|boolean
name|volatilep
decl_stmt|;
block|{
name|struct
name|debug_method_variant
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|debug_method_variant
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|physname
operator|=
name|physname
expr_stmt|;
name|m
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|m
operator|->
name|visibility
operator|=
name|visibility
expr_stmt|;
name|m
operator|->
name|constp
operator|=
name|constp
expr_stmt|;
name|m
operator|->
name|volatilep
operator|=
name|volatilep
expr_stmt|;
name|m
operator|->
name|voffset
operator|=
name|VOFFSET_STATIC_METHOD
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Name a type.  */
end_comment

begin_function
name|debug_type
name|debug_name_type
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_named_type
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
operator|||
name|info
operator|->
name|current_file
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_name_type: no current file"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_NAMED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|n
operator|=
operator|(
expr|struct
name|debug_named_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|knamed
operator|=
name|n
expr_stmt|;
comment|/* We always add the name to the global namespace.  This is probably      wrong in some cases, but it seems to be right for stabs.  FIXME.  */
name|nm
operator|=
name|debug_add_to_namespace
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|current_file
operator|->
name|globals
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_TYPE
argument_list|,
name|DEBUG_LINKAGE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|nm
operator|->
name|u
operator|.
name|type
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|nm
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Tag a type.  */
end_comment

begin_function
name|debug_type
name|debug_tag_type
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t
decl_stmt|;
name|struct
name|debug_named_type
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|nm
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
if|if
condition|(
name|info
operator|->
name|current_file
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_tag_type: no current file"
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
if|if
condition|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|type
return|;
name|debug_error
argument_list|(
literal|"debug_tag_type: extra tag attempted"
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
name|t
operator|=
name|debug_make_type
argument_list|(
name|info
argument_list|,
name|DEBUG_KIND_TAGGED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|n
operator|=
operator|(
expr|struct
name|debug_named_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|knamed
operator|=
name|n
expr_stmt|;
comment|/* We keep a global namespace of tags for each compilation unit.  I      don't know if that is the right thing to do.  */
name|nm
operator|=
name|debug_add_to_namespace
argument_list|(
name|info
argument_list|,
operator|&
name|info
operator|->
name|current_file
operator|->
name|globals
argument_list|,
name|name
argument_list|,
name|DEBUG_OBJECT_TAG
argument_list|,
name|DEBUG_LINKAGE_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|nm
operator|->
name|u
operator|.
name|tag
operator|=
name|t
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|nm
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Record the size of a given type.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|boolean
name|debug_record_type_size
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|->
name|size
operator|!=
literal|0
operator|&&
name|type
operator|->
name|size
operator|!=
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: changing type size from %d to %d\n"
argument_list|,
name|type
operator|->
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|type
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find a named type.  */
end_comment

begin_function
name|debug_type
name|debug_find_named_type
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|b
decl_stmt|;
name|struct
name|debug_file
modifier|*
name|f
decl_stmt|;
comment|/* We only search the current compilation unit.  I don't know if      this is right or not.  */
if|if
condition|(
name|info
operator|->
name|current_unit
operator|==
name|NULL
condition|)
block|{
name|debug_error
argument_list|(
literal|"debug_find_named_type: no current compilation unit"
argument_list|)
expr_stmt|;
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
for|for
control|(
name|b
operator|=
name|info
operator|->
name|current_block
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|b
operator|->
name|locals
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|b
operator|->
name|locals
operator|->
name|list
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|kind
operator|==
name|DEBUG_OBJECT_TYPE
operator|&&
name|n
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n
operator|->
name|u
operator|.
name|type
return|;
block|}
block|}
block|}
for|for
control|(
name|f
operator|=
name|info
operator|->
name|current_unit
operator|->
name|files
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|f
operator|->
name|globals
operator|->
name|list
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|kind
operator|==
name|DEBUG_OBJECT_TYPE
operator|&&
name|n
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n
operator|->
name|u
operator|.
name|type
return|;
block|}
block|}
block|}
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
end_function

begin_comment
comment|/* Find a tagged type.  */
end_comment

begin_function
name|debug_type
name|debug_find_tagged_type
parameter_list|(
name|handle
parameter_list|,
name|name
parameter_list|,
name|kind
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_type_kind
name|kind
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_unit
modifier|*
name|u
decl_stmt|;
comment|/* We search the globals of all the compilation units.  I don't know      if this is correct or not.  It would be easy to change.  */
for|for
control|(
name|u
operator|=
name|info
operator|->
name|units
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|next
control|)
block|{
name|struct
name|debug_file
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|u
operator|->
name|files
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
name|f
operator|->
name|globals
operator|->
name|list
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|kind
operator|==
name|DEBUG_OBJECT_TAG
operator|&&
operator|(
name|kind
operator|==
name|DEBUG_KIND_ILLEGAL
operator|||
name|n
operator|->
name|u
operator|.
name|tag
operator|->
name|kind
operator|==
name|kind
operator|)
operator|&&
name|n
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|n
operator|->
name|u
operator|.
name|tag
return|;
block|}
block|}
block|}
block|}
return|return
name|DEBUG_TYPE_NULL
return|;
block|}
end_function

begin_comment
comment|/* Get a base type.  */
end_comment

begin_function
specifier|static
name|struct
name|debug_type
modifier|*
name|debug_get_real_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
name|type
return|;
case|case
name|DEBUG_KIND_INDIRECT
case|:
if|if
condition|(
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
operator|!=
name|NULL
condition|)
return|return
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
argument_list|)
return|;
return|return
name|type
return|;
case|case
name|DEBUG_KIND_NAMED
case|:
case|case
name|DEBUG_KIND_TAGGED
case|:
return|return
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the kind of a type.  */
end_comment

begin_function
name|enum
name|debug_type_kind
name|debug_get_type_kind
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_KIND_ILLEGAL
return|;
name|type
operator|=
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
operator|->
name|kind
return|;
block|}
end_function

begin_comment
comment|/* Get the name of a type.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|debug_get_type_name
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_INDIRECT
condition|)
block|{
if|if
condition|(
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
operator|!=
name|NULL
condition|)
return|return
name|debug_get_type_name
argument_list|(
name|handle
argument_list|,
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
argument_list|)
return|;
return|return
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|tag
return|;
block|}
if|if
condition|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_NAMED
operator|||
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
condition|)
return|return
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get the size of a type.  */
end_comment

begin_function
name|bfd_vma
name|debug_get_type_size
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* We don't call debug_get_real_type, because somebody might have      called debug_record_type_size on a named or indirect type.  */
if|if
condition|(
name|type
operator|->
name|size
operator|!=
literal|0
condition|)
return|return
name|type
operator|->
name|size
return|;
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|DEBUG_KIND_INDIRECT
case|:
if|if
condition|(
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
operator|!=
name|NULL
condition|)
return|return
name|debug_get_type_size
argument_list|(
name|handle
argument_list|,
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|DEBUG_KIND_NAMED
case|:
case|case
name|DEBUG_KIND_TAGGED
case|:
return|return
name|debug_get_type_size
argument_list|(
name|handle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the return type of a function or method type.  */
end_comment

begin_function
name|debug_type
name|debug_get_return_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|DEBUG_TYPE_NULL
return|;
name|type
operator|=
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
name|DEBUG_TYPE_NULL
return|;
case|case
name|DEBUG_KIND_FUNCTION
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|return_type
return|;
case|case
name|DEBUG_KIND_METHOD
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|return_type
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the parameter types of a function or method type (except that    we don't currently store the parameter types of a function).  */
end_comment

begin_function
specifier|const
name|debug_type
modifier|*
name|debug_get_parameter_types
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|,
name|pvarargs
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
name|boolean
modifier|*
name|pvarargs
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|type
operator|=
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|DEBUG_KIND_FUNCTION
case|:
operator|*
name|pvarargs
operator|=
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|varargs
expr_stmt|;
return|return
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
return|;
case|case
name|DEBUG_KIND_METHOD
case|:
operator|*
name|pvarargs
operator|=
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|varargs
expr_stmt|;
return|return
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the target type of a type.  */
end_comment

begin_function
name|debug_type
name|debug_get_target_type
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|type
operator|=
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|DEBUG_KIND_POINTER
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kpointer
return|;
case|case
name|DEBUG_KIND_REFERENCE
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kreference
return|;
case|case
name|DEBUG_KIND_CONST
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kconst
return|;
case|case
name|DEBUG_KIND_VOLATILE
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kvolatile
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the NULL terminated array of fields for a struct, union, or    class.  */
end_comment

begin_function
specifier|const
name|debug_field
modifier|*
name|debug_get_fields
parameter_list|(
name|handle
parameter_list|,
name|type
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_type
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|type
operator|=
name|debug_get_real_type
argument_list|(
name|handle
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|DEBUG_KIND_STRUCT
case|:
case|case
name|DEBUG_KIND_UNION
case|:
case|case
name|DEBUG_KIND_CLASS
case|:
case|case
name|DEBUG_KIND_UNION_CLASS
case|:
return|return
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Get the type of a field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|debug_type
name|debug_get_field_type
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|field
operator|->
name|type
return|;
block|}
end_function

begin_comment
comment|/* Get the name of a field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|const
name|char
modifier|*
name|debug_get_field_name
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|field
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Get the bit position of a field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|bfd_vma
name|debug_get_field_bitpos
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
operator|||
name|field
operator|->
name|static_member
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
return|return
name|field
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
return|;
block|}
end_function

begin_comment
comment|/* Get the bit size of a field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|bfd_vma
name|debug_get_field_bitsize
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
operator|||
name|field
operator|->
name|static_member
condition|)
return|return
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
return|;
return|return
name|field
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
return|;
block|}
end_function

begin_comment
comment|/* Get the visibility of a field.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|enum
name|debug_visibility
name|debug_get_field_visibility
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
name|DEBUG_VISIBILITY_IGNORE
return|;
return|return
name|field
operator|->
name|visibility
return|;
block|}
end_function

begin_comment
comment|/* Get the physical name of a field.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|debug_get_field_physname
parameter_list|(
name|handle
parameter_list|,
name|field
parameter_list|)
name|PTR
name|handle
decl_stmt|;
name|debug_field
name|field
decl_stmt|;
block|{
if|if
condition|(
name|field
operator|==
name|NULL
operator|||
operator|!
name|field
operator|->
name|static_member
condition|)
return|return
name|NULL
return|;
return|return
name|field
operator|->
name|u
operator|.
name|s
operator|.
name|physname
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the debugging information.  This is given a handle to    debugging information, and a set of function pointers to call.  */
end_comment

begin_function
name|boolean
name|debug_write
parameter_list|(
name|handle
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|)
name|PTR
name|handle
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
block|{
name|struct
name|debug_handle
modifier|*
name|info
init|=
operator|(
expr|struct
name|debug_handle
operator|*
operator|)
name|handle
decl_stmt|;
name|struct
name|debug_unit
modifier|*
name|u
decl_stmt|;
comment|/* We use a mark to tell whether we have already written out a      particular name.  We use an integer, so that we don't have to      clear the mark fields if we happen to write out the same      information more than once.  */
operator|++
name|info
operator|->
name|mark
expr_stmt|;
comment|/* The base_id field holds an ID value which will never be used, so      that we can tell whether we have assigned an ID during this call      to debug_write.  */
name|info
operator|->
name|base_id
operator|=
name|info
operator|->
name|class_id
expr_stmt|;
comment|/* We keep a linked list of classes for which was have assigned ID's      during this call to debug_write.  */
name|info
operator|->
name|id_list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|u
operator|=
name|info
operator|->
name|units
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|next
control|)
block|{
name|struct
name|debug_file
modifier|*
name|f
decl_stmt|;
name|boolean
name|first_file
decl_stmt|;
name|info
operator|->
name|current_write_lineno
operator|=
name|u
operator|->
name|linenos
expr_stmt|;
name|info
operator|->
name|current_write_lineno_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_compilation_unit
call|)
argument_list|(
name|fhandle
argument_list|,
name|u
operator|->
name|files
operator|->
name|filename
argument_list|)
condition|)
return|return
name|false
return|;
name|first_file
operator|=
name|true
expr_stmt|;
for|for
control|(
name|f
operator|=
name|u
operator|->
name|files
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|first_file
condition|)
name|first_file
operator|=
name|false
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_source
call|)
argument_list|(
name|fhandle
argument_list|,
name|f
operator|->
name|filename
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|f
operator|->
name|globals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
name|f
operator|->
name|globals
operator|->
name|list
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|debug_write_name
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* Output any line number information which hasn't already been          handled.  */
if|if
condition|(
operator|!
name|debug_write_linenos
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an element in a namespace.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_name
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|n
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
operator|->
name|kind
condition|)
block|{
case|case
name|DEBUG_OBJECT_TYPE
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
operator|->
name|u
operator|.
name|type
argument_list|,
name|n
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|fns
operator|->
name|typdef
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
case|case
name|DEBUG_OBJECT_TAG
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
operator|->
name|u
operator|.
name|tag
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|tag
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|)
return|;
case|case
name|DEBUG_OBJECT_VARIABLE
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
operator|->
name|u
operator|.
name|variable
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|variable
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|u
operator|.
name|variable
operator|->
name|kind
argument_list|,
name|n
operator|->
name|u
operator|.
name|variable
operator|->
name|val
argument_list|)
return|;
case|case
name|DEBUG_OBJECT_FUNCTION
case|:
return|return
name|debug_write_function
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|linkage
argument_list|,
name|n
operator|->
name|u
operator|.
name|function
argument_list|)
return|;
case|case
name|DEBUG_OBJECT_INT_CONSTANT
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|int_constant
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|u
operator|.
name|int_constant
argument_list|)
return|;
case|case
name|DEBUG_OBJECT_FLOAT_CONSTANT
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|float_constant
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|u
operator|.
name|float_constant
argument_list|)
return|;
case|case
name|DEBUG_OBJECT_TYPED_CONSTANT
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
operator|->
name|u
operator|.
name|typed_constant
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|typed_constant
call|)
argument_list|(
name|fhandle
argument_list|,
name|n
operator|->
name|name
argument_list|,
name|n
operator|->
name|u
operator|.
name|typed_constant
operator|->
name|val
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Write out a type.  If the type is DEBUG_KIND_NAMED or    DEBUG_KIND_TAGGED, then the name argument is the name for which we    are about to call typedef or tag.  If the type is anything else,    then the name argument is a tag from a DEBUG_KIND_TAGGED type which    points to this one.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_type
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|type
parameter_list|,
name|name
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
name|struct
name|debug_name
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|is
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* If we have a name for this type, just output it.  We only output      typedef names after they have been defined.  We output type tags      whenever we are not actually defining them.  */
if|if
condition|(
operator|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_NAMED
operator|||
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
operator|)
operator|&&
operator|(
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|mark
operator|==
name|info
operator|->
name|mark
operator|||
operator|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
operator|&&
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|!=
name|name
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_NAMED
condition|)
return|return
call|(
modifier|*
name|fns
operator|->
name|typedef_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|)
return|;
else|else
block|{
name|struct
name|debug_type
modifier|*
name|real
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|real
operator|=
name|debug_get_real_type
argument_list|(
operator|(
name|PTR
operator|)
name|info
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|real
operator|->
name|kind
operator|==
name|DEBUG_KIND_STRUCT
operator|||
name|real
operator|->
name|kind
operator|==
name|DEBUG_KIND_UNION
operator|||
name|real
operator|->
name|kind
operator|==
name|DEBUG_KIND_CLASS
operator|||
name|real
operator|->
name|kind
operator|==
name|DEBUG_KIND_UNION_CLASS
operator|)
operator|&&
name|real
operator|->
name|u
operator|.
name|kclass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|real
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|<=
name|info
operator|->
name|base_id
condition|)
block|{
if|if
condition|(
operator|!
name|debug_set_class_id
argument_list|(
name|info
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|,
name|real
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|id
operator|=
name|real
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
expr_stmt|;
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|tag_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|,
name|id
argument_list|,
name|real
operator|->
name|kind
argument_list|)
return|;
block|}
block|}
comment|/* Mark the name after we have already looked for a known name, so      that we don't just define a type in terms of itself.  We need to      mark the name here so that a struct containing a pointer to      itself will work.  */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|name
operator|->
name|mark
operator|=
name|info
operator|->
name|mark
expr_stmt|;
name|tag
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|type
operator|->
name|kind
operator|!=
name|DEBUG_KIND_NAMED
operator|&&
name|type
operator|->
name|kind
operator|!=
name|DEBUG_KIND_TAGGED
condition|)
block|{
name|assert
argument_list|(
name|name
operator|->
name|kind
operator|==
name|DEBUG_OBJECT_TAG
argument_list|)
expr_stmt|;
name|tag
operator|=
name|name
operator|->
name|name
expr_stmt|;
block|}
switch|switch
condition|(
name|type
operator|->
name|kind
condition|)
block|{
case|case
name|DEBUG_KIND_ILLEGAL
case|:
name|debug_error
argument_list|(
literal|"debug_write_type: illegal type encountered"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|DEBUG_KIND_INDIRECT
case|:
if|if
condition|(
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
operator|==
name|DEBUG_TYPE_NULL
condition|)
return|return
call|(
modifier|*
name|fns
operator|->
name|empty_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
return|return
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
operator|*
name|type
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
argument_list|,
name|name
argument_list|)
return|;
case|case
name|DEBUG_KIND_VOID
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|void_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_INT
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|int_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|size
argument_list|,
name|type
operator|->
name|u
operator|.
name|kint
argument_list|)
return|;
case|case
name|DEBUG_KIND_FLOAT
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|float_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|size
argument_list|)
return|;
case|case
name|DEBUG_KIND_COMPLEX
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|complex_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|size
argument_list|)
return|;
case|case
name|DEBUG_KIND_BOOL
case|:
return|return
call|(
modifier|*
name|fns
operator|->
name|bool_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|size
argument_list|)
return|;
case|case
name|DEBUG_KIND_STRUCT
case|:
case|case
name|DEBUG_KIND_UNION
case|:
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|<=
name|info
operator|->
name|base_id
condition|)
block|{
if|if
condition|(
operator|!
name|debug_set_class_id
argument_list|(
name|info
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|mark
operator|==
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|mark
condition|)
block|{
comment|/* We are currently outputting this struct, or we have 		 already output it.  I don't know if this can happen, 		 but it can happen for a class.  */
name|assert
argument_list|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|>
name|info
operator|->
name|base_id
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|fns
operator|->
name|tag_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
argument_list|,
name|type
operator|->
name|kind
argument_list|)
return|;
block|}
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|mark
operator|=
name|info
operator|->
name|mark
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_struct_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
operator|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|!=
name|NULL
condition|?
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
else|:
literal|0
operator|)
argument_list|,
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_STRUCT
argument_list|,
name|type
operator|->
name|size
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|!=
name|NULL
operator|&&
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|debug_field
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|f
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|fns
operator|->
name|struct_field
call|)
argument_list|(
name|fhandle
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
argument_list|,
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
argument_list|,
name|f
operator|->
name|visibility
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|end_struct_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_CLASS
case|:
case|case
name|DEBUG_KIND_UNION_CLASS
case|:
return|return
name|debug_write_class_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
argument_list|,
name|tag
argument_list|)
return|;
case|case
name|DEBUG_KIND_ENUM
case|:
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kenum
operator|==
name|NULL
condition|)
return|return
call|(
modifier|*
name|fns
operator|->
name|enum_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|NULL
argument_list|)
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|enum_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
name|type
operator|->
name|u
operator|.
name|kenum
operator|->
name|names
argument_list|,
name|type
operator|->
name|u
operator|.
name|kenum
operator|->
name|values
argument_list|)
return|;
case|case
name|DEBUG_KIND_POINTER
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kpointer
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|pointer_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_FUNCTION
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|return_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
operator|==
name|NULL
condition|)
name|is
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|is
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
index|[
name|is
index|]
operator|!=
name|NULL
condition|;
name|is
operator|++
control|)
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
index|[
name|is
index|]
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|function_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|is
argument_list|,
name|type
operator|->
name|u
operator|.
name|kfunction
operator|->
name|varargs
argument_list|)
return|;
case|case
name|DEBUG_KIND_REFERENCE
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kreference
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|reference_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_RANGE
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|krange
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|range_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|krange
operator|->
name|lower
argument_list|,
name|type
operator|->
name|u
operator|.
name|krange
operator|->
name|upper
argument_list|)
return|;
case|case
name|DEBUG_KIND_ARRAY
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|karray
operator|->
name|element_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|karray
operator|->
name|range_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|array_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|karray
operator|->
name|lower
argument_list|,
name|type
operator|->
name|u
operator|.
name|karray
operator|->
name|upper
argument_list|,
name|type
operator|->
name|u
operator|.
name|karray
operator|->
name|stringp
argument_list|)
return|;
case|case
name|DEBUG_KIND_SET
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kset
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|set_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kset
operator|->
name|bitstringp
argument_list|)
return|;
case|case
name|DEBUG_KIND_OFFSET
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|koffset
operator|->
name|base_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|koffset
operator|->
name|target_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|offset_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_METHOD
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|return_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
operator|==
name|NULL
condition|)
name|is
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|is
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
index|[
name|is
index|]
operator|!=
name|NULL
condition|;
name|is
operator|++
control|)
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
index|[
name|is
index|]
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|domain_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|domain_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|method_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|domain_type
operator|!=
name|NULL
argument_list|,
name|is
argument_list|,
name|type
operator|->
name|u
operator|.
name|kmethod
operator|->
name|varargs
argument_list|)
return|;
case|case
name|DEBUG_KIND_CONST
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kconst
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|const_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_VOLATILE
case|:
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|kvolatile
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
call|(
modifier|*
name|fns
operator|->
name|volatile_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
case|case
name|DEBUG_KIND_NAMED
case|:
return|return
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
return|;
case|case
name|DEBUG_KIND_TAGGED
case|:
return|return
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|,
name|type
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Write out a class type.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_class_type
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|type
parameter_list|,
name|tag
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|vptrbase
decl_stmt|;
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|==
name|NULL
condition|)
block|{
name|id
operator|=
literal|0
expr_stmt|;
name|vptrbase
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|<=
name|info
operator|->
name|base_id
condition|)
block|{
if|if
condition|(
operator|!
name|debug_set_class_id
argument_list|(
name|info
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|info
operator|->
name|mark
operator|==
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|mark
condition|)
block|{
comment|/* We are currently outputting this class, or we have 	     already output it.  This can happen when there are 	     methods for an anonymous class.  */
name|assert
argument_list|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|>
name|info
operator|->
name|base_id
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|fns
operator|->
name|tag_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
argument_list|,
name|type
operator|->
name|kind
argument_list|)
return|;
block|}
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|mark
operator|=
name|info
operator|->
name|mark
expr_stmt|;
name|id
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
expr_stmt|;
name|vptrbase
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|vptrbase
expr_stmt|;
if|if
condition|(
name|vptrbase
operator|!=
name|NULL
operator|&&
name|vptrbase
operator|!=
name|type
condition|)
block|{
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|vptrbase
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_class_type
call|)
argument_list|(
name|fhandle
argument_list|,
name|tag
argument_list|,
name|id
argument_list|,
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_CLASS
argument_list|,
name|type
operator|->
name|size
argument_list|,
name|vptrbase
operator|!=
name|NULL
argument_list|,
name|vptrbase
operator|==
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|debug_field
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|fields
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|f
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|f
operator|->
name|static_member
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_static_member
call|)
argument_list|(
name|fhandle
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|f
operator|->
name|u
operator|.
name|s
operator|.
name|physname
argument_list|,
name|f
operator|->
name|visibility
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|struct_field
call|)
argument_list|(
name|fhandle
argument_list|,
name|f
operator|->
name|name
argument_list|,
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
argument_list|,
name|f
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
argument_list|,
name|f
operator|->
name|visibility
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|baseclasses
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|baseclasses
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|debug_baseclass
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|baseclasses
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|b
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_baseclass
call|)
argument_list|(
name|fhandle
argument_list|,
name|b
operator|->
name|bitpos
argument_list|,
name|b
operator|->
name|virtual
argument_list|,
name|b
operator|->
name|visibility
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|methods
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|methods
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|debug_method
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|m
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|methods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_start_method
call|)
argument_list|(
name|fhandle
argument_list|,
name|m
operator|->
name|name
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|m
operator|->
name|variants
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|debug_method_variant
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|m
operator|->
name|variants
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|context
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|v
operator|->
name|context
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|v
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|v
operator|->
name|voffset
operator|!=
name|VOFFSET_STATIC_METHOD
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_method_variant
call|)
argument_list|(
name|fhandle
argument_list|,
name|v
operator|->
name|physname
argument_list|,
name|v
operator|->
name|visibility
argument_list|,
name|v
operator|->
name|constp
argument_list|,
name|v
operator|->
name|volatilep
argument_list|,
name|v
operator|->
name|voffset
argument_list|,
name|v
operator|->
name|context
operator|!=
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_static_method_variant
call|)
argument_list|(
name|fhandle
argument_list|,
name|v
operator|->
name|physname
argument_list|,
name|v
operator|->
name|visibility
argument_list|,
name|v
operator|->
name|constp
argument_list|,
name|v
operator|->
name|volatilep
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|class_end_method
call|)
argument_list|(
name|fhandle
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|end_class_type
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out information for a function.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_function
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|name
parameter_list|,
name|linkage
parameter_list|,
name|function
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|debug_object_linkage
name|linkage
decl_stmt|;
name|struct
name|debug_function
modifier|*
name|function
decl_stmt|;
block|{
name|struct
name|debug_parameter
modifier|*
name|p
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|debug_write_linenos
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|function
operator|->
name|blocks
operator|->
name|start
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|function
operator|->
name|return_type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_function
call|)
argument_list|(
name|fhandle
argument_list|,
name|name
argument_list|,
name|linkage
operator|==
name|DEBUG_LINKAGE_GLOBAL
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|p
operator|=
name|function
operator|->
name|parameters
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|debug_write_type
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|p
operator|->
name|type
argument_list|,
operator|(
expr|struct
name|debug_name
operator|*
operator|)
name|NULL
argument_list|)
operator|||
operator|!
call|(
modifier|*
name|fns
operator|->
name|function_parameter
call|)
argument_list|(
name|fhandle
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|kind
argument_list|,
name|p
operator|->
name|val
argument_list|)
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|b
operator|=
name|function
operator|->
name|blocks
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|debug_write_block
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
call|(
modifier|*
name|fns
operator|->
name|end_function
call|)
argument_list|(
name|fhandle
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out information for a block.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_block
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|block
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|block
decl_stmt|;
block|{
name|struct
name|debug_name
modifier|*
name|n
decl_stmt|;
name|struct
name|debug_block
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|debug_write_linenos
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|block
operator|->
name|start
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* I can't see any point to writing out a block with no local      variables, so we don't bother, except for the top level block.  */
if|if
condition|(
name|block
operator|->
name|locals
operator|!=
name|NULL
operator|||
name|block
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|start_block
call|)
argument_list|(
name|fhandle
argument_list|,
name|block
operator|->
name|start
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|block
operator|->
name|locals
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
name|block
operator|->
name|locals
operator|->
name|list
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|debug_write_name
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
for|for
control|(
name|b
operator|=
name|block
operator|->
name|children
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|debug_write_block
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|debug_write_linenos
argument_list|(
name|info
argument_list|,
name|fns
argument_list|,
name|fhandle
argument_list|,
name|block
operator|->
name|end
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|block
operator|->
name|locals
operator|!=
name|NULL
operator|||
name|block
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|end_block
call|)
argument_list|(
name|fhandle
argument_list|,
name|block
operator|->
name|end
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out line number information up to ADDRESS.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_write_linenos
parameter_list|(
name|info
parameter_list|,
name|fns
parameter_list|,
name|fhandle
parameter_list|,
name|address
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|struct
name|debug_write_fns
modifier|*
name|fns
decl_stmt|;
name|PTR
name|fhandle
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
while|while
condition|(
name|info
operator|->
name|current_write_lineno
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_lineno
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|info
operator|->
name|current_write_lineno
expr_stmt|;
while|while
condition|(
name|info
operator|->
name|current_write_lineno_index
operator|<
name|DEBUG_LINENO_COUNT
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|linenos
index|[
name|info
operator|->
name|current_write_lineno_index
index|]
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|l
operator|->
name|addrs
index|[
name|info
operator|->
name|current_write_lineno_index
index|]
operator|>=
name|address
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
call|(
modifier|*
name|fns
operator|->
name|lineno
call|)
argument_list|(
name|fhandle
argument_list|,
name|l
operator|->
name|file
operator|->
name|filename
argument_list|,
name|l
operator|->
name|linenos
index|[
name|info
operator|->
name|current_write_lineno_index
index|]
argument_list|,
name|l
operator|->
name|addrs
index|[
name|info
operator|->
name|current_write_lineno_index
index|]
argument_list|)
condition|)
return|return
name|false
return|;
operator|++
name|info
operator|->
name|current_write_lineno_index
expr_stmt|;
block|}
name|info
operator|->
name|current_write_lineno
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|info
operator|->
name|current_write_lineno_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the ID number for a class.  If during the same call to    debug_write we find a struct with the same definition with the same    name, we use the same ID.  This type of things happens because the    same struct will be defined by multiple compilation units.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_set_class_id
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|type
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|type
decl_stmt|;
block|{
name|struct
name|debug_class_type
modifier|*
name|c
decl_stmt|;
name|struct
name|debug_class_id
modifier|*
name|l
decl_stmt|;
name|assert
argument_list|(
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_STRUCT
operator|||
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_UNION
operator|||
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_CLASS
operator|||
name|type
operator|->
name|kind
operator|==
name|DEBUG_KIND_UNION_CLASS
argument_list|)
expr_stmt|;
name|c
operator|=
name|type
operator|->
name|u
operator|.
name|kclass
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|id
operator|>
name|info
operator|->
name|base_id
condition|)
return|return
name|true
return|;
for|for
control|(
name|l
operator|=
name|info
operator|->
name|id_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|type
operator|->
name|kind
operator|!=
name|type
operator|->
name|kind
condition|)
continue|continue;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|NULL
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|l
operator|->
name|tag
operator|==
name|NULL
operator|||
name|l
operator|->
name|tag
index|[
literal|0
index|]
operator|!=
name|tag
index|[
literal|0
index|]
operator|||
name|strcmp
argument_list|(
name|l
operator|->
name|tag
argument_list|,
name|tag
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|l
operator|->
name|type
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|c
operator|->
name|id
operator|=
name|l
operator|->
name|type
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* There are no identical types.  Use a new ID, and add it to the      list.  */
operator|++
name|info
operator|->
name|class_id
expr_stmt|;
name|c
operator|->
name|id
operator|=
name|info
operator|->
name|class_id
expr_stmt|;
name|l
operator|=
operator|(
expr|struct
name|debug_class_id
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|l
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|l
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|info
operator|->
name|id_list
expr_stmt|;
name|info
operator|->
name|id_list
operator|=
name|l
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* See if two types are the same.  At this point, we don't care about    tags and the like.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_type_samep
parameter_list|(
name|info
parameter_list|,
name|t1
parameter_list|,
name|t2
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t1
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t2
decl_stmt|;
block|{
name|struct
name|debug_type_compare_list
modifier|*
name|l
decl_stmt|;
name|struct
name|debug_type_compare_list
name|top
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
return|return
name|t2
operator|==
name|NULL
return|;
if|if
condition|(
name|t2
operator|==
name|NULL
condition|)
return|return
name|false
return|;
while|while
condition|(
name|t1
operator|->
name|kind
operator|==
name|DEBUG_KIND_INDIRECT
condition|)
block|{
name|t1
operator|=
operator|*
name|t1
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
while|while
condition|(
name|t2
operator|->
name|kind
operator|==
name|DEBUG_KIND_INDIRECT
condition|)
block|{
name|t2
operator|=
operator|*
name|t2
operator|->
name|u
operator|.
name|kindirect
operator|->
name|slot
expr_stmt|;
if|if
condition|(
name|t2
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
name|true
return|;
comment|/* As a special case, permit a typedef to match a tag, since C++      debugging output will sometimes add a typedef where C debugging      output will not.  */
if|if
condition|(
name|t1
operator|->
name|kind
operator|==
name|DEBUG_KIND_NAMED
operator|&&
name|t2
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
condition|)
return|return
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|,
name|t2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|t1
operator|->
name|kind
operator|==
name|DEBUG_KIND_TAGGED
operator|&&
name|t2
operator|->
name|kind
operator|==
name|DEBUG_KIND_NAMED
condition|)
return|return
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
argument_list|,
name|t2
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|)
return|;
if|if
condition|(
name|t1
operator|->
name|kind
operator|!=
name|t2
operator|->
name|kind
operator|||
name|t1
operator|->
name|size
operator|!=
name|t2
operator|->
name|size
condition|)
return|return
name|false
return|;
comment|/* Get rid of the trivial cases first.  */
switch|switch
condition|(
name|t1
operator|->
name|kind
condition|)
block|{
default|default:
break|break;
case|case
name|DEBUG_KIND_VOID
case|:
case|case
name|DEBUG_KIND_FLOAT
case|:
case|case
name|DEBUG_KIND_COMPLEX
case|:
case|case
name|DEBUG_KIND_BOOL
case|:
return|return
name|true
return|;
case|case
name|DEBUG_KIND_INT
case|:
return|return
name|t1
operator|->
name|u
operator|.
name|kint
operator|==
name|t2
operator|->
name|u
operator|.
name|kint
return|;
block|}
comment|/* We have to avoid an infinite recursion.  We do this by keeping a      list of types which we are comparing.  We just keep the list on      the stack.  If we encounter a pair of types we are currently      comparing, we just assume that they are equal.  */
for|for
control|(
name|l
operator|=
name|info
operator|->
name|compare_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|t1
operator|==
name|t1
operator|&&
name|l
operator|->
name|t2
operator|==
name|t2
condition|)
return|return
name|true
return|;
block|}
name|top
operator|.
name|t1
operator|=
name|t1
expr_stmt|;
name|top
operator|.
name|t2
operator|=
name|t2
expr_stmt|;
name|top
operator|.
name|next
operator|=
name|info
operator|->
name|compare_list
expr_stmt|;
name|info
operator|->
name|compare_list
operator|=
operator|&
name|top
expr_stmt|;
switch|switch
condition|(
name|t1
operator|->
name|kind
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_STRUCT
case|:
case|case
name|DEBUG_KIND_UNION
case|:
case|case
name|DEBUG_KIND_CLASS
case|:
case|case
name|DEBUG_KIND_UNION_CLASS
case|:
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kclass
operator|==
name|NULL
condition|)
name|ret
operator|=
name|t2
operator|->
name|u
operator|.
name|kclass
operator|==
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|t2
operator|->
name|u
operator|.
name|kclass
operator|==
name|NULL
condition|)
name|ret
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|>
name|info
operator|->
name|base_id
operator|&&
name|t1
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
operator|==
name|t2
operator|->
name|u
operator|.
name|kclass
operator|->
name|id
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
name|ret
operator|=
name|debug_class_type_samep
argument_list|(
name|info
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_ENUM
case|:
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kenum
operator|==
name|NULL
condition|)
name|ret
operator|=
name|t2
operator|->
name|u
operator|.
name|kenum
operator|==
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|t2
operator|->
name|u
operator|.
name|kenum
operator|==
name|NULL
condition|)
name|ret
operator|=
name|false
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
modifier|*
name|pn1
decl_stmt|,
modifier|*
modifier|*
name|pn2
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|pv1
decl_stmt|,
modifier|*
name|pv2
decl_stmt|;
name|pn1
operator|=
name|t1
operator|->
name|u
operator|.
name|kenum
operator|->
name|names
expr_stmt|;
name|pn2
operator|=
name|t2
operator|->
name|u
operator|.
name|kenum
operator|->
name|names
expr_stmt|;
name|pv1
operator|=
name|t1
operator|->
name|u
operator|.
name|kenum
operator|->
name|values
expr_stmt|;
name|pv2
operator|=
name|t2
operator|->
name|u
operator|.
name|kenum
operator|->
name|values
expr_stmt|;
while|while
condition|(
operator|*
name|pn1
operator|!=
name|NULL
operator|&&
operator|*
name|pn2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pn1
operator|!=
operator|*
operator|*
name|pn2
operator|||
operator|*
name|pv1
operator|!=
operator|*
name|pv2
operator|||
name|strcmp
argument_list|(
operator|*
name|pn1
argument_list|,
operator|*
name|pn2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
operator|++
name|pn1
expr_stmt|;
operator|++
name|pn2
expr_stmt|;
operator|++
name|pv1
expr_stmt|;
operator|++
name|pv2
expr_stmt|;
block|}
name|ret
operator|=
operator|*
name|pn1
operator|==
name|NULL
operator|&&
operator|*
name|pn2
operator|==
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DEBUG_KIND_POINTER
case|:
name|ret
operator|=
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kpointer
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kpointer
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_FUNCTION
case|:
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kfunction
operator|->
name|varargs
operator|!=
name|t2
operator|->
name|u
operator|.
name|kfunction
operator|->
name|varargs
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kfunction
operator|->
name|return_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kfunction
operator|->
name|return_type
argument_list|)
operator|||
operator|(
operator|(
name|t1
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|t2
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
operator|==
name|NULL
operator|)
operator|)
condition|)
name|ret
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
operator|==
name|NULL
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
block|{
name|struct
name|debug_type
modifier|*
modifier|*
name|a1
decl_stmt|,
modifier|*
modifier|*
name|a2
decl_stmt|;
name|a1
operator|=
name|t1
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
expr_stmt|;
name|a2
operator|=
name|t2
operator|->
name|u
operator|.
name|kfunction
operator|->
name|arg_types
expr_stmt|;
while|while
condition|(
operator|*
name|a1
operator|!=
name|NULL
operator|&&
operator|*
name|a2
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
operator|*
name|a1
argument_list|,
operator|*
name|a2
argument_list|)
condition|)
break|break;
name|ret
operator|=
operator|*
name|a1
operator|==
name|NULL
operator|&&
operator|*
name|a2
operator|==
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DEBUG_KIND_REFERENCE
case|:
name|ret
operator|=
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kreference
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kreference
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_RANGE
case|:
name|ret
operator|=
operator|(
name|t1
operator|->
name|u
operator|.
name|krange
operator|->
name|lower
operator|==
name|t2
operator|->
name|u
operator|.
name|krange
operator|->
name|lower
operator|&&
name|t1
operator|->
name|u
operator|.
name|krange
operator|->
name|upper
operator|==
name|t2
operator|->
name|u
operator|.
name|krange
operator|->
name|upper
operator|&&
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|krange
operator|->
name|type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|krange
operator|->
name|type
argument_list|)
operator|)
expr_stmt|;
case|case
name|DEBUG_KIND_ARRAY
case|:
name|ret
operator|=
operator|(
name|t1
operator|->
name|u
operator|.
name|karray
operator|->
name|lower
operator|==
name|t2
operator|->
name|u
operator|.
name|karray
operator|->
name|lower
operator|&&
name|t1
operator|->
name|u
operator|.
name|karray
operator|->
name|upper
operator|==
name|t2
operator|->
name|u
operator|.
name|karray
operator|->
name|upper
operator|&&
name|t1
operator|->
name|u
operator|.
name|karray
operator|->
name|stringp
operator|==
name|t2
operator|->
name|u
operator|.
name|karray
operator|->
name|stringp
operator|&&
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|karray
operator|->
name|element_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|karray
operator|->
name|element_type
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_SET
case|:
name|ret
operator|=
operator|(
name|t1
operator|->
name|u
operator|.
name|kset
operator|->
name|bitstringp
operator|==
name|t2
operator|->
name|u
operator|.
name|kset
operator|->
name|bitstringp
operator|&&
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kset
operator|->
name|type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kset
operator|->
name|type
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_OFFSET
case|:
name|ret
operator|=
operator|(
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|koffset
operator|->
name|base_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|koffset
operator|->
name|base_type
argument_list|)
operator|&&
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|koffset
operator|->
name|target_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|koffset
operator|->
name|target_type
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_METHOD
case|:
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|varargs
operator|!=
name|t2
operator|->
name|u
operator|.
name|kmethod
operator|->
name|varargs
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|return_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kmethod
operator|->
name|return_type
argument_list|)
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|domain_type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kmethod
operator|->
name|domain_type
argument_list|)
operator|||
operator|(
operator|(
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|t2
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
operator|==
name|NULL
operator|)
operator|)
condition|)
name|ret
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
operator|==
name|NULL
condition|)
name|ret
operator|=
name|true
expr_stmt|;
else|else
block|{
name|struct
name|debug_type
modifier|*
modifier|*
name|a1
decl_stmt|,
modifier|*
modifier|*
name|a2
decl_stmt|;
name|a1
operator|=
name|t1
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
expr_stmt|;
name|a2
operator|=
name|t2
operator|->
name|u
operator|.
name|kmethod
operator|->
name|arg_types
expr_stmt|;
while|while
condition|(
operator|*
name|a1
operator|!=
name|NULL
operator|&&
operator|*
name|a2
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
operator|*
name|a1
argument_list|,
operator|*
name|a2
argument_list|)
condition|)
break|break;
name|ret
operator|=
operator|*
name|a1
operator|==
name|NULL
operator|&&
operator|*
name|a2
operator|==
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|DEBUG_KIND_CONST
case|:
name|ret
operator|=
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kconst
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kconst
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_VOLATILE
case|:
name|ret
operator|=
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|kvolatile
argument_list|,
name|t2
operator|->
name|u
operator|.
name|kvolatile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUG_KIND_NAMED
case|:
case|case
name|DEBUG_KIND_TAGGED
case|:
name|ret
operator|=
operator|(
name|strcmp
argument_list|(
name|t1
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|,
name|t2
operator|->
name|u
operator|.
name|knamed
operator|->
name|name
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|t1
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|,
name|t2
operator|->
name|u
operator|.
name|knamed
operator|->
name|type
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
name|info
operator|->
name|compare_list
operator|=
name|top
operator|.
name|next
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* See if two classes are the same.  This is a subroutine of    debug_type_samep.  */
end_comment

begin_function
specifier|static
name|boolean
name|debug_class_type_samep
parameter_list|(
name|info
parameter_list|,
name|t1
parameter_list|,
name|t2
parameter_list|)
name|struct
name|debug_handle
modifier|*
name|info
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t1
decl_stmt|;
name|struct
name|debug_type
modifier|*
name|t2
decl_stmt|;
block|{
name|struct
name|debug_class_type
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|c1
operator|=
name|t1
operator|->
name|u
operator|.
name|kclass
expr_stmt|;
name|c2
operator|=
name|t2
operator|->
name|u
operator|.
name|kclass
expr_stmt|;
if|if
condition|(
operator|(
name|c1
operator|->
name|fields
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|c2
operator|->
name|fields
operator|==
name|NULL
operator|)
operator|||
operator|(
name|c1
operator|->
name|baseclasses
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|c2
operator|->
name|baseclasses
operator|==
name|NULL
operator|)
operator|||
operator|(
name|c1
operator|->
name|methods
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|c2
operator|->
name|methods
operator|==
name|NULL
operator|)
operator|||
operator|(
name|c1
operator|->
name|vptrbase
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|c2
operator|->
name|vptrbase
operator|==
name|NULL
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|c1
operator|->
name|fields
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_field
modifier|*
modifier|*
name|pf1
decl_stmt|,
modifier|*
modifier|*
name|pf2
decl_stmt|;
for|for
control|(
name|pf1
operator|=
name|c1
operator|->
name|fields
operator|,
name|pf2
operator|=
name|c2
operator|->
name|fields
init|;
operator|*
name|pf1
operator|!=
name|NULL
operator|&&
operator|*
name|pf2
operator|!=
name|NULL
condition|;
name|pf1
operator|++
operator|,
name|pf2
operator|++
control|)
block|{
name|struct
name|debug_field
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
name|f1
operator|=
operator|*
name|pf1
expr_stmt|;
name|f2
operator|=
operator|*
name|pf2
expr_stmt|;
if|if
condition|(
name|f1
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|f2
operator|->
name|name
index|[
literal|0
index|]
operator|||
name|f1
operator|->
name|visibility
operator|!=
name|f2
operator|->
name|visibility
operator|||
name|f1
operator|->
name|static_member
operator|!=
name|f2
operator|->
name|static_member
condition|)
return|return
name|false
return|;
if|if
condition|(
name|f1
operator|->
name|static_member
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|f1
operator|->
name|u
operator|.
name|s
operator|.
name|physname
argument_list|,
name|f2
operator|->
name|u
operator|.
name|s
operator|.
name|physname
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
if|if
condition|(
name|f1
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
operator|!=
name|f2
operator|->
name|u
operator|.
name|f
operator|.
name|bitpos
operator|||
name|f1
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
operator|!=
name|f2
operator|->
name|u
operator|.
name|f
operator|.
name|bitsize
condition|)
return|return
name|false
return|;
block|}
comment|/* We do the checks which require function calls last.  We              don't require that the types of fields have the same              names, since that sometimes fails in the presence of              typedefs and we really don't care.  */
if|if
condition|(
name|strcmp
argument_list|(
name|f1
operator|->
name|name
argument_list|,
name|f2
operator|->
name|name
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|debug_get_real_type
argument_list|(
operator|(
name|PTR
operator|)
name|info
argument_list|,
name|f1
operator|->
name|type
argument_list|)
argument_list|,
name|debug_get_real_type
argument_list|(
operator|(
name|PTR
operator|)
name|info
argument_list|,
name|f2
operator|->
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
name|pf1
operator|!=
name|NULL
operator|||
operator|*
name|pf2
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|c1
operator|->
name|vptrbase
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|c1
operator|->
name|vptrbase
argument_list|,
name|c2
operator|->
name|vptrbase
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|c1
operator|->
name|baseclasses
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_baseclass
modifier|*
modifier|*
name|pb1
decl_stmt|,
modifier|*
modifier|*
name|pb2
decl_stmt|;
for|for
control|(
name|pb1
operator|=
name|c1
operator|->
name|baseclasses
operator|,
name|pb2
operator|=
name|c2
operator|->
name|baseclasses
init|;
operator|*
name|pb1
operator|!=
name|NULL
operator|&&
operator|*
name|pb2
operator|!=
name|NULL
condition|;
operator|++
name|pb1
operator|,
operator|++
name|pb2
control|)
block|{
name|struct
name|debug_baseclass
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
name|b1
operator|=
operator|*
name|pb1
expr_stmt|;
name|b2
operator|=
operator|*
name|pb2
expr_stmt|;
if|if
condition|(
name|b1
operator|->
name|bitpos
operator|!=
name|b2
operator|->
name|bitpos
operator|||
name|b1
operator|->
name|virtual
operator|!=
name|b2
operator|->
name|virtual
operator|||
name|b1
operator|->
name|visibility
operator|!=
name|b2
operator|->
name|visibility
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|b1
operator|->
name|type
argument_list|,
name|b2
operator|->
name|type
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
operator|*
name|pb1
operator|!=
name|NULL
operator|||
operator|*
name|pb2
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|c1
operator|->
name|methods
operator|!=
name|NULL
condition|)
block|{
name|struct
name|debug_method
modifier|*
modifier|*
name|pm1
decl_stmt|,
modifier|*
modifier|*
name|pm2
decl_stmt|;
for|for
control|(
name|pm1
operator|=
name|c1
operator|->
name|methods
operator|,
name|pm2
operator|=
name|c2
operator|->
name|methods
init|;
operator|*
name|pm1
operator|!=
name|NULL
operator|&&
operator|*
name|pm2
operator|!=
name|NULL
condition|;
operator|++
name|pm1
operator|,
operator|++
name|pm2
control|)
block|{
name|struct
name|debug_method
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|m1
operator|=
operator|*
name|pm1
expr_stmt|;
name|m2
operator|=
operator|*
name|pm2
expr_stmt|;
if|if
condition|(
name|m1
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|m2
operator|->
name|name
index|[
literal|0
index|]
operator|||
name|strcmp
argument_list|(
name|m1
operator|->
name|name
argument_list|,
name|m2
operator|->
name|name
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|m1
operator|->
name|variants
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|m2
operator|->
name|variants
operator|==
name|NULL
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|m1
operator|->
name|variants
operator|==
name|NULL
condition|)
block|{
name|struct
name|debug_method_variant
modifier|*
modifier|*
name|pv1
decl_stmt|,
modifier|*
modifier|*
name|pv2
decl_stmt|;
for|for
control|(
name|pv1
operator|=
name|m1
operator|->
name|variants
operator|,
name|pv2
operator|=
name|m2
operator|->
name|variants
init|;
operator|*
name|pv1
operator|!=
name|NULL
operator|&&
operator|*
name|pv2
operator|!=
name|NULL
condition|;
operator|++
name|pv1
operator|,
operator|++
name|pv2
control|)
block|{
name|struct
name|debug_method_variant
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|v1
operator|=
operator|*
name|pv1
expr_stmt|;
name|v2
operator|=
operator|*
name|pv2
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|physname
index|[
literal|0
index|]
operator|!=
name|v2
operator|->
name|physname
index|[
literal|0
index|]
operator|||
name|v1
operator|->
name|visibility
operator|!=
name|v2
operator|->
name|visibility
operator|||
name|v1
operator|->
name|constp
operator|!=
name|v2
operator|->
name|constp
operator|||
name|v1
operator|->
name|volatilep
operator|!=
name|v2
operator|->
name|volatilep
operator|||
name|v1
operator|->
name|voffset
operator|!=
name|v2
operator|->
name|voffset
operator|||
operator|(
name|v1
operator|->
name|context
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|v2
operator|->
name|context
operator|==
name|NULL
operator|)
operator|||
name|strcmp
argument_list|(
name|v1
operator|->
name|physname
argument_list|,
name|v2
operator|->
name|physname
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|v1
operator|->
name|type
argument_list|,
name|v2
operator|->
name|type
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|v1
operator|->
name|context
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|debug_type_samep
argument_list|(
name|info
argument_list|,
name|v1
operator|->
name|context
argument_list|,
name|v2
operator|->
name|context
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|*
name|pv1
operator|!=
name|NULL
operator|||
operator|*
name|pv2
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|*
name|pm1
operator|!=
name|NULL
operator|||
operator|*
name|pm2
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

