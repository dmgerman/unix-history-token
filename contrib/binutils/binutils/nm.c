begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nm.c -- Describe symbol table of a rel file.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"budemang.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ranlib.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_comment
comment|/* When sorting by size, we use this structure to hold the size and a    pointer to the minisymbol.  */
end_comment

begin_struct
struct|struct
name|size_sym
block|{
specifier|const
name|void
modifier|*
name|minisym
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* When fetching relocs, we use this structure to pass information to    get_relocs.  */
end_comment

begin_struct
struct|struct
name|get_relocs_info
block|{
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|long
modifier|*
name|relcount
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|extended_symbol_info
block|{
name|symbol_info
modifier|*
name|sinfo
decl_stmt|;
name|bfd_vma
name|ssize
decl_stmt|;
name|elf_symbol_type
modifier|*
name|elfinfo
decl_stmt|;
comment|/* FIXME: We should add more fields for Type, Line, Section.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SYM_NAME
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->name)
end_define

begin_define
define|#
directive|define
name|SYM_VALUE
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->value)
end_define

begin_define
define|#
directive|define
name|SYM_TYPE
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->type)
end_define

begin_define
define|#
directive|define
name|SYM_STAB_NAME
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->stab_name)
end_define

begin_define
define|#
directive|define
name|SYM_STAB_DESC
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->stab_desc)
end_define

begin_define
define|#
directive|define
name|SYM_STAB_OTHER
parameter_list|(
name|sym
parameter_list|)
value|(sym->sinfo->stab_other)
end_define

begin_define
define|#
directive|define
name|SYM_SIZE
parameter_list|(
name|sym
parameter_list|)
define|\
value|(sym->elfinfo ? sym->elfinfo->internal_elf_sym.st_size: sym->ssize)
end_define

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_print_radix
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_output_format
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_archive
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|display_file
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_rel_file
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|filter_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|void
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|sort_symbols_by_size
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|void
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|struct
name|size_sym
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|void
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_size_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|struct
name|size_sym
modifier|*
parameter_list|,
name|long
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symname
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|bfd_vma
name|ssize
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symdef_entry
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The sorting functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|numeric_forward
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|numeric_reverse
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|non_numeric_forward
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|non_numeric_reverse
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_forward1
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|size_forward2
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The output formatting functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|print_object_filename_bsd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_object_filename_sysv
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_object_filename_posix
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_filename_bsd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_filename_sysv
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_filename_posix
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_member_bsd
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_member_sysv
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_archive_member_posix
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_filename_bsd
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_filename_sysv
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_filename_posix
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_value
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_info_bsd
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_info_sysv
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_symbol_info_posix
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support for different output formats.  */
end_comment

begin_struct
struct|struct
name|output_fns
block|{
comment|/* Print the name of an object file given on the command line.  */
name|void
function_decl|(
modifier|*
name|print_object_filename
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Print the name of an archive file given on the command line.  */
name|void
function_decl|(
modifier|*
name|print_archive_filename
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Print the name of an archive member file.  */
name|void
function_decl|(
modifier|*
name|print_archive_member
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Print the name of the file (and archive, if there is one)        containing a symbol.  */
name|void
function_decl|(
modifier|*
name|print_symbol_filename
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
comment|/* Print a line of information about a symbol.  */
name|void
function_decl|(
modifier|*
name|print_symbol_info
function_decl|)
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|output_fns
name|formats
index|[]
init|=
block|{
block|{
name|print_object_filename_bsd
block|,
name|print_archive_filename_bsd
block|,
name|print_archive_member_bsd
block|,
name|print_symbol_filename_bsd
block|,
name|print_symbol_info_bsd
block|}
block|,
block|{
name|print_object_filename_sysv
block|,
name|print_archive_filename_sysv
block|,
name|print_archive_member_sysv
block|,
name|print_symbol_filename_sysv
block|,
name|print_symbol_info_sysv
block|}
block|,
block|{
name|print_object_filename_posix
block|,
name|print_archive_filename_posix
block|,
name|print_archive_member_posix
block|,
name|print_symbol_filename_posix
block|,
name|print_symbol_info_posix
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indices in `formats'.  */
end_comment

begin_define
define|#
directive|define
name|FORMAT_BSD
value|0
end_define

begin_define
define|#
directive|define
name|FORMAT_SYSV
value|1
end_define

begin_define
define|#
directive|define
name|FORMAT_POSIX
value|2
end_define

begin_define
define|#
directive|define
name|FORMAT_DEFAULT
value|FORMAT_BSD
end_define

begin_comment
comment|/* The output format to use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|output_fns
modifier|*
name|format
init|=
operator|&
name|formats
index|[
name|FORMAT_DEFAULT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_demangle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pretty print C++ symbol names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|external_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print external symbols only.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|defined_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print defined symbols only.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_sort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't sort; print syms in order found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_debug_syms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print debugger-only symbols too.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_armap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe __.SYMDEF data in archive files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print size of defined symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverse_sort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sort in downward(alpha or numeric) order.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sort_numerically
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sort in numeric rather than alpha order.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sort_by_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sort by size of symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|undefined_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print undefined symbols only.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dynamic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print dynamic symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show the version number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_stats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_numbers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print line numbers for symbols.  */
end_comment

begin_comment
comment|/* When to print the names of files.  Not mutually exclusive in SYSV format.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filename_per_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Once per file, on its own line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filename_per_symbol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Once per symbol, at start of line.  */
end_comment

begin_comment
comment|/* Print formats for printing a symbol value.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD64
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|value_format
index|[]
init|=
literal|"%08lx"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|BFD_HOST_64BIT_LONG
end_if

begin_decl_stmt
specifier|static
name|char
name|value_format
index|[]
init|=
literal|"%016lx"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* We don't use value_format for this case.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|print_width
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|print_width
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|print_radix
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print formats for printing stab info.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|other_format
index|[]
init|=
literal|"%02x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|desc_format
index|[]
init|=
literal|"%04x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to cache the line numbers for a BFD.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|lineno_cache_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|lineno_cache_rel_bfd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_TARGET
value|200
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"debug-syms"
block|,
name|no_argument
block|,
operator|&
name|print_debug_syms
block|,
literal|1
block|}
block|,
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"dynamic"
block|,
name|no_argument
block|,
operator|&
name|dynamic
block|,
literal|1
block|}
block|,
block|{
literal|"extern-only"
block|,
name|no_argument
block|,
operator|&
name|external_only
block|,
literal|1
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"line-numbers"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-cplus"
block|,
name|no_argument
block|,
operator|&
name|do_demangle
block|,
literal|0
block|}
block|,
comment|/* Linux compatibility.  */
block|{
literal|"no-demangle"
block|,
name|no_argument
block|,
operator|&
name|do_demangle
block|,
literal|0
block|}
block|,
block|{
literal|"no-sort"
block|,
name|no_argument
block|,
operator|&
name|no_sort
block|,
literal|1
block|}
block|,
block|{
literal|"numeric-sort"
block|,
name|no_argument
block|,
operator|&
name|sort_numerically
block|,
literal|1
block|}
block|,
block|{
literal|"portability"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'P'
block|}
block|,
block|{
literal|"print-armap"
block|,
name|no_argument
block|,
operator|&
name|print_armap
block|,
literal|1
block|}
block|,
block|{
literal|"print-file-name"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"print-size"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"radix"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"reverse-sort"
block|,
name|no_argument
block|,
operator|&
name|reverse_sort
block|,
literal|1
block|}
block|,
block|{
literal|"size-sort"
block|,
name|no_argument
block|,
operator|&
name|sort_by_size
block|,
literal|1
block|}
block|,
block|{
literal|"stats"
block|,
name|no_argument
block|,
operator|&
name|show_stats
block|,
literal|1
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPTION_TARGET
block|}
block|,
block|{
literal|"defined-only"
block|,
name|no_argument
block|,
operator|&
name|defined_only
block|,
literal|1
block|}
block|,
block|{
literal|"undefined-only"
block|,
name|no_argument
block|,
operator|&
name|undefined_only
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|show_version
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Some error-reporting functions.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [option(s)] [file(s)]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" List symbols in [file(s)] (a.out by default).\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" The options are:\n\   -a, --debug-syms       Display debugger-only symbols\n\   -A, --print-file-name  Print name of the input file before every symbol\n\   -B                     Same as --format=bsd\n\   -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n\                           The STYLE, if specified, can be `auto' (the default),\n\                           `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\                           or `gnat'\n\       --no-demangle      Do not demangle low-level symbol names\n\   -D, --dynamic          Display dynamic symbols instead of normal symbols\n\       --defined-only     Display only defined symbols\n\   -e                     (ignored)\n\   -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\                            `sysv' or `posix'.  The default is `bsd'\n\   -g, --extern-only      Display only external symbols\n\   -l, --line-numbers     Use debugging information to find a filename and\n\                            line number for each symbol\n\   -n, --numeric-sort     Sort symbols numerically by address\n\   -o                     Same as -A\n\   -p, --no-sort          Do not sort the symbols\n\   -P, --portability      Same as --format=posix\n\   -r, --reverse-sort     Reverse the sense of the sort\n\   -S, --print-size       Print size of defined symbols\n\   -s, --print-armap      Include index for symbols from archive members\n\       --size-sort        Sort symbols by size\n\   -t, --radix=RADIX      Use RADIX for printing symbol values\n\       --target=BFDNAME   Specify the target object format as BFDNAME\n\   -u, --undefined-only   Display only undefined symbols\n\   -X 32_64               (ignored)\n\   -h, --help             Display this information\n\   -V, --version          Display this program's version number\n\ \n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s.\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the radix for the symbol value and size according to RADIX.  */
end_comment

begin_function
specifier|static
name|void
name|set_print_radix
parameter_list|(
name|char
modifier|*
name|radix
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|radix
condition|)
block|{
case|case
literal|'x'
case|:
break|break;
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
if|if
condition|(
operator|*
name|radix
operator|==
literal|'d'
condition|)
name|print_radix
operator|=
literal|10
expr_stmt|;
else|else
name|print_radix
operator|=
literal|8
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD64
name|value_format
index|[
literal|4
index|]
operator|=
operator|*
name|radix
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|BFD_HOST_64BIT_LONG
name|value_format
index|[
literal|5
index|]
operator|=
operator|*
name|radix
expr_stmt|;
else|#
directive|else
comment|/* This case requires special handling for octal and decimal          printing.  */
endif|#
directive|endif
endif|#
directive|endif
name|other_format
index|[
literal|3
index|]
operator|=
name|desc_format
index|[
literal|3
index|]
operator|=
operator|*
name|radix
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: invalid radix"
argument_list|)
argument_list|,
name|radix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_output_format
parameter_list|(
name|char
modifier|*
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|f
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|i
operator|=
name|FORMAT_BSD
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|i
operator|=
name|FORMAT_POSIX
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|i
operator|=
name|FORMAT_SYSV
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: invalid output format"
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|format
operator|=
operator|&
name|formats
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
operator|*
name|argv
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aABCDef:gHhlnopPrSst:uvVvX:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|print_debug_syms
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'o'
case|:
name|filename_per_symbol
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* For MIPS compatibility.  */
name|set_output_format
argument_list|(
literal|"bsd"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|do_demangle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unknown demangling style `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
name|dynamic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* Ignored for HP/UX compatibility.  */
break|break;
case|case
literal|'f'
case|:
name|set_output_format
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|external_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
name|line_numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'v'
case|:
name|sort_numerically
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|no_sort
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|set_output_format
argument_list|(
literal|"posix"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|reverse_sort
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|print_armap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|print_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|set_print_radix
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|undefined_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Ignored for (partial) AIX compatibility.  On AIX, the 	     argument has values 32, 64, or 32_64, and specifies that 	     only 32-bit, only 64-bit, or both kinds of objects should 	     be examined.  The default is 32.  So plain AIX nm on a 	     library archive with both kinds of objects will ignore 	     the 64-bit ones.  For GNU nm, the default is and always 	     has been -X 32_64, and other options are not supported.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"32_64"
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Only -X 32_64 is supported"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TARGET
case|:
comment|/* --target */
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* A long option that just sets a flag.  */
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"nm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_by_size
operator|&&
name|undefined_only
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Using the --size-sort and --undefined-only options together"
argument_list|)
argument_list|)
expr_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"will produce no output, since undefined symbols have no size."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* OK, all options now parsed.  If no filename specified, do a.out.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
return|return
operator|!
name|display_file
argument_list|(
literal|"a.out"
argument_list|)
return|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|-
name|optind
operator|>
literal|1
condition|)
name|filename_per_file
operator|=
literal|1
expr_stmt|;
comment|/* We were given several filenames to do.  */
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|display_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
condition|)
name|retval
operator|++
expr_stmt|;
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
if|if
condition|(
name|show_stats
condition|)
block|{
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"data size %ld"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_symbol_type
parameter_list|(
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|buff
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"TLS"
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|STT_LOPROC
operator|&&
name|type
operator|<=
name|STT_HIPROC
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<processor specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|>=
name|STT_LOOS
operator|&&
name|type
operator|<=
name|STT_HIOS
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<OS specific>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_
argument_list|(
literal|"<unknown>: %d"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_archive
parameter_list|(
name|bfd
modifier|*
name|file
parameter_list|)
block|{
name|bfd
modifier|*
name|arfile
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|last_arfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
call|(
modifier|*
name|format
operator|->
name|print_archive_filename
call|)
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_armap
condition|)
name|print_symdef_entry
argument_list|(
name|file
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|file
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_more_archived_files
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|arfile
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|arfile
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|print_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|format
operator|->
name|print_archive_member
call|)
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|arfile
argument_list|)
argument_list|)
expr_stmt|;
name|display_rel_file
argument_list|(
name|arfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|arfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
block|{
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
name|lineno_cache_bfd
operator|=
name|NULL
expr_stmt|;
name|lineno_cache_rel_bfd
operator|=
name|NULL
expr_stmt|;
block|}
name|last_arfile
operator|=
name|arfile
expr_stmt|;
block|}
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
block|{
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
name|lineno_cache_bfd
operator|=
name|NULL
expr_stmt|;
name|lineno_cache_rel_bfd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|display_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd_boolean
name|retval
init|=
name|TRUE
decl_stmt|;
name|bfd
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|get_file_size
argument_list|(
name|filename
argument_list|)
operator|<
literal|1
condition|)
return|return
name|FALSE
return|;
name|file
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|bfd_nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|display_archive
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|file
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|print_width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|format
operator|->
name|print_object_filename
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|display_rel_file
argument_list|(
name|file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|file
argument_list|)
condition|)
name|bfd_fatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|lineno_cache_bfd
operator|=
name|NULL
expr_stmt|;
name|lineno_cache_rel_bfd
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* These globals are used to pass information into the sorting    routines.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|sort_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sort_dynamic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|sort_x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|sort_y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol-sorting predicates */
end_comment

begin_define
define|#
directive|define
name|valueof
parameter_list|(
name|x
parameter_list|)
value|((x)->section->vma + (x)->value)
end_define

begin_comment
comment|/* Numeric sorts.  Undefined symbols are always considered "less than"    defined symbols with zero values.  Common symbols are not treated    specially -- i.e., their sizes are used as their "values".  */
end_comment

begin_function
specifier|static
name|int
name|numeric_forward
parameter_list|(
specifier|const
name|void
modifier|*
name|P_x
parameter_list|,
specifier|const
name|void
modifier|*
name|P_y
parameter_list|)
block|{
name|asymbol
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|asection
modifier|*
name|xs
decl_stmt|,
modifier|*
name|ys
decl_stmt|;
name|x
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_x
argument_list|,
name|sort_x
argument_list|)
expr_stmt|;
name|y
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_y
argument_list|,
name|sort_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
name|y
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|sort_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|=
name|bfd_get_section
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
name|bfd_get_section
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|xs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_is_und_section
argument_list|(
name|ys
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|ys
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|valueof
argument_list|(
name|x
argument_list|)
operator|!=
name|valueof
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|valueof
argument_list|(
name|x
argument_list|)
operator|<
name|valueof
argument_list|(
name|y
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
name|non_numeric_forward
argument_list|(
name|P_x
argument_list|,
name|P_y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|numeric_reverse
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|-
name|numeric_forward
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|non_numeric_forward
parameter_list|(
specifier|const
name|void
modifier|*
name|P_x
parameter_list|,
specifier|const
name|void
modifier|*
name|P_y
parameter_list|)
block|{
name|asymbol
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
specifier|const
name|char
modifier|*
name|xn
decl_stmt|,
modifier|*
name|yn
decl_stmt|;
name|x
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_x
argument_list|,
name|sort_x
argument_list|)
expr_stmt|;
name|y
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_y
argument_list|,
name|sort_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
name|y
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|sort_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|xn
operator|=
name|bfd_asymbol_name
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|yn
operator|=
name|bfd_asymbol_name
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|yn
operator|==
name|NULL
condition|)
return|return
name|xn
operator|!=
name|NULL
return|;
if|if
condition|(
name|xn
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|HAVE_STRCOLL
comment|/* Solaris 2.5 has a bug in strcoll.      strcoll returns invalid values when confronted with empty strings.  */
if|if
condition|(
operator|*
name|yn
operator|==
literal|'\0'
condition|)
return|return
operator|*
name|xn
operator|!=
literal|'\0'
return|;
if|if
condition|(
operator|*
name|xn
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|strcoll
argument_list|(
name|xn
argument_list|,
name|yn
argument_list|)
return|;
else|#
directive|else
return|return
name|strcmp
argument_list|(
name|xn
argument_list|,
name|yn
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|non_numeric_reverse
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|-
name|non_numeric_forward
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|int
argument_list|(
operator|*
operator|(
name|sorters
index|[
literal|2
index|]
index|[
literal|2
index|]
operator|)
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|=
block|{
block|{
name|non_numeric_forward
block|,
name|non_numeric_reverse
block|}
block|,
block|{
name|numeric_forward
block|,
name|numeric_reverse
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This sort routine is used by sort_symbols_by_size.  It is similar    to numeric_forward, but when symbols have the same value it sorts    by section VMA.  This simplifies the sort_symbols_by_size code    which handles symbols at the end of sections.  Also, this routine    tries to sort file names before other symbols with the same value.    That will make the file name have a zero size, which will make    sort_symbols_by_size choose the non file name symbol, leading to    more meaningful output.  For similar reasons, this code sorts    gnu_compiled_* and gcc2_compiled before other symbols with the same    value.  */
end_comment

begin_function
specifier|static
name|int
name|size_forward1
parameter_list|(
specifier|const
name|void
modifier|*
name|P_x
parameter_list|,
specifier|const
name|void
modifier|*
name|P_y
parameter_list|)
block|{
name|asymbol
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|asection
modifier|*
name|xs
decl_stmt|,
modifier|*
name|ys
decl_stmt|;
specifier|const
name|char
modifier|*
name|xn
decl_stmt|,
modifier|*
name|yn
decl_stmt|;
name|size_t
name|xnl
decl_stmt|,
name|ynl
decl_stmt|;
name|int
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|x
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_x
argument_list|,
name|sort_x
argument_list|)
expr_stmt|;
name|y
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|sort_bfd
argument_list|,
name|sort_dynamic
argument_list|,
name|P_y
argument_list|,
name|sort_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
name|y
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|sort_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|=
name|bfd_get_section
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ys
operator|=
name|bfd_get_section
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|xs
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|ys
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|valueof
argument_list|(
name|x
argument_list|)
operator|!=
name|valueof
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|valueof
argument_list|(
name|x
argument_list|)
operator|<
name|valueof
argument_list|(
name|y
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
name|xs
operator|->
name|vma
operator|!=
name|ys
operator|->
name|vma
condition|)
return|return
name|xs
operator|->
name|vma
operator|<
name|ys
operator|->
name|vma
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|xn
operator|=
name|bfd_asymbol_name
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|yn
operator|=
name|bfd_asymbol_name
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|xnl
operator|=
name|strlen
argument_list|(
name|xn
argument_list|)
expr_stmt|;
name|ynl
operator|=
name|strlen
argument_list|(
name|yn
argument_list|)
expr_stmt|;
comment|/* The symbols gnu_compiled and gcc2_compiled convey even less      information than the file name, so sort them out first.  */
name|xf
operator|=
operator|(
name|strstr
argument_list|(
name|xn
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|xn
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|yf
operator|=
operator|(
name|strstr
argument_list|(
name|yn
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|yn
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|xf
operator|&&
operator|!
name|yf
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|xf
operator|&&
name|yf
condition|)
return|return
literal|1
return|;
comment|/* We use a heuristic for the file name.  It may not work on non      Unix systems, but it doesn't really matter; the only difference      is precisely which symbol names get printed.  */
define|#
directive|define
name|file_symbol
parameter_list|(
name|s
parameter_list|,
name|sn
parameter_list|,
name|snl
parameter_list|)
define|\
value|(((s)->flags& BSF_FILE) != 0			\    || ((sn)[(snl) - 2] == '.'			\&& ((sn)[(snl) - 1] == 'o'		\ 	   || (sn)[(snl) - 1] == 'a')))
name|xf
operator|=
name|file_symbol
argument_list|(
name|x
argument_list|,
name|xn
argument_list|,
name|xnl
argument_list|)
expr_stmt|;
name|yf
operator|=
name|file_symbol
argument_list|(
name|y
argument_list|,
name|yn
argument_list|,
name|ynl
argument_list|)
expr_stmt|;
if|if
condition|(
name|xf
operator|&&
operator|!
name|yf
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|xf
operator|&&
name|yf
condition|)
return|return
literal|1
return|;
return|return
name|non_numeric_forward
argument_list|(
name|P_x
argument_list|,
name|P_y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This sort routine is used by sort_symbols_by_size.  It is sorting    an array of size_sym structures into size order.  */
end_comment

begin_function
specifier|static
name|int
name|size_forward2
parameter_list|(
specifier|const
name|void
modifier|*
name|P_x
parameter_list|,
specifier|const
name|void
modifier|*
name|P_y
parameter_list|)
block|{
specifier|const
name|struct
name|size_sym
modifier|*
name|x
init|=
operator|(
specifier|const
expr|struct
name|size_sym
operator|*
operator|)
name|P_x
decl_stmt|;
specifier|const
name|struct
name|size_sym
modifier|*
name|y
init|=
operator|(
specifier|const
expr|struct
name|size_sym
operator|*
operator|)
name|P_y
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|size
operator|<
name|y
operator|->
name|size
condition|)
return|return
name|reverse_sort
condition|?
literal|1
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|x
operator|->
name|size
operator|>
name|y
operator|->
name|size
condition|)
return|return
name|reverse_sort
condition|?
operator|-
literal|1
else|:
literal|1
return|;
else|else
return|return
name|sorters
index|[
literal|0
index|]
index|[
name|reverse_sort
index|]
operator|(
name|x
operator|->
name|minisym
operator|,
name|y
operator|->
name|minisym
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the symbols by size.  ELF provides a size but for other formats    we have to make a guess by assuming that the difference between the    address of a symbol and the address of the next higher symbol is the    size.  */
end_comment

begin_function
specifier|static
name|long
name|sort_symbols_by_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
name|void
modifier|*
name|minisyms
parameter_list|,
name|long
name|symcount
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|struct
name|size_sym
modifier|*
modifier|*
name|symsizesp
parameter_list|)
block|{
name|struct
name|size_sym
modifier|*
name|symsizes
decl_stmt|;
name|bfd_byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|asymbol
modifier|*
name|store_sym
decl_stmt|,
modifier|*
name|store_next
decl_stmt|;
name|qsort
argument_list|(
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|,
name|size_forward1
argument_list|)
expr_stmt|;
comment|/* We are going to return a special set of symbols and sizes to      print.  */
name|symsizes
operator|=
operator|(
expr|struct
name|size_sym
operator|*
operator|)
name|xmalloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|size_sym
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|symsizesp
operator|=
name|symsizes
expr_stmt|;
comment|/* Note that filter_symbols has already removed all absolute and      undefined symbols.  Here we remove all symbols whose size winds      up as zero.  */
name|from
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
operator|*
name|size
expr_stmt|;
name|store_sym
operator|=
name|sort_x
expr_stmt|;
name|store_next
operator|=
name|sort_y
expr_stmt|;
if|if
condition|(
name|from
operator|<
name|fromend
condition|)
block|{
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|from
argument_list|,
name|store_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|+=
name|size
control|)
block|{
name|asymbol
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|sz
decl_stmt|;
name|asymbol
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|from
operator|+
name|size
operator|<
name|fromend
condition|)
block|{
name|next
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|from
operator|+
name|size
operator|)
argument_list|,
name|store_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|next
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|sz
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|sz
operator|=
name|sym
operator|->
name|value
expr_stmt|;
else|else
block|{
if|if
condition|(
name|from
operator|+
name|size
operator|<
name|fromend
operator|&&
name|sec
operator|==
name|bfd_get_section
argument_list|(
name|next
argument_list|)
condition|)
name|sz
operator|=
name|valueof
argument_list|(
name|next
argument_list|)
operator|-
name|valueof
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|sz
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|-
name|valueof
argument_list|(
name|sym
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|!=
literal|0
condition|)
block|{
name|symsizes
operator|->
name|minisym
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|from
expr_stmt|;
name|symsizes
operator|->
name|size
operator|=
name|sz
expr_stmt|;
operator|++
name|symsizes
expr_stmt|;
block|}
name|sym
operator|=
name|next
expr_stmt|;
name|temp
operator|=
name|store_sym
expr_stmt|;
name|store_sym
operator|=
name|store_next
expr_stmt|;
name|store_next
operator|=
name|temp
expr_stmt|;
block|}
name|symcount
operator|=
name|symsizes
operator|-
operator|*
name|symsizesp
expr_stmt|;
comment|/* We must now sort again by size.  */
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|symsizesp
argument_list|,
name|symcount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|size_sym
argument_list|)
argument_list|,
name|size_forward2
argument_list|)
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|display_rel_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|archive_bfd
parameter_list|)
block|{
name|long
name|symcount
decl_stmt|;
name|void
modifier|*
name|minisyms
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|struct
name|size_sym
modifier|*
name|symsizes
decl_stmt|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|symcount
operator|=
name|bfd_read_minisymbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
operator|&
name|minisyms
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Discard the symbols we don't want to print.      It's OK to do this in place; we'll free the storage anyway      (after printing).  */
name|symcount
operator|=
name|filter_symbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|symsizes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|no_sort
condition|)
block|{
name|sort_bfd
operator|=
name|abfd
expr_stmt|;
name|sort_dynamic
operator|=
name|dynamic
expr_stmt|;
name|sort_x
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sort_y
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_x
operator|==
name|NULL
operator|||
name|sort_y
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sort_by_size
condition|)
name|qsort
argument_list|(
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|,
name|sorters
index|[
name|sort_numerically
index|]
index|[
name|reverse_sort
index|]
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|sort_symbols_by_size
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|,
operator|&
name|symsizes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sort_by_size
condition|)
name|print_symbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisyms
argument_list|,
name|symcount
argument_list|,
name|size
argument_list|,
name|archive_bfd
argument_list|)
expr_stmt|;
else|else
name|print_size_symbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|symsizes
argument_list|,
name|symcount
argument_list|,
name|archive_bfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|minisyms
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Choose which symbol entries to print;    compact them downward to get rid of the rest.    Return the number of symbols to be printed.  */
end_comment

begin_function
specifier|static
name|long
name|filter_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
name|void
modifier|*
name|minisyms
parameter_list|,
name|long
name|symcount
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|asymbol
modifier|*
name|store
decl_stmt|;
name|store
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
operator|*
name|size
expr_stmt|;
name|to
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|+=
name|size
control|)
block|{
name|int
name|keep
init|=
literal|0
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|from
argument_list|,
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|undefined_only
condition|)
name|keep
operator|=
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|external_only
condition|)
name|keep
operator|=
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|)
expr_stmt|;
else|else
name|keep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
operator|!
name|print_debug_syms
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|sort_by_size
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
operator|&&
name|defined_only
condition|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|keep
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|keep
condition|)
block|{
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|to
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|to
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
operator|)
operator|/
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print symbol name NAME, read from ABFD, with printf format FORMAT,    demangling it if requested.  */
end_comment

begin_function
specifier|static
name|void
name|print_symname
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|do_demangle
operator|&&
operator|*
name|name
condition|)
block|{
name|char
modifier|*
name|res
init|=
name|demangle
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|printf
argument_list|(
name|format
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
name|format
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the symbols.  If ARCHIVE_BFD is non-NULL, it is the archive    containing ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
name|void
modifier|*
name|minisyms
parameter_list|,
name|long
name|symcount
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|bfd
modifier|*
name|archive_bfd
parameter_list|)
block|{
name|asymbol
modifier|*
name|store
decl_stmt|;
name|bfd_byte
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|;
name|store
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|minisyms
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
operator|*
name|size
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|+=
name|size
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|from
argument_list|,
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|archive_bfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the symbols when sorting by size.  */
end_comment

begin_function
specifier|static
name|void
name|print_size_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
name|struct
name|size_sym
modifier|*
name|symsizes
parameter_list|,
name|long
name|symcount
parameter_list|,
name|bfd
modifier|*
name|archive_bfd
parameter_list|)
block|{
name|asymbol
modifier|*
name|store
decl_stmt|;
name|struct
name|size_sym
modifier|*
name|from
decl_stmt|,
modifier|*
name|fromend
decl_stmt|;
name|store
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|symsizes
expr_stmt|;
name|fromend
operator|=
name|from
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|ssize
decl_stmt|;
name|sym
operator|=
name|bfd_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|from
operator|->
name|minisym
argument_list|,
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For elf we have already computed the correct symbol size.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|ssize
operator|=
name|from
operator|->
name|size
expr_stmt|;
else|else
name|ssize
operator|=
name|from
operator|->
name|size
operator|-
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|print_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
name|ssize
argument_list|,
name|archive_bfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a single symbol.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|ssize
parameter_list|,
name|bfd
modifier|*
name|archive_bfd
parameter_list|)
block|{
name|symbol_info
name|syminfo
decl_stmt|;
name|struct
name|extended_symbol_info
name|info
decl_stmt|;
name|PROGRESS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|format
operator|->
name|print_symbol_filename
call|)
argument_list|(
name|archive_bfd
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_get_symbol_info
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|syminfo
argument_list|)
expr_stmt|;
name|info
operator|.
name|sinfo
operator|=
operator|&
name|syminfo
expr_stmt|;
name|info
operator|.
name|ssize
operator|=
name|ssize
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|info
operator|.
name|elfinfo
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
expr_stmt|;
else|else
name|info
operator|.
name|elfinfo
operator|=
name|NULL
expr_stmt|;
call|(
modifier|*
name|format
operator|->
name|print_symbol_info
call|)
argument_list|(
operator|&
name|info
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_numbers
condition|)
block|{
specifier|static
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
specifier|static
name|long
name|symcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
comment|/* We need to get the canonical symbols in order to call          bfd_find_nearest_line.  This is inefficient, but, then, you          don't have to use --line-numbers.  */
if|if
condition|(
name|abfd
operator|!=
name|lineno_cache_bfd
operator|&&
name|syms
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
name|syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|NULL
condition|)
block|{
name|long
name|symsize
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|lineno_cache_bfd
operator|=
name|abfd
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
specifier|static
name|arelent
modifier|*
modifier|*
modifier|*
name|relocs
decl_stmt|;
specifier|static
name|long
modifier|*
name|relcount
decl_stmt|;
specifier|static
name|unsigned
name|int
name|seccount
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
comment|/* For an undefined symbol, we try to find a reloc for the              symbol, and print the line number of the reloc.  */
if|if
condition|(
name|abfd
operator|!=
name|lineno_cache_rel_bfd
operator|&&
name|relocs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seccount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|relocs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relocs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|secs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|relcount
argument_list|)
expr_stmt|;
name|secs
operator|=
name|NULL
expr_stmt|;
name|relocs
operator|=
name|NULL
expr_stmt|;
name|relcount
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|relocs
operator|==
name|NULL
condition|)
block|{
name|struct
name|get_relocs_info
name|info
decl_stmt|;
name|seccount
operator|=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|secs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|seccount
operator|*
sizeof|sizeof
expr|*
name|secs
argument_list|)
expr_stmt|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|seccount
operator|*
sizeof|sizeof
expr|*
name|relocs
argument_list|)
expr_stmt|;
name|relcount
operator|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
name|seccount
operator|*
sizeof|sizeof
expr|*
name|relcount
argument_list|)
expr_stmt|;
name|info
operator|.
name|secs
operator|=
name|secs
expr_stmt|;
name|info
operator|.
name|relocs
operator|=
name|relocs
expr_stmt|;
name|info
operator|.
name|relcount
operator|=
name|relcount
expr_stmt|;
name|info
operator|.
name|syms
operator|=
name|syms
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|get_relocs
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
name|lineno_cache_rel_bfd
operator|=
name|abfd
expr_stmt|;
block|}
name|symname
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seccount
condition|;
name|i
operator|++
control|)
block|{
name|long
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|relcount
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|relocs
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
operator|==
name|sym
operator|->
name|section
operator|&&
operator|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|value
operator|==
name|sym
operator|->
name|value
operator|&&
name|strcmp
argument_list|(
name|symname
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|r
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|secs
index|[
name|i
index|]
argument_list|,
name|syms
argument_list|,
name|r
operator|->
name|address
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|lineno
argument_list|)
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
comment|/* We only print the first one we find.  */
name|printf
argument_list|(
literal|"\t%s:%u"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|i
operator|=
name|seccount
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
operator|->
name|owner
operator|==
name|abfd
condition|)
block|{
if|if
condition|(
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|,
name|syms
argument_list|,
name|sym
operator|->
name|value
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|lineno
argument_list|)
operator|&&
name|filename
operator|!=
name|NULL
operator|&&
name|lineno
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s:%u"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following 3 groups of functions are called unconditionally,    once at the start of processing each file of the appropriate type.    They should check `filename_per_file' and `filename_per_symbol',    as appropriate for their output format, to determine whether to    print anything.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Print the name of an object file given on the command line.  */
end_comment

begin_function
specifier|static
name|void
name|print_object_filename_bsd
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|filename_per_file
operator|&&
operator|!
name|filename_per_symbol
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_object_filename_sysv
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|undefined_only
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\nUndefined symbols from %s:\n\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\nSymbols from %s:\n\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_width
operator|==
literal|8
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Name                  Value   Class        Type         Size     Line  Section\n\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Name                  Value           Class        Type         Size             Line  Section\n\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_object_filename_posix
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|filename_per_file
operator|&&
operator|!
name|filename_per_symbol
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the name of an archive file given on the command line.  */
end_comment

begin_function
specifier|static
name|void
name|print_archive_filename_bsd
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|filename_per_file
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_archive_filename_sysv
parameter_list|(
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|print_archive_filename_posix
parameter_list|(
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the name of an archive member file.  */
end_comment

begin_function
specifier|static
name|void
name|print_archive_member_bsd
parameter_list|(
name|char
modifier|*
name|archive
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
operator|!
name|filename_per_symbol
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_archive_member_sysv
parameter_list|(
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|undefined_only
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\nUndefined symbols from %s[%s]:\n\n"
argument_list|)
argument_list|,
name|archive
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n\nSymbols from %s[%s]:\n\n"
argument_list|)
argument_list|,
name|archive
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_width
operator|==
literal|8
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Name                  Value   Class        Type         Size     Line  Section\n\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Name                  Value           Class        Type         Size             Line  Section\n\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_archive_member_posix
parameter_list|(
name|char
modifier|*
name|archive
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
operator|!
name|filename_per_symbol
condition|)
name|printf
argument_list|(
literal|"%s[%s]:\n"
argument_list|,
name|archive
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the name of the file (and archive, if there is one)    containing a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol_filename_bsd
parameter_list|(
name|bfd
modifier|*
name|archive_bfd
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|filename_per_symbol
condition|)
block|{
if|if
condition|(
name|archive_bfd
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|bfd_get_filename
argument_list|(
name|archive_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol_filename_sysv
parameter_list|(
name|bfd
modifier|*
name|archive_bfd
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|filename_per_symbol
condition|)
block|{
if|if
condition|(
name|archive_bfd
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|bfd_get_filename
argument_list|(
name|archive_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol_filename_posix
parameter_list|(
name|bfd
modifier|*
name|archive_bfd
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|filename_per_symbol
condition|)
block|{
if|if
condition|(
name|archive_bfd
condition|)
name|printf
argument_list|(
literal|"%s[%s]: "
argument_list|,
name|bfd_get_filename
argument_list|(
name|archive_bfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a symbol value.  */
end_comment

begin_function
specifier|static
name|void
name|print_value
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|val
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BFD64
argument_list|)
operator|||
name|BFD_HOST_64BIT_LONG
name|printf
argument_list|(
name|value_format
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* We have a 64 bit value to print, but the host is only 32 bit.  */
if|if
condition|(
name|print_radix
operator|==
literal|16
condition|)
name|bfd_fprintf_vma
argument_list|(
name|abfd
argument_list|,
name|stdout
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|buf
operator|+
sizeof|sizeof
name|buf
expr_stmt|;
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|val
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|s
operator|=
operator|(
name|val
operator|%
name|print_radix
operator|)
operator|+
literal|'0'
expr_stmt|;
name|val
operator|/=
name|print_radix
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
operator|)
operator|-
name|s
operator|<
literal|16
condition|)
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print a line of information about a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|print_symbol_info_bsd
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_is_undefined_symclass
argument_list|(
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_width
operator|==
literal|16
condition|)
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Normally we print the value of the symbol.  If we are printing the 	 size or sorting by size then we print its size, except for the 	 (weird) special case where both flags are defined, in which case we 	 print both values.  This conforms to documented behaviour.  */
if|if
condition|(
name|sort_by_size
operator|&&
operator|!
name|print_size
condition|)
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_VALUE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_size
operator|&&
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" %c"
argument_list|,
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
operator|==
literal|'-'
condition|)
block|{
comment|/* A stab.  */
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|other_format
argument_list|,
name|SYM_STAB_OTHER
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|desc_format
argument_list|,
name|SYM_STAB_DESC
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %5s"
argument_list|,
name|SYM_STAB_NAME
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|print_symname
argument_list|(
literal|" %s"
argument_list|,
name|SYM_NAME
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol_info_sysv
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|print_symname
argument_list|(
literal|"%-20s|"
argument_list|,
name|SYM_NAME
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_undefined_symclass
argument_list|(
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_width
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
block|}
else|else
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_VALUE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"|   %c  |"
argument_list|,
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
operator|==
literal|'-'
condition|)
block|{
comment|/* A stab.  */
name|printf
argument_list|(
literal|"%18s|  "
argument_list|,
name|SYM_STAB_NAME
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (C) Type.  */
name|printf
argument_list|(
name|desc_format
argument_list|,
name|SYM_STAB_DESC
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Size.  */
name|printf
argument_list|(
literal|"|     |"
argument_list|)
expr_stmt|;
comment|/* Line, Section.  */
block|}
else|else
block|{
comment|/* Type, Size, Line, Section */
if|if
condition|(
name|info
operator|->
name|elfinfo
condition|)
name|printf
argument_list|(
literal|"%18s|"
argument_list|,
name|get_symbol_type
argument_list|(
name|ELF_ST_TYPE
argument_list|(
name|info
operator|->
name|elfinfo
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                  |"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
condition|)
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|print_width
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|elfinfo
condition|)
name|printf
argument_list|(
literal|"|     |%s"
argument_list|,
name|info
operator|->
name|elfinfo
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"|     |"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_symbol_info_posix
parameter_list|(
name|struct
name|extended_symbol_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|print_symname
argument_list|(
literal|"%s "
argument_list|,
name|SYM_NAME
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c "
argument_list|,
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_undefined_symclass
argument_list|(
name|SYM_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
else|else
block|{
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_VALUE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
condition|)
name|print_value
argument_list|(
name|abfd
argument_list|,
name|SYM_SIZE
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_symdef_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|symindex
name|idx
init|=
name|BFD_NO_MORE_SYMBOLS
decl_stmt|;
name|carsym
modifier|*
name|thesym
decl_stmt|;
name|bfd_boolean
name|everprinted
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|bfd_get_next_mapent
argument_list|(
name|abfd
argument_list|,
name|idx
argument_list|,
operator|&
name|thesym
argument_list|)
init|;
name|idx
operator|!=
name|BFD_NO_MORE_SYMBOLS
condition|;
name|idx
operator|=
name|bfd_get_next_mapent
argument_list|(
name|abfd
argument_list|,
name|idx
argument_list|,
operator|&
name|thesym
argument_list|)
control|)
block|{
name|bfd
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
operator|!
name|everprinted
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nArchive index:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|everprinted
operator|=
name|TRUE
expr_stmt|;
block|}
name|elt
operator|=
name|bfd_get_elt_at_index
argument_list|(
name|abfd
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL
condition|)
name|bfd_fatal
argument_list|(
literal|"bfd_get_elt_at_index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thesym
operator|->
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|print_symname
argument_list|(
literal|"%s"
argument_list|,
name|thesym
operator|->
name|name
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" in %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is used to get the relocs for a particular section.    It is called via bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|get_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|dataarg
parameter_list|)
block|{
name|struct
name|get_relocs_info
modifier|*
name|data
init|=
operator|(
expr|struct
name|get_relocs_info
operator|*
operator|)
name|dataarg
decl_stmt|;
operator|*
name|data
operator|->
name|secs
operator|=
name|sec
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|data
operator|->
name|relocs
operator|=
name|NULL
expr_stmt|;
operator|*
name|data
operator|->
name|relcount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|long
name|relsize
decl_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|data
operator|->
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
operator|*
name|data
operator|->
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|*
name|data
operator|->
name|relocs
argument_list|,
name|data
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|->
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|++
name|data
operator|->
name|secs
expr_stmt|;
operator|++
name|data
operator|->
name|relocs
expr_stmt|;
operator|++
name|data
operator|->
name|relcount
expr_stmt|;
block|}
end_function

end_unit

