begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for GNU C++ - main program    Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003 Free Software Foundation, Inc.    Written by James Clark (jjc@jclark.uucp)    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling    Modified by Satish Pai (pai@apollo.hp.com) for HP demangling  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_VERBOSE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|demangle_it
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_demangler_list
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|demangle_it
parameter_list|(
name|char
modifier|*
name|mangled_name
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
comment|/* For command line args, also try to demangle type encodings.  */
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|flags
operator||
name|DMGL_TYPES
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mangled_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_demangler_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
specifier|const
name|struct
name|demangler_engine
modifier|*
name|demangler
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%s"
argument_list|,
name|libiberty_demanglers
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
for|for
control|(
name|demangler
operator|=
name|libiberty_demanglers
operator|+
literal|1
init|;
name|demangler
operator|->
name|demangling_style
operator|!=
name|unknown_demangling
condition|;
operator|++
name|demangler
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|demangler
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-_] [-n] [--strip-underscores] [--no-strip-underscores]\n\        [-p] [--no-params]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [-s "
argument_list|)
expr_stmt|;
name|print_demangler_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [--format "
argument_list|)
expr_stmt|;
name|print_demangler_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [--help] [--version] [arg...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MBUF_SIZE
value|32767
end_define

begin_decl_stmt
name|char
name|mbuffer
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strip_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'_'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-params"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"no-strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|standard_symbol_characters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|hp_symbol_characters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return the string of non-alnum characters that may occur    as a valid symbol component, in the standard assembler symbol    syntax.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|standard_symbol_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"_$."
return|;
block|}
end_function

begin_comment
comment|/* Return the string of non-alnum characters that may occur    as a valid symbol name component in an HP object file.     Note that, since HP's compiler generates object code straight from    C++ source, without going through an assembler, its mangled    identifiers can use all sorts of characters that no assembler would    tolerate, so the alphabet this function creates is a little odd.    Here are some sample mangled identifiers offered by HP:  	typeid*__XT24AddressIndExpClassMember_ 	[Vftptr]key:__dt__32OrdinaryCompareIndExpClassMemberFv 	__ct__Q2_9Elf64_Dyn18{unnamed.union.#1}Fv     This still seems really weird to me, since nowhere else in this    file is there anything to recognize curly brackets, parens, etc.    I've talked with Srikanth<srikanth@cup.hp.com>, and he assures me    this is right, but I still strongly suspect that there's a    misunderstanding here.     If we decide it's better for c++filt to use HP's assembler syntax    to scrape identifiers out of its input, here's the definition of    the symbol name syntax from the HP assembler manual:         Symbols are composed of uppercase and lowercase letters, decimal        digits, dollar symbol, period (.), ampersand (&), pound sign(#) and        underscore (_). A symbol can begin with a letter, digit underscore or        dollar sign. If a symbol begins with a digit, it must contain a        non-digit character.     So have fun.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hp_symbol_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|"_$.<>#,*&[]:(){}"
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|valid_symbols
decl_stmt|;
name|enum
name|demangling_styles
name|style
init|=
name|auto_demangling
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|strip_underscore
operator|=
name|TARGET_PREPENDS_UNDERSCORE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"_nps:"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|strip_underscore
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator|&=
operator|~
name|DMGL_PARAMS
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|print_version
argument_list|(
literal|"c++filt"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'_'
case|:
name|strip_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
block|{
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown demangling style `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|demangle_it
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|current_demangling_style
condition|)
block|{
case|case
name|gnu_demangling
case|:
case|case
name|lucid_demangling
case|:
case|case
name|arm_demangling
case|:
case|case
name|java_demangling
case|:
case|case
name|edg_demangling
case|:
case|case
name|gnat_demangling
case|:
case|case
name|gnu_v3_demangling
case|:
case|case
name|auto_demangling
case|:
name|valid_symbols
operator|=
name|standard_symbol_characters
argument_list|()
expr_stmt|;
break|break;
case|case
name|hp_demangling
case|:
name|valid_symbols
operator|=
name|hp_symbol_characters
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Folks should explicitly indicate the appropriate alphabet for 	     each demangling.  Providing a default would allow the 	     question to go unconsidered.  */
name|fatal
argument_list|(
literal|"Internal error: no symbol alphabet for current style"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Try to read a label.  */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|valid_symbols
argument_list|,
name|c
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MBUF_SIZE
operator|-
literal|1
condition|)
break|break;
name|mbuffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|skip_first
init|=
literal|0
decl_stmt|;
name|mbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|strip_underscore
operator|&&
name|mbuffer
index|[
name|skip_first
index|]
operator|==
literal|'_'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|skip_first
operator|>
name|i
condition|)
name|skip_first
operator|=
name|i
expr_stmt|;
name|flags
operator||=
operator|(
name|int
operator|)
name|style
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mbuffer
operator|+
name|skip_first
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|mbuffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

