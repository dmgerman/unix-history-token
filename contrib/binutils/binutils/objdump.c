begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objdump.c -- dump information about an object file.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Objdump overview.     Objdump displays information about one or more object files, either on    their own, or inside libraries.  It is commonly used as a disassembler,    but it can also display information about file headers, symbol tables,    relocations, debugging directives and more.     The flow of execution is as follows:      1. Command line arguments are checked for control switches and the       information to be displayed is selected.           2. Any remaining arguments are assumed to be object files, and they are       processed in order by display_bfd().  If the file is an archive each       of its elements is processed in turn.           3. The file's target architecture and binary file format are determined       by bfd_check_format().  If they are recognised, then dump_bfd() is       called.     4. dump_bfd() in turn calls separate functions to display the requested       item(s) of information(s).  For example disassemble_data() is called if       a disassembly has been requested.     When disassembling the code loops through blocks of instructions bounded    by symbols, calling disassemble_bytes() on each block.  The actual    disassembling is done by the libopcodes library, via a function pointer    supplied by the disassembler() function.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdver.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"budemang.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_comment
comment|/* Internal headers for the ELF .stab-dump code - sorry.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|32
end_define

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_FPRINTF
end_ifdef

begin_comment
comment|/* This is needed by init_disassemble_info().  */
end_comment

begin_function_decl
specifier|extern
name|int
name|fprintf
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Exit status.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_target
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default at runtime.  */
end_comment

begin_comment
comment|/* The following variables are set based on arguments passed on the    command line.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Show the version number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_section_contents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_section_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|dump_file_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_dynamic_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -T */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_reloc_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_dynamic_reloc_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -R */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_ar_hdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_private_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prefix_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --prefix-addresses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|with_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|with_source_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_raw_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --show-raw-insn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_stab_section_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --stabs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -C, --demangle */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|disassemble
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|disassemble_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D */
end_comment

begin_decl_stmt
specifier|static
name|int
name|disassemble_zeroes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --disassemble-zeroes */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|formats_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wide_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|start_address
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --start-address */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|stop_address
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --stop-address */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --debugging */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_debugging_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --debugging-tags */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|adjust_section_vma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --adjust-vma */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_start_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --file-start-context */
end_comment

begin_comment
comment|/* Pointer to an array of section names provided by    one or more "-j secname" command line options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The total number of slots in the only[] array.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|only_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of occupied slots in the only[] array.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|only_used
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for handling include file path table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|include_paths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|include_path_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extra info to pass to the section disassembler and address printing    function.  */
end_comment

begin_struct
struct|struct
name|objdump_disasm_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|require_sec
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|dynrelbuf
decl_stmt|;
name|long
name|dynrelcount
decl_stmt|;
name|disassembler_ftype
name|disassemble_fn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Architecture to disassemble for, or default if NULL.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|machine
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target specific options to the disassembler.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|disassembler_options
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|bfd_endian
name|endian
init|=
name|BFD_ENDIAN_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `syms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|symcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sorted symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|sorted_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `sorted_syms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|sorted_symcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dynamic symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|dynsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `dynsyms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|dynsymcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|stabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|stab_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|stabstr_size
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s<option(s)><file(s)>\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Display information from object<file(s)>.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" At least one of the following switches must be given:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -a, --archive-headers    Display archive header information\n\   -f, --file-headers       Display the contents of the overall file header\n\   -p, --private-headers    Display object format specific file header contents\n\   -h, --[section-]headers  Display the contents of the section headers\n\   -x, --all-headers        Display the contents of all headers\n\   -d, --disassemble        Display assembler contents of executable sections\n\   -D, --disassemble-all    Display assembler contents of all sections\n\   -S, --source             Intermix source code with disassembly\n\   -s, --full-contents      Display the full contents of all sections requested\n\   -g, --debugging          Display debug information in object file\n\   -e, --debugging-tags     Display debug information using ctags style\n\   -G, --stabs              Display (in raw form) any STABS info in the file\n\   -t, --syms               Display the contents of the symbol table(s)\n\   -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\   -r, --reloc              Display the relocation entries in the file\n\   -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\   -v, --version            Display this program's version number\n\   -i, --info               List object formats and architectures supported\n\   -H, --help               Display this information\n\ "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n The following switches are optional:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\   -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\   -j, --section=NAME             Only display information for section NAME\n\   -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\   -EB --endian=big               Assume big endian format when disassembling\n\   -EL --endian=little            Assume little endian format when disassembling\n\       --file-start-context       Include context from start of file (with -S)\n\   -I, --include=DIR              Add DIR to search list for source files\n\   -l, --line-numbers             Include line numbers and filenames in output\n\   -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\                                   The STYLE, if specified, can be `auto', `gnu',\n\                                   `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\                                   or `gnat'\n\   -w, --wide                     Format output for more than 80 columns\n\   -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\       --start-address=ADDR       Only process data whose address is>= ADDR\n\       --stop-address=ADDR        Only process data whose address is<= ADDR\n\       --prefix-addresses         Print complete address alongside disassembly\n\       --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n\       --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\ \n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|list_supported_architectures
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|disassembler_usage
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s.\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_enum
enum|enum
name|option_values
block|{
name|OPTION_ENDIAN
init|=
literal|150
block|,
name|OPTION_START_ADDRESS
block|,
name|OPTION_STOP_ADDRESS
block|,
name|OPTION_ADJUST_VMA
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ADJUST_VMA
block|}
block|,
block|{
literal|"all-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"private-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"archive-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"debugging"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"debugging-tags"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"disassemble"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"disassemble-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"disassembler-options"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"disassemble-zeroes"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"dynamic-reloc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"dynamic-syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"endian"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ENDIAN
block|}
block|,
block|{
literal|"file-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"file-start-context"
block|,
name|no_argument
block|,
operator|&
name|file_start_context
block|,
literal|1
block|}
block|,
block|{
literal|"full-contents"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"info"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"line-numbers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-show-raw-insn"
block|,
name|no_argument
block|,
operator|&
name|show_raw_insn
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"prefix-addresses"
block|,
name|no_argument
block|,
operator|&
name|prefix_addresses
block|,
literal|1
block|}
block|,
block|{
literal|"reloc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'j'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"show-raw-insn"
block|,
name|no_argument
block|,
operator|&
name|show_raw_insn
block|,
literal|1
block|}
block|,
block|{
literal|"source"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"include"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
block|{
literal|"stabs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"start-address"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_START_ADDRESS
block|}
block|,
block|{
literal|"stop-address"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_STOP_ADDRESS
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"wide"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|nonfatal
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|bfd_nonfatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_section_header
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|ignored
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%3d %-13s %08lx  "
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|/
name|opb
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|lma
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %08lx  2**%u"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|filepos
argument_list|,
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_output
condition|)
name|printf
argument_list|(
literal|"\n                "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
define|#
directive|define
name|PF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (section->flags& x) { printf ("%s%s", comma, y); comma = ", "; }
name|PF
argument_list|(
name|SEC_HAS_CONTENTS
argument_list|,
literal|"CONTENTS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ALLOC
argument_list|,
literal|"ALLOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CONSTRUCTOR
argument_list|,
literal|"CONSTRUCTOR"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_LOAD
argument_list|,
literal|"LOAD"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_RELOC
argument_list|,
literal|"RELOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_READONLY
argument_list|,
literal|"READONLY"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CODE
argument_list|,
literal|"CODE"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_DATA
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ROM
argument_list|,
literal|"ROM"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_DEBUGGING
argument_list|,
literal|"DEBUGGING"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_NEVER_LOAD
argument_list|,
literal|"NEVER_LOAD"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_EXCLUDE
argument_list|,
literal|"EXCLUDE"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SORT_ENTRIES
argument_list|,
literal|"SORT_ENTRIES"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_BLOCK
argument_list|,
literal|"BLOCK"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CLINK
argument_list|,
literal|"CLINK"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SMALL_DATA
argument_list|,
literal|"SMALL_DATA"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SHARED
argument_list|,
literal|"SHARED"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ARCH_BIT_0
argument_list|,
literal|"ARCH_BIT_0"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_THREAD_LOCAL
argument_list|,
literal|"THREAD_LOCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ls
decl_stmt|;
switch|switch
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
name|ls
operator|=
literal|"LINK_ONCE_DISCARD"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
name|ls
operator|=
literal|"LINK_ONCE_ONE_ONLY"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
name|ls
operator|=
literal|"LINK_ONCE_SAME_SIZE"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
name|ls
operator|=
literal|"LINK_ONCE_SAME_CONTENTS"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|comma
argument_list|,
name|ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|comdat
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" (COMDAT %s %ld)"
argument_list|,
name|section
operator|->
name|comdat
operator|->
name|name
argument_list|,
name|section
operator|->
name|comdat
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PF
block|}
end_function

begin_function
specifier|static
name|void
name|dump_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Sections:\n"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD64
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA       LMA       File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|abfd
argument_list|)
operator|==
literal|32
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA       LMA       File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA               LMA               File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wide_output
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_LOAD_PAGE
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Pg"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dump_section_header
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|sy
init|=
name|NULL
decl_stmt|;
name|long
name|storage
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
block|{
name|symcount
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|storage
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
condition|)
name|sy
operator|=
name|xmalloc
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|sy
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sy
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|sy
init|=
name|NULL
decl_stmt|;
name|long
name|storage
decl_stmt|;
name|storage
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: not a dynamic object"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|dynsymcount
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
condition|)
name|sy
operator|=
name|xmalloc
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|dynsymcount
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|sy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sy
return|;
block|}
end_function

begin_comment
comment|/* Filter out (in place) symbols that are useless for disassembly.    COUNT is the number of elements in SYMBOLS.    Return the number of useful symbols.  */
end_comment

begin_function
specifier|static
name|long
name|remove_useless_symbols
parameter_list|(
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|long
name|count
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|in_ptr
init|=
name|symbols
decl_stmt|,
modifier|*
modifier|*
name|out_ptr
init|=
name|symbols
decl_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|asymbol
modifier|*
name|sym
init|=
operator|*
name|in_ptr
operator|++
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|name
operator|==
name|NULL
operator|||
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_DEBUGGING
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
continue|continue;
operator|*
name|out_ptr
operator|++
operator|=
name|sym
expr_stmt|;
block|}
return|return
name|out_ptr
operator|-
name|symbols
return|;
block|}
end_function

begin_comment
comment|/* Sort symbols into value order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|asymbol
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|asymbol
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|bp
decl_stmt|;
specifier|const
name|char
modifier|*
name|an
decl_stmt|;
specifier|const
name|char
modifier|*
name|bn
decl_stmt|;
name|size_t
name|anl
decl_stmt|;
name|size_t
name|bnl
decl_stmt|;
name|bfd_boolean
name|af
decl_stmt|;
name|bfd_boolean
name|bf
decl_stmt|;
name|flagword
name|aflags
decl_stmt|;
name|flagword
name|bflags
decl_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|a
argument_list|)
operator|>
name|bfd_asymbol_value
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|a
argument_list|)
operator|<
name|bfd_asymbol_value
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|section
operator|>
name|b
operator|->
name|section
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|section
operator|<
name|b
operator|->
name|section
condition|)
return|return
operator|-
literal|1
return|;
name|an
operator|=
name|bfd_asymbol_name
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bn
operator|=
name|bfd_asymbol_name
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|anl
operator|=
name|strlen
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|bnl
operator|=
name|strlen
argument_list|(
name|bn
argument_list|)
expr_stmt|;
comment|/* The symbols gnu_compiled and gcc2_compiled convey no real      information, so put them after other symbols with the same value.  */
name|af
operator|=
operator|(
name|strstr
argument_list|(
name|an
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|an
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|bf
operator|=
operator|(
name|strstr
argument_list|(
name|bn
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|bn
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|af
operator|&&
operator|!
name|bf
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|af
operator|&&
name|bf
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We use a heuristic for the file name, to try to sort it after      more useful symbols.  It may not work on non Unix systems, but it      doesn't really matter; the only difference is precisely which      symbol names get printed.  */
define|#
directive|define
name|file_symbol
parameter_list|(
name|s
parameter_list|,
name|sn
parameter_list|,
name|snl
parameter_list|)
define|\
value|(((s)->flags& BSF_FILE) != 0			\    || ((sn)[(snl) - 2] == '.'			\&& ((sn)[(snl) - 1] == 'o'		\ 	   || (sn)[(snl) - 1] == 'a')))
name|af
operator|=
name|file_symbol
argument_list|(
name|a
argument_list|,
name|an
argument_list|,
name|anl
argument_list|)
expr_stmt|;
name|bf
operator|=
name|file_symbol
argument_list|(
name|b
argument_list|,
name|bn
argument_list|,
name|bnl
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|&&
operator|!
name|bf
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|af
operator|&&
name|bf
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try to sort global symbols before local symbols before function      symbols before debugging symbols.  */
name|aflags
operator|=
name|a
operator|->
name|flags
expr_stmt|;
name|bflags
operator|=
name|b
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_DEBUGGING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_LOCAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_GLOBAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/* Symbols that start with '.' might be section names, so sort them      after symbols that don't start with '.'.  */
if|if
condition|(
name|an
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|bn
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|an
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|bn
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Finally, if we can't distinguish them in any other way, try to      get consistent results by sorting the symbols by name.  */
return|return
name|strcmp
argument_list|(
name|an
argument_list|,
name|bn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort relocs into address order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_relocs
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|address
operator|>
name|b
operator|->
name|address
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|address
operator|<
name|b
operator|->
name|address
condition|)
return|return
operator|-
literal|1
return|;
comment|/* So that associated relocations tied to the same address show up      in the correct order, we don't do any further sorting.  */
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print an address (VMA) to the output stream in INFO.    If SKIP_ZEROES is TRUE, omit leading zeroes.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_value
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|skip_zeroes
parameter_list|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_zeroes
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|==
literal|'0'
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the name of a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_symname
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
name|char
modifier|*
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|alloc
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Demangle the name.  */
name|alloc
operator|=
name|demangle
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|alloc
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate a symbol given a bfd and a section (from INFO->application_data),    and a VMA.  If INFO->application_data->require_sec is TRUE, then always    require the symbol to be in the section.  Returns NULL if there is no    suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index    of the symbol in sorted_syms.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|find_symbol_for_address
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
modifier|*
name|place
parameter_list|)
block|{
comment|/* @@ Would it speed things up to cache the last two symbols returned,      and maybe their address ranges?  For many processors, only one memory      operand can be present at a time, so the 2-entry cache wouldn't be      constantly churned by code doing heavy memory accesses.  */
comment|/* Indices in `sorted_syms'.  */
name|long
name|min
init|=
literal|0
decl_stmt|;
name|long
name|max
init|=
name|sorted_symcount
decl_stmt|;
name|long
name|thisplace
decl_stmt|;
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|opb
decl_stmt|;
if|if
condition|(
name|sorted_symcount
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|abfd
operator|=
name|aux
operator|->
name|abfd
expr_stmt|;
name|sec
operator|=
name|aux
operator|->
name|sec
expr_stmt|;
name|opb
operator|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Perform a binary search looking for the closest symbol to the      required value.  We are searching the range (min, max].  */
while|while
condition|(
name|min
operator|+
literal|1
operator|<
name|max
condition|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|thisplace
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|/
literal|2
expr_stmt|;
name|sym
operator|=
name|sorted_syms
index|[
name|thisplace
index|]
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|vma
condition|)
name|max
operator|=
name|thisplace
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|<
name|vma
condition|)
name|min
operator|=
name|thisplace
expr_stmt|;
else|else
block|{
name|min
operator|=
name|thisplace
expr_stmt|;
break|break;
block|}
block|}
comment|/* The symbol we want is now in min, the low end of the range we      were searching.  If there are several symbols with the same      value, we want the first one.  */
name|thisplace
operator|=
name|min
expr_stmt|;
while|while
condition|(
name|thisplace
operator|>
literal|0
operator|&&
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|)
operator|==
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
operator|--
name|thisplace
expr_stmt|;
comment|/* If the file is relocatable, and the symbol could be from this      section, prefer a symbol from this section over symbols from      others, even if the other symbol's value might be closer.       Note that this may be wrong for some symbol references if the      sections have overlapping memory ranges, but in that case there's      no way to tell what's desired without looking at the relocation      table.  */
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
operator|&&
operator|(
name|aux
operator|->
name|require_sec
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|vma
operator|>=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&&
name|vma
operator|<
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|/
name|opb
operator|)
operator|)
operator|)
condition|)
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|thisplace
operator|+
literal|1
init|;
name|i
operator|<
name|sorted_symcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|)
condition|)
break|break;
block|}
operator|--
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|section
operator|==
name|sec
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|sorted_syms
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|section
operator|!=
name|sec
operator|||
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|thisplace
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
condition|)
block|{
comment|/* We didn't find a good symbol with a smaller value. 	     Look for one with a larger value.  */
for|for
control|(
name|i
operator|=
name|thisplace
operator|+
literal|1
init|;
name|i
operator|<
name|sorted_symcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|section
operator|==
name|sec
condition|)
block|{
name|thisplace
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
operator|&&
operator|(
name|aux
operator|->
name|require_sec
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|vma
operator|>=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&&
name|vma
operator|<
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
operator|)
operator|)
condition|)
comment|/* There is no suitable symbol.  */
return|return
name|NULL
return|;
block|}
comment|/* Give the target a chance to reject the symbol.  */
while|while
condition|(
operator|!
name|info
operator|->
name|symbol_is_valid
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|,
name|info
argument_list|)
condition|)
block|{
operator|++
name|thisplace
expr_stmt|;
if|if
condition|(
name|thisplace
operator|>=
name|sorted_symcount
operator|||
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|)
operator|>
name|vma
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|place
operator|!=
name|NULL
condition|)
operator|*
name|place
operator|=
name|thisplace
expr_stmt|;
return|return
name|sorted_syms
index|[
name|thisplace
index|]
return|;
block|}
end_function

begin_comment
comment|/* Print an address and the offset to the nearest symbol.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_addr_with_sym
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|skip_zeroes
parameter_list|)
block|{
name|objdump_print_value
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|bfd_vma
name|secaddr
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<%s"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|secaddr
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|vma
operator|<
name|secaddr
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|secaddr
operator|-
name|vma
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|>
name|secaddr
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
operator|-
name|secaddr
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|objdump_print_symname
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|vma
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|-
name|vma
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|>
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
operator|-
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an address (VMA), symbolically if possible.    If SKIP_ZEROES is TRUE, don't output leading zeroes.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_addr
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|skip_zeroes
parameter_list|)
block|{
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|sorted_symcount
operator|<
literal|1
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
return|return;
block|}
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|objdump_print_addr_with_sym
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|aux
operator|->
name|sec
argument_list|,
name|sym
argument_list|,
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print VMA to INFO.  This function is passed to the disassembler    routine.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_address
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|objdump_print_addr
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
operator|!
name|prefix_addresses
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine of the given address has a symbol associated with it.  */
end_comment

begin_function
specifier|static
name|int
name|objdump_symbol_at_address
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|==
name|vma
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hold the last function name and the last line number we displayed    in a disassembly.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_functionname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|prev_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a list of all files that we have seen when doing a    disassembly with source, so that we know how much of the file to    display.  This can be important for inlined functions.  */
end_comment

begin_struct
struct|struct
name|print_file_list
block|{
name|struct
name|print_file_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|modname
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|print_file_list
modifier|*
name|print_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of preceding context lines to show when we start    displaying a file for the first time.  */
end_comment

begin_define
define|#
directive|define
name|SHOW_PRECEDING_CONTEXT_LINES
value|(5)
end_define

begin_comment
comment|/* Tries to open MODNAME, and if successful adds a node to print_files    linked list and returns that node.  Returns NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|print_file_list
modifier|*
name|try_print_file_open
parameter_list|(
specifier|const
name|char
modifier|*
name|origname
parameter_list|,
specifier|const
name|char
modifier|*
name|modname
parameter_list|)
block|{
name|struct
name|print_file_list
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|modname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|print_files
operator|!=
name|NULL
operator|&&
name|print_files
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|print_files
operator|->
name|f
argument_list|)
expr_stmt|;
name|print_files
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|print_file_list
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|origname
expr_stmt|;
name|p
operator|->
name|modname
operator|=
name|modname
expr_stmt|;
name|p
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|print_files
expr_stmt|;
name|print_files
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* If the the source file, as described in the symtab, is not found    try to locate it in one of the paths specified with -I    If found, add location to print_files linked list.  */
end_comment

begin_function
specifier|static
name|struct
name|print_file_list
modifier|*
name|update_source_path
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|print_file_list
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
name|try_print_file_open
argument_list|(
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
name|include_path_count
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Get the name of the file.  */
name|fname
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have a mixed forward/back slash case.  */
name|char
modifier|*
name|backslash
init|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
operator|(
name|backslash
operator|!=
name|NULL
operator|&&
name|backslash
operator|>
name|fname
operator|)
condition|)
name|fname
operator|=
name|backslash
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|&&
name|filename
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|fname
operator|=
name|filename
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
name|fname
operator|=
name|filename
expr_stmt|;
else|else
operator|++
name|fname
expr_stmt|;
comment|/* If file exists under a new path, we need to add it to the list      so that show_line knows about it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_path_count
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|modname
init|=
name|concat
argument_list|(
name|include_paths
index|[
name|i
index|]
argument_list|,
literal|"/"
argument_list|,
name|fname
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|p
operator|=
name|try_print_file_open
argument_list|(
name|filename
argument_list|,
name|modname
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|p
return|;
name|free
argument_list|(
name|modname
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Skip ahead to a given line in a file, optionally printing each    line.  */
end_comment

begin_function
specifier|static
name|void
name|skip_to_line
parameter_list|(
name|struct
name|print_file_list
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|bfd_boolean
name|show
parameter_list|)
block|{
while|while
condition|(
name|p
operator|->
name|line
operator|<
name|line
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|p
operator|->
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|f
argument_list|)
expr_stmt|;
name|p
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|show
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
operator|++
name|p
operator|->
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show the line number, or the source line, in a disassembly    listing.  */
end_comment

begin_function
specifier|static
name|void
name|show_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|addr_offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
operator|!
name|with_line_numbers
operator|&&
operator|!
name|with_source_code
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|syms
argument_list|,
name|addr_offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|line
argument_list|)
condition|)
return|return;
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
operator|*
name|filename
operator|==
literal|'\0'
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|*
name|functionname
operator|==
literal|'\0'
condition|)
name|functionname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|with_line_numbers
condition|)
block|{
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|prev_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|prev_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"%s():\n"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
name|line
operator|!=
name|prev_line
condition|)
name|printf
argument_list|(
literal|"%s:%u\n"
argument_list|,
name|filename
operator|==
name|NULL
condition|?
literal|"???"
else|:
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|with_source_code
operator|&&
name|filename
operator|!=
name|NULL
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|struct
name|print_file_list
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|print_files
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|print_files
condition|)
block|{
name|int
name|l
decl_stmt|;
comment|/* We have reencountered a file name which we saw 		 earlier.  This implies that either we are dumping out 		 code from an included file, or the same file was 		 linked in more than once.  There are two common cases 		 of an included file: inline functions in a header 		 file, and a bison or flex skeleton file.  In the 		 former case we want to just start printing (but we 		 back up a few lines to give context); in the latter 		 case we want to continue from where we left off.  I 		 can't think of a good way to distinguish the cases, 		 so I used a heuristic based on the file name.  */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|filename
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|filename
argument_list|)
operator|-
literal|2
argument_list|,
literal|".h"
argument_list|)
operator|!=
literal|0
condition|)
name|l
operator|=
name|p
operator|->
name|line
expr_stmt|;
else|else
block|{
name|l
operator|=
name|line
operator|-
name|SHOW_PRECEDING_CONTEXT_LINES
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|f
operator|=
name|fopen
argument_list|(
name|p
operator|->
name|modname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|p
operator|->
name|line
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_files
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|print_files
operator|->
name|f
argument_list|)
expr_stmt|;
name|print_files
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|print_files
expr_stmt|;
name|print_files
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|update_source_path
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|file_start_context
condition|)
name|l
operator|=
literal|0
expr_stmt|;
else|else
name|l
operator|=
name|line
operator|-
name|SHOW_PRECEDING_CONTEXT_LINES
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|prev_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|prev_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|prev_functionname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|prev_functionname
argument_list|)
expr_stmt|;
name|prev_functionname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|functionname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prev_functionname
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
name|line
operator|!=
name|prev_line
condition|)
name|prev_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pseudo FILE object for strings.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|current
decl_stmt|;
block|}
name|SFILE
typedef|;
end_typedef

begin_comment
comment|/* sprintf to a "stream".  */
end_comment

begin_function
specifier|static
name|int
name|objdump_sprintf
parameter_list|(
name|SFILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Out of virtual memory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|f
operator|->
name|buffer
operator|+
name|f
operator|->
name|size
operator|)
operator|-
name|f
operator|->
name|current
argument_list|)
operator|<
name|n
operator|+
literal|1
condition|)
block|{
name|size_t
name|curroff
decl_stmt|;
name|curroff
operator|=
name|f
operator|->
name|current
operator|-
name|f
operator|->
name|buffer
expr_stmt|;
name|f
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|f
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|f
operator|->
name|buffer
argument_list|,
name|f
operator|->
name|size
argument_list|)
expr_stmt|;
name|f
operator|->
name|current
operator|=
name|f
operator|->
name|buffer
operator|+
name|curroff
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|f
operator|->
name|current
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|f
operator|->
name|current
operator|+=
name|n
expr_stmt|;
name|f
operator|->
name|current
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the specified section should be dumped.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|process_section_p
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|only
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|only_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|only
index|[
name|i
index|]
argument_list|,
name|section
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* The number of zeroes we want to see before we start skipping them.    The number is arbitrarily chosen.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_ZEROES
end_ifndef

begin_define
define|#
directive|define
name|SKIP_ZEROES
value|(8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of zeroes to skip at the end of a section.  If the    number of zeroes at the end is between SKIP_ZEROES_AT_END and    SKIP_ZEROES, they will be disassembled.  If there are fewer than    SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic    attempt to avoid disassembling zeroes inserted by section    alignment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_ZEROES_AT_END
end_ifndef

begin_define
define|#
directive|define
name|SKIP_ZEROES_AT_END
value|(3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Disassemble some data in memory between given values.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_bytes
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|disassembler_ftype
name|disassemble_fn
parameter_list|,
name|bfd_boolean
name|insns
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|start_offset
parameter_list|,
name|bfd_vma
name|stop_offset
parameter_list|,
name|bfd_vma
name|rel_offset
parameter_list|,
name|arelent
modifier|*
modifier|*
modifier|*
name|relppp
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relppend
parameter_list|)
block|{
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|int
name|octets_per_line
decl_stmt|;
name|bfd_boolean
name|done_dot
decl_stmt|;
name|int
name|skip_addr_chars
decl_stmt|;
name|bfd_vma
name|addr_offset
decl_stmt|;
name|int
name|opb
init|=
name|info
operator|->
name|octets_per_byte
decl_stmt|;
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|section
operator|=
name|aux
operator|->
name|sec
expr_stmt|;
if|if
condition|(
name|insns
condition|)
name|octets_per_line
operator|=
literal|4
expr_stmt|;
else|else
name|octets_per_line
operator|=
literal|16
expr_stmt|;
comment|/* Figure out how many characters to skip at the start of an      address, to make the disassembly look nicer.  We discard leading      zeroes in chunks of 4, ensuring that there is always a leading      zero remaining.  */
name|skip_addr_chars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|(
name|section
operator|->
name|vma
operator|+
name|bfd_section_size
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|)
operator|/
name|opb
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|4
index|]
operator|==
literal|'0'
condition|)
block|{
name|skip_addr_chars
operator|+=
literal|4
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|info
operator|->
name|insn_info_valid
operator|=
literal|0
expr_stmt|;
name|done_dot
operator|=
name|FALSE
expr_stmt|;
name|addr_offset
operator|=
name|start_offset
expr_stmt|;
while|while
condition|(
name|addr_offset
operator|<
name|stop_offset
condition|)
block|{
name|bfd_vma
name|z
decl_stmt|;
name|int
name|octets
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|need_nl
init|=
name|FALSE
decl_stmt|;
comment|/* If we see more than SKIP_ZEROES octets of zeroes, we just 	 print `...'.  */
for|for
control|(
name|z
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|z
operator|<
name|stop_offset
operator|*
name|opb
condition|;
name|z
operator|++
control|)
if|if
condition|(
name|data
index|[
name|z
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|disassemble_zeroes
operator|&&
operator|(
name|info
operator|->
name|insn_info_valid
operator|==
literal|0
operator|||
name|info
operator|->
name|branch_delay_insns
operator|==
literal|0
operator|)
operator|&&
operator|(
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|>=
name|SKIP_ZEROES
operator|||
operator|(
name|z
operator|==
name|stop_offset
operator|*
name|opb
operator|&&
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|<
name|SKIP_ZEROES_AT_END
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\t...\n"
argument_list|)
expr_stmt|;
comment|/* If there are more nonzero octets to follow, we only skip 	     zeroes in multiples of 4, to try to avoid running over 	     the start of an instruction which happens to start with 	     zero.  */
if|if
condition|(
name|z
operator|!=
name|stop_offset
operator|*
name|opb
condition|)
name|z
operator|=
name|addr_offset
operator|*
name|opb
operator|+
operator|(
operator|(
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|octets
operator|=
name|z
operator|-
name|addr_offset
operator|*
name|opb
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|SFILE
name|sfile
decl_stmt|;
name|int
name|bpc
init|=
literal|0
decl_stmt|;
name|int
name|pb
init|=
literal|0
decl_stmt|;
name|done_dot
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|with_line_numbers
operator|||
name|with_source_code
condition|)
comment|/* The line number tables will refer to unadjusted 	       section VMAs, so we must undo any VMA modifications 	       when calling show_line.  */
name|show_line
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|section
argument_list|,
name|addr_offset
operator|-
name|adjust_section_vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|+
name|skip_addr_chars
init|;
operator|*
name|s
operator|==
literal|'0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\t"
argument_list|,
name|buf
operator|+
name|skip_addr_chars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|->
name|require_sec
operator|=
name|TRUE
expr_stmt|;
name|objdump_print_address
argument_list|(
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|aux
operator|->
name|require_sec
operator|=
name|FALSE
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insns
condition|)
block|{
name|sfile
operator|.
name|size
operator|=
literal|120
expr_stmt|;
name|sfile
operator|.
name|buffer
operator|=
name|xmalloc
argument_list|(
name|sfile
operator|.
name|size
argument_list|)
expr_stmt|;
name|sfile
operator|.
name|current
operator|=
name|sfile
operator|.
name|buffer
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|objdump_sprintf
expr_stmt|;
name|info
operator|->
name|stream
operator|=
operator|(
name|FILE
operator|*
operator|)
operator|&
name|sfile
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DISASSEMBLER_NEEDS_RELOCS
comment|/* FIXME: This is wrong.  It tests the number of octets 		 in the last instruction, not the current one.  */
if|if
condition|(
operator|*
name|relppp
operator|<
name|relppend
operator|&&
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|>=
name|rel_offset
operator|+
name|addr_offset
operator|&&
operator|(
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|<
name|rel_offset
operator|+
name|addr_offset
operator|+
name|octets
operator|/
name|opb
operator|)
condition|)
name|info
operator|->
name|flags
operator|=
name|INSN_HAS_RELOC
expr_stmt|;
else|else
endif|#
directive|endif
name|info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|octets
operator|=
call|(
modifier|*
name|disassemble_fn
call|)
argument_list|(
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|fprintf
expr_stmt|;
name|info
operator|->
name|stream
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bytes_per_line
operator|!=
literal|0
condition|)
name|octets_per_line
operator|=
name|info
operator|->
name|bytes_per_line
expr_stmt|;
if|if
condition|(
name|octets
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sfile
operator|.
name|current
operator|!=
name|sfile
operator|.
name|buffer
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|bfd_vma
name|j
decl_stmt|;
name|octets
operator|=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|addr_offset
operator|+
name|octets
operator|/
name|opb
operator|>
name|stop_offset
condition|)
name|octets
operator|=
operator|(
name|stop_offset
operator|-
name|addr_offset
operator|)
operator|*
name|opb
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|octets
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
condition|)
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
else|else
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|prefix_addresses
condition|?
name|show_raw_insn
operator|>
literal|0
else|:
name|show_raw_insn
operator|>=
literal|0
condition|)
block|{
name|bfd_vma
name|j
decl_stmt|;
comment|/* If ! prefix_addresses and ! wide_output, we print 		 octets_per_line octets per line.  */
name|pb
operator|=
name|octets
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|octets_per_line
operator|&&
operator|!
name|prefix_addresses
operator|&&
operator|!
name|wide_output
condition|)
name|pb
operator|=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bytes_per_chunk
condition|)
name|bpc
operator|=
name|info
operator|->
name|bytes_per_chunk
expr_stmt|;
else|else
name|bpc
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|pb
condition|;
name|j
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|bpc
operator|>
literal|1
operator|&&
name|info
operator|->
name|display_endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
block|{
for|for
control|(
name|k
operator|=
name|bpc
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|pb
operator|<
name|octets_per_line
condition|;
name|pb
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* Separate raw data from instruction by extra space.  */
if|if
condition|(
name|insns
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insns
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefix_addresses
condition|?
name|show_raw_insn
operator|>
literal|0
else|:
name|show_raw_insn
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|pb
operator|<
name|octets
condition|)
block|{
name|bfd_vma
name|j
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|j
operator|=
name|addr_offset
operator|*
name|opb
operator|+
name|pb
expr_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|section
operator|->
name|vma
operator|+
name|j
operator|/
name|opb
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|+
name|skip_addr_chars
init|;
operator|*
name|s
operator|==
literal|'0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\t"
argument_list|,
name|buf
operator|+
name|skip_addr_chars
argument_list|)
expr_stmt|;
name|pb
operator|+=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|octets
condition|)
name|pb
operator|=
name|octets
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|pb
condition|;
name|j
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|bpc
operator|>
literal|1
operator|&&
name|info
operator|->
name|display_endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
block|{
for|for
control|(
name|k
operator|=
name|bpc
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|wide_output
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|need_nl
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|relppp
operator|)
operator|<
name|relppend
operator|&&
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|<
name|rel_offset
operator|+
name|addr_offset
operator|+
name|octets
operator|/
name|opb
condition|)
block|{
if|if
condition|(
name|dump_reloc_info
operator|||
name|dump_dynamic_reloc_info
condition|)
block|{
name|arelent
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|*
operator|*
name|relppp
expr_stmt|;
if|if
condition|(
name|wide_output
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t\t\t"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|section
operator|->
name|vma
operator|-
name|rel_offset
operator|+
name|q
operator|->
name|address
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s\t"
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
operator|||
operator|*
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"*unknown*"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|sym_name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|!=
name|NULL
operator|&&
operator|*
name|sym_name
operator|!=
literal|'\0'
condition|)
name|objdump_print_symname
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|info
argument_list|,
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|sym_sec
operator|=
name|bfd_get_section
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_get_section_name
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
operator|||
operator|*
name|sym_name
operator|==
literal|'\0'
condition|)
name|sym_name
operator|=
literal|"*unknown*"
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|addend
condition|)
block|{
name|printf
argument_list|(
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|q
operator|->
name|addend
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|need_nl
operator|=
name|FALSE
expr_stmt|;
block|}
operator|++
operator|(
operator|*
name|relppp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|need_nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|addr_offset
operator|+=
name|octets
operator|/
name|opb
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disassemble_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|disassemble_info
modifier|*
name|pinfo
init|=
operator|(
expr|struct
name|disassemble_info
operator|*
operator|)
name|info
decl_stmt|;
name|struct
name|objdump_disasm_info
modifier|*
name|paux
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|pinfo
operator|->
name|octets_per_byte
decl_stmt|;
name|bfd_byte
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|rel_pp
init|=
name|NULL
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|rel_ppstart
init|=
name|NULL
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|rel_ppend
decl_stmt|;
name|unsigned
name|long
name|stop_offset
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|long
name|place
init|=
literal|0
decl_stmt|;
name|long
name|rel_count
decl_stmt|;
name|bfd_vma
name|rel_offset
decl_stmt|;
name|unsigned
name|long
name|addr_offset
decl_stmt|;
comment|/* Sections that do not contain machine      code are not normally disassembled.  */
if|if
condition|(
operator|!
name|disassemble_all
operator|&&
name|only
operator|==
name|NULL
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|process_section_p
argument_list|(
name|section
argument_list|)
condition|)
return|return;
name|datasize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
return|return;
comment|/* Decide which set of relocs to use.  Load them if necessary.  */
name|paux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|pinfo
operator|->
name|application_data
expr_stmt|;
if|if
condition|(
name|paux
operator|->
name|dynrelbuf
condition|)
block|{
name|rel_pp
operator|=
name|paux
operator|->
name|dynrelbuf
expr_stmt|;
name|rel_count
operator|=
name|paux
operator|->
name|dynrelcount
expr_stmt|;
comment|/* Dynamic reloc addresses are absolute, non-dynamic are section 	 relative.  REL_OFFSET specifies the reloc address corresponding 	 to the start of this section.  */
name|rel_offset
operator|=
name|section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|rel_count
operator|=
literal|0
expr_stmt|;
name|rel_pp
operator|=
name|NULL
expr_stmt|;
name|rel_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
ifndef|#
directive|ifndef
name|DISASSEMBLER_NEEDS_RELOCS
operator|&&
name|dump_reloc_info
endif|#
directive|endif
condition|)
block|{
name|long
name|relsize
decl_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|>
literal|0
condition|)
block|{
name|rel_ppstart
operator|=
name|rel_pp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|rel_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|rel_pp
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_count
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the relocs by address.  */
name|qsort
argument_list|(
name|rel_pp
argument_list|,
name|rel_count
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|,
name|compare_relocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rel_ppend
operator|=
name|rel_pp
operator|+
name|rel_count
expr_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|paux
operator|->
name|sec
operator|=
name|section
expr_stmt|;
name|pinfo
operator|->
name|buffer
operator|=
name|data
expr_stmt|;
name|pinfo
operator|->
name|buffer_vma
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|pinfo
operator|->
name|buffer_length
operator|=
name|datasize
expr_stmt|;
name|pinfo
operator|->
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|start_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|start_address
operator|<
name|pinfo
operator|->
name|buffer_vma
condition|)
name|addr_offset
operator|=
literal|0
expr_stmt|;
else|else
name|addr_offset
operator|=
name|start_address
operator|-
name|pinfo
operator|->
name|buffer_vma
expr_stmt|;
if|if
condition|(
name|stop_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|stop_offset
operator|=
name|datasize
operator|/
name|opb
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stop_address
operator|<
name|pinfo
operator|->
name|buffer_vma
condition|)
name|stop_offset
operator|=
literal|0
expr_stmt|;
else|else
name|stop_offset
operator|=
name|stop_address
operator|-
name|pinfo
operator|->
name|buffer_vma
expr_stmt|;
if|if
condition|(
name|stop_offset
operator|>
name|pinfo
operator|->
name|buffer_length
operator|/
name|opb
condition|)
name|stop_offset
operator|=
name|pinfo
operator|->
name|buffer_length
operator|/
name|opb
expr_stmt|;
block|}
comment|/* Skip over the relocs belonging to addresses below the      start address.  */
while|while
condition|(
name|rel_pp
operator|<
name|rel_ppend
operator|&&
operator|(
operator|*
name|rel_pp
operator|)
operator|->
name|address
operator|<
name|rel_offset
operator|+
name|addr_offset
condition|)
operator|++
name|rel_pp
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Disassembly of section %s:\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Find the nearest symbol forwards from our current position.  */
name|paux
operator|->
name|require_sec
operator|=
name|TRUE
expr_stmt|;
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|info
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
name|paux
operator|->
name|require_sec
operator|=
name|FALSE
expr_stmt|;
comment|/* Disassemble a block of instructions up to the address associated with      the symbol we have just found.  Then print the symbol and find the      next symbol on.  Repeat until we have disassembled the entire section      or we have reached the end of the address range we are interested in.  */
while|while
condition|(
name|addr_offset
operator|<
name|stop_offset
condition|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|asymbol
modifier|*
name|nextsym
decl_stmt|;
name|unsigned
name|long
name|nextstop_offset
decl_stmt|;
name|bfd_boolean
name|insns
decl_stmt|;
name|addr
operator|=
name|section
operator|->
name|vma
operator|+
name|addr_offset
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|<=
name|addr
condition|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|place
init|;
operator|(
name|x
operator|<
name|sorted_symcount
operator|&&
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|x
index|]
argument_list|)
operator|<=
name|addr
operator|)
operator|)
condition|;
operator|++
name|x
control|)
continue|continue;
name|pinfo
operator|->
name|symbols
operator|=
name|sorted_syms
operator|+
name|place
expr_stmt|;
name|pinfo
operator|->
name|num_symbols
operator|=
name|x
operator|-
name|place
expr_stmt|;
block|}
else|else
block|{
name|pinfo
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
name|pinfo
operator|->
name|num_symbols
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|pinfo
operator|->
name|fprintf_func
argument_list|(
name|pinfo
operator|->
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|objdump_print_addr_with_sym
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|pinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pinfo
operator|->
name|fprintf_func
argument_list|(
name|pinfo
operator|->
name|stream
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|addr
condition|)
name|nextsym
operator|=
name|sym
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|nextsym
operator|=
name|NULL
expr_stmt|;
else|else
block|{
define|#
directive|define
name|is_valid_next_sym
parameter_list|(
name|SYM
parameter_list|)
define|\
value|((SYM)->section == section \&& (bfd_asymbol_value (SYM)> bfd_asymbol_value (sym)) \&& pinfo->symbol_is_valid (SYM, pinfo))
comment|/* Search forward for the next appropriate symbol in 	     SECTION.  Note that all the symbols are sorted 	     together into one big array, and that some sections 	     may have overlapping addresses.  */
while|while
condition|(
name|place
operator|<
name|sorted_symcount
operator|&&
operator|!
name|is_valid_next_sym
argument_list|(
name|sorted_syms
index|[
name|place
index|]
argument_list|)
condition|)
operator|++
name|place
expr_stmt|;
if|if
condition|(
name|place
operator|>=
name|sorted_symcount
condition|)
name|nextsym
operator|=
name|NULL
expr_stmt|;
else|else
name|nextsym
operator|=
name|sorted_syms
index|[
name|place
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|addr
condition|)
name|nextstop_offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
elseif|else
if|if
condition|(
name|nextsym
operator|==
name|NULL
condition|)
name|nextstop_offset
operator|=
name|stop_offset
expr_stmt|;
else|else
name|nextstop_offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|nextsym
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|nextstop_offset
operator|>
name|stop_offset
condition|)
name|nextstop_offset
operator|=
name|stop_offset
expr_stmt|;
comment|/* If a symbol is explicitly marked as being an object 	 rather than a function, just dump the bytes without 	 disassembling them.  */
if|if
condition|(
name|disassemble_all
operator|||
name|sym
operator|==
name|NULL
operator|||
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|addr
operator|||
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_OBJECT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|strstr
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|strstr
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
name|insns
operator|=
name|TRUE
expr_stmt|;
else|else
name|insns
operator|=
name|FALSE
expr_stmt|;
name|disassemble_bytes
argument_list|(
name|pinfo
argument_list|,
name|paux
operator|->
name|disassemble_fn
argument_list|,
name|insns
argument_list|,
name|data
argument_list|,
name|addr_offset
argument_list|,
name|nextstop_offset
argument_list|,
name|rel_offset
argument_list|,
operator|&
name|rel_pp
argument_list|,
name|rel_ppend
argument_list|)
expr_stmt|;
name|addr_offset
operator|=
name|nextstop_offset
expr_stmt|;
name|sym
operator|=
name|nextsym
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel_ppstart
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rel_ppstart
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Disassemble the contents of an object file.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|disassemble_info
name|disasm_info
decl_stmt|;
name|struct
name|objdump_disasm_info
name|aux
decl_stmt|;
name|print_files
operator|=
name|NULL
expr_stmt|;
name|prev_functionname
operator|=
name|NULL
expr_stmt|;
name|prev_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We make a copy of syms to sort.  We don't want to sort syms      because that will screw up the relocs.  */
name|sorted_syms
operator|=
name|xmalloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sorted_syms
argument_list|,
name|syms
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sorted_symcount
operator|=
name|remove_useless_symbols
argument_list|(
name|sorted_syms
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* Sort the symbols into section and symbol order.  */
name|qsort
argument_list|(
name|sorted_syms
argument_list|,
name|sorted_symcount
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
name|init_disassemble_info
argument_list|(
operator|&
name|disasm_info
argument_list|,
name|stdout
argument_list|,
operator|(
name|fprintf_ftype
operator|)
name|fprintf
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|application_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|aux
expr_stmt|;
name|aux
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|aux
operator|.
name|require_sec
operator|=
name|FALSE
expr_stmt|;
name|aux
operator|.
name|dynrelbuf
operator|=
name|NULL
expr_stmt|;
name|aux
operator|.
name|dynrelcount
operator|=
literal|0
expr_stmt|;
name|disasm_info
operator|.
name|print_address_func
operator|=
name|objdump_print_address
expr_stmt|;
name|disasm_info
operator|.
name|symbol_at_address_func
operator|=
name|objdump_symbol_at_address
expr_stmt|;
if|if
condition|(
name|machine
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|info
init|=
name|bfd_scan_arch
argument_list|(
name|machine
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Can't use supplied machine %s"
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|arch_info
operator|=
name|info
expr_stmt|;
block|}
if|if
condition|(
name|endian
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
name|struct
name|bfd_target
modifier|*
name|xvec
decl_stmt|;
name|xvec
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_target
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|xvec
argument_list|,
name|abfd
operator|->
name|xvec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_target
argument_list|)
argument_list|)
expr_stmt|;
name|xvec
operator|->
name|byteorder
operator|=
name|endian
expr_stmt|;
name|abfd
operator|->
name|xvec
operator|=
name|xvec
expr_stmt|;
block|}
comment|/* Use libopcodes to locate a suitable disassembler.  */
name|aux
operator|.
name|disassemble_fn
operator|=
name|disassembler
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aux
operator|.
name|disassemble_fn
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't disassemble for architecture %s\n"
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|disasm_info
operator|.
name|flavour
operator|=
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|arch
operator|=
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|mach
operator|=
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|disassembler_options
operator|=
name|disassembler_options
expr_stmt|;
name|disasm_info
operator|.
name|octets_per_byte
operator|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|disasm_info
operator|.
name|display_endian
operator|=
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|disasm_info
operator|.
name|display_endian
operator|=
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
comment|/* ??? Aborting here seems too drastic.  We could default to big or little        instead.  */
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_UNKNOWN
expr_stmt|;
comment|/* Allow the target to customize the info structure.  */
name|disassemble_init_for_target
argument_list|(
operator|&
name|disasm_info
argument_list|)
expr_stmt|;
comment|/* Pre-load the dynamic relocs if we are going      to be dumping them along with the disassembly.  */
if|if
condition|(
name|dump_dynamic_reloc_info
condition|)
block|{
name|long
name|relsize
init|=
name|bfd_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|>
literal|0
condition|)
block|{
name|aux
operator|.
name|dynrelbuf
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|aux
operator|.
name|dynrelcount
operator|=
name|bfd_canonicalize_dynamic_reloc
argument_list|(
name|abfd
argument_list|,
name|aux
operator|.
name|dynrelbuf
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|dynrelcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the relocs by address.  */
name|qsort
argument_list|(
name|aux
operator|.
name|dynrelbuf
argument_list|,
name|aux
operator|.
name|dynrelcount
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|,
name|compare_relocs
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|disassemble_section
argument_list|,
operator|&
name|disasm_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|.
name|dynrelbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aux
operator|.
name|dynrelbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sorted_syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to    it.  Return NULL on failure.   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_section_stabs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|bfd_size_type
modifier|*
name|size_ptr
parameter_list|)
block|{
name|asection
modifier|*
name|stabsect
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|stabsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabsect
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"No %s section present\n\n"
argument_list|)
argument_list|,
name|sect_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|stabsect
argument_list|)
expr_stmt|;
name|contents
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stabsect
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Reading %s section of %s failed: %s"
argument_list|)
argument_list|,
name|sect_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|size_ptr
operator|=
name|size
expr_stmt|;
return|return
name|contents
return|;
block|}
end_function

begin_comment
comment|/* Stabs entries use a 12 byte format:      4 byte string table index      1 byte stab type      1 byte stab other field      2 byte stab desc field      4 byte stab value    FIXME: This will have to change for a 64 bit object format.  */
end_comment

begin_define
define|#
directive|define
name|STRDXOFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TYPEOFF
value|(4)
end_define

begin_define
define|#
directive|define
name|OTHEROFF
value|(5)
end_define

begin_define
define|#
directive|define
name|DESCOFF
value|(6)
end_define

begin_define
define|#
directive|define
name|VALOFF
value|(8)
end_define

begin_define
define|#
directive|define
name|STABSIZE
value|(12)
end_define

begin_comment
comment|/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),    using string table section STRSECT_NAME (in `strtab').  */
end_comment

begin_function
specifier|static
name|void
name|print_section_stabs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|stabsect_name
parameter_list|,
name|unsigned
modifier|*
name|string_offset_ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|file_string_table_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|next_file_string_table_offset
init|=
operator|*
name|string_offset_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|stabp
decl_stmt|,
modifier|*
name|stabs_end
decl_stmt|;
name|stabp
operator|=
name|stabs
expr_stmt|;
name|stabs_end
operator|=
name|stabp
operator|+
name|stab_size
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of %s section:\n\n"
argument_list|)
argument_list|,
name|stabsect_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Symnum n_type n_othr n_desc n_value  n_strx String\n"
argument_list|)
expr_stmt|;
comment|/* Loop through all symbols and print them.       We start the index at -1 because there is a dummy symbol on      the front of stabs-in-{coff,elf} sections that supplies sizes.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|stabp
operator|<
name|stabs_end
condition|;
name|stabp
operator|+=
name|STABSIZE
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|strx
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|,
name|other
decl_stmt|;
name|unsigned
name|short
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|strx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|TYPEOFF
argument_list|)
expr_stmt|;
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|OTHEROFF
argument_list|)
expr_stmt|;
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%-6d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Either print the stab name, or, if unnamed, print its number 	 again (makes consistent formatting for tools like awk).  */
name|name
operator|=
name|bfd_get_stab_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|N_UNDF
condition|)
name|printf
argument_list|(
literal|"HdrSym"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-6d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6d %-6d "
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6lu"
argument_list|,
name|strx
argument_list|)
expr_stmt|;
comment|/* Symbols with type == 0 (N_UNDF) specify the length of the 	 string table associated with this file.  We use that info 	 to know how to relocate the *next* file's string table indices.  */
if|if
condition|(
name|type
operator|==
name|N_UNDF
condition|)
block|{
name|file_string_table_offset
operator|=
name|next_file_string_table_offset
expr_stmt|;
name|next_file_string_table_offset
operator|+=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Using the (possibly updated) string table offset, print the 	     string (if any) associated with this symbol.  */
if|if
condition|(
operator|(
name|strx
operator|+
name|file_string_table_offset
operator|)
operator|<
name|stabstr_size
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|&
name|strtab
index|[
name|strx
operator|+
name|file_string_table_offset
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
operator|*
name|string_offset_ptr
operator|=
name|next_file_string_table_offset
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_section_name
decl_stmt|;
name|unsigned
name|string_offset
decl_stmt|;
block|}
name|stab_section_names
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|find_stabs_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|names
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|stab_section_names
modifier|*
name|sought
init|=
operator|(
name|stab_section_names
operator|*
operator|)
name|names
decl_stmt|;
comment|/* Check for section names for which stabsect_name is a prefix, to      handle .stab.N, etc.  */
name|len
operator|=
name|strlen
argument_list|(
name|sought
operator|->
name|section_name
argument_list|)
expr_stmt|;
comment|/* If the prefix matches, and the files section name ends with a      nul or a digit, then we match.  I.e., we want either an exact      match or a section followed by a number.  */
if|if
condition|(
name|strncmp
argument_list|(
name|sought
operator|->
name|section_name
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|section
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'.'
operator|&&
name|ISDIGIT
argument_list|(
name|section
operator|->
name|name
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
name|strtab
operator|=
name|read_section_stabs
argument_list|(
name|abfd
argument_list|,
name|sought
operator|->
name|string_section_name
argument_list|,
operator|&
name|stabstr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
condition|)
block|{
name|stabs
operator|=
name|read_section_stabs
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|&
name|stab_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabs
condition|)
name|print_section_stabs
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|&
name|sought
operator|->
name|string_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_stabs_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|stabsect_name
parameter_list|,
name|char
modifier|*
name|strsect_name
parameter_list|)
block|{
name|stab_section_names
name|s
decl_stmt|;
name|s
operator|.
name|section_name
operator|=
name|stabsect_name
expr_stmt|;
name|s
operator|.
name|string_section_name
operator|=
name|strsect_name
expr_stmt|;
name|s
operator|.
name|string_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_stabs_section
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the any sections containing stabs debugging information.  */
end_comment

begin_function
specifier|static
name|void
name|dump_stabs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|dump_stabs_section
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
name|dump_stabs_section
argument_list|(
name|abfd
argument_list|,
literal|".stab.excl"
argument_list|,
literal|".stab.exclstr"
argument_list|)
expr_stmt|;
name|dump_stabs_section
argument_list|(
name|abfd
argument_list|,
literal|".stab.index"
argument_list|,
literal|".stab.indexstr"
argument_list|)
expr_stmt|;
name|dump_stabs_section
argument_list|(
name|abfd
argument_list|,
literal|"$GDB_SYMBOLS$"
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_bfd_header
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"architecture: %s, "
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"flags 0x%08x:\n"
argument_list|)
argument_list|,
name|abfd
operator|->
name|flags
argument_list|)
expr_stmt|;
define|#
directive|define
name|PF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|if (abfd->flags& x) {printf("%s%s", comma, y); comma=", ";}
name|PF
argument_list|(
name|HAS_RELOC
argument_list|,
literal|"HAS_RELOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|EXEC_P
argument_list|,
literal|"EXEC_P"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_LINENO
argument_list|,
literal|"HAS_LINENO"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_DEBUG
argument_list|,
literal|"HAS_DEBUG"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_SYMS
argument_list|,
literal|"HAS_SYMS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_LOCALS
argument_list|,
literal|"HAS_LOCALS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|DYNAMIC
argument_list|,
literal|"DYNAMIC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|WP_TEXT
argument_list|,
literal|"WP_TEXT"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|D_PAGED
argument_list|,
literal|"D_PAGED"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|BFD_IS_RELAXABLE
argument_list|,
literal|"BFD_IS_RELAXABLE"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_LOAD_PAGE
argument_list|,
literal|"HAS_LOAD_PAGE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nstart address 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_bfd_private_header
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Display a section in hexadecimal format with associated characters.    Each line prefixed by the zero padded address.  */
end_comment

begin_function
specifier|static
name|void
name|dump_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|datasize
decl_stmt|;
name|bfd_size_type
name|addr_offset
decl_stmt|;
name|bfd_size_type
name|start_offset
decl_stmt|;
name|bfd_size_type
name|stop_offset
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Bytes per line.  */
specifier|const
name|int
name|onaline
init|=
literal|16
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|process_section_p
argument_list|(
name|section
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of section %s:\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|data
operator|=
name|xmalloc
argument_list|(
name|datasize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
comment|/* Compute the address range to display.  */
if|if
condition|(
name|start_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|start_address
operator|<
name|section
operator|->
name|vma
condition|)
name|start_offset
operator|=
literal|0
expr_stmt|;
else|else
name|start_offset
operator|=
name|start_address
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|stop_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|stop_offset
operator|=
name|datasize
operator|/
name|opb
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stop_address
operator|<
name|section
operator|->
name|vma
condition|)
name|stop_offset
operator|=
literal|0
expr_stmt|;
else|else
name|stop_offset
operator|=
name|stop_address
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|stop_offset
operator|>
name|datasize
operator|/
name|opb
condition|)
name|stop_offset
operator|=
name|datasize
operator|/
name|opb
expr_stmt|;
block|}
name|width
operator|=
literal|4
expr_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|start_offset
operator|+
name|section
operator|->
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|count
index|]
operator|==
literal|'0'
operator|&&
name|buf
index|[
name|count
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|count
operator|++
expr_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|width
condition|)
name|width
operator|=
name|count
expr_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
name|stop_offset
operator|+
name|section
operator|->
name|vma
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|count
index|]
operator|==
literal|'0'
operator|&&
name|buf
index|[
name|count
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|count
operator|++
expr_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|width
condition|)
name|width
operator|=
name|count
expr_stmt|;
for|for
control|(
name|addr_offset
operator|=
name|start_offset
init|;
name|addr_offset
operator|<
name|stop_offset
condition|;
name|addr_offset
operator|+=
name|onaline
operator|/
name|opb
control|)
block|{
name|bfd_size_type
name|j
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
operator|(
name|addr_offset
operator|+
name|section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|count
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|width
condition|)
block|{
name|putchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|buf
operator|+
name|count
operator|-
name|width
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|onaline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|stop_offset
operator|*
name|opb
condition|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|onaline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|stop_offset
operator|*
name|opb
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|ISPRINT
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
condition|?
name|data
index|[
name|j
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Actually display the various requested regions.  */
end_comment

begin_function
specifier|static
name|void
name|dump_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dump_section
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should perhaps share code and display with nm?  */
end_comment

begin_function
specifier|static
name|void
name|dump_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|current
decl_stmt|;
name|long
name|max
decl_stmt|;
name|long
name|count
decl_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|current
operator|=
name|dynsyms
expr_stmt|;
name|max
operator|=
name|dynsymcount
expr_stmt|;
name|printf
argument_list|(
literal|"DYNAMIC SYMBOL TABLE:\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|syms
expr_stmt|;
name|max
operator|=
name|symcount
expr_stmt|;
name|printf
argument_list|(
literal|"SYMBOL TABLE:\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|==
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"no symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max
condition|;
name|count
operator|++
control|)
block|{
name|bfd
modifier|*
name|cur_bfd
decl_stmt|;
if|if
condition|(
operator|*
name|current
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"no information for the %ld'th symbol"
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cur_bfd
operator|=
name|bfd_asymbol_bfd
argument_list|(
operator|*
name|current
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"could not determine the type of the %ld'th symbol"
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
operator|*
name|current
operator|)
operator|->
name|name
decl_stmt|;
if|if
condition|(
name|do_demangle
operator|&&
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|alloc
decl_stmt|;
comment|/* If we want to demangle the name, we demangle it 		 here, and temporarily clobber it while calling 		 bfd_print_symbol.  FIXME: This is a gross hack.  */
name|alloc
operator|=
name|demangle
argument_list|(
name|cur_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|current
operator|)
operator|->
name|name
operator|=
name|alloc
expr_stmt|;
name|bfd_print_symbol
argument_list|(
name|cur_bfd
argument_list|,
name|stdout
argument_list|,
operator|*
name|current
argument_list|,
name|bfd_print_symbol_all
argument_list|)
expr_stmt|;
operator|(
operator|*
name|current
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|free
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_print_symbol
argument_list|(
name|cur_bfd
argument_list|,
name|stdout
argument_list|,
operator|*
name|current
argument_list|,
name|bfd_print_symbol_all
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|current
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_reloc_set
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relpp
parameter_list|,
name|long
name|relcount
parameter_list|)
block|{
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|last_filename
decl_stmt|,
modifier|*
name|last_functionname
decl_stmt|;
name|unsigned
name|int
name|last_line
decl_stmt|;
comment|/* Get column headers lined up reasonably.  */
block|{
specifier|static
name|int
name|width
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"OFFSET %*s TYPE %*s VALUE \n"
argument_list|,
name|width
argument_list|,
literal|""
argument_list|,
literal|12
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|last_filename
operator|=
name|NULL
expr_stmt|;
name|last_functionname
operator|=
name|NULL
expr_stmt|;
name|last_line
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|relpp
init|;
name|relcount
operator|&&
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|relcount
operator|--
control|)
block|{
name|arelent
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
if|if
condition|(
name|start_address
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|q
operator|->
name|address
operator|<
name|start_address
condition|)
continue|continue;
if|if
condition|(
name|stop_address
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|q
operator|->
name|address
operator|>
name|stop_address
condition|)
continue|continue;
if|if
condition|(
name|with_line_numbers
operator|&&
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|syms
argument_list|,
name|q
operator|->
name|address
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|last_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|last_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s():\n"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_functionname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_functionname
argument_list|)
expr_stmt|;
name|last_functionname
operator|=
name|xstrdup
argument_list|(
name|functionname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
operator|(
name|line
operator|!=
name|last_line
operator|||
operator|(
name|filename
operator|!=
name|NULL
operator|&&
name|last_filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|last_filename
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%u\n"
argument_list|,
name|filename
operator|==
name|NULL
condition|?
literal|"???"
else|:
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|last_line
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|last_filename
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|last_filename
operator|=
name|NULL
expr_stmt|;
else|else
name|last_filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|&&
operator|*
name|q
operator|->
name|sym_ptr_ptr
condition|)
block|{
name|sym_name
operator|=
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|name
expr_stmt|;
name|section_name
operator|=
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|sym_name
operator|=
name|NULL
expr_stmt|;
name|section_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sym_name
condition|)
block|{
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|howto
operator|->
name|name
condition|)
name|printf
argument_list|(
literal|" %-16s  "
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %-16d  "
argument_list|,
name|q
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|objdump_print_symname
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|section_name
operator|==
name|NULL
condition|)
name|section_name
operator|=
literal|"*unknown*"
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-16s  [%s]"
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|addend
condition|)
block|{
name|printf
argument_list|(
literal|"+0x"
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_relocs_in_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|long
name|relsize
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
operator|||
operator|(
operator|!
name|process_section_p
argument_list|(
name|section
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RELOCATION RECORDS FOR [%s]:"
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relpp
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_reloc_set
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dump_relocs_in_section
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dynamic_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|relsize
operator|=
name|bfd_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DYNAMIC RELOCATION RECORDS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|relpp
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_dynamic_reloc
argument_list|(
name|abfd
argument_list|,
name|relpp
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_reloc_set
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Creates a table of paths, to search for source files.  */
end_comment

begin_function
specifier|static
name|void
name|add_include_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
name|include_path_count
operator|++
expr_stmt|;
name|include_paths
operator|=
name|xrealloc
argument_list|(
name|include_paths
argument_list|,
name|include_path_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_paths
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
if|if
condition|(
name|path
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|path
index|[
literal|2
index|]
operator|==
literal|0
condition|)
name|path
operator|=
name|concat
argument_list|(
name|path
argument_list|,
literal|"."
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|include_paths
index|[
name|include_path_count
operator|-
literal|1
index|]
operator|=
name|path
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_addresses
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|dummy
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|section
operator|->
name|vma
operator|+=
name|adjust_section_vma
expr_stmt|;
name|section
operator|->
name|lma
operator|+=
name|adjust_section_vma
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump selected contents of ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|dump_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* If we are adjusting section VMA's, change them all now.  Changing      the BFD information is a hack.  However, we must do it, or      bfd_find_nearest_line will not do the right thing.  */
if|if
condition|(
name|adjust_section_vma
operator|!=
literal|0
condition|)
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|adjust_addresses
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_debugging_tags
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n%s:     file format %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_ar_hdrs
condition|)
name|print_arelt_descr
argument_list|(
name|stdout
argument_list|,
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file_header
condition|)
name|dump_bfd_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_private_headers
condition|)
name|dump_bfd_private_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dump_debugging_tags
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_section_headers
condition|)
name|dump_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_symtab
operator|||
name|dump_reloc_info
operator|||
name|disassemble
operator|||
name|dump_debugging
condition|)
name|syms
operator|=
name|slurp_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_dynamic_symtab
operator|||
name|dump_dynamic_reloc_info
condition|)
name|dynsyms
operator|=
name|slurp_dynamic_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_symtab
condition|)
name|dump_symbols
argument_list|(
name|abfd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_dynamic_symtab
condition|)
name|dump_symbols
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_stab_section_info
condition|)
name|dump_stabs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_reloc_info
operator|&&
operator|!
name|disassemble
condition|)
name|dump_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_dynamic_reloc_info
operator|&&
operator|!
name|disassemble
condition|)
name|dump_dynamic_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_section_contents
condition|)
name|dump_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|disassemble
condition|)
name|disassemble_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_debugging
condition|)
block|{
name|void
modifier|*
name|dhandle
decl_stmt|;
name|dhandle
operator|=
name|read_debugging_info
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhandle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|print_debugging_info
argument_list|(
name|stdout
argument_list|,
name|dhandle
argument_list|,
name|abfd
argument_list|,
name|syms
argument_list|,
name|demangle
argument_list|,
name|dump_debugging_tags
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: printing debugging information failed"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|syms
condition|)
block|{
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
name|syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynsyms
condition|)
block|{
name|free
argument_list|(
name|dynsyms
argument_list|)
expr_stmt|;
name|dynsyms
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|dump_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_not_recognized
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_core
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|dump_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|target
parameter_list|)
block|{
name|bfd
modifier|*
name|file
decl_stmt|;
name|bfd
modifier|*
name|arfile
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|get_file_size
argument_list|(
name|filename
argument_list|)
operator|<
literal|1
condition|)
return|return;
name|file
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the file is an archive, process all of its elements.  */
if|if
condition|(
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|last_arfile
init|=
name|NULL
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"In archive %s:\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|file
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_more_archived_files
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|display_bfd
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
name|last_arfile
operator|=
name|arfile
expr_stmt|;
block|}
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
block|}
else|else
name|display_bfd
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|default_target
decl_stmt|;
name|bfd_boolean
name|seenflag
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
operator|*
name|argv
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"pib:m:M:VvCdDlfaHhrRtTxsSI:j:wE:zgeG"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* We've been given a long option.  */
case|case
literal|'m'
case|:
name|machine
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|disassembler_options
condition|)
comment|/* Ignore potential memory leak for now.  */
name|disassembler_options
operator|=
name|concat
argument_list|(
name|disassembler_options
argument_list|,
literal|","
argument_list|,
name|optarg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|disassembler_options
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
name|only_used
operator|==
name|only_size
condition|)
block|{
name|only_size
operator|+=
literal|8
expr_stmt|;
name|only
operator|=
name|xrealloc
argument_list|(
name|only
argument_list|,
name|only_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|only
index|[
name|only_used
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|with_line_numbers
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|do_demangle
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unknown demangling style `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|wide_output
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_ADJUST_VMA
case|:
name|adjust_section_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--adjust-vma"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_START_ADDRESS
case|:
name|start_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--start-address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_STOP_ADDRESS
case|:
name|stop_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--stop-address"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"B"
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"L"
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized -E option"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_ENDIAN
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"big"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"little"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized --endian type `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|dump_file_header
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|formats_info
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|add_include_path
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|dump_private_headers
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|dump_private_headers
operator|=
name|TRUE
expr_stmt|;
name|dump_symtab
operator|=
name|TRUE
expr_stmt|;
name|dump_reloc_info
operator|=
name|TRUE
expr_stmt|;
name|dump_file_header
operator|=
name|TRUE
expr_stmt|;
name|dump_ar_hdrs
operator|=
name|TRUE
expr_stmt|;
name|dump_section_headers
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|dump_symtab
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|dump_dynamic_symtab
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|disassemble
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|disassemble_zeroes
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|disassemble
operator|=
name|TRUE
expr_stmt|;
name|disassemble_all
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|disassemble
operator|=
name|TRUE
expr_stmt|;
name|with_source_code
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|dump_debugging
operator|=
literal|1
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|dump_debugging
operator|=
literal|1
expr_stmt|;
name|dump_debugging_tags
operator|=
literal|1
expr_stmt|;
name|do_demangle
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|dump_stab_section_info
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|dump_section_contents
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|dump_reloc_info
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|dump_dynamic_reloc_info
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|dump_ar_hdrs
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|dump_section_headers
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|show_version
operator|=
name|TRUE
expr_stmt|;
name|seenflag
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"objdump"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seenflag
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|formats_info
condition|)
name|exit_status
operator|=
name|display_info
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|display_file
argument_list|(
literal|"a.out"
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
control|)
name|display_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

end_unit

