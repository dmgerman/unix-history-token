begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objdump.c -- dump information about an object file.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"budemang.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"budbg.h"
end_include

begin_comment
comment|/* Internal headers for the ELF .stab-dump code - sorry.  */
end_comment

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|32
end_define

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_FPRINTF
end_ifdef

begin_comment
comment|/* This is needed by INIT_DISASSEMBLE_INFO.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fprintf
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Exit status.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_target
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default at runtime */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* show the version number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_section_contents
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_section_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|dump_file_header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -f */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_dynamic_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -T */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_reloc_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_dynamic_reloc_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -R */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_ar_hdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -a */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_private_headers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prefix_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --prefix-addresses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|with_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|with_source_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_raw_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --show-raw-insn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_stab_section_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --stabs */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_demangle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -C, --demangle */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|disassemble
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|disassemble_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D */
end_comment

begin_decl_stmt
specifier|static
name|int
name|disassemble_zeroes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --disassemble-zeroes */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|formats_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -j secname */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wide_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|start_address
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --start-address */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|stop_address
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --stop-address */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dump_debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --debugging */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|adjust_section_vma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --adjust-vma */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_start_context
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --file-start-context */
end_comment

begin_comment
comment|/* Extra info to pass to the disassembler address printing function.  */
end_comment

begin_struct
struct|struct
name|objdump_disasm_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|boolean
name|require_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Architecture to disassemble for, or default if NULL.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|machine
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target specific options to the disassembler.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|disassembler_options
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|bfd_endian
name|endian
init|=
name|BFD_ENDIAN_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `syms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|symcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sorted symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|sorted_syms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `sorted_syms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|sorted_symcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dynamic symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|dynsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of symbols in `dynsyms'.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|dynsymcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nonfatal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_section_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_dynamic_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_reloc_set
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|boolean
name|dynamic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_bfd_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_bfd_private_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_bfd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_bfd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_target_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_info_table
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_target_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|display_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|objdump_print_value
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|objdump_print_symname
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|find_symbol_for_address
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|boolean
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|objdump_print_addr_with_sym
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|objdump_print_addr
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|objdump_print_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|objdump_symbol_at_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_line
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disassemble_bytes
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|disassembler_ftype
operator|,
name|boolean
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|arelent
operator|*
operator|*
operator|*
operator|,
name|arelent
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disassemble_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|endian_string
name|PARAMS
argument_list|(
operator|(
expr|enum
name|bfd_endian
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|remove_useless_symbols
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_relocs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_stabs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|read_section_stabs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_section_stabs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Usage: %s<option(s)><file(s)>\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" Display information from object<file(s)>.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|" At least one of the following switches must be given:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -a, --archive-headers    Display archive header information\n\   -f, --file-headers       Display the contents of the overall file header\n\   -p, --private-headers    Display object format specific file header contents\n\   -h, --[section-]headers  Display the contents of the section headers\n\   -x, --all-headers        Display the contents of all headers\n\   -d, --disassemble        Display assembler contents of executable sections\n\   -D, --disassemble-all    Display assembler contents of all sections\n\   -S, --source             Intermix source code with disassembly\n\   -s, --full-contents      Display the full contents of all sections requested\n\   -g, --debugging          Display debug information in object file\n\   -G, --stabs              Display (in raw form) any STABS info in the file\n\   -t, --syms               Display the contents of the symbol table(s)\n\   -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\   -r, --reloc              Display the relocation entries in the file\n\   -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\   -v, --version            Display this program's version number\n\   -i, --info               List object formats and architectures supported\n\   -H, --help               Display this information\n\ "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n The following switches are optional:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\   -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\   -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\   -j, --section=NAME             Only display information for section NAME\n\   -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\   -EB --endian=big               Assume big endian format when disassembling\n\   -EL --endian=little            Assume little endian format when disassembling\n\       --file-start-context       Include context from start of file (with -S)\n\   -l, --line-numbers             Include line numbers and filenames in output\n\   -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\                                   The STYLE, if specified, can be `auto', 'gnu',\n\                                   'lucid', 'arm', 'hp', 'edg', or 'gnu-new-abi'\n\   -w, --wide                     Format output for more than 80 columns\n\   -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\       --start-address=ADDR       Only process data whoes address is>= ADDR\n\       --stop-address=ADDR        Only process data whoes address is<= ADDR\n\       --prefix-addresses         Print complete address alongside disassembly\n\       --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n\       --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\ \n"
argument_list|)
argument_list|)
expr_stmt|;
name|list_supported_targets
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|list_supported_architectures
argument_list|(
name|program_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|disassembler_usage
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"Report bugs to %s.\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_ENDIAN
value|(150)
end_define

begin_define
define|#
directive|define
name|OPTION_START_ADDRESS
value|(OPTION_ENDIAN + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STOP_ADDRESS
value|(OPTION_START_ADDRESS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_ADJUST_VMA
value|(OPTION_STOP_ADDRESS + 1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"adjust-vma"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ADJUST_VMA
block|}
block|,
block|{
literal|"all-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"private-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"archive-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"debugging"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"disassemble"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"disassemble-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"disassembler-options"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"disassemble-zeroes"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"dynamic-reloc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"dynamic-syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
block|{
literal|"endian"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ENDIAN
block|}
block|,
block|{
literal|"file-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"file-start-context"
block|,
name|no_argument
block|,
operator|&
name|file_start_context
block|,
literal|1
block|}
block|,
block|{
literal|"full-contents"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"info"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"line-numbers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"no-show-raw-insn"
block|,
name|no_argument
block|,
operator|&
name|show_raw_insn
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"prefix-addresses"
block|,
name|no_argument
block|,
operator|&
name|prefix_addresses
block|,
literal|1
block|}
block|,
block|{
literal|"reloc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'j'
block|}
block|,
block|{
literal|"section-headers"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"show-raw-insn"
block|,
name|no_argument
block|,
operator|&
name|show_raw_insn
block|,
literal|1
block|}
block|,
block|{
literal|"source"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"stabs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"start-address"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_START_ADDRESS
block|}
block|,
block|{
literal|"stop-address"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_STOP_ADDRESS
block|}
block|,
block|{
literal|"syms"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"target"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"wide"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|nonfatal
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|bfd_nonfatal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_section_header
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|ignored
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%3d %-13s %08lx  "
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|/
name|opb
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|lma
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %08lx  2**%u"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|filepos
argument_list|,
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wide_output
condition|)
name|printf
argument_list|(
literal|"\n                "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
define|#
directive|define
name|PF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (section->flags& x) { printf ("%s%s", comma, y); comma = ", "; }
name|PF
argument_list|(
name|SEC_HAS_CONTENTS
argument_list|,
literal|"CONTENTS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ALLOC
argument_list|,
literal|"ALLOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CONSTRUCTOR
argument_list|,
literal|"CONSTRUCTOR"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_LOAD
argument_list|,
literal|"LOAD"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_RELOC
argument_list|,
literal|"RELOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_READONLY
argument_list|,
literal|"READONLY"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CODE
argument_list|,
literal|"CODE"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_DATA
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ROM
argument_list|,
literal|"ROM"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_DEBUGGING
argument_list|,
literal|"DEBUGGING"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_NEVER_LOAD
argument_list|,
literal|"NEVER_LOAD"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_EXCLUDE
argument_list|,
literal|"EXCLUDE"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SORT_ENTRIES
argument_list|,
literal|"SORT_ENTRIES"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_BLOCK
argument_list|,
literal|"BLOCK"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_CLINK
argument_list|,
literal|"CLINK"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SMALL_DATA
argument_list|,
literal|"SMALL_DATA"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_SHARED
argument_list|,
literal|"SHARED"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_ARCH_BIT_0
argument_list|,
literal|"ARCH_BIT_0"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|SEC_THREAD_LOCAL
argument_list|,
literal|"THREAD_LOCAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ls
decl_stmt|;
switch|switch
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
name|ls
operator|=
literal|"LINK_ONCE_DISCARD"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
name|ls
operator|=
literal|"LINK_ONCE_ONE_ONLY"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
name|ls
operator|=
literal|"LINK_ONCE_SAME_SIZE"
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
name|ls
operator|=
literal|"LINK_ONCE_SAME_CONTENTS"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|comma
argument_list|,
name|ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|comdat
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" (COMDAT %s %ld)"
argument_list|,
name|section
operator|->
name|comdat
operator|->
name|name
argument_list|,
name|section
operator|->
name|comdat
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|", "
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PF
block|}
end_function

begin_function
specifier|static
name|void
name|dump_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Sections:\n"
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BFD64
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA       LMA       File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|abfd
argument_list|)
operator|==
literal|32
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA       LMA       File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|_
argument_list|(
literal|"Idx Name          Size      VMA               LMA               File off  Algn"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wide_output
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Flags"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dump_section_header
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_symtab
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|sy
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|long
name|storage
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_SYMS
operator|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|symcount
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|storage
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
condition|)
name|sy
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|sy
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: no symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sy
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
modifier|*
name|slurp_dynamic_symtab
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|sy
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|long
name|storage
decl_stmt|;
name|storage
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: not a dynamic object"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|dynsymcount
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
condition|)
name|sy
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|dynsymcount
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|sy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsymcount
operator|==
literal|0
condition|)
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: No dynamic symbols"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sy
return|;
block|}
end_function

begin_comment
comment|/* Filter out (in place) symbols that are useless for disassembly.    COUNT is the number of elements in SYMBOLS.    Return the number of useful symbols.  */
end_comment

begin_function
specifier|static
name|long
name|remove_useless_symbols
parameter_list|(
name|symbols
parameter_list|,
name|count
parameter_list|)
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|long
name|count
decl_stmt|;
block|{
specifier|register
name|asymbol
modifier|*
modifier|*
name|in_ptr
init|=
name|symbols
decl_stmt|,
modifier|*
modifier|*
name|out_ptr
init|=
name|symbols
decl_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|asymbol
modifier|*
name|sym
init|=
operator|*
name|in_ptr
operator|++
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|name
operator|==
name|NULL
operator|||
name|sym
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_DEBUGGING
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
continue|continue;
operator|*
name|out_ptr
operator|++
operator|=
name|sym
expr_stmt|;
block|}
return|return
name|out_ptr
operator|-
name|symbols
return|;
block|}
end_function

begin_comment
comment|/* Sort symbols into value order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|PTR
name|ap
decl_stmt|;
specifier|const
name|PTR
name|bp
decl_stmt|;
block|{
specifier|const
name|asymbol
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|asymbol
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|asymbol
operator|*
operator|*
operator|)
name|bp
decl_stmt|;
specifier|const
name|char
modifier|*
name|an
decl_stmt|,
modifier|*
name|bn
decl_stmt|;
name|size_t
name|anl
decl_stmt|,
name|bnl
decl_stmt|;
name|boolean
name|af
decl_stmt|,
name|bf
decl_stmt|;
name|flagword
name|aflags
decl_stmt|,
name|bflags
decl_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|a
argument_list|)
operator|>
name|bfd_asymbol_value
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|a
argument_list|)
operator|<
name|bfd_asymbol_value
argument_list|(
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|section
operator|>
name|b
operator|->
name|section
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|section
operator|<
name|b
operator|->
name|section
condition|)
return|return
operator|-
literal|1
return|;
name|an
operator|=
name|bfd_asymbol_name
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bn
operator|=
name|bfd_asymbol_name
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|anl
operator|=
name|strlen
argument_list|(
name|an
argument_list|)
expr_stmt|;
name|bnl
operator|=
name|strlen
argument_list|(
name|bn
argument_list|)
expr_stmt|;
comment|/* The symbols gnu_compiled and gcc2_compiled convey no real      information, so put them after other symbols with the same value.  */
name|af
operator|=
operator|(
name|strstr
argument_list|(
name|an
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|an
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|bf
operator|=
operator|(
name|strstr
argument_list|(
name|bn
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|bn
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|af
operator|&&
operator|!
name|bf
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|af
operator|&&
name|bf
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We use a heuristic for the file name, to try to sort it after      more useful symbols.  It may not work on non Unix systems, but it      doesn't really matter; the only difference is precisely which      symbol names get printed.  */
define|#
directive|define
name|file_symbol
parameter_list|(
name|s
parameter_list|,
name|sn
parameter_list|,
name|snl
parameter_list|)
define|\
value|(((s)->flags& BSF_FILE) != 0			\    || ((sn)[(snl) - 2] == '.'			\&& ((sn)[(snl) - 1] == 'o'		\ 	   || (sn)[(snl) - 1] == 'a')))
name|af
operator|=
name|file_symbol
argument_list|(
name|a
argument_list|,
name|an
argument_list|,
name|anl
argument_list|)
expr_stmt|;
name|bf
operator|=
name|file_symbol
argument_list|(
name|b
argument_list|,
name|bn
argument_list|,
name|bnl
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|&&
operator|!
name|bf
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|af
operator|&&
name|bf
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try to sort global symbols before local symbols before function      symbols before debugging symbols.  */
name|aflags
operator|=
name|a
operator|->
name|flags
expr_stmt|;
name|bflags
operator|=
name|b
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_DEBUGGING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_FUNCTION
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_LOCAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
operator|(
name|bflags
operator|&
name|BSF_GLOBAL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|aflags
operator|&
name|BSF_GLOBAL
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
comment|/* Symbols that start with '.' might be section names, so sort them      after symbols that don't start with '.'.  */
if|if
condition|(
name|an
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|bn
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|an
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|bn
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Finally, if we can't distinguish them in any other way, try to      get consistent results by sorting the symbols by name.  */
return|return
name|strcmp
argument_list|(
name|an
argument_list|,
name|bn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort relocs into address order.  */
end_comment

begin_function
specifier|static
name|int
name|compare_relocs
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|PTR
name|ap
decl_stmt|;
specifier|const
name|PTR
name|bp
decl_stmt|;
block|{
specifier|const
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
specifier|const
name|arelent
operator|*
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|address
operator|>
name|b
operator|->
name|address
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|address
operator|<
name|b
operator|->
name|address
condition|)
return|return
operator|-
literal|1
return|;
comment|/* So that associated relocations tied to the same address show up      in the correct order, we don't do any further sorting.  */
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print VMA to STREAM.  If SKIP_ZEROES is true, omit leading zeroes.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_value
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|,
name|skip_zeroes
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|skip_zeroes
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|objdump_disasm_info
modifier|*
name|aux
init|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_zeroes
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|==
literal|'0'
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the name of a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_symname
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|alloc
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_demangle
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Demangle the name.  */
name|alloc
operator|=
name|demangle
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|alloc
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate a symbol given a bfd, a section, and a VMA.  If REQUIRE_SEC    is true, then always require the symbol to be in the section.  This    returns NULL if there is no suitable symbol.  If PLACE is not NULL,    then *PLACE is set to the index of the symbol in sorted_syms.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|find_symbol_for_address
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|vma
parameter_list|,
name|require_sec
parameter_list|,
name|place
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|boolean
name|require_sec
decl_stmt|;
name|long
modifier|*
name|place
decl_stmt|;
block|{
comment|/* @@ Would it speed things up to cache the last two symbols returned,      and maybe their address ranges?  For many processors, only one memory      operand can be present at a time, so the 2-entry cache wouldn't be      constantly churned by code doing heavy memory accesses.  */
comment|/* Indices in `sorted_syms'.  */
name|long
name|min
init|=
literal|0
decl_stmt|;
name|long
name|max
init|=
name|sorted_symcount
decl_stmt|;
name|long
name|thisplace
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|sorted_symcount
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Perform a binary search looking for the closest symbol to the      required value.  We are searching the range (min, max].  */
while|while
condition|(
name|min
operator|+
literal|1
operator|<
name|max
condition|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|thisplace
operator|=
operator|(
name|max
operator|+
name|min
operator|)
operator|/
literal|2
expr_stmt|;
name|sym
operator|=
name|sorted_syms
index|[
name|thisplace
index|]
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|vma
condition|)
name|max
operator|=
name|thisplace
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|<
name|vma
condition|)
name|min
operator|=
name|thisplace
expr_stmt|;
else|else
block|{
name|min
operator|=
name|thisplace
expr_stmt|;
break|break;
block|}
block|}
comment|/* The symbol we want is now in min, the low end of the range we      were searching.  If there are several symbols with the same      value, we want the first one.  */
name|thisplace
operator|=
name|min
expr_stmt|;
while|while
condition|(
name|thisplace
operator|>
literal|0
operator|&&
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|)
operator|==
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
operator|--
name|thisplace
expr_stmt|;
comment|/* If the file is relocateable, and the symbol could be from this      section, prefer a symbol from this section over symbols from      others, even if the other symbol's value might be closer.       Note that this may be wrong for some symbol references if the      sections have overlapping memory ranges, but in that case there's      no way to tell what's desired without looking at the relocation      table.  */
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
operator|&&
operator|(
name|require_sec
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|vma
operator|>=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&&
name|vma
operator|<
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|/
name|opb
operator|)
operator|)
operator|)
condition|)
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|thisplace
operator|+
literal|1
init|;
name|i
operator|<
name|sorted_symcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|thisplace
index|]
argument_list|)
condition|)
break|break;
block|}
operator|--
name|i
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|section
operator|==
name|sec
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|sorted_syms
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|section
operator|!=
name|sec
operator|||
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|!=
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|thisplace
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
condition|)
block|{
comment|/* We didn't find a good symbol with a smaller value. 	     Look for one with a larger value.  */
for|for
control|(
name|i
operator|=
name|thisplace
operator|+
literal|1
init|;
name|i
operator|<
name|sorted_symcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|section
operator|==
name|sec
condition|)
block|{
name|thisplace
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|sorted_syms
index|[
name|thisplace
index|]
operator|->
name|section
operator|!=
name|sec
operator|&&
operator|(
name|require_sec
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|vma
operator|>=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&&
name|vma
operator|<
operator|(
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* There is no suitable symbol.  */
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|place
operator|!=
name|NULL
condition|)
operator|*
name|place
operator|=
name|thisplace
expr_stmt|;
return|return
name|sorted_syms
index|[
name|thisplace
index|]
return|;
block|}
end_function

begin_comment
comment|/* Print an address to INFO symbolically.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_addr_with_sym
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|sym
parameter_list|,
name|vma
parameter_list|,
name|info
parameter_list|,
name|skip_zeroes
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|skip_zeroes
decl_stmt|;
block|{
name|objdump_print_value
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|bfd_vma
name|secaddr
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<%s"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|secaddr
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|vma
operator|<
name|secaddr
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|secaddr
operator|-
name|vma
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|>
name|secaddr
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
operator|-
name|secaddr
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|objdump_print_symname
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|vma
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|-
name|vma
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vma
operator|>
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
operator|-
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print VMA to INFO, symbolically if possible.  If SKIP_ZEROES is    true, don't output leading zeroes.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_addr
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|,
name|skip_zeroes
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|skip_zeroes
decl_stmt|;
block|{
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|sorted_symcount
operator|<
literal|1
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
return|return;
block|}
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|aux
operator|->
name|sec
argument_list|,
name|vma
argument_list|,
name|aux
operator|->
name|require_sec
argument_list|,
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|objdump_print_addr_with_sym
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|aux
operator|->
name|sec
argument_list|,
name|sym
argument_list|,
name|vma
argument_list|,
name|info
argument_list|,
name|skip_zeroes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print VMA to INFO.  This function is passed to the disassembler    routine.  */
end_comment

begin_function
specifier|static
name|void
name|objdump_print_address
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|objdump_print_addr
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
operator|!
name|prefix_addresses
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine of the given address has a symbol associated with it.  */
end_comment

begin_function
specifier|static
name|int
name|objdump_symbol_at_address
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|vma
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
comment|/* No symbols - do not bother checking.  */
if|if
condition|(
name|sorted_symcount
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|aux
operator|->
name|sec
argument_list|,
name|vma
argument_list|,
name|aux
operator|->
name|require_sec
argument_list|,
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|==
name|vma
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Hold the last function name and the last line number we displayed    in a disassembly.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_functionname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|prev_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We keep a list of all files that we have seen when doing a    dissassembly with source, so that we know how much of the file to    display.  This can be important for inlined functions.  */
end_comment

begin_struct
struct|struct
name|print_file_list
block|{
name|struct
name|print_file_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|print_file_list
modifier|*
name|print_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of preceding context lines to show when we start    displaying a file for the first time.  */
end_comment

begin_define
define|#
directive|define
name|SHOW_PRECEDING_CONTEXT_LINES
value|(5)
end_define

begin_comment
comment|/* Skip ahead to a given line in a file, optionally printing each    line.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|skip_to_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|print_file_list
operator|*
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|skip_to_line
parameter_list|(
name|p
parameter_list|,
name|line
parameter_list|,
name|show
parameter_list|)
name|struct
name|print_file_list
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|boolean
name|show
decl_stmt|;
block|{
while|while
condition|(
name|p
operator|->
name|line
operator|<
name|line
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|p
operator|->
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|p
operator|->
name|f
argument_list|)
expr_stmt|;
name|p
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|show
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
operator|++
name|p
operator|->
name|line
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show the line number, or the source line, in a dissassembly    listing.  */
end_comment

begin_function
specifier|static
name|void
name|show_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|addr_offset
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|addr_offset
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
if|if
condition|(
operator|!
name|with_line_numbers
operator|&&
operator|!
name|with_source_code
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|syms
argument_list|,
name|addr_offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|line
argument_list|)
condition|)
return|return;
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
operator|*
name|filename
operator|==
literal|'\0'
condition|)
name|filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|*
name|functionname
operator|==
literal|'\0'
condition|)
name|functionname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|with_line_numbers
condition|)
block|{
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|prev_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|prev_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"%s():\n"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
name|line
operator|!=
name|prev_line
condition|)
name|printf
argument_list|(
literal|"%s:%u\n"
argument_list|,
name|filename
operator|==
name|NULL
condition|?
literal|"???"
else|:
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|with_source_code
operator|&&
name|filename
operator|!=
name|NULL
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|struct
name|print_file_list
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|print_files
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|print_files
condition|)
block|{
name|int
name|l
decl_stmt|;
comment|/* We have reencountered a file name which we saw 		 earlier.  This implies that either we are dumping out 		 code from an included file, or the same file was 		 linked in more than once.  There are two common cases 		 of an included file: inline functions in a header 		 file, and a bison or flex skeleton file.  In the 		 former case we want to just start printing (but we 		 back up a few lines to give context); in the latter 		 case we want to continue from where we left off.  I 		 can't think of a good way to distinguish the cases, 		 so I used a heuristic based on the file name.  */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|filename
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|filename
argument_list|)
operator|-
literal|2
argument_list|,
literal|".h"
argument_list|)
operator|!=
literal|0
condition|)
name|l
operator|=
name|p
operator|->
name|line
expr_stmt|;
else|else
block|{
name|l
operator|=
name|line
operator|-
name|SHOW_PRECEDING_CONTEXT_LINES
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|f
operator|=
name|fopen
argument_list|(
name|p
operator|->
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|p
operator|->
name|line
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_files
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|print_files
operator|->
name|f
argument_list|)
expr_stmt|;
name|print_files
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|true
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|print_files
expr_stmt|;
name|print_files
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|print_file_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|print_file_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|p
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|f
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|print_files
operator|!=
name|NULL
operator|&&
name|print_files
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|print_files
operator|->
name|f
argument_list|)
expr_stmt|;
name|print_files
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|print_files
expr_stmt|;
name|print_files
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|file_start_context
condition|)
name|l
operator|=
literal|0
expr_stmt|;
else|else
name|l
operator|=
name|line
operator|-
name|SHOW_PRECEDING_CONTEXT_LINES
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|f
operator|!=
name|NULL
condition|)
name|skip_to_line
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|prev_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|prev_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|prev_functionname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|prev_functionname
argument_list|)
expr_stmt|;
name|prev_functionname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|functionname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prev_functionname
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
name|line
operator|!=
name|prev_line
condition|)
name|prev_line
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pseudo FILE object for strings.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|current
decl_stmt|;
block|}
name|SFILE
typedef|;
end_typedef

begin_comment
comment|/* sprintf to a "stream" */
end_comment

begin_decl_stmt
specifier|static
name|int
name|objdump_sprintf
name|VPARAMS
argument_list|(
operator|(
name|SFILE
operator|*
name|f
operator|,
specifier|const
name|char
operator|*
name|format
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
name|SFILE
operator|*
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vasprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Out of virtual memory"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
name|size_t
call|)
argument_list|(
operator|(
name|f
operator|->
name|buffer
operator|+
name|f
operator|->
name|size
operator|)
operator|-
name|f
operator|->
name|current
argument_list|)
operator|<
name|n
operator|+
literal|1
condition|)
block|{
name|size_t
name|curroff
decl_stmt|;
name|curroff
operator|=
name|f
operator|->
name|current
operator|-
name|f
operator|->
name|buffer
expr_stmt|;
name|f
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|f
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|f
operator|->
name|buffer
argument_list|,
name|f
operator|->
name|size
argument_list|)
expr_stmt|;
name|f
operator|->
name|current
operator|=
name|f
operator|->
name|buffer
operator|+
name|curroff
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|f
operator|->
name|current
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|f
operator|->
name|current
operator|+=
name|n
expr_stmt|;
name|f
operator|->
name|current
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_decl_stmt

begin_comment
comment|/* The number of zeroes we want to see before we start skipping them.    The number is arbitrarily chosen.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_ZEROES
end_ifndef

begin_define
define|#
directive|define
name|SKIP_ZEROES
value|(8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The number of zeroes to skip at the end of a section.  If the    number of zeroes at the end is between SKIP_ZEROES_AT_END and    SKIP_ZEROES, they will be disassembled.  If there are fewer than    SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic    attempt to avoid disassembling zeroes inserted by section    alignment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_ZEROES_AT_END
end_ifndef

begin_define
define|#
directive|define
name|SKIP_ZEROES_AT_END
value|(3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Disassemble some data in memory between given values.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_bytes
parameter_list|(
name|info
parameter_list|,
name|disassemble_fn
parameter_list|,
name|insns
parameter_list|,
name|data
parameter_list|,
name|start_offset
parameter_list|,
name|stop_offset
parameter_list|,
name|relppp
parameter_list|,
name|relppend
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|disassembler_ftype
name|disassemble_fn
decl_stmt|;
name|boolean
name|insns
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|start_offset
decl_stmt|;
name|bfd_vma
name|stop_offset
decl_stmt|;
name|arelent
modifier|*
modifier|*
modifier|*
name|relppp
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relppend
decl_stmt|;
block|{
name|struct
name|objdump_disasm_info
modifier|*
name|aux
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|int
name|octets_per_line
decl_stmt|;
name|boolean
name|done_dot
decl_stmt|;
name|int
name|skip_addr_chars
decl_stmt|;
name|bfd_vma
name|addr_offset
decl_stmt|;
name|int
name|opb
init|=
name|info
operator|->
name|octets_per_byte
decl_stmt|;
name|aux
operator|=
operator|(
expr|struct
name|objdump_disasm_info
operator|*
operator|)
name|info
operator|->
name|application_data
expr_stmt|;
name|section
operator|=
name|aux
operator|->
name|sec
expr_stmt|;
if|if
condition|(
name|insns
condition|)
name|octets_per_line
operator|=
literal|4
expr_stmt|;
else|else
name|octets_per_line
operator|=
literal|16
expr_stmt|;
comment|/* Figure out how many characters to skip at the start of an      address, to make the disassembly look nicer.  We discard leading      zeroes in chunks of 4, ensuring that there is always a leading      zero remaining.  */
name|skip_addr_chars
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
operator|(
name|section
operator|->
name|vma
operator|+
name|bfd_section_size
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|)
operator|/
name|opb
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|3
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|4
index|]
operator|==
literal|'0'
condition|)
block|{
name|skip_addr_chars
operator|+=
literal|4
expr_stmt|;
name|s
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|info
operator|->
name|insn_info_valid
operator|=
literal|0
expr_stmt|;
name|done_dot
operator|=
name|false
expr_stmt|;
name|addr_offset
operator|=
name|start_offset
expr_stmt|;
while|while
condition|(
name|addr_offset
operator|<
name|stop_offset
condition|)
block|{
name|bfd_vma
name|z
decl_stmt|;
name|int
name|octets
init|=
literal|0
decl_stmt|;
name|boolean
name|need_nl
init|=
name|false
decl_stmt|;
comment|/* If we see more than SKIP_ZEROES octets of zeroes, we just          print `...'.  */
for|for
control|(
name|z
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|z
operator|<
name|stop_offset
operator|*
name|opb
condition|;
name|z
operator|++
control|)
if|if
condition|(
name|data
index|[
name|z
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|disassemble_zeroes
operator|&&
operator|(
name|info
operator|->
name|insn_info_valid
operator|==
literal|0
operator|||
name|info
operator|->
name|branch_delay_insns
operator|==
literal|0
operator|)
operator|&&
operator|(
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|>=
name|SKIP_ZEROES
operator|||
operator|(
name|z
operator|==
name|stop_offset
operator|*
name|opb
operator|&&
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|<
name|SKIP_ZEROES_AT_END
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\t...\n"
argument_list|)
expr_stmt|;
comment|/* If there are more nonzero octets to follow, we only skip              zeroes in multiples of 4, to try to avoid running over              the start of an instruction which happens to start with              zero.  */
if|if
condition|(
name|z
operator|!=
name|stop_offset
operator|*
name|opb
condition|)
name|z
operator|=
name|addr_offset
operator|*
name|opb
operator|+
operator|(
operator|(
name|z
operator|-
name|addr_offset
operator|*
name|opb
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|octets
operator|=
name|z
operator|-
name|addr_offset
operator|*
name|opb
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|SFILE
name|sfile
decl_stmt|;
name|int
name|bpc
init|=
literal|0
decl_stmt|;
name|int
name|pb
init|=
literal|0
decl_stmt|;
name|done_dot
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|with_line_numbers
operator|||
name|with_source_code
condition|)
comment|/* The line number tables will refer to unadjusted 	       section VMAs, so we must undo any VMA modifications 	       when calling show_line.  */
name|show_line
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|section
argument_list|,
name|addr_offset
operator|-
name|adjust_section_vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|+
name|skip_addr_chars
init|;
operator|*
name|s
operator|==
literal|'0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\t"
argument_list|,
name|buf
operator|+
name|skip_addr_chars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|->
name|require_sec
operator|=
name|true
expr_stmt|;
name|objdump_print_address
argument_list|(
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|aux
operator|->
name|require_sec
operator|=
name|false
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insns
condition|)
block|{
name|sfile
operator|.
name|size
operator|=
literal|120
expr_stmt|;
name|sfile
operator|.
name|buffer
operator|=
name|xmalloc
argument_list|(
name|sfile
operator|.
name|size
argument_list|)
expr_stmt|;
name|sfile
operator|.
name|current
operator|=
name|sfile
operator|.
name|buffer
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|objdump_sprintf
expr_stmt|;
name|info
operator|->
name|stream
operator|=
operator|(
name|FILE
operator|*
operator|)
operator|&
name|sfile
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DISASSEMBLER_NEEDS_RELOCS
comment|/* FIXME: This is wrong.  It tests the number of octets                  in the last instruction, not the current one.  */
if|if
condition|(
operator|*
name|relppp
operator|<
name|relppend
operator|&&
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|>=
name|addr_offset
operator|&&
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|<=
name|addr_offset
operator|+
name|octets
operator|/
name|opb
condition|)
name|info
operator|->
name|flags
operator|=
name|INSN_HAS_RELOC
expr_stmt|;
else|else
endif|#
directive|endif
name|info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|octets
operator|=
call|(
modifier|*
name|disassemble_fn
call|)
argument_list|(
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|fprintf
expr_stmt|;
name|info
operator|->
name|stream
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bytes_per_line
operator|!=
literal|0
condition|)
name|octets_per_line
operator|=
name|info
operator|->
name|bytes_per_line
expr_stmt|;
if|if
condition|(
name|octets
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sfile
operator|.
name|current
operator|!=
name|sfile
operator|.
name|buffer
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|bfd_vma
name|j
decl_stmt|;
name|octets
operator|=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|addr_offset
operator|+
name|octets
operator|/
name|opb
operator|>
name|stop_offset
condition|)
name|octets
operator|=
operator|(
name|stop_offset
operator|-
name|addr_offset
operator|)
operator|*
name|opb
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|octets
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|ISPRINT
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
condition|)
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
name|data
index|[
name|j
index|]
expr_stmt|;
else|else
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
name|buf
index|[
name|j
operator|-
name|addr_offset
operator|*
name|opb
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|prefix_addresses
condition|?
name|show_raw_insn
operator|>
literal|0
else|:
name|show_raw_insn
operator|>=
literal|0
condition|)
block|{
name|bfd_vma
name|j
decl_stmt|;
comment|/* If ! prefix_addresses and ! wide_output, we print                  octets_per_line octets per line.  */
name|pb
operator|=
name|octets
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|octets_per_line
operator|&&
operator|!
name|prefix_addresses
operator|&&
operator|!
name|wide_output
condition|)
name|pb
operator|=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|bytes_per_chunk
condition|)
name|bpc
operator|=
name|info
operator|->
name|bytes_per_chunk
expr_stmt|;
else|else
name|bpc
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|pb
condition|;
name|j
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|bpc
operator|>
literal|1
operator|&&
name|info
operator|->
name|display_endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
block|{
for|for
control|(
name|k
operator|=
name|bpc
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|pb
operator|<
name|octets_per_line
condition|;
name|pb
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* Separate raw data from instruction by extra space.  */
if|if
condition|(
name|insns
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insns
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfile
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prefix_addresses
condition|?
name|show_raw_insn
operator|>
literal|0
else|:
name|show_raw_insn
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|pb
operator|<
name|octets
condition|)
block|{
name|bfd_vma
name|j
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|j
operator|=
name|addr_offset
operator|*
name|opb
operator|+
name|pb
expr_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|buf
argument_list|,
name|section
operator|->
name|vma
operator|+
name|j
operator|/
name|opb
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|+
name|skip_addr_chars
init|;
operator|*
name|s
operator|==
literal|'0'
condition|;
name|s
operator|++
control|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s:\t"
argument_list|,
name|buf
operator|+
name|skip_addr_chars
argument_list|)
expr_stmt|;
name|pb
operator|+=
name|octets_per_line
expr_stmt|;
if|if
condition|(
name|pb
operator|>
name|octets
condition|)
name|pb
operator|=
name|octets
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|pb
condition|;
name|j
operator|+=
name|bpc
control|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|bpc
operator|>
literal|1
operator|&&
name|info
operator|->
name|display_endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
block|{
for|for
control|(
name|k
operator|=
name|bpc
operator|-
literal|1
init|;
name|k
operator|>=
literal|0
condition|;
name|k
operator|--
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|bpc
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
index|[
name|j
operator|+
name|k
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|wide_output
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|need_nl
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
ifndef|#
directive|ifndef
name|DISASSEMBLER_NEEDS_RELOCS
operator|&&
name|dump_reloc_info
endif|#
directive|endif
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|relppp
operator|)
operator|<
name|relppend
operator|&&
operator|(
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|>=
operator|(
name|bfd_vma
operator|)
name|addr_offset
operator|&&
operator|(
operator|*
operator|*
name|relppp
operator|)
operator|->
name|address
operator|<
operator|(
name|bfd_vma
operator|)
name|addr_offset
operator|+
name|octets
operator|/
name|opb
operator|)
condition|)
ifdef|#
directive|ifdef
name|DISASSEMBLER_NEEDS_RELOCS
if|if
condition|(
operator|!
name|dump_reloc_info
condition|)
operator|++
operator|(
operator|*
name|relppp
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|arelent
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|*
operator|*
name|relppp
expr_stmt|;
if|if
condition|(
name|wide_output
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t\t\t"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|section
operator|->
name|vma
operator|+
name|q
operator|->
name|address
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": %s\t"
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
operator|||
operator|*
name|q
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"*unknown*"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|sym_name
operator|=
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|!=
name|NULL
operator|&&
operator|*
name|sym_name
operator|!=
literal|'\0'
condition|)
name|objdump_print_symname
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|info
argument_list|,
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|sym_sec
operator|=
name|bfd_get_section
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_get_section_name
argument_list|(
name|aux
operator|->
name|abfd
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
operator|||
operator|*
name|sym_name
operator|==
literal|'\0'
condition|)
name|sym_name
operator|=
literal|"*unknown*"
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|addend
condition|)
block|{
name|printf
argument_list|(
literal|"+0x"
argument_list|)
expr_stmt|;
name|objdump_print_value
argument_list|(
name|q
operator|->
name|addend
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|need_nl
operator|=
name|false
expr_stmt|;
operator|++
operator|(
operator|*
name|relppp
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|addr_offset
operator|+=
name|octets
operator|/
name|opb
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disassemble the contents of an object file.  */
end_comment

begin_function
specifier|static
name|void
name|disassemble_data
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|long
name|addr_offset
decl_stmt|;
name|disassembler_ftype
name|disassemble_fn
decl_stmt|;
name|struct
name|disassemble_info
name|disasm_info
decl_stmt|;
name|struct
name|objdump_disasm_info
name|aux
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|opb
decl_stmt|;
name|print_files
operator|=
name|NULL
expr_stmt|;
name|prev_functionname
operator|=
name|NULL
expr_stmt|;
name|prev_line
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We make a copy of syms to sort.  We don't want to sort syms      because that will screw up the relocs.  */
name|sorted_syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sorted_syms
argument_list|,
name|syms
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sorted_symcount
operator|=
name|remove_useless_symbols
argument_list|(
name|sorted_syms
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* Sort the symbols into section and symbol order */
name|qsort
argument_list|(
name|sorted_syms
argument_list|,
name|sorted_symcount
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
name|INIT_DISASSEMBLE_INFO
argument_list|(
name|disasm_info
argument_list|,
name|stdout
argument_list|,
name|fprintf
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|application_data
operator|=
operator|(
name|PTR
operator|)
operator|&
name|aux
expr_stmt|;
name|aux
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|aux
operator|.
name|require_sec
operator|=
name|false
expr_stmt|;
name|disasm_info
operator|.
name|print_address_func
operator|=
name|objdump_print_address
expr_stmt|;
name|disasm_info
operator|.
name|symbol_at_address_func
operator|=
name|objdump_symbol_at_address
expr_stmt|;
if|if
condition|(
name|machine
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|info
init|=
name|bfd_scan_arch
argument_list|(
name|machine
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Can't use supplied machine %s"
argument_list|)
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
name|abfd
operator|->
name|arch_info
operator|=
name|info
expr_stmt|;
block|}
if|if
condition|(
name|endian
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
name|struct
name|bfd_target
modifier|*
name|xvec
decl_stmt|;
name|xvec
operator|=
operator|(
expr|struct
name|bfd_target
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_target
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|xvec
argument_list|,
name|abfd
operator|->
name|xvec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_target
argument_list|)
argument_list|)
expr_stmt|;
name|xvec
operator|->
name|byteorder
operator|=
name|endian
expr_stmt|;
name|abfd
operator|->
name|xvec
operator|=
name|xvec
expr_stmt|;
block|}
name|disassemble_fn
operator|=
name|disassembler
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disassemble_fn
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Can't disassemble for architecture %s\n"
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|opb
operator|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|flavour
operator|=
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|arch
operator|=
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|mach
operator|=
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|disasm_info
operator|.
name|disassembler_options
operator|=
name|disassembler_options
expr_stmt|;
name|disasm_info
operator|.
name|octets_per_byte
operator|=
name|opb
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|disasm_info
operator|.
name|display_endian
operator|=
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|disasm_info
operator|.
name|display_endian
operator|=
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
comment|/* ??? Aborting here seems too drastic.  We could default to big or little        instead.  */
name|disasm_info
operator|.
name|endian
operator|=
name|BFD_ENDIAN_UNKNOWN
expr_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|bfd_byte
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relbuf
init|=
name|NULL
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
init|=
name|NULL
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relppend
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|stop_offset
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|long
name|place
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|disassemble_all
operator|&&
name|only
operator|==
name|NULL
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|only
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|only
argument_list|,
name|section
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
ifndef|#
directive|ifndef
name|DISASSEMBLER_NEEDS_RELOCS
operator|&&
name|dump_reloc_info
endif|#
directive|endif
condition|)
block|{
name|long
name|relsize
decl_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|>
literal|0
condition|)
block|{
name|long
name|relcount
decl_stmt|;
name|relbuf
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relbuf
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the relocs by address.  */
name|qsort
argument_list|(
name|relbuf
argument_list|,
name|relcount
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|,
name|compare_relocs
argument_list|)
expr_stmt|;
name|relpp
operator|=
name|relbuf
expr_stmt|;
name|relppend
operator|=
name|relpp
operator|+
name|relcount
expr_stmt|;
comment|/* Skip over the relocs belonging to addresses below the 		 start address.  */
if|if
condition|(
name|start_address
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|relpp
operator|<
name|relppend
operator|&&
operator|(
operator|*
name|relpp
operator|)
operator|->
name|address
operator|<
name|start_address
condition|)
operator|++
name|relpp
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"Disassembly of section %s:\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|datasize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|datasize
operator|==
literal|0
condition|)
continue|continue;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|datasize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|aux
operator|.
name|sec
operator|=
name|section
expr_stmt|;
name|disasm_info
operator|.
name|buffer
operator|=
name|data
expr_stmt|;
name|disasm_info
operator|.
name|buffer_vma
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|disasm_info
operator|.
name|buffer_length
operator|=
name|datasize
expr_stmt|;
name|disasm_info
operator|.
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|start_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|start_address
operator|<
name|disasm_info
operator|.
name|buffer_vma
condition|)
name|addr_offset
operator|=
literal|0
expr_stmt|;
else|else
name|addr_offset
operator|=
name|start_address
operator|-
name|disasm_info
operator|.
name|buffer_vma
expr_stmt|;
if|if
condition|(
name|stop_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|stop_offset
operator|=
name|datasize
operator|/
name|opb
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stop_address
operator|<
name|disasm_info
operator|.
name|buffer_vma
condition|)
name|stop_offset
operator|=
literal|0
expr_stmt|;
else|else
name|stop_offset
operator|=
name|stop_address
operator|-
name|disasm_info
operator|.
name|buffer_vma
expr_stmt|;
if|if
condition|(
name|stop_offset
operator|>
name|disasm_info
operator|.
name|buffer_length
operator|/
name|opb
condition|)
name|stop_offset
operator|=
name|disasm_info
operator|.
name|buffer_length
operator|/
name|opb
expr_stmt|;
block|}
name|sym
operator|=
name|find_symbol_for_address
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
name|true
argument_list|,
operator|&
name|place
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr_offset
operator|<
name|stop_offset
condition|)
block|{
name|asymbol
modifier|*
name|nextsym
decl_stmt|;
name|unsigned
name|long
name|nextstop_offset
decl_stmt|;
name|boolean
name|insns
decl_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|<=
name|section
operator|->
name|vma
operator|+
name|addr_offset
condition|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
name|place
init|;
operator|(
name|x
operator|<
name|sorted_symcount
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|x
index|]
argument_list|)
operator|<=
name|section
operator|->
name|vma
operator|+
name|addr_offset
operator|)
condition|;
operator|++
name|x
control|)
continue|continue;
name|disasm_info
operator|.
name|symbols
operator|=
operator|&
name|sorted_syms
index|[
name|place
index|]
expr_stmt|;
name|disasm_info
operator|.
name|num_symbols
operator|=
name|x
operator|-
name|place
expr_stmt|;
block|}
else|else
name|disasm_info
operator|.
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|prefix_addresses
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|objdump_print_addr_with_sym
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|sym
argument_list|,
name|section
operator|->
name|vma
operator|+
name|addr_offset
argument_list|,
operator|&
name|disasm_info
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|section
operator|->
name|vma
operator|+
name|addr_offset
condition|)
name|nextsym
operator|=
name|sym
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|nextsym
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Search forward for the next appropriate symbol in                  SECTION.  Note that all the symbols are sorted                  together into one big array, and that some sections                  may have overlapping addresses.  */
while|while
condition|(
name|place
operator|<
name|sorted_symcount
operator|&&
operator|(
name|sorted_syms
index|[
name|place
index|]
operator|->
name|section
operator|!=
name|section
operator|||
operator|(
name|bfd_asymbol_value
argument_list|(
name|sorted_syms
index|[
name|place
index|]
argument_list|)
operator|<=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|)
operator|)
condition|)
operator|++
name|place
expr_stmt|;
if|if
condition|(
name|place
operator|>=
name|sorted_symcount
condition|)
name|nextsym
operator|=
name|NULL
expr_stmt|;
else|else
name|nextsym
operator|=
name|sorted_syms
index|[
name|place
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|section
operator|->
name|vma
operator|+
name|addr_offset
condition|)
block|{
name|nextstop_offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|nextstop_offset
operator|>
name|stop_offset
condition|)
name|nextstop_offset
operator|=
name|stop_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextsym
operator|==
name|NULL
condition|)
name|nextstop_offset
operator|=
name|stop_offset
expr_stmt|;
else|else
block|{
name|nextstop_offset
operator|=
name|bfd_asymbol_value
argument_list|(
name|nextsym
argument_list|)
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|nextstop_offset
operator|>
name|stop_offset
condition|)
name|nextstop_offset
operator|=
name|stop_offset
expr_stmt|;
block|}
comment|/* If a symbol is explicitly marked as being an object 	     rather than a function, just dump the bytes without 	     disassembling them.  */
if|if
condition|(
name|disassemble_all
operator|||
name|sym
operator|==
name|NULL
operator|||
name|bfd_asymbol_value
argument_list|(
name|sym
argument_list|)
operator|>
name|section
operator|->
name|vma
operator|+
name|addr_offset
operator|||
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_OBJECT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|strstr
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"gnu_compiled"
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|strstr
argument_list|(
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"gcc2_compiled"
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|||
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
name|insns
operator|=
name|true
expr_stmt|;
else|else
name|insns
operator|=
name|false
expr_stmt|;
name|disassemble_bytes
argument_list|(
operator|&
name|disasm_info
argument_list|,
name|disassemble_fn
argument_list|,
name|insns
argument_list|,
name|data
argument_list|,
name|addr_offset
argument_list|,
name|nextstop_offset
argument_list|,
operator|&
name|relpp
argument_list|,
name|relppend
argument_list|)
expr_stmt|;
name|addr_offset
operator|=
name|nextstop_offset
expr_stmt|;
name|sym
operator|=
name|nextsym
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|relbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relbuf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sorted_syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define a table of stab values and print-strings.  We wish the initializer    could be a direct-mapped table, but instead we build one the first    time we need it.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dump_section_stabs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|char
operator|*
name|stabsect_name
operator|,
name|char
operator|*
name|strsect_name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dump the stabs sections from an object file that has a section that    uses Sun stabs encoding.  */
end_comment

begin_function
specifier|static
name|void
name|dump_stabs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|dump_section_stabs
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|,
literal|".stabstr"
argument_list|)
expr_stmt|;
name|dump_section_stabs
argument_list|(
name|abfd
argument_list|,
literal|".stab.excl"
argument_list|,
literal|".stab.exclstr"
argument_list|)
expr_stmt|;
name|dump_section_stabs
argument_list|(
name|abfd
argument_list|,
literal|".stab.index"
argument_list|,
literal|".stab.indexstr"
argument_list|)
expr_stmt|;
name|dump_section_stabs
argument_list|(
name|abfd
argument_list|,
literal|"$GDB_SYMBOLS$"
argument_list|,
literal|"$GDB_STRINGS$"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|stabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|stab_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|stabstr_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read ABFD's stabs section STABSECT_NAME into `stabs'    and string table section STRSECT_NAME into `strtab'.    If the section exists and was read, allocate the space and return true.    Otherwise return false.  */
end_comment

begin_function
specifier|static
name|boolean
name|read_section_stabs
parameter_list|(
name|abfd
parameter_list|,
name|stabsect_name
parameter_list|,
name|strsect_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|stabsect_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|strsect_name
decl_stmt|;
block|{
name|asection
modifier|*
name|stabsect
decl_stmt|,
modifier|*
name|stabstrsect
decl_stmt|;
name|stabsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|stabsect_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|stabsect
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"No %s section present\n\n"
argument_list|)
argument_list|,
name|stabsect_name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|stabstrsect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|strsect_name
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|stabstrsect
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s has no %s section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|strsect_name
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|stab_size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|stabsect
argument_list|)
expr_stmt|;
name|stabstr_size
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|stabstrsect
argument_list|)
expr_stmt|;
name|stabs
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|stab_size
argument_list|)
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|stabstr_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stabsect
argument_list|,
operator|(
name|PTR
operator|)
name|stabs
argument_list|,
literal|0
argument_list|,
name|stab_size
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Reading %s section of %s failed: %s"
argument_list|)
argument_list|,
name|stabsect_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stabs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stabstrsect
argument_list|,
operator|(
name|PTR
operator|)
name|strtab
argument_list|,
literal|0
argument_list|,
name|stabstr_size
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"Reading %s section of %s failed: %s\n"
argument_list|)
argument_list|,
name|strsect_name
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stabs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Stabs entries use a 12 byte format:      4 byte string table index      1 byte stab type      1 byte stab other field      2 byte stab desc field      4 byte stab value    FIXME: This will have to change for a 64 bit object format.  */
end_comment

begin_define
define|#
directive|define
name|STRDXOFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TYPEOFF
value|(4)
end_define

begin_define
define|#
directive|define
name|OTHEROFF
value|(5)
end_define

begin_define
define|#
directive|define
name|DESCOFF
value|(6)
end_define

begin_define
define|#
directive|define
name|VALOFF
value|(8)
end_define

begin_define
define|#
directive|define
name|STABSIZE
value|(12)
end_define

begin_comment
comment|/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),    using string table section STRSECT_NAME (in `strtab').  */
end_comment

begin_function
specifier|static
name|void
name|print_section_stabs
parameter_list|(
name|abfd
parameter_list|,
name|stabsect_name
parameter_list|,
name|strsect_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|stabsect_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|strsect_name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|file_string_table_offset
init|=
literal|0
decl_stmt|,
name|next_file_string_table_offset
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|stabp
decl_stmt|,
modifier|*
name|stabs_end
decl_stmt|;
name|stabp
operator|=
name|stabs
expr_stmt|;
name|stabs_end
operator|=
name|stabp
operator|+
name|stab_size
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of %s section:\n\n"
argument_list|)
argument_list|,
name|stabsect_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Symnum n_type n_othr n_desc n_value  n_strx String\n"
argument_list|)
expr_stmt|;
comment|/* Loop through all symbols and print them.       We start the index at -1 because there is a dummy symbol on      the front of stabs-in-{coff,elf} sections that supplies sizes.  */
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|stabp
operator|<
name|stabs_end
condition|;
name|stabp
operator|+=
name|STABSIZE
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|strx
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|,
name|other
decl_stmt|;
name|unsigned
name|short
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|strx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|TYPEOFF
argument_list|)
expr_stmt|;
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|OTHEROFF
argument_list|)
expr_stmt|;
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%-6d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Either print the stab name, or, if unnamed, print its number 	 again (makes consistent formatting for tools like awk).  */
name|name
operator|=
name|bfd_get_stab_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%-6s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|N_UNDF
condition|)
name|printf
argument_list|(
literal|"HdrSym"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-6d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6d %-6d "
argument_list|,
name|other
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-6lu"
argument_list|,
name|strx
argument_list|)
expr_stmt|;
comment|/* Symbols with type == 0 (N_UNDF) specify the length of the 	 string table associated with this file.  We use that info 	 to know how to relocate the *next* file's string table indices.  */
if|if
condition|(
name|type
operator|==
name|N_UNDF
condition|)
block|{
name|file_string_table_offset
operator|=
name|next_file_string_table_offset
expr_stmt|;
name|next_file_string_table_offset
operator|+=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|/* Using the (possibly updated) string table offset, print the 	     string (if any) associated with this symbol.  */
if|if
condition|(
operator|(
name|strx
operator|+
name|file_string_table_offset
operator|)
operator|<
name|stabstr_size
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|&
name|strtab
index|[
name|strx
operator|+
name|file_string_table_offset
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_section_stabs
parameter_list|(
name|abfd
parameter_list|,
name|stabsect_name
parameter_list|,
name|strsect_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|stabsect_name
decl_stmt|;
name|char
modifier|*
name|strsect_name
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Check for section names for which stabsect_name is a prefix, to      handle .stab0, etc.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|stabsect_name
argument_list|)
expr_stmt|;
comment|/* If the prefix matches, and the files section name ends with a 	 nul or a digit, then we match.  I.e., we want either an exact 	 match or a section followed by a number.  */
if|if
condition|(
name|strncmp
argument_list|(
name|stabsect_name
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|s
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\000'
operator|||
name|ISDIGIT
argument_list|(
name|s
operator|->
name|name
index|[
name|len
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|read_section_stabs
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|strsect_name
argument_list|)
condition|)
block|{
name|print_section_stabs
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|strsect_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stabs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_bfd_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|comma
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"architecture: %s, "
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"flags 0x%08x:\n"
argument_list|)
argument_list|,
name|abfd
operator|->
name|flags
argument_list|)
expr_stmt|;
define|#
directive|define
name|PF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|if (abfd->flags& x) {printf("%s%s", comma, y); comma=", ";}
name|PF
argument_list|(
name|HAS_RELOC
argument_list|,
literal|"HAS_RELOC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|EXEC_P
argument_list|,
literal|"EXEC_P"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_LINENO
argument_list|,
literal|"HAS_LINENO"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_DEBUG
argument_list|,
literal|"HAS_DEBUG"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_SYMS
argument_list|,
literal|"HAS_SYMS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|HAS_LOCALS
argument_list|,
literal|"HAS_LOCALS"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|DYNAMIC
argument_list|,
literal|"DYNAMIC"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|WP_TEXT
argument_list|,
literal|"WP_TEXT"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|D_PAGED
argument_list|,
literal|"D_PAGED"
argument_list|)
expr_stmt|;
name|PF
argument_list|(
name|BFD_IS_RELAXABLE
argument_list|,
literal|"BFD_IS_RELAXABLE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nstart address 0x"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dump_bfd_private_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump selected contents of ABFD */
end_comment

begin_function
specifier|static
name|void
name|dump_bfd
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* If we are adjusting section VMA's, change them all now.  Changing      the BFD information is a hack.  However, we must do it, or      bfd_find_nearest_line will not do the right thing.  */
if|if
condition|(
name|adjust_section_vma
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|s
operator|->
name|vma
operator|+=
name|adjust_section_vma
expr_stmt|;
name|s
operator|->
name|lma
operator|+=
name|adjust_section_vma
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"\n%s:     file format %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_ar_hdrs
condition|)
name|print_arelt_descr
argument_list|(
name|stdout
argument_list|,
name|abfd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file_header
condition|)
name|dump_bfd_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_private_headers
condition|)
name|dump_bfd_private_header
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_section_headers
condition|)
name|dump_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_symtab
operator|||
name|dump_reloc_info
operator|||
name|disassemble
operator|||
name|dump_debugging
condition|)
block|{
name|syms
operator|=
name|slurp_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_dynamic_symtab
operator|||
name|dump_dynamic_reloc_info
condition|)
block|{
name|dynsyms
operator|=
name|slurp_dynamic_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_symtab
condition|)
name|dump_symbols
argument_list|(
name|abfd
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_dynamic_symtab
condition|)
name|dump_symbols
argument_list|(
name|abfd
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_stab_section_info
condition|)
name|dump_stabs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_reloc_info
operator|&&
operator|!
name|disassemble
condition|)
name|dump_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_dynamic_reloc_info
condition|)
name|dump_dynamic_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_section_contents
condition|)
name|dump_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|disassemble
condition|)
name|disassemble_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_debugging
condition|)
block|{
name|PTR
name|dhandle
decl_stmt|;
name|dhandle
operator|=
name|read_debugging_info
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhandle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|print_debugging_info
argument_list|(
name|stdout
argument_list|,
name|dhandle
argument_list|)
condition|)
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"%s: printing debugging information failed"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|exit_status
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|syms
condition|)
block|{
name|free
argument_list|(
name|syms
argument_list|)
expr_stmt|;
name|syms
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynsyms
condition|)
block|{
name|free
argument_list|(
name|dynsyms
argument_list|)
expr_stmt|;
name|dynsyms
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_bfd
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|dump_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_not_recognized
condition|)
block|{
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format_matches
argument_list|(
name|abfd
argument_list|,
name|bfd_core
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|dump_bfd
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return;
block|}
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|list_matching_formats
argument_list|(
name|matching
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matching
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_file
parameter_list|(
name|filename
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|bfd
modifier|*
name|file
decl_stmt|,
modifier|*
name|arfile
init|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
decl_stmt|;
name|file
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_archive
argument_list|)
operator|==
name|true
condition|)
block|{
name|bfd
modifier|*
name|last_arfile
init|=
name|NULL
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"In archive %s:\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|arfile
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|file
argument_list|,
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|arfile
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_more_archived_files
condition|)
name|nonfatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|display_bfd
argument_list|(
name|arfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
name|last_arfile
operator|=
name|arfile
expr_stmt|;
block|}
if|if
condition|(
name|last_arfile
operator|!=
name|NULL
condition|)
name|bfd_close
argument_list|(
name|last_arfile
argument_list|)
expr_stmt|;
block|}
else|else
name|display_bfd
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Actually display the various requested regions */
end_comment

begin_function
specifier|static
name|void
name|dump_data
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_byte
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|datasize
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|addr_offset
decl_stmt|;
name|bfd_size_type
name|start_offset
decl_stmt|,
name|stop_offset
decl_stmt|;
name|unsigned
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|int
name|onaline
init|=
literal|16
decl_stmt|;
if|if
condition|(
name|only
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|||
name|strcmp
argument_list|(
name|only
argument_list|,
name|section
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Contents of section %s:\n"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|datasize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|data
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|start_address
operator|<
name|section
operator|->
name|vma
condition|)
name|start_offset
operator|=
literal|0
expr_stmt|;
else|else
name|start_offset
operator|=
name|start_address
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|stop_address
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|stop_offset
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|/
name|opb
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stop_address
operator|<
name|section
operator|->
name|vma
condition|)
name|stop_offset
operator|=
literal|0
expr_stmt|;
else|else
name|stop_offset
operator|=
name|stop_address
operator|-
name|section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|stop_offset
operator|>
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|/
name|opb
condition|)
name|stop_offset
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|/
name|opb
expr_stmt|;
block|}
for|for
control|(
name|addr_offset
operator|=
name|start_offset
init|;
name|addr_offset
operator|<
name|stop_offset
condition|;
name|addr_offset
operator|+=
name|onaline
control|)
block|{
name|bfd_size_type
name|j
decl_stmt|;
name|printf
argument_list|(
literal|" %04lx "
argument_list|,
call|(
name|unsigned
name|long
name|int
call|)
argument_list|(
name|addr_offset
operator|+
name|section
operator|->
name|vma
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
operator|*
name|opb
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|onaline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<
name|stop_offset
operator|*
name|opb
condition|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|addr_offset
init|;
name|j
operator|<
name|addr_offset
operator|*
name|opb
operator|+
name|onaline
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|stop_offset
operator|*
name|opb
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|ISPRINT
argument_list|(
name|data
index|[
name|j
index|]
argument_list|)
condition|?
name|data
index|[
name|j
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Should perhaps share code and display with nm? */
end_comment

begin_function
specifier|static
name|void
name|dump_symbols
parameter_list|(
name|abfd
parameter_list|,
name|dynamic
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|dynamic
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|current
decl_stmt|;
name|long
name|max
decl_stmt|;
name|long
name|count
decl_stmt|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|current
operator|=
name|dynsyms
expr_stmt|;
name|max
operator|=
name|dynsymcount
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"DYNAMIC SYMBOL TABLE:\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|syms
expr_stmt|;
name|max
operator|=
name|symcount
expr_stmt|;
if|if
condition|(
name|max
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"SYMBOL TABLE:\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|max
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|current
condition|)
block|{
name|bfd
modifier|*
name|cur_bfd
init|=
name|bfd_asymbol_bfd
argument_list|(
operator|*
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_bfd
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|alloc
decl_stmt|;
name|name
operator|=
operator|(
operator|*
name|current
operator|)
operator|->
name|name
expr_stmt|;
name|alloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|do_demangle
operator|&&
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
comment|/* If we want to demangle the name, we demangle it                      here, and temporarily clobber it while calling                      bfd_print_symbol.  FIXME: This is a gross hack.  */
name|alloc
operator|=
name|demangle
argument_list|(
name|cur_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|current
operator|)
operator|->
name|name
operator|=
name|alloc
expr_stmt|;
block|}
name|bfd_print_symbol
argument_list|(
name|cur_bfd
argument_list|,
name|stdout
argument_list|,
operator|*
name|current
argument_list|,
name|bfd_print_symbol_all
argument_list|)
expr_stmt|;
operator|(
operator|*
name|current
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|alloc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|current
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_relocs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|asection
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|abfd
operator|->
name|sections
init|;
name|a
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|long
name|relsize
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|a
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|a
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|a
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|only
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|only
argument_list|,
name|a
operator|->
name|name
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RELOCATION RECORDS FOR [%s]:"
argument_list|,
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|a
argument_list|,
name|relpp
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_reloc_set
argument_list|(
name|abfd
argument_list|,
name|a
argument_list|,
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dynamic_relocs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|relsize
operator|=
name|bfd_get_dynamic_reloc_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DYNAMIC RELOCATION RECORDS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_dynamic_reloc
argument_list|(
name|abfd
argument_list|,
name|relpp
argument_list|,
name|dynsyms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|relcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" (none)\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dump_reloc_set
argument_list|(
name|abfd
argument_list|,
operator|(
name|asection
operator|*
operator|)
name|NULL
argument_list|,
name|relpp
argument_list|,
name|relcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_reloc_set
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|relpp
parameter_list|,
name|relcount
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
block|{
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|last_filename
decl_stmt|,
modifier|*
name|last_functionname
decl_stmt|;
name|unsigned
name|int
name|last_line
decl_stmt|;
comment|/* Get column headers lined up reasonably.  */
block|{
specifier|static
name|int
name|width
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bfd_sprintf_vma
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|width
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|7
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"OFFSET %*s TYPE %*s VALUE \n"
argument_list|,
name|width
argument_list|,
literal|""
argument_list|,
literal|12
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|last_filename
operator|=
name|NULL
expr_stmt|;
name|last_functionname
operator|=
name|NULL
expr_stmt|;
name|last_line
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|relpp
init|;
name|relcount
operator|&&
operator|*
name|p
operator|!=
operator|(
name|arelent
operator|*
operator|)
name|NULL
condition|;
name|p
operator|++
operator|,
name|relcount
operator|--
control|)
block|{
name|arelent
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
if|if
condition|(
name|start_address
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|q
operator|->
name|address
operator|<
name|start_address
condition|)
continue|continue;
if|if
condition|(
name|stop_address
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|q
operator|->
name|address
operator|>
name|stop_address
condition|)
continue|continue;
if|if
condition|(
name|with_line_numbers
operator|&&
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|syms
argument_list|,
name|q
operator|->
name|address
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
operator|(
name|last_functionname
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|functionname
argument_list|,
name|last_functionname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s():\n"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_functionname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_functionname
argument_list|)
expr_stmt|;
name|last_functionname
operator|=
name|xstrdup
argument_list|(
name|functionname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>
literal|0
operator|&&
operator|(
name|line
operator|!=
name|last_line
operator|||
operator|(
name|filename
operator|!=
name|NULL
operator|&&
name|last_filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|last_filename
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%u\n"
argument_list|,
name|filename
operator|==
name|NULL
condition|?
literal|"???"
else|:
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|last_line
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|last_filename
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|last_filename
operator|=
name|NULL
expr_stmt|;
else|else
name|last_filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|&&
operator|*
name|q
operator|->
name|sym_ptr_ptr
condition|)
block|{
name|sym_name
operator|=
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|name
expr_stmt|;
name|section_name
operator|=
operator|(
operator|*
operator|(
name|q
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|sym_name
operator|=
name|NULL
expr_stmt|;
name|section_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sym_name
condition|)
block|{
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|howto
operator|->
name|name
condition|)
name|printf
argument_list|(
literal|" %-16s  "
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %-16d  "
argument_list|,
name|q
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|objdump_print_symname
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|disassemble_info
operator|*
operator|)
name|NULL
argument_list|,
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|section_name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
name|section_name
operator|=
literal|"*unknown*"
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-16s  [%s]"
argument_list|,
name|q
operator|->
name|howto
operator|->
name|name
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|addend
condition|)
block|{
name|printf
argument_list|(
literal|"+0x"
argument_list|)
expr_stmt|;
name|bfd_printf_vma
argument_list|(
name|abfd
argument_list|,
name|q
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The length of the longest architecture name + 1.  */
end_comment

begin_define
define|#
directive|define
name|LONGEST_ARCH
value|sizeof("powerpc:common")
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|endian_string
parameter_list|(
name|endian
parameter_list|)
name|enum
name|bfd_endian
name|endian
decl_stmt|;
block|{
if|if
condition|(
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
literal|"big endian"
return|;
elseif|else
if|if
condition|(
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
return|return
literal|"little endian"
return|;
else|else
return|return
literal|"endianness unknown"
return|;
block|}
end_function

begin_comment
comment|/* List the targets that BFD is configured to support, each followed    by its endianness and the architectures it supports.  */
end_comment

begin_function
specifier|static
name|void
name|display_target_list
parameter_list|()
block|{
specifier|extern
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|bfd_target_vector
decl_stmt|;
name|char
modifier|*
name|dummy_name
decl_stmt|;
name|int
name|t
decl_stmt|;
name|dummy_name
operator|=
name|make_temp_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
block|{
specifier|const
name|bfd_target
modifier|*
name|p
init|=
name|bfd_target_vector
index|[
name|t
index|]
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openw
argument_list|(
name|dummy_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|a
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n (header %s, data %s)\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|endian_string
argument_list|(
name|p
operator|->
name|header_byteorder
argument_list|)
argument_list|,
name|endian_string
argument_list|(
name|p
operator|->
name|byteorder
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_invalid_operation
condition|)
name|nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|a
operator|=
operator|(
name|int
operator|)
name|bfd_arch_obscure
operator|+
literal|1
init|;
name|a
operator|<
operator|(
name|int
operator|)
name|bfd_arch_last
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
operator|(
expr|enum
name|bfd_architecture
operator|)
name|a
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
operator|(
expr|enum
name|bfd_architecture
operator|)
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a table showing which architectures are supported for entries    FIRST through LAST-1 of bfd_target_vector (targets across,    architectures down).  */
end_comment

begin_function
specifier|static
name|void
name|display_info_table
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
name|int
name|last
decl_stmt|;
block|{
specifier|extern
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|bfd_target_vector
decl_stmt|;
name|int
name|t
decl_stmt|,
name|a
decl_stmt|;
name|char
modifier|*
name|dummy_name
decl_stmt|;
comment|/* Print heading of target names.  */
name|printf
argument_list|(
literal|"\n%*s"
argument_list|,
operator|(
name|int
operator|)
name|LONGEST_ARCH
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|first
init|;
name|t
operator|<
name|last
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|dummy_name
operator|=
name|make_temp_file
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
operator|(
name|int
operator|)
name|bfd_arch_obscure
operator|+
literal|1
init|;
name|a
operator|<
operator|(
name|int
operator|)
name|bfd_arch_last
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_printable_arch_mach
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"UNKNOWN!"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s "
argument_list|,
operator|(
name|int
operator|)
name|LONGEST_ARCH
operator|-
literal|1
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|first
init|;
name|t
operator|<
name|last
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
condition|;
name|t
operator|++
control|)
block|{
specifier|const
name|bfd_target
modifier|*
name|p
init|=
name|bfd_target_vector
index|[
name|t
index|]
decl_stmt|;
name|boolean
name|ok
init|=
name|true
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|bfd_openw
argument_list|(
name|dummy_name
argument_list|,
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
name|nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_invalid_operation
condition|)
name|nonfatal
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|ok
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
condition|)
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|!=
name|NULL
condition|)
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummy_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print tables of all the target-architecture combinations that    BFD has been configured to support.  */
end_comment

begin_function
specifier|static
name|void
name|display_target_tables
parameter_list|()
block|{
name|int
name|t
decl_stmt|,
name|columns
decl_stmt|;
specifier|extern
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|bfd_target_vector
decl_stmt|;
name|char
modifier|*
name|colum
decl_stmt|;
name|columns
operator|=
literal|0
expr_stmt|;
name|colum
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|colum
operator|!=
name|NULL
condition|)
name|columns
operator|=
name|atoi
argument_list|(
name|colum
argument_list|)
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|80
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bfd_target_vector
index|[
name|t
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|oldt
init|=
name|t
decl_stmt|,
name|wid
decl_stmt|;
name|wid
operator|=
name|LONGEST_ARCH
operator|+
name|strlen
argument_list|(
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|t
expr_stmt|;
while|while
condition|(
name|wid
operator|<
name|columns
operator|&&
name|bfd_target_vector
index|[
name|t
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|newwid
decl_stmt|;
name|newwid
operator|=
name|wid
operator|+
name|strlen
argument_list|(
name|bfd_target_vector
index|[
name|t
index|]
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newwid
operator|>=
name|columns
condition|)
break|break;
name|wid
operator|=
name|newwid
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
name|display_info_table
argument_list|(
name|oldt
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|display_info
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"BFD header file version %s\n"
argument_list|)
argument_list|,
name|BFD_VERSION_STRING
argument_list|)
expr_stmt|;
name|display_target_list
argument_list|()
expr_stmt|;
name|display_target_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|default_target
decl_stmt|;
name|boolean
name|seenflag
init|=
name|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
operator|*
name|argv
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|set_default_bfd_target
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"pib:m:M:VvCdDlfaHhrRtTxsSj:wE:zgG"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* We've been given a long option.  */
case|case
literal|'m'
case|:
name|machine
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|disassembler_options
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|only
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|with_line_numbers
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|target
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|do_demangle
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unknown demangling style `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|wide_output
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_ADJUST_VMA
case|:
name|adjust_section_vma
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--adjust-vma"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_START_ADDRESS
case|:
name|start_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--start-address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_STOP_ADDRESS
case|:
name|stop_address
operator|=
name|parse_vma
argument_list|(
name|optarg
argument_list|,
literal|"--stop-address"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"B"
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"L"
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized -E option"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_ENDIAN
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"big"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"little"
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
else|else
block|{
name|non_fatal
argument_list|(
name|_
argument_list|(
literal|"unrecognized --endian type `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|dump_file_header
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|formats_info
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|dump_private_headers
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|dump_private_headers
operator|=
name|true
expr_stmt|;
name|dump_symtab
operator|=
name|true
expr_stmt|;
name|dump_reloc_info
operator|=
name|true
expr_stmt|;
name|dump_file_header
operator|=
name|true
expr_stmt|;
name|dump_ar_hdrs
operator|=
name|true
expr_stmt|;
name|dump_section_headers
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|dump_symtab
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|dump_dynamic_symtab
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|disassemble
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|disassemble_zeroes
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|disassemble
operator|=
name|true
expr_stmt|;
name|disassemble_all
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|disassemble
operator|=
name|true
expr_stmt|;
name|with_source_code
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|dump_debugging
operator|=
literal|1
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|dump_stab_section_info
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|dump_section_contents
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|dump_reloc_info
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|dump_dynamic_reloc_info
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|dump_ar_hdrs
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|dump_section_headers
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|show_version
operator|=
name|true
expr_stmt|;
name|seenflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_version
condition|)
name|print_version
argument_list|(
literal|"objdump"
argument_list|)
expr_stmt|;
if|if
condition|(
name|seenflag
operator|==
name|false
condition|)
name|usage
argument_list|(
name|stderr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|formats_info
condition|)
name|display_info
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|display_file
argument_list|(
literal|"a.out"
argument_list|,
name|target
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
control|)
name|display_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

end_unit

