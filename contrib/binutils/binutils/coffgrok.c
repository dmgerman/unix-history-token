begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* coffgrok.c    Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.  This file is part of GNU Binutils.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Steve Chamberlain (sac@cygnus.com)     This module reads a coff file and builds a really simple type tree    which can be read by other programs.  The first application is a    coff->sysroff converter.  It can be tested with coffdump.c.  */
end_comment

begin_include
include|#
directive|include
file|<bfd.h>
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"../bfd/libcoff.h"
end_include

begin_include
include|#
directive|include
file|"coffgrok.h"
end_include

begin_decl_stmt
name|int
name|lofile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_scope
modifier|*
name|top_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_scope
modifier|*
name|file_scope
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_ofile
modifier|*
name|ofile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|coff_symbol
modifier|*
name|last_function_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|coff_type
modifier|*
name|last_function_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|coff_type
modifier|*
name|last_struct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|coff_type
modifier|*
name|last_enum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|coff_sfile
modifier|*
name|cur_sfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|coff_symbol
modifier|*
modifier|*
name|tindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|symcount
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N
parameter_list|(
name|x
parameter_list|)
value|((x)->_n._n_nptr[1])
end_define

begin_decl_stmt
specifier|static
name|struct
name|coff_ptr_struct
modifier|*
name|rawsyms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rawcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|xcalloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PTR_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|SHORT_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|INT_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|LONG_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|FLOAT_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|DOUBLE_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|INDEXOF
parameter_list|(
name|p
parameter_list|)
value|((struct coff_ptr_struct *)(p)-(rawsyms))
end_define

begin_function
specifier|static
name|struct
name|coff_scope
modifier|*
name|empty_scope
parameter_list|()
block|{
name|struct
name|coff_scope
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|coff_scope
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_scope
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_symbol
modifier|*
name|empty_symbol
parameter_list|()
block|{
return|return
operator|(
expr|struct
name|coff_symbol
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symbol
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*int l;*/
end_comment

begin_function
specifier|static
name|void
name|push_scope
parameter_list|(
name|link
parameter_list|)
name|int
name|link
decl_stmt|;
block|{
name|struct
name|coff_scope
modifier|*
name|n
init|=
name|empty_scope
argument_list|()
decl_stmt|;
if|if
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|top_scope
condition|)
block|{
if|if
condition|(
name|top_scope
operator|->
name|list_tail
condition|)
block|{
name|top_scope
operator|->
name|list_tail
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|top_scope
operator|->
name|list_head
operator|=
name|n
expr_stmt|;
block|}
name|top_scope
operator|->
name|list_tail
operator|=
name|n
expr_stmt|;
block|}
block|}
name|n
operator|->
name|parent
operator|=
name|top_scope
expr_stmt|;
name|top_scope
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_scope
parameter_list|()
block|{
name|top_scope
operator|=
name|top_scope
operator|->
name|parent
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_sections_p1
parameter_list|(
name|head
parameter_list|)
name|struct
name|coff_ofile
modifier|*
name|head
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|coff_section
modifier|*
name|all
init|=
operator|(
expr|struct
name|coff_section
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
name|abfd
operator|->
name|section_count
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|head
operator|->
name|nsections
operator|=
name|abfd
operator|->
name|section_count
operator|+
literal|1
expr_stmt|;
name|head
operator|->
name|sections
operator|=
name|all
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
operator|,
name|idx
operator|++
control|)
block|{
name|long
name|relsize
decl_stmt|;
name|int
name|i
init|=
name|section
operator|->
name|target_index
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
continue|continue;
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relpp
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|section
operator|->
name|name
operator|)
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|code
operator|=
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|data
operator|=
name|section
operator|->
name|flags
operator|&
name|SEC_DATA
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|data
operator|=
literal|1
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|address
operator|=
name|section
operator|->
name|lma
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|number
operator|=
name|idx
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|nrelocs
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|relocs
operator|=
operator|(
expr|struct
name|coff_reloc
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
name|section
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_reloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|bfd_section
operator|=
name|section
expr_stmt|;
block|}
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|"ABSOLUTE"
expr_stmt|;
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|sections
index|[
literal|0
index|]
operator|.
name|number
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_sections_p2
parameter_list|(
name|head
parameter_list|)
name|struct
name|coff_ofile
modifier|*
name|head
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|j
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|i
init|=
name|section
operator|->
name|target_index
decl_stmt|;
name|struct
name|coff_reloc
modifier|*
name|r
init|=
name|head
operator|->
name|sections
index|[
name|i
index|]
operator|.
name|relocs
operator|+
name|j
decl_stmt|;
name|arelent
modifier|*
name|sr
init|=
name|section
operator|->
name|relocation
operator|+
name|j
decl_stmt|;
name|r
operator|->
name|offset
operator|=
name|sr
operator|->
name|address
expr_stmt|;
name|r
operator|->
name|addend
operator|=
name|sr
operator|->
name|addend
expr_stmt|;
name|idx
operator|=
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
name|sr
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|)
operator|)
operator|->
name|native
operator|-
name|rawsyms
expr_stmt|;
name|r
operator|->
name|symbol
operator|=
name|tindex
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_where
modifier|*
name|do_where
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|sym
init|=
operator|&
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
decl_stmt|;
name|struct
name|coff_where
modifier|*
name|where
init|=
operator|(
expr|struct
name|coff_where
operator|*
operator|)
operator|(
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_where
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|where
operator|->
name|offset
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|n_scnum
operator|==
operator|-
literal|1
condition|)
name|sym
operator|->
name|n_scnum
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sym
operator|->
name|n_sclass
condition|)
block|{
case|case
name|C_FIELD
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_member_of_struct
expr_stmt|;
name|where
operator|->
name|offset
operator|=
name|sym
operator|->
name|n_value
operator|/
literal|8
expr_stmt|;
name|where
operator|->
name|bitoffset
operator|=
name|sym
operator|->
name|n_value
operator|%
literal|8
expr_stmt|;
name|where
operator|->
name|bitsize
operator|=
name|rawsyms
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
break|break;
case|case
name|C_MOE
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_member_of_enum
expr_stmt|;
break|break;
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_member_of_struct
expr_stmt|;
break|break;
case|case
name|C_AUTO
case|:
case|case
name|C_ARG
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_stack
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
case|case
name|C_STAT
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_LABEL
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_memory
expr_stmt|;
name|where
operator|->
name|section
operator|=
operator|&
name|ofile
operator|->
name|sections
index|[
name|sym
operator|->
name|n_scnum
index|]
expr_stmt|;
break|break;
case|case
name|C_REG
case|:
case|case
name|C_REGPARM
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_register
expr_stmt|;
break|break;
case|case
name|C_ENTAG
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_entag
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_strtag
expr_stmt|;
break|break;
case|case
name|C_TPDEF
case|:
name|where
operator|->
name|where
operator|=
name|coff_where_typedef
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|where
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_line
modifier|*
name|do_lines
parameter_list|(
name|i
parameter_list|,
name|name
parameter_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|coff_line
modifier|*
name|res
init|=
operator|(
expr|struct
name|coff_line
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_line
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|l
decl_stmt|;
comment|/* Find out if this function has any line numbers in the table */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|s
operator|->
name|lineno_count
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|lineno
index|[
name|l
index|]
operator|.
name|line_number
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rawsyms
operator|+
name|i
operator|==
operator|(
operator|(
name|coff_symbol_type
operator|*
operator|)
operator|(
operator|&
operator|(
name|s
operator|->
name|lineno
index|[
name|l
index|]
operator|.
name|u
operator|.
name|sym
index|[
literal|0
index|]
operator|)
operator|)
operator|)
operator|->
name|native
condition|)
block|{
comment|/* These lines are for this function - so count them and stick them on */
name|int
name|c
init|=
literal|0
decl_stmt|;
comment|/* Find the linenumber of the top of the function, since coff linenumbers 		     are relative to the start of the function. */
name|int
name|start_line
init|=
name|rawsyms
index|[
name|i
operator|+
literal|3
index|]
operator|.
name|u
operator|.
name|auxent
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
decl_stmt|;
name|l
operator|++
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|s
operator|->
name|lineno
index|[
name|l
operator|+
name|c
operator|+
literal|1
index|]
operator|.
name|line_number
condition|;
name|c
operator|++
control|)
empty_stmt|;
comment|/* Add two extra records, one for the prologue and one for the epilogue */
name|c
operator|+=
literal|1
expr_stmt|;
name|res
operator|->
name|nlines
operator|=
name|c
expr_stmt|;
name|res
operator|->
name|lines
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
name|res
operator|->
name|addresses
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|c
argument_list|)
operator|)
expr_stmt|;
name|res
operator|->
name|lines
index|[
literal|0
index|]
operator|=
name|start_line
expr_stmt|;
name|res
operator|->
name|addresses
index|[
literal|0
index|]
operator|=
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
operator|.
name|n_value
operator|-
name|s
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|s
operator|->
name|lineno
index|[
name|l
operator|+
name|c
operator|+
literal|1
index|]
operator|.
name|line_number
condition|;
name|c
operator|++
control|)
block|{
name|res
operator|->
name|lines
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|s
operator|->
name|lineno
index|[
name|l
operator|+
name|c
index|]
operator|.
name|line_number
operator|+
name|start_line
operator|-
literal|1
expr_stmt|;
name|res
operator|->
name|addresses
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|s
operator|->
name|lineno
index|[
name|l
operator|+
name|c
index|]
operator|.
name|u
operator|.
name|offset
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_type
modifier|*
name|do_type
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|sym
init|=
operator|&
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
decl_stmt|;
name|union
name|internal_auxent
modifier|*
name|aux
init|=
operator|&
name|rawsyms
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|u
operator|.
name|auxent
decl_stmt|;
name|struct
name|coff_type
modifier|*
name|res
init|=
operator|(
expr|struct
name|coff_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_type
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|sym
operator|->
name|n_type
decl_stmt|;
name|int
name|which_dt
init|=
literal|0
decl_stmt|;
name|int
name|dimind
init|=
literal|0
decl_stmt|;
name|res
operator|->
name|type
operator|=
name|coff_basic_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|basic
operator|=
name|type
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
literal|0xf
condition|)
block|{
case|case
name|T_NULL
case|:
case|case
name|T_VOID
case|:
if|if
condition|(
name|sym
operator|->
name|n_numaux
operator|&&
name|sym
operator|->
name|n_sclass
operator|==
name|C_STAT
condition|)
block|{
comment|/* This is probably a section definition */
name|res
operator|->
name|type
operator|=
name|coff_secdef_type
expr_stmt|;
name|res
operator|->
name|size
operator|=
name|aux
operator|->
name|x_scn
operator|.
name|x_scnlen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
comment|/* Don't know what this is, let's make it a simple int */
name|res
operator|->
name|size
operator|=
name|INT_SIZE
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|basic
operator|=
name|T_UINT
expr_stmt|;
block|}
else|else
block|{
comment|/* Else it could be a function or pointer to void */
name|res
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
break|break;
case|case
name|T_UCHAR
case|:
case|case
name|T_CHAR
case|:
name|res
operator|->
name|size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|T_USHORT
case|:
case|case
name|T_SHORT
case|:
name|res
operator|->
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|T_UINT
case|:
case|case
name|T_INT
case|:
name|res
operator|->
name|size
operator|=
name|INT_SIZE
expr_stmt|;
break|break;
case|case
name|T_ULONG
case|:
case|case
name|T_LONG
case|:
name|res
operator|->
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|T_FLOAT
case|:
name|res
operator|->
name|size
operator|=
name|FLOAT_SIZE
expr_stmt|;
break|break;
case|case
name|T_DOUBLE
case|:
name|res
operator|->
name|size
operator|=
name|DOUBLE_SIZE
expr_stmt|;
break|break;
case|case
name|T_STRUCT
case|:
case|case
name|T_UNION
case|:
if|if
condition|(
name|sym
operator|->
name|n_numaux
condition|)
block|{
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
condition|)
block|{
comment|/* Refering to a struct defined elsewhere */
name|res
operator|->
name|type
operator|=
name|coff_structref_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|astructref
operator|.
name|ref
operator|=
name|tindex
index|[
name|INDEXOF
argument_list|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
argument_list|)
index|]
expr_stmt|;
name|res
operator|->
name|size
operator|=
name|res
operator|->
name|u
operator|.
name|astructref
operator|.
name|ref
condition|?
name|res
operator|->
name|u
operator|.
name|astructref
operator|.
name|ref
operator|->
name|type
operator|->
name|size
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* A definition of a struct */
name|last_struct
operator|=
name|res
expr_stmt|;
name|res
operator|->
name|type
operator|=
name|coff_structdef_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|astructdef
operator|.
name|elements
operator|=
name|empty_scope
argument_list|()
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|astructdef
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|astructdef
operator|.
name|isstruct
operator|=
operator|(
name|type
operator|&
literal|0xf
operator|)
operator|==
name|T_STRUCT
expr_stmt|;
name|res
operator|->
name|size
operator|=
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No auxents - it's anonynmous */
name|res
operator|->
name|type
operator|=
name|coff_structref_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|astructref
operator|.
name|ref
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|T_ENUM
case|:
if|if
condition|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
condition|)
block|{
comment|/* Refering to a enum defined elsewhere */
name|res
operator|->
name|type
operator|=
name|coff_enumref_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|aenumref
operator|.
name|ref
operator|=
name|tindex
index|[
name|INDEXOF
argument_list|(
name|aux
operator|->
name|x_sym
operator|.
name|x_tagndx
operator|.
name|p
argument_list|)
index|]
expr_stmt|;
name|res
operator|->
name|size
operator|=
name|res
operator|->
name|u
operator|.
name|aenumref
operator|.
name|ref
operator|->
name|type
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* A definition of an enum */
name|last_enum
operator|=
name|res
expr_stmt|;
name|res
operator|->
name|type
operator|=
name|coff_enumdef_type
expr_stmt|;
name|res
operator|->
name|u
operator|.
name|aenumdef
operator|.
name|elements
operator|=
name|empty_scope
argument_list|()
expr_stmt|;
name|res
operator|->
name|size
operator|=
name|aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_size
expr_stmt|;
block|}
break|break;
case|case
name|T_MOE
case|:
break|break;
block|}
for|for
control|(
name|which_dt
operator|=
literal|5
init|;
name|which_dt
operator|>=
literal|0
condition|;
name|which_dt
operator|--
control|)
block|{
switch|switch
condition|(
operator|(
name|type
operator|>>
operator|(
operator|(
name|which_dt
operator|*
literal|2
operator|)
operator|+
literal|4
operator|)
operator|)
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|DT_ARY
case|:
block|{
name|struct
name|coff_type
modifier|*
name|ptr
init|=
operator|(
operator|(
expr|struct
name|coff_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|els
init|=
operator|(
name|dimind
operator|<
name|DIMNUM
condition|?
name|aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
index|[
name|dimind
index|]
else|:
literal|0
operator|)
decl_stmt|;
operator|++
name|dimind
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|coff_array_type
expr_stmt|;
name|ptr
operator|->
name|size
operator|=
name|els
operator|*
name|res
operator|->
name|size
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|array
operator|.
name|dim
operator|=
name|els
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|array
operator|.
name|array_of
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
case|case
name|DT_PTR
case|:
block|{
name|struct
name|coff_type
modifier|*
name|ptr
init|=
operator|(
expr|struct
name|coff_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_type
argument_list|)
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|size
operator|=
name|PTR_SIZE
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|coff_pointer_type
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|pointer
operator|.
name|points_to
operator|=
name|res
expr_stmt|;
name|res
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
case|case
name|DT_FCN
case|:
block|{
name|struct
name|coff_type
modifier|*
name|ptr
init|=
operator|(
expr|struct
name|coff_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_type
argument_list|)
argument_list|)
decl_stmt|;
name|ptr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|type
operator|=
name|coff_function_type
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|function
operator|.
name|function_returns
operator|=
name|res
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|function
operator|.
name|parameters
operator|=
name|empty_scope
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|function
operator|.
name|lines
operator|=
name|do_lines
argument_list|(
name|i
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_nptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|u
operator|.
name|function
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|last_function_type
operator|=
name|ptr
expr_stmt|;
name|res
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_visible
modifier|*
name|do_visible
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|struct
name|internal_syment
modifier|*
name|sym
init|=
operator|&
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
decl_stmt|;
name|struct
name|coff_visible
modifier|*
name|visible
init|=
operator|(
expr|struct
name|coff_visible
operator|*
operator|)
operator|(
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_visible
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|enum
name|coff_vis_type
name|t
decl_stmt|;
switch|switch
condition|(
name|sym
operator|->
name|n_sclass
condition|)
block|{
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
case|case
name|C_FIELD
case|:
name|t
operator|=
name|coff_vis_member_of_struct
expr_stmt|;
break|break;
case|case
name|C_MOE
case|:
name|t
operator|=
name|coff_vis_member_of_enum
expr_stmt|;
break|break;
case|case
name|C_REGPARM
case|:
name|t
operator|=
name|coff_vis_regparam
expr_stmt|;
break|break;
case|case
name|C_REG
case|:
name|t
operator|=
name|coff_vis_register
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_TPDEF
case|:
name|t
operator|=
name|coff_vis_tag
expr_stmt|;
break|break;
case|case
name|C_AUTOARG
case|:
case|case
name|C_ARG
case|:
name|t
operator|=
name|coff_vis_autoparam
expr_stmt|;
break|break;
case|case
name|C_AUTO
case|:
name|t
operator|=
name|coff_vis_auto
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
case|case
name|C_STAT
case|:
name|t
operator|=
name|coff_vis_int_def
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
if|if
condition|(
name|sym
operator|->
name|n_scnum
operator|==
name|N_UNDEF
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|n_value
condition|)
name|t
operator|=
name|coff_vis_common
expr_stmt|;
else|else
name|t
operator|=
name|coff_vis_ext_ref
expr_stmt|;
block|}
else|else
name|t
operator|=
name|coff_vis_ext_def
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
name|visible
operator|->
name|type
operator|=
name|t
expr_stmt|;
return|return
name|visible
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_define
parameter_list|(
name|i
parameter_list|,
name|b
parameter_list|)
name|int
name|i
decl_stmt|;
name|struct
name|coff_scope
modifier|*
name|b
decl_stmt|;
block|{
specifier|static
name|int
name|symbol_index
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
init|=
operator|&
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
decl_stmt|;
comment|/* Define a symbol and attach to block b */
name|struct
name|coff_symbol
modifier|*
name|s
init|=
name|empty_symbol
argument_list|()
decl_stmt|;
name|s
operator|->
name|number
operator|=
operator|++
name|symbol_index
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|sym
operator|->
name|_n
operator|.
name|_n_nptr
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|sfile
operator|=
name|cur_sfile
expr_stmt|;
comment|/* Glue onto the ofile list */
if|if
condition|(
name|lofile
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ofile
operator|->
name|symbol_list_tail
condition|)
name|ofile
operator|->
name|symbol_list_tail
operator|->
name|next_in_ofile_list
operator|=
name|s
expr_stmt|;
else|else
name|ofile
operator|->
name|symbol_list_head
operator|=
name|s
expr_stmt|;
name|ofile
operator|->
name|symbol_list_tail
operator|=
name|s
expr_stmt|;
comment|/* And the block list */
block|}
if|if
condition|(
name|b
operator|->
name|vars_tail
condition|)
name|b
operator|->
name|vars_tail
operator|->
name|next
operator|=
name|s
expr_stmt|;
else|else
name|b
operator|->
name|vars_head
operator|=
name|s
expr_stmt|;
name|b
operator|->
name|vars_tail
operator|=
name|s
expr_stmt|;
name|b
operator|->
name|nvars
operator|++
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|do_type
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|where
operator|=
name|do_where
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|s
operator|->
name|visible
operator|=
name|do_visible
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tindex
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
comment|/* We remember the lowest address in each section for each source file */
if|if
condition|(
name|s
operator|->
name|where
operator|->
name|where
operator|==
name|coff_where_memory
operator|&&
name|s
operator|->
name|type
operator|->
name|type
operator|==
name|coff_secdef_type
condition|)
block|{
name|struct
name|coff_isection
modifier|*
name|is
init|=
name|cur_sfile
operator|->
name|section
operator|+
name|s
operator|->
name|where
operator|->
name|section
operator|->
name|number
decl_stmt|;
if|if
condition|(
operator|!
name|is
operator|->
name|init
condition|)
block|{
name|is
operator|->
name|low
operator|=
name|s
operator|->
name|where
operator|->
name|offset
expr_stmt|;
name|is
operator|->
name|high
operator|=
name|s
operator|->
name|where
operator|->
name|offset
operator|+
name|s
operator|->
name|type
operator|->
name|size
expr_stmt|;
name|is
operator|->
name|init
operator|=
literal|1
expr_stmt|;
name|is
operator|->
name|parent
operator|=
name|s
operator|->
name|where
operator|->
name|section
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|type
operator|->
name|type
operator|==
name|coff_function_type
condition|)
name|last_function_symbol
operator|=
name|s
expr_stmt|;
return|return
name|i
operator|+
name|sym
operator|->
name|n_numaux
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|coff_ofile
modifier|*
name|doit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|infile
init|=
literal|0
decl_stmt|;
name|struct
name|coff_ofile
modifier|*
name|head
init|=
operator|(
expr|struct
name|coff_ofile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_ofile
argument_list|)
argument_list|)
decl_stmt|;
name|ofile
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|source_head
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|source_tail
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|nsources
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|symbol_list_tail
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|symbol_list_head
operator|=
literal|0
expr_stmt|;
name|do_sections_p1
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|push_scope
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rawcount
condition|;
control|)
block|{
name|struct
name|internal_syment
modifier|*
name|sym
init|=
operator|&
name|rawsyms
index|[
name|i
index|]
operator|.
name|u
operator|.
name|syment
decl_stmt|;
switch|switch
condition|(
name|sym
operator|->
name|n_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
block|{
comment|/* new source file announced */
name|struct
name|coff_sfile
modifier|*
name|n
init|=
operator|(
expr|struct
name|coff_sfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_sfile
argument_list|)
argument_list|)
decl_stmt|;
name|n
operator|->
name|section
operator|=
operator|(
expr|struct
name|coff_isection
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_isection
argument_list|)
argument_list|,
name|abfd
operator|->
name|section_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cur_sfile
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|sym
operator|->
name|_n
operator|.
name|_n_nptr
index|[
literal|1
index|]
expr_stmt|;
name|n
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|infile
condition|)
block|{
name|pop_scope
argument_list|()
expr_stmt|;
block|}
name|infile
operator|=
literal|1
expr_stmt|;
name|push_scope
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|file_scope
operator|=
name|n
operator|->
name|scope
operator|=
name|top_scope
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|source_tail
condition|)
name|head
operator|->
name|source_tail
operator|->
name|next
operator|=
name|n
expr_stmt|;
else|else
name|head
operator|->
name|source_head
operator|=
name|n
expr_stmt|;
name|head
operator|->
name|source_tail
operator|=
name|n
expr_stmt|;
name|head
operator|->
name|nsources
operator|++
expr_stmt|;
name|i
operator|+=
name|sym
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C_FCN
case|:
block|{
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|_n
operator|.
name|_n_nptr
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
comment|/* Function start */
name|push_scope
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|last_function_type
operator|->
name|u
operator|.
name|function
operator|.
name|code
operator|=
name|top_scope
expr_stmt|;
name|top_scope
operator|->
name|sec
operator|=
name|ofile
operator|->
name|sections
operator|+
name|sym
operator|->
name|n_scnum
expr_stmt|;
name|top_scope
operator|->
name|offset
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
else|else
block|{
name|top_scope
operator|->
name|size
operator|=
name|sym
operator|->
name|n_value
operator|-
name|top_scope
operator|->
name|offset
operator|+
literal|1
expr_stmt|;
name|pop_scope
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
name|sym
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
block|{
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|_n
operator|.
name|_n_nptr
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
comment|/* Block start */
name|push_scope
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|top_scope
operator|->
name|sec
operator|=
name|ofile
operator|->
name|sections
operator|+
name|sym
operator|->
name|n_scnum
expr_stmt|;
name|top_scope
operator|->
name|offset
operator|=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
else|else
block|{
name|top_scope
operator|->
name|size
operator|=
name|sym
operator|->
name|n_value
operator|-
name|top_scope
operator|->
name|offset
operator|+
literal|1
expr_stmt|;
name|pop_scope
argument_list|()
expr_stmt|;
block|}
name|i
operator|+=
name|sym
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|C_REGPARM
case|:
case|case
name|C_ARG
case|:
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|last_function_symbol
operator|->
name|type
operator|->
name|u
operator|.
name|function
operator|.
name|parameters
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_MOS
case|:
case|case
name|C_MOU
case|:
case|case
name|C_FIELD
case|:
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|last_struct
operator|->
name|u
operator|.
name|astructdef
operator|.
name|elements
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_MOE
case|:
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|last_enum
operator|->
name|u
operator|.
name|aenumdef
operator|.
name|elements
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
comment|/* Various definition */
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|top_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
case|case
name|C_LABEL
case|:
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|file_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
case|case
name|C_TPDEF
case|:
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
name|i
operator|=
name|do_define
argument_list|(
name|i
argument_list|,
name|top_scope
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|C_EOS
case|:
name|i
operator|+=
name|sym
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|do_sections_p2
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_function
name|struct
name|coff_ofile
modifier|*
name|coff_grok
parameter_list|(
name|inabfd
parameter_list|)
name|bfd
modifier|*
name|inabfd
decl_stmt|;
block|{
name|long
name|storage
decl_stmt|;
name|struct
name|coff_ofile
modifier|*
name|p
decl_stmt|;
name|abfd
operator|=
name|inabfd
expr_stmt|;
name|storage
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|<
literal|0
condition|)
name|bfd_fatal
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|rawsyms
operator|=
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rawcount
operator|=
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
empty_stmt|;
name|tindex
operator|=
operator|(
expr|struct
name|coff_symbol
operator|*
operator|*
operator|)
operator|(
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symbol
operator|*
argument_list|)
argument_list|,
name|rawcount
argument_list|)
operator|)
expr_stmt|;
name|p
operator|=
name|doit
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

