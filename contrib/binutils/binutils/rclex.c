begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* rclex.c -- lexer for Windows rc files parser  */
end_comment

begin_comment
comment|/* Copyright 1997, 1998, 1999, 2001, 2002, 2003, 2005, 2006, 2007    Free Software Foundation, Inc.     Written by Kai Tietz, Onevision.     This file is part of GNU Binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is a lexer used by the Windows rc file parser.  It basically    just recognized a bunch of keywords.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bucomm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"windres.h"
end_include

begin_include
include|#
directive|include
file|"rcparse.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* Whether we are in rcdata mode, in which we returns the lengths of    strings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rcdata_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are supressing lines from cpp (including windows.h or    headers from your C sources may bring in externs and typedefs).    When active, we return IGNORED_TOKEN, which lets us ignore these    outside of resource constructs.  Thus, it isn't required to protect    all the non-preprocessor lines in your header files with #ifdef    RC_INVOKED.  It also means your RC file can't include other RC    files if they're named "*.h".  Sorry.  Name them *.rch or whatever.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|suppress_cpp_data
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGNORE_CPP
parameter_list|(
name|x
parameter_list|)
value|(suppress_cpp_data ? IGNORED_TOKEN : (x))
end_define

begin_comment
comment|/* The first filename we detect in the cpp output.  We use this to    tell included files from the original file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initial_fn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of allocated strings.  */
end_comment

begin_struct
struct|struct
name|alloc_string
block|{
name|struct
name|alloc_string
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alloc_string
modifier|*
name|strings
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rclex_keywords
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|tok
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|K
parameter_list|(
name|KEY
parameter_list|)
value|{ #KEY, KEY }
end_define

begin_define
define|#
directive|define
name|KRT
parameter_list|(
name|KEY
parameter_list|)
value|{ #KEY, RT_##KEY }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|rclex_keywords
name|keywds
index|[]
init|=
block|{
name|K
argument_list|(
name|ACCELERATORS
argument_list|)
block|,
name|K
argument_list|(
name|ALT
argument_list|)
block|,
name|K
argument_list|(
name|ANICURSOR
argument_list|)
block|,
name|K
argument_list|(
name|ANIICON
argument_list|)
block|,
name|K
argument_list|(
name|ASCII
argument_list|)
block|,
name|K
argument_list|(
name|AUTO3STATE
argument_list|)
block|,
name|K
argument_list|(
name|AUTOCHECKBOX
argument_list|)
block|,
name|K
argument_list|(
name|AUTORADIOBUTTON
argument_list|)
block|,
name|K
argument_list|(
name|BEDIT
argument_list|)
block|,
block|{
literal|"BEGIN"
block|,
name|BEG
block|}
block|,
name|K
argument_list|(
name|BITMAP
argument_list|)
block|,
name|K
argument_list|(
name|BLOCK
argument_list|)
block|,
name|K
argument_list|(
name|BUTTON
argument_list|)
block|,
name|K
argument_list|(
name|CAPTION
argument_list|)
block|,
name|K
argument_list|(
name|CHARACTERISTICS
argument_list|)
block|,
name|K
argument_list|(
name|CHECKBOX
argument_list|)
block|,
name|K
argument_list|(
name|CHECKED
argument_list|)
block|,
name|K
argument_list|(
name|CLASS
argument_list|)
block|,
name|K
argument_list|(
name|COMBOBOX
argument_list|)
block|,
name|K
argument_list|(
name|CONTROL
argument_list|)
block|,
name|K
argument_list|(
name|CTEXT
argument_list|)
block|,
name|K
argument_list|(
name|CURSOR
argument_list|)
block|,
name|K
argument_list|(
name|DEFPUSHBUTTON
argument_list|)
block|,
name|K
argument_list|(
name|DIALOG
argument_list|)
block|,
name|K
argument_list|(
name|DIALOGEX
argument_list|)
block|,
name|K
argument_list|(
name|DISCARDABLE
argument_list|)
block|,
name|K
argument_list|(
name|DLGINCLUDE
argument_list|)
block|,
name|K
argument_list|(
name|DLGINIT
argument_list|)
block|,
name|K
argument_list|(
name|EDITTEXT
argument_list|)
block|,
name|K
argument_list|(
name|END
argument_list|)
block|,
name|K
argument_list|(
name|EXSTYLE
argument_list|)
block|,
name|K
argument_list|(
name|FILEFLAGS
argument_list|)
block|,
name|K
argument_list|(
name|FILEFLAGSMASK
argument_list|)
block|,
name|K
argument_list|(
name|FILEOS
argument_list|)
block|,
name|K
argument_list|(
name|FILESUBTYPE
argument_list|)
block|,
name|K
argument_list|(
name|FILETYPE
argument_list|)
block|,
name|K
argument_list|(
name|FILEVERSION
argument_list|)
block|,
name|K
argument_list|(
name|FIXED
argument_list|)
block|,
name|K
argument_list|(
name|FONT
argument_list|)
block|,
name|K
argument_list|(
name|FONTDIR
argument_list|)
block|,
name|K
argument_list|(
name|GRAYED
argument_list|)
block|,
name|KRT
argument_list|(
name|GROUP_CURSOR
argument_list|)
block|,
name|KRT
argument_list|(
name|GROUP_ICON
argument_list|)
block|,
name|K
argument_list|(
name|GROUPBOX
argument_list|)
block|,
name|K
argument_list|(
name|HEDIT
argument_list|)
block|,
name|K
argument_list|(
name|HELP
argument_list|)
block|,
name|K
argument_list|(
name|HTML
argument_list|)
block|,
name|K
argument_list|(
name|ICON
argument_list|)
block|,
name|K
argument_list|(
name|IEDIT
argument_list|)
block|,
name|K
argument_list|(
name|IMPURE
argument_list|)
block|,
name|K
argument_list|(
name|INACTIVE
argument_list|)
block|,
name|K
argument_list|(
name|LANGUAGE
argument_list|)
block|,
name|K
argument_list|(
name|LISTBOX
argument_list|)
block|,
name|K
argument_list|(
name|LOADONCALL
argument_list|)
block|,
name|K
argument_list|(
name|LTEXT
argument_list|)
block|,
name|K
argument_list|(
name|MANIFEST
argument_list|)
block|,
name|K
argument_list|(
name|MENU
argument_list|)
block|,
name|K
argument_list|(
name|MENUBARBREAK
argument_list|)
block|,
name|K
argument_list|(
name|MENUBREAK
argument_list|)
block|,
name|K
argument_list|(
name|MENUEX
argument_list|)
block|,
name|K
argument_list|(
name|MENUITEM
argument_list|)
block|,
name|K
argument_list|(
name|MESSAGETABLE
argument_list|)
block|,
name|K
argument_list|(
name|MOVEABLE
argument_list|)
block|,
name|K
argument_list|(
name|NOINVERT
argument_list|)
block|,
name|K
argument_list|(
name|NOT
argument_list|)
block|,
name|K
argument_list|(
name|PLUGPLAY
argument_list|)
block|,
name|K
argument_list|(
name|POPUP
argument_list|)
block|,
name|K
argument_list|(
name|PRELOAD
argument_list|)
block|,
name|K
argument_list|(
name|PRODUCTVERSION
argument_list|)
block|,
name|K
argument_list|(
name|PURE
argument_list|)
block|,
name|K
argument_list|(
name|PUSHBOX
argument_list|)
block|,
name|K
argument_list|(
name|PUSHBUTTON
argument_list|)
block|,
name|K
argument_list|(
name|RADIOBUTTON
argument_list|)
block|,
name|K
argument_list|(
name|RCDATA
argument_list|)
block|,
name|K
argument_list|(
name|RTEXT
argument_list|)
block|,
name|K
argument_list|(
name|SCROLLBAR
argument_list|)
block|,
name|K
argument_list|(
name|SEPARATOR
argument_list|)
block|,
name|K
argument_list|(
name|SHIFT
argument_list|)
block|,
name|K
argument_list|(
name|STATE3
argument_list|)
block|,
name|K
argument_list|(
name|STRINGTABLE
argument_list|)
block|,
name|K
argument_list|(
name|STYLE
argument_list|)
block|,
name|K
argument_list|(
name|TOOLBAR
argument_list|)
block|,
name|K
argument_list|(
name|USERBUTTON
argument_list|)
block|,
name|K
argument_list|(
name|VALUE
argument_list|)
block|,
block|{
literal|"VERSION"
block|,
name|VERSIONK
block|}
block|,
name|K
argument_list|(
name|VERSIONINFO
argument_list|)
block|,
name|K
argument_list|(
name|VIRTKEY
argument_list|)
block|,
name|K
argument_list|(
name|VXD
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External input stream from resrc */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|cpp_pipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lexical scanner helpers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rclex_lastch
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|rclex_tok_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|rclex_tok_pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rclex_tok
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rclex_translatekeyword
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|&&
name|ISUPPER
argument_list|(
name|key
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|rclex_keywords
modifier|*
name|kw
init|=
operator|&
name|keywds
index|[
literal|0
index|]
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|kw
operator|->
name|name
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|kw
operator|->
name|tok
return|;
operator|++
name|kw
expr_stmt|;
block|}
do|while
condition|(
name|kw
operator|->
name|name
operator|!=
name|NULL
condition|)
do|;
block|}
return|return
name|STRING
return|;
block|}
end_function

begin_comment
comment|/* Handle a C preprocessor line.  */
end_comment

begin_function
specifier|static
name|void
name|cpp_line
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|rclex_tok
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|send
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|mlen
decl_stmt|;
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
comment|/* Check for #pragma code_page ( DEFAULT |<nr>).  */
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mlen
operator|=
name|strlen
argument_list|(
literal|"pragma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|mlen
operator|&&
name|memcmp
argument_list|(
name|s
argument_list|,
literal|"pragma"
argument_list|,
name|mlen
argument_list|)
operator|==
literal|0
operator|&&
name|ISSPACE
argument_list|(
name|s
index|[
name|mlen
index|]
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|s
operator|+=
name|mlen
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mlen
operator|=
name|strlen
argument_list|(
literal|"code_page"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|mlen
operator|||
name|memcmp
argument_list|(
name|s
argument_list|,
literal|"code_page"
argument_list|,
name|mlen
argument_list|)
operator|!=
literal|0
condition|)
comment|/* FIXME: We ought to issue a warning message about an unrecognised pragma.  */
return|return;
name|s
operator|+=
name|mlen
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
comment|/* FIXME: We ought to issue an error message about a malformed pragma.  */
return|return;
operator|++
name|s
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
operator|||
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* FIXME: We ought to issue an error message about a malformed pragma.  */
return|return;
name|len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|s
argument_list|)
expr_stmt|;
name|fn
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|memcpy
argument_list|(
name|fn
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fn
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|fn
index|[
name|len
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|fn
index|[
name|len
operator|-
literal|1
index|]
operator|<=
literal|0x20
operator|)
condition|)
name|fn
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|||
operator|(
name|len
operator|==
name|strlen
argument_list|(
literal|"DEFAULT"
argument_list|)
operator|&&
name|strcasecmp
argument_list|(
name|fn
argument_list|,
literal|"DEFAULT"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|wind_current_codepage
operator|=
name|wind_default_codepage
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|rc_uint_type
name|ncp
decl_stmt|;
if|if
condition|(
name|fn
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|fn
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|fn
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
name|ncp
operator|=
operator|(
name|rc_uint_type
operator|)
name|strtol
argument_list|(
name|fn
operator|+
literal|2
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|ncp
operator|=
operator|(
name|rc_uint_type
operator|)
name|strtol
argument_list|(
name|fn
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp
operator|==
name|CP_UTF16
operator|||
operator|!
name|unicode_is_valid_codepage
argument_list|(
name|ncp
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid value specified for pragma code_page.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|wind_current_codepage
operator|=
name|ncp
expr_stmt|;
block|}
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|send
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|send
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|send
argument_list|)
condition|)
return|return;
comment|/* Subtract 1 because we are about to count the newline.  */
name|rc_lineno
operator|=
name|line
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|send
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'"'
condition|)
return|return;
operator|++
name|s
expr_stmt|;
name|send
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|send
operator|==
name|NULL
condition|)
return|return;
name|fn
operator|=
name|xmalloc
argument_list|(
name|send
operator|-
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fn
argument_list|,
name|s
argument_list|,
name|send
operator|-
name|s
argument_list|)
expr_stmt|;
name|fn
index|[
name|send
operator|-
name|s
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|rc_filename
argument_list|)
expr_stmt|;
name|rc_filename
operator|=
name|fn
expr_stmt|;
if|if
condition|(
operator|!
name|initial_fn
condition|)
block|{
name|initial_fn
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|initial_fn
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Allow the initial file, regardless of name.  Suppress all other      files if they end in ".h" (this allows included "*.rc").  */
if|if
condition|(
name|strcmp
argument_list|(
name|initial_fn
argument_list|,
name|fn
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|fn
operator|+
name|strlen
argument_list|(
name|fn
argument_list|)
operator|-
literal|2
argument_list|,
literal|".h"
argument_list|)
operator|!=
literal|0
condition|)
name|suppress_cpp_data
operator|=
literal|0
expr_stmt|;
else|else
name|suppress_cpp_data
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate a string of a given length.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_string
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|struct
name|alloc_string
modifier|*
name|as
decl_stmt|;
name|as
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|as
argument_list|)
expr_stmt|;
name|as
operator|->
name|s
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|as
operator|->
name|next
operator|=
name|strings
expr_stmt|;
name|strings
operator|=
name|as
expr_stmt|;
return|return
name|as
operator|->
name|s
return|;
block|}
end_function

begin_comment
comment|/* Handle a quoted string.  The quotes are stripped.  A pair of quotes    in a string are turned into a single quote.  Adjacent strings are    merged separated by whitespace are merged, as in C.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|handle_quotes
parameter_list|(
name|rc_uint_type
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|input
init|=
name|rclex_tok
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|num_xdigits
decl_stmt|;
name|ret
operator|=
name|get_string
argument_list|(
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|ret
expr_stmt|;
name|t
operator|=
name|input
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'"'
condition|)
operator|++
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|t
expr_stmt|;
switch|switch
condition|(
operator|*
name|t
condition|)
block|{
case|case
literal|'\0'
case|:
name|rcparse_warning
argument_list|(
literal|"backslash at end of string"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|rcparse_warning
argument_list|(
literal|"use \"\" to put \" in a string"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_B
expr_stmt|;
comment|/* Strange, but true...  */
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_B
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_F
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_N
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_R
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_T
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_V
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|ch
operator|=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'7'
condition|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'7'
condition|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|++
operator|=
name|ch
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
operator|++
name|t
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* We only handle single byte chars here.  Make sure 		 we finish an escape sequence like "/xB0ABC" after 		 the first two digits.  */
name|num_xdigits
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|num_xdigits
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'9'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|>=
literal|'a'
operator|&&
operator|*
name|t
operator|<=
literal|'f'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|>=
literal|'A'
operator|&&
operator|*
name|t
operator|<=
literal|'F'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
break|break;
operator|++
name|t
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
name|ch
expr_stmt|;
break|break;
default|default:
name|rcparse_warning
argument_list|(
literal|"unrecognized escape sequence"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|!=
literal|'"'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|rcparse_warning
argument_list|(
literal|"unexpected character after '\"'"
argument_list|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
name|assert
argument_list|(
name|ISSPACE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|==
literal|'\n'
condition|)
operator|++
name|rc_lineno
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
break|break;
name|assert
argument_list|(
operator|*
name|t
operator|==
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|len
operator|=
name|s
operator|-
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate a unicode string of a given length.  */
end_comment

begin_function
specifier|static
name|unichar
modifier|*
name|get_unistring
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|unichar
operator|*
operator|)
name|get_string
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|unichar
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a quoted unicode string.  The quotes are stripped.  A pair of quotes    in a string are turned into a single quote.  Adjacent strings are    merged separated by whitespace are merged, as in C.  */
end_comment

begin_function
specifier|static
name|unichar
modifier|*
name|handle_uniquotes
parameter_list|(
name|rc_uint_type
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|input
init|=
name|rclex_tok
decl_stmt|;
name|unichar
modifier|*
name|ret
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|num_xdigits
decl_stmt|;
name|ret
operator|=
name|get_unistring
argument_list|(
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|ret
expr_stmt|;
name|t
operator|=
name|input
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'L'
operator|||
operator|*
name|t
operator|==
literal|'l'
operator|)
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
name|t
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'"'
condition|)
operator|++
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|t
expr_stmt|;
switch|switch
condition|(
operator|*
name|t
condition|)
block|{
case|case
literal|'\0'
case|:
name|rcparse_warning
argument_list|(
literal|"backslash at end of string"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|rcparse_warning
argument_list|(
literal|"use \"\" to put \" in a string"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_B
expr_stmt|;
comment|/* Strange, but true...  */
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_B
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_F
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_N
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_R
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_T
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|*
name|s
operator|++
operator|=
name|ESCAPE_V
expr_stmt|;
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|*
name|s
operator|++
operator|=
operator|(
name|unichar
operator|)
operator|*
name|t
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|ch
operator|=
operator|*
name|t
operator|-
literal|'0'
expr_stmt|;
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'7'
condition|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'7'
condition|)
block|{
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|++
operator|=
operator|(
name|unichar
operator|)
name|ch
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
operator|++
name|t
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* We only handle two byte chars here.  Make sure 		 we finish an escape sequence like "/xB0ABC" after 		 the first two digits.  */
name|num_xdigits
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|num_xdigits
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|>=
literal|'0'
operator|&&
operator|*
name|t
operator|<=
literal|'9'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|>=
literal|'a'
operator|&&
operator|*
name|t
operator|<=
literal|'f'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'a'
operator|+
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|>=
literal|'A'
operator|&&
operator|*
name|t
operator|<=
literal|'F'
condition|)
name|ch
operator|=
operator|(
name|ch
operator|<<
literal|4
operator|)
operator||
operator|(
operator|*
name|t
operator|-
literal|'A'
operator|+
literal|10
operator|)
expr_stmt|;
else|else
break|break;
operator|++
name|t
expr_stmt|;
block|}
operator|*
name|s
operator|++
operator|=
operator|(
name|unichar
operator|)
name|ch
expr_stmt|;
break|break;
default|default:
name|rcparse_warning
argument_list|(
literal|"unrecognized escape sequence"
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|(
name|unichar
operator|)
operator|*
name|t
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|!=
literal|'"'
condition|)
operator|*
name|s
operator|++
operator|=
operator|(
name|unichar
operator|)
operator|*
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
elseif|else
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'"'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'"'
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|++
name|t
expr_stmt|;
name|assert
argument_list|(
name|ISSPACE
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|==
literal|'\n'
condition|)
operator|++
name|rc_lineno
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
condition|)
break|break;
name|assert
argument_list|(
operator|*
name|t
operator|==
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|t
expr_stmt|;
block|}
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|len
operator|=
name|s
operator|-
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Discard all the strings we have allocated.  The parser calls this    when it no longer needs them.  */
end_comment

begin_function
name|void
name|rcparse_discard_strings
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|alloc_string
modifier|*
name|as
decl_stmt|;
name|as
operator|=
name|strings
expr_stmt|;
while|while
condition|(
name|as
operator|!=
name|NULL
condition|)
block|{
name|struct
name|alloc_string
modifier|*
name|n
decl_stmt|;
name|free
argument_list|(
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
name|n
operator|=
name|as
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|as
operator|=
name|n
expr_stmt|;
block|}
name|strings
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter rcdata mode.  */
end_comment

begin_function
name|void
name|rcparse_rcdata
parameter_list|(
name|void
parameter_list|)
block|{
name|rcdata_mode
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go back to normal mode from rcdata mode.  */
end_comment

begin_function
name|void
name|rcparse_normal
parameter_list|(
name|void
parameter_list|)
block|{
name|rcdata_mode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rclex_tok_add_char
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rclex_tok
operator|||
name|rclex_tok_max
operator|<=
name|rclex_tok_pos
condition|)
block|{
name|char
modifier|*
name|h
init|=
name|xmalloc
argument_list|(
name|rclex_tok_max
operator|+
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rclex_tok
condition|)
block|{
name|memcpy
argument_list|(
name|h
argument_list|,
name|rclex_tok
argument_list|,
name|rclex_tok_pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rclex_tok
argument_list|)
expr_stmt|;
block|}
else|else
name|rclex_tok_pos
operator|=
literal|0
expr_stmt|;
name|rclex_tok_max
operator|+=
literal|8
expr_stmt|;
name|rclex_tok
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
operator|-
literal|1
condition|)
name|rclex_tok
index|[
name|rclex_tok_pos
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|rclex_tok
index|[
name|rclex_tok_pos
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rclex_readch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|rclex_lastch
operator|)
operator|!=
operator|-
literal|1
condition|)
name|rclex_lastch
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|char
name|ch
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|cpp_pipe
operator|||
name|feof
argument_list|(
name|cpp_pipe
argument_list|)
operator|||
name|fread
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|cpp_pipe
argument_list|)
operator|!=
literal|1
condition|)
break|break;
name|r
operator|=
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|==
literal|0
operator|||
name|r
operator|==
literal|'\r'
condition|)
do|;
block|}
name|rclex_tok_add_char
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rclex_peekch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|rclex_lastch
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|rclex_readch
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rclex_lastch
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|rclex_tok_pos
operator|>
literal|0
condition|)
name|rclex_tok
index|[
operator|--
name|rclex_tok_pos
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rclex_string
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|rclex_peekch
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|rclex_readch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|rclex_peekch
argument_list|()
operator|)
operator|==
operator|-
literal|1
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|rclex_readch
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rclex_readch
argument_list|()
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|rclex_peekch
argument_list|()
operator|==
literal|'"'
condition|)
name|rclex_readch
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|rc_uint_type
name|read_digit
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|rc_uint_type
name|base
init|=
literal|10
decl_stmt|;
name|rc_uint_type
name|ret
decl_stmt|,
name|val
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'0'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
switch|switch
condition|(
name|rclex_peekch
argument_list|()
condition|)
block|{
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|rclex_readch
argument_list|()
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|rclex_readch
argument_list|()
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
break|break;
block|}
block|}
else|else
name|ret
operator|=
call|(
name|rc_uint_type
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|rclex_peekch
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ISDIGIT
argument_list|(
name|ch
argument_list|)
condition|)
name|val
operator|=
call|(
name|rc_uint_type
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
name|val
operator|=
call|(
name|rc_uint_type
call|)
argument_list|(
operator|(
name|ch
operator|-
literal|'a'
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
name|val
operator|=
call|(
name|rc_uint_type
call|)
argument_list|(
operator|(
name|ch
operator|-
literal|'A'
operator|)
operator|+
literal|10
argument_list|)
expr_stmt|;
else|else
break|break;
name|rclex_readch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|warned
operator|&&
name|val
operator|>=
name|base
condition|)
block|{
name|warned
operator|=
literal|1
expr_stmt|;
name|rcparse_warning
argument_list|(
literal|"digit exceeds base"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|*=
name|base
expr_stmt|;
name|ret
operator|+=
name|val
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* yyparser entry method.  */
end_comment

begin_function
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|unichar
modifier|*
name|us
decl_stmt|;
name|rc_uint_type
name|length
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* Make sure that rclex_tok is initialized.  */
if|if
condition|(
operator|!
name|rclex_tok
condition|)
name|rclex_tok_add_char
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
comment|/* Clear token.  */
name|rclex_tok_pos
operator|=
literal|0
expr_stmt|;
name|rclex_tok
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|rclex_readch
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
operator|++
name|rc_lineno
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|<=
literal|0x20
condition|)
do|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'#'
case|:
while|while
condition|(
operator|(
name|ch
operator|=
name|rclex_peekch
argument_list|()
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|rclex_readch
argument_list|()
expr_stmt|;
name|cpp_line
argument_list|()
expr_stmt|;
name|ch
operator|=
name|IGNORED_TOKEN
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
name|BEG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|yylval
operator|.
name|i
operator|.
name|val
operator|=
name|read_digit
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|i
operator|.
name|dword
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rclex_peekch
argument_list|()
condition|)
block|{
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|rclex_readch
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|i
operator|.
name|dword
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|rclex_string
argument_list|()
expr_stmt|;
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
operator|(
operator|!
name|rcdata_mode
condition|?
name|QUOTEDSTRING
else|:
name|SIZEDSTRING
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|IGNORED_TOKEN
condition|)
break|break;
name|s
operator|=
name|handle_quotes
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcdata_mode
condition|)
name|yylval
operator|.
name|s
operator|=
name|s
expr_stmt|;
else|else
block|{
name|yylval
operator|.
name|ss
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|yylval
operator|.
name|ss
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|rclex_peekch
argument_list|()
operator|==
literal|'"'
condition|)
block|{
name|rclex_readch
argument_list|()
expr_stmt|;
name|rclex_string
argument_list|()
expr_stmt|;
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
operator|(
operator|!
name|rcdata_mode
condition|?
name|QUOTEDUNISTRING
else|:
name|SIZEDUNISTRING
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|IGNORED_TOKEN
condition|)
break|break;
name|us
operator|=
name|handle_uniquotes
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcdata_mode
condition|)
name|yylval
operator|.
name|uni
operator|=
name|us
expr_stmt|;
else|else
block|{
name|yylval
operator|.
name|suni
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|yylval
operator|.
name|suni
operator|.
name|s
operator|=
name|us
expr_stmt|;
block|}
break|break;
block|}
comment|/* Fall through.  */
default|default:
if|if
condition|(
name|ISIDST
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'$'
condition|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
name|rclex_peekch
argument_list|()
operator|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|ISIDNUM
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'$'
operator|||
name|ch
operator|==
literal|'.'
operator|)
condition|)
name|rclex_readch
argument_list|()
expr_stmt|;
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
name|rclex_translatekeyword
argument_list|(
name|rclex_tok
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|STRING
condition|)
block|{
name|s
operator|=
name|get_string
argument_list|(
name|strlen
argument_list|(
name|rclex_tok
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|rclex_tok
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|s
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|BLOCK
condition|)
block|{
specifier|const
name|char
modifier|*
name|hs
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|yylex
argument_list|()
condition|)
block|{
case|case
name|STRING
case|:
case|case
name|QUOTEDSTRING
case|:
name|hs
operator|=
name|yylval
operator|.
name|s
expr_stmt|;
break|break;
case|case
name|SIZEDSTRING
case|:
name|hs
operator|=
name|yylval
operator|.
name|s
operator|=
name|yylval
operator|.
name|ss
operator|.
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hs
condition|)
block|{
name|rcparse_warning
argument_list|(
literal|"BLOCK expects a string as argument."
argument_list|)
expr_stmt|;
name|ch
operator|=
name|IGNORED_TOKEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hs
argument_list|,
literal|"StringFileInfo"
argument_list|)
condition|)
name|ch
operator|=
name|BLOCKSTRINGFILEINFO
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hs
argument_list|,
literal|"VarFileInfo"
argument_list|)
condition|)
name|ch
operator|=
name|BLOCKVARFILEINFO
expr_stmt|;
block|}
break|break;
block|}
name|ch
operator|=
name|IGNORE_CPP
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ch
operator|==
name|IGNORED_TOKEN
condition|)
do|;
return|return
name|ch
return|;
block|}
end_function

end_unit

