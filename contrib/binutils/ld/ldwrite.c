begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldwrite.c -- write out the linked file    Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.    Written by Steve Chamberlain sac@cygnus.com  This file is part of GLD, the Gnu Linker.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|build_link_order
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|clone_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|split_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build link_order structures for the BFD linker.  */
end_comment

begin_function
specifier|static
name|void
name|build_link_order
parameter_list|(
name|statement
parameter_list|)
name|lang_statement_union_type
modifier|*
name|statement
decl_stmt|;
block|{
switch|switch
condition|(
name|statement
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_data_statement_enum
case|:
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|output_section
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: bfd_new_link_order failed\n"
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|type
operator|=
name|bfd_data_link_order
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|output_vma
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|QUAD_SIZE
argument_list|)
expr_stmt|;
name|value
operator|=
name|statement
operator|->
name|data_statement
operator|.
name|value
expr_stmt|;
comment|/* If the endianness of the output BFD is not known, then we 	   base the endianness of the data on the first input file. 	   By convention, the bfd_put routines for an unknown 	   endianness are big endian, so we must swap here if the 	   input file is little endian.  */
if|if
condition|(
operator|!
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
operator|&&
operator|!
name|bfd_little_endian
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|boolean
name|swap
decl_stmt|;
name|swap
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
condition|)
name|swap
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_UNSET
condition|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|s
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|the_bfd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_little_endian
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|)
condition|)
name|swap
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|swap
condition|)
block|{
name|bfd_byte
name|buffer
index|[
literal|8
index|]
decl_stmt|;
switch|switch
condition|(
name|statement
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
name|bfd_putl64
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb64
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|bfd_putl32
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|bfd_putl16
argument_list|(
name|value
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|statement
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|bfd_put_8
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|link_order
operator|->
name|u
operator|.
name|data
operator|.
name|contents
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|lang_reloc_statement_type
modifier|*
name|rs
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|rs
operator|=
operator|&
name|statement
operator|->
name|reloc_statement
expr_stmt|;
name|output_section
operator|=
name|rs
operator|->
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_order
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: bfd_new_link_order failed\n"
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|rs
operator|->
name|output_vma
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|rs
operator|->
name|howto
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|=
operator|(
operator|(
expr|struct
name|bfd_link_order_reloc
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_link_order_reloc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|reloc
operator|=
name|rs
operator|->
name|reloc
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|=
name|rs
operator|->
name|addend_value
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_section_reloc_link_order
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|section
operator|->
name|owner
operator|==
name|output_bfd
condition|)
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|=
name|rs
operator|->
name|section
expr_stmt|;
else|else
block|{
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|section
operator|=
name|rs
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|addend
operator|+=
name|rs
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
else|else
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_symbol_reloc_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|reloc
operator|.
name|p
operator|->
name|u
operator|.
name|name
operator|=
name|rs
operator|->
name|name
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_input_section_enum
case|:
comment|/* Create a new link_order in the output section with this 	 attached */
if|if
condition|(
name|statement
operator|->
name|input_section
operator|.
name|ifile
operator|->
name|just_syms_flag
operator|==
name|false
condition|)
block|{
name|asection
modifier|*
name|i
init|=
name|statement
operator|->
name|input_section
operator|.
name|section
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|i
operator|->
name|output_section
decl_stmt|;
name|ASSERT
argument_list|(
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
block|{
comment|/* We've got a never load section inside one which 		     is going to be output, we'll change it into a 		     fill link_order */
name|link_order
operator|->
name|type
operator|=
name|bfd_fill_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|fill
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|link_order
operator|->
name|type
operator|=
name|bfd_indirect_link_order
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|=
name|i
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|->
name|output_section
operator|==
name|output_section
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|_cooked_size
condition|)
name|link_order
operator|->
name|size
operator|=
name|i
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|link_order
operator|->
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|i
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
comment|/* Make a new link_order with the right filler */
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|output_section
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|output_section
expr_stmt|;
name|ASSERT
argument_list|(
name|statement
operator|->
name|padding_statement
operator|.
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|link_order
operator|=
name|bfd_new_link_order
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
name|link_order
operator|->
name|type
operator|=
name|bfd_fill_link_order
expr_stmt|;
name|link_order
operator|->
name|size
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
name|link_order
operator|->
name|offset
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|output_offset
expr_stmt|;
name|link_order
operator|->
name|u
operator|.
name|fill
operator|.
name|value
operator|=
name|statement
operator|->
name|padding_statement
operator|.
name|fill
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* All the other ones fall through */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Call BFD to write out the linked file.  */
end_comment

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* Wander around the input sections, make sure that    we'll never try and create an output section with more relocs    than will fit.. Do this by always assuming the worst case, and    creating new output sections with all the right bits */
end_comment

begin_define
define|#
directive|define
name|TESTIT
value|1
end_define

begin_function
specifier|static
name|asection
modifier|*
name|clone_section
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
block|{
define|#
directive|define
name|SSIZE
value|8
name|char
name|sname
index|[
name|SSIZE
index|]
decl_stmt|;
comment|/* ??  find the name for this size */
name|asection
modifier|*
name|n
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Invent a section name - use first five      chars of base section name and a digit suffix */
do|do
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|b
index|[
literal|6
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|b
argument_list|)
operator|-
literal|1
operator|&&
name|s
operator|->
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
name|s
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|"%s%d"
argument_list|,
name|b
argument_list|,
operator|(
operator|*
name|count
operator|)
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
condition|)
do|;
name|n
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|xstrdup
argument_list|(
name|sname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a symbol of the same name */
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|sname
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
name|n
operator|->
name|vma
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|n
operator|->
name|user_set_vma
operator|=
name|s
operator|->
name|user_set_vma
expr_stmt|;
name|n
operator|->
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|n
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|output_offset
operator|=
name|s
operator|->
name|output_offset
expr_stmt|;
name|n
operator|->
name|output_section
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|orelocation
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|alignment_power
operator|=
name|s
operator|->
name|alignment_power
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TESTING
end_if

begin_function
specifier|static
name|void
name|ds
parameter_list|(
name|s
parameter_list|)
name|asection
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|bfd_link_order
modifier|*
name|l
init|=
name|s
operator|->
name|link_order_head
decl_stmt|;
name|printf
argument_list|(
literal|"vma %x size %x\n"
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|printf
argument_list|(
literal|"%8x %s\n"
argument_list|,
name|l
operator|->
name|offset
argument_list|,
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%8x something else\n"
argument_list|,
name|l
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|dump
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ds
argument_list|(
name|a1
argument_list|)
expr_stmt|;
name|ds
argument_list|(
name|a2
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|sanity_check
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|link_order_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|offset
operator|>
literal|100000
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|offset
operator|<
name|prev
condition|)
name|abort
argument_list|()
expr_stmt|;
name|prev
operator|=
name|p
operator|->
name|offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sanity_check
parameter_list|(
name|a
parameter_list|)
end_define

begin_define
define|#
directive|define
name|dump
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|split_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|original_sec
decl_stmt|;
name|int
name|nsecs
init|=
name|abfd
operator|->
name|section_count
decl_stmt|;
name|sanity_check
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* look through all the original sections */
for|for
control|(
name|original_sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|original_sec
operator|&&
name|nsecs
condition|;
name|original_sec
operator|=
name|original_sec
operator|->
name|next
operator|,
name|nsecs
operator|--
control|)
block|{
name|boolean
name|first
init|=
name|true
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|lines
init|=
literal|0
decl_stmt|;
name|int
name|relocs
init|=
literal|0
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
modifier|*
name|pp
decl_stmt|;
name|bfd_vma
name|vma
init|=
name|original_sec
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|shift_offset
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|cursor
init|=
name|original_sec
decl_stmt|;
comment|/* count up the relocations and line entries to see if 	 anything would be too big to fit */
for|for
control|(
name|pp
operator|=
operator|&
operator|(
name|cursor
operator|->
name|link_order_head
operator|)
init|;
operator|*
name|pp
condition|;
name|pp
operator|=
operator|&
operator|(
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
operator|)
control|)
block|{
name|struct
name|bfd_link_order
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|thislines
init|=
literal|0
decl_stmt|;
name|int
name|thisrelocs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|strip
operator|==
name|strip_none
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_some
condition|)
name|thislines
operator|=
name|sec
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
name|thisrelocs
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|relocateable
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|bfd_section_reloc_link_order
operator|||
name|p
operator|->
name|type
operator|==
name|bfd_symbol_reloc_link_order
operator|)
condition|)
name|thisrelocs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
name|thisrelocs
operator|+
name|relocs
operator|>
name|config
operator|.
name|split_by_reloc
operator|||
name|thislines
operator|+
name|lines
operator|>
name|config
operator|.
name|split_by_reloc
operator|||
name|config
operator|.
name|split_by_file
operator|)
condition|)
block|{
comment|/* create a new section and put this link order and the 		 following link orders into it */
name|struct
name|bfd_link_order
modifier|*
name|l
init|=
name|p
decl_stmt|;
name|asection
modifier|*
name|n
init|=
name|clone_section
argument_list|(
name|abfd
argument_list|,
name|cursor
argument_list|,
operator|&
name|count
argument_list|)
decl_stmt|;
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
comment|/* Snip off link orders from old section */
name|n
operator|->
name|link_order_head
operator|=
name|l
expr_stmt|;
comment|/* attach to new section */
name|pp
operator|=
operator|&
name|n
operator|->
name|link_order_head
expr_stmt|;
comment|/* change the size of the original section and 		 update the vma of the new one */
name|dump
argument_list|(
literal|"before snip"
argument_list|,
name|cursor
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|_raw_size
operator|=
name|cursor
operator|->
name|_raw_size
operator|-
name|l
operator|->
name|offset
expr_stmt|;
name|cursor
operator|->
name|_raw_size
operator|=
name|l
operator|->
name|offset
expr_stmt|;
name|vma
operator|+=
name|cursor
operator|->
name|_raw_size
expr_stmt|;
name|n
operator|->
name|lma
operator|=
name|n
operator|->
name|vma
operator|=
name|vma
expr_stmt|;
name|shift_offset
operator|=
name|l
operator|->
name|offset
expr_stmt|;
comment|/* run down the chain and change the output section to 		 the right one, update the offsets too */
while|while
condition|(
name|l
condition|)
block|{
name|l
operator|->
name|offset
operator|-=
name|shift_offset
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|type
operator|==
name|bfd_indirect_link_order
condition|)
block|{
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|=
name|n
expr_stmt|;
name|l
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_offset
operator|=
name|l
operator|->
name|offset
expr_stmt|;
block|}
name|l
operator|=
name|l
operator|->
name|next
expr_stmt|;
block|}
name|dump
argument_list|(
literal|"after snip"
argument_list|,
name|cursor
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|n
expr_stmt|;
name|relocs
operator|=
name|thisrelocs
expr_stmt|;
name|lines
operator|=
name|thislines
expr_stmt|;
block|}
else|else
block|{
name|relocs
operator|+=
name|thisrelocs
expr_stmt|;
name|lines
operator|+=
name|thislines
expr_stmt|;
block|}
name|first
operator|=
name|false
expr_stmt|;
block|}
block|}
name|sanity_check
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
name|void
name|ldwrite
parameter_list|()
block|{
comment|/* Reset error indicator, which can typically something like invalid      format from openning up the .o files */
name|bfd_set_error
argument_list|(
name|bfd_error_no_error
argument_list|)
expr_stmt|;
name|lang_for_each_statement
argument_list|(
name|build_link_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|split_by_reloc
operator|||
name|config
operator|.
name|split_by_file
condition|)
name|split_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_final_link
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
block|{
comment|/* If there was an error recorded, print it out.  Otherwise assume 	 an appropriate error message like unknown symbol was printed 	 out.  */
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_no_error
condition|)
name|einfo
argument_list|(
literal|"%F%P: final link failed: %E\n"
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
else|else
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

