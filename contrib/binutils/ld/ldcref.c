begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldcref.c -- output a cross reference table    Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.    Written by Ian Lance Taylor<ian@cygnus.com>  This file is part of GLD, the Gnu Linker.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file holds routines that manage the cross reference table.    The table is used to generate cross reference reports.  It is also    used to implement the NOCROSSREFS command in the linker script.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_comment
comment|/* We keep an instance of this structure for each reference to a    symbol from a given object.  */
end_comment

begin_struct
struct|struct
name|cref_ref
block|{
comment|/* The next reference.  */
name|struct
name|cref_ref
modifier|*
name|next
decl_stmt|;
comment|/* The object.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* True if the symbol is defined.  */
name|unsigned
name|int
name|def
range|:
literal|1
decl_stmt|;
comment|/* True if the symbol is common.  */
name|unsigned
name|int
name|common
range|:
literal|1
decl_stmt|;
comment|/* True if the symbol is undefined.  */
name|unsigned
name|int
name|undef
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We keep a hash table of symbols.  Each entry looks like this.  */
end_comment

begin_struct
struct|struct
name|cref_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* The demangled name.  */
name|char
modifier|*
name|demangled
decl_stmt|;
comment|/* References to and definitions of this symbol.  */
name|struct
name|cref_ref
modifier|*
name|refs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is what the hash table looks like.  */
end_comment

begin_struct
struct|struct
name|cref_hash_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|cref_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|cref_fill_array
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cref_sort_array
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_one_cref
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|cref_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|check_nocrossref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_refs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
expr|struct
name|lang_nocrossrefs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_reloc_refs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an entry in the cref hash table.  */
end_comment

begin_define
define|#
directive|define
name|cref_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct cref_hash_entry *)					\    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_comment
comment|/* Traverse the cref hash table.  */
end_comment

begin_define
define|#
directive|define
name|cref_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(bfd_hash_traverse							\    (&(table)->root,							\     (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* The cref hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cref_hash_table
name|cref_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the cref hash table has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|cref_initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of symbols seen so far.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|cref_symcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an entry in a cref hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|cref_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|cref_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cref_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|demangled
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|refs
operator|=
name|NULL
expr_stmt|;
comment|/* Keep a count of the number of entries created in the hash          table.  */
operator|++
name|cref_symcount
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to the cref hash table.  This is called for every    symbol that is seen during the link.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|add_cref
parameter_list|(
name|name
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|cref_ref
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|cref_initialized
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|cref_table
operator|.
name|root
argument_list|,
name|cref_hash_newfunc
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: bfd_hash_table_init of cref table failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
name|cref_initialized
operator|=
name|true
expr_stmt|;
block|}
name|h
operator|=
name|cref_hash_lookup
argument_list|(
operator|&
name|cref_table
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: cref_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|h
operator|->
name|refs
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
name|r
operator|->
name|abfd
operator|==
name|abfd
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
operator|(
expr|struct
name|cref_ref
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|h
operator|->
name|refs
expr_stmt|;
name|h
operator|->
name|refs
operator|=
name|r
expr_stmt|;
name|r
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|r
operator|->
name|def
operator|=
name|false
expr_stmt|;
name|r
operator|->
name|common
operator|=
name|false
expr_stmt|;
name|r
operator|->
name|undef
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|r
operator|->
name|undef
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
name|r
operator|->
name|common
operator|=
name|true
expr_stmt|;
else|else
name|r
operator|->
name|def
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the addresses of the hash table entries into an array.  This    is called via cref_hash_traverse.  We also fill in the demangled    name.  */
end_comment

begin_function
specifier|static
name|boolean
name|cref_fill_array
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|cref_hash_entry
modifier|*
modifier|*
modifier|*
name|pph
init|=
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|ASSERT
argument_list|(
name|h
operator|->
name|demangled
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|demangled
operator|=
name|demangle
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
operator|*
operator|*
name|pph
operator|=
name|h
expr_stmt|;
operator|++
operator|*
name|pph
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Sort an array of cref hash table entries by name.  */
end_comment

begin_function
specifier|static
name|int
name|cref_sort_array
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
specifier|const
name|PTR
name|a1
decl_stmt|;
specifier|const
name|PTR
name|a2
decl_stmt|;
block|{
specifier|const
name|struct
name|cref_hash_entry
modifier|*
modifier|*
name|p1
init|=
operator|(
specifier|const
expr|struct
name|cref_hash_entry
operator|*
operator|*
operator|)
name|a1
decl_stmt|;
specifier|const
name|struct
name|cref_hash_entry
modifier|*
modifier|*
name|p2
init|=
operator|(
specifier|const
expr|struct
name|cref_hash_entry
operator|*
operator|*
operator|)
name|a2
decl_stmt|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|p1
operator|)
operator|->
name|demangled
argument_list|,
operator|(
operator|*
name|p2
operator|)
operator|->
name|demangled
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the cref table.  */
end_comment

begin_define
define|#
directive|define
name|FILECOL
value|(50)
end_define

begin_function
name|void
name|output_cref
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|cref_hash_entry
modifier|*
modifier|*
name|csyms
decl_stmt|,
modifier|*
modifier|*
name|csym_fill
decl_stmt|,
modifier|*
modifier|*
name|csym
decl_stmt|,
modifier|*
modifier|*
name|csym_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"\nCross Reference Table\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|_
argument_list|(
literal|"Symbol"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|FILECOL
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"File\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cref_initialized
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"No symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|csyms
operator|=
operator|(
operator|(
expr|struct
name|cref_hash_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cref_symcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|csyms
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|csym_fill
operator|=
name|csyms
expr_stmt|;
name|cref_hash_traverse
argument_list|(
operator|&
name|cref_table
argument_list|,
name|cref_fill_array
argument_list|,
operator|&
name|csym_fill
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|csym_fill
operator|-
name|csyms
argument_list|)
operator|==
name|cref_symcount
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|csyms
argument_list|,
name|cref_symcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|csyms
argument_list|)
argument_list|,
name|cref_sort_array
argument_list|)
expr_stmt|;
name|csym_end
operator|=
name|csyms
operator|+
name|cref_symcount
expr_stmt|;
for|for
control|(
name|csym
operator|=
name|csyms
init|;
name|csym
operator|<
name|csym_end
condition|;
name|csym
operator|++
control|)
name|output_one_cref
argument_list|(
name|fp
argument_list|,
operator|*
name|csym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output one entry in the cross reference table.  */
end_comment

begin_function
specifier|static
name|void
name|output_one_cref
parameter_list|(
name|fp
parameter_list|,
name|h
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|hl
decl_stmt|;
name|struct
name|cref_ref
modifier|*
name|r
decl_stmt|;
name|hl
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P: symbol `%T' missing from main hash table\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If this symbol is defined in a dynamic object but never 	 referenced by a normal object, then don't print it.  */
if|if
condition|(
name|hl
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
block|{
if|if
condition|(
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
operator|(
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|r
operator|=
name|h
operator|->
name|refs
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|r
operator|->
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|h
operator|->
name|demangled
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|demangled
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
name|h
operator|->
name|refs
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|def
condition|)
block|{
while|while
condition|(
name|len
operator|<
name|FILECOL
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B\n"
argument_list|,
name|r
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|r
operator|=
name|h
operator|->
name|refs
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|r
operator|->
name|def
condition|)
block|{
while|while
condition|(
name|len
operator|<
name|FILECOL
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B\n"
argument_list|,
name|r
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for prohibited cross references.  */
end_comment

begin_function
name|void
name|check_nocrossrefs
parameter_list|()
block|{
if|if
condition|(
operator|!
name|cref_initialized
condition|)
return|return;
name|cref_hash_traverse
argument_list|(
operator|&
name|cref_table
argument_list|,
name|check_nocrossref
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check one symbol to see if it is a prohibited cross reference.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|boolean
name|check_nocrossref
parameter_list|(
name|h
parameter_list|,
name|ignore
parameter_list|)
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|hl
decl_stmt|;
name|asection
modifier|*
name|defsec
decl_stmt|;
specifier|const
name|char
modifier|*
name|defsecname
decl_stmt|;
name|struct
name|lang_nocrossrefs
modifier|*
name|ncrs
decl_stmt|;
name|struct
name|lang_nocrossref
modifier|*
name|ncr
decl_stmt|;
name|hl
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: symbol `%T' missing from main hash table\n"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|hl
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|hl
operator|->
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
return|return
name|true
return|;
name|defsec
operator|=
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|defsec
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|defsecname
operator|=
name|bfd_get_section_name
argument_list|(
name|defsec
operator|->
name|owner
argument_list|,
name|defsec
argument_list|)
expr_stmt|;
for|for
control|(
name|ncrs
operator|=
name|nocrossref_list
init|;
name|ncrs
operator|!=
name|NULL
condition|;
name|ncrs
operator|=
name|ncrs
operator|->
name|next
control|)
for|for
control|(
name|ncr
operator|=
name|ncrs
operator|->
name|list
init|;
name|ncr
operator|!=
name|NULL
condition|;
name|ncr
operator|=
name|ncr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ncr
operator|->
name|name
argument_list|,
name|defsecname
argument_list|)
operator|==
literal|0
condition|)
name|check_refs
argument_list|(
name|h
argument_list|,
name|hl
argument_list|,
name|ncrs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* The struct is used to pass information from check_refs to    check_reloc_refs through bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|check_refs_info
block|{
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|defsec
decl_stmt|;
name|struct
name|lang_nocrossrefs
modifier|*
name|ncrs
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|boolean
name|same
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function is called for each symbol defined in a section which    prohibits cross references.  We need to look through all references    to this symbol, and ensure that the references are not from    prohibited sections.  */
end_comment

begin_function
specifier|static
name|void
name|check_refs
parameter_list|(
name|h
parameter_list|,
name|hl
parameter_list|,
name|ncrs
parameter_list|)
name|struct
name|cref_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|hl
decl_stmt|;
name|struct
name|lang_nocrossrefs
modifier|*
name|ncrs
decl_stmt|;
block|{
name|struct
name|cref_ref
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|ref
operator|=
name|h
operator|->
name|refs
init|;
name|ref
operator|!=
name|NULL
condition|;
name|ref
operator|=
name|ref
operator|->
name|next
control|)
block|{
name|lang_input_statement_type
modifier|*
name|li
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|struct
name|check_refs_info
name|info
decl_stmt|;
comment|/* We need to look through the relocations for this BFD, to see          if any of the relocations which refer to this symbol are from          a prohibited section.  Note that we need to do this even for          the BFD in which the symbol is defined, since even a single          BFD might contain a prohibited cross reference; for this          case, we set the SAME field in INFO, which will cause          CHECK_RELOCS_REFS to check for relocations against the          section as well as against the symbol.  */
name|li
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|ref
operator|->
name|abfd
operator|->
name|usrdata
expr_stmt|;
if|if
condition|(
name|li
operator|!=
name|NULL
operator|&&
name|li
operator|->
name|asymbols
operator|!=
name|NULL
condition|)
name|asymbols
operator|=
name|li
operator|->
name|asymbols
expr_stmt|;
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symbol_count
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|ref
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols; %E\n"
argument_list|)
argument_list|,
name|ref
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|asymbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symbol_count
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|ref
operator|->
name|abfd
argument_list|,
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|ref
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|!=
name|NULL
condition|)
block|{
name|li
operator|->
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|li
operator|->
name|symbol_count
operator|=
name|symbol_count
expr_stmt|;
block|}
block|}
name|info
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|info
operator|.
name|defsec
operator|=
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|info
operator|.
name|ncrs
operator|=
name|ncrs
expr_stmt|;
name|info
operator|.
name|asymbols
operator|=
name|asymbols
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|abfd
operator|==
name|hl
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
condition|)
name|info
operator|.
name|same
operator|=
name|true
expr_stmt|;
else|else
name|info
operator|.
name|same
operator|=
name|false
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|ref
operator|->
name|abfd
argument_list|,
name|check_reloc_refs
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|li
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|asymbols
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called via bfd_map_over_sections.  INFO->H is a symbol    defined in INFO->DEFSECNAME.  If this section maps into any of the    sections listed in INFO->NCRS, other than INFO->DEFSECNAME, then we    look through the relocations.  If any of the relocations are to    INFO->H, then we report a prohibited cross reference error.  */
end_comment

begin_function
specifier|static
name|void
name|check_reloc_refs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|iarg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|iarg
decl_stmt|;
block|{
name|struct
name|check_refs_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|check_refs_info
operator|*
operator|)
name|iarg
decl_stmt|;
name|asection
modifier|*
name|outsec
decl_stmt|;
specifier|const
name|char
modifier|*
name|outsecname
decl_stmt|;
name|asection
modifier|*
name|outdefsec
decl_stmt|;
specifier|const
name|char
modifier|*
name|outdefsecname
decl_stmt|;
name|struct
name|lang_nocrossref
modifier|*
name|ncr
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
name|outsec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|outsecname
operator|=
name|bfd_get_section_name
argument_list|(
name|outsec
operator|->
name|owner
argument_list|,
name|outsec
argument_list|)
expr_stmt|;
name|outdefsec
operator|=
name|info
operator|->
name|defsec
operator|->
name|output_section
expr_stmt|;
name|outdefsecname
operator|=
name|bfd_get_section_name
argument_list|(
name|outdefsec
operator|->
name|owner
argument_list|,
name|outdefsec
argument_list|)
expr_stmt|;
comment|/* The section where the symbol is defined is permitted.  */
if|if
condition|(
name|strcmp
argument_list|(
name|outsecname
argument_list|,
name|outdefsecname
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|ncr
operator|=
name|info
operator|->
name|ncrs
operator|->
name|list
init|;
name|ncr
operator|!=
name|NULL
condition|;
name|ncr
operator|=
name|ncr
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|outsecname
argument_list|,
name|ncr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ncr
operator|==
name|NULL
condition|)
return|return;
comment|/* This section is one for which cross references are prohibited.      Look through the relocations, and see if any of them are to      INFO->H.  */
name|symname
operator|=
name|info
operator|->
name|h
operator|->
name|root
operator|.
name|string
expr_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relpp
argument_list|,
name|info
operator|->
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|relpp
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|relcount
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
operator|&&
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|arelent
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
operator|*
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|symname
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|info
operator|->
name|same
operator|&&
name|bfd_get_section
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
operator|==
name|info
operator|->
name|defsec
operator|)
operator|)
condition|)
block|{
comment|/* We found a reloc for the symbol.  The symbol is defined              in OUTSECNAME.  This reloc is from a section which is              mapped into a section from which references to OUTSECNAME              are prohibited.  We must report an error.  */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: prohibited cross reference from %s to `%T' in %s\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|q
operator|->
name|address
argument_list|,
name|outsecname
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|outdefsecname
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

