begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldlang.h - linker command language support    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDLANG_H
end_ifndef

begin_define
define|#
directive|define
name|LDLANG_H
end_define

begin_define
define|#
directive|define
name|DEFAULT_MEMORY_REGION
value|"*default*"
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|lang_input_file_is_l_enum
block|,
name|lang_input_file_is_symbols_only_enum
block|,
name|lang_input_file_is_marker_enum
block|,
name|lang_input_file_is_fake_enum
block|,
name|lang_input_file_is_search_file_enum
block|,
name|lang_input_file_is_file_enum
block|}
name|lang_input_file_enum_type
typedef|;
end_typedef

begin_struct
struct|struct
name|_fill_type
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|statement_list
block|{
name|union
name|lang_statement_union
modifier|*
name|head
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
name|lang_statement_list_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|memory_region_struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|memory_region_struct
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|origin
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|bfd_vma
name|current
decl_stmt|;
name|bfd_size_type
name|old_length
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flagword
name|not_flags
decl_stmt|;
name|bfd_boolean
name|had_full_message
decl_stmt|;
block|}
name|lang_memory_region_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_statement_header_struct
block|{
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
enum|enum
name|statement_enum
block|{
name|lang_output_section_statement_enum
block|,
name|lang_assignment_statement_enum
block|,
name|lang_input_statement_enum
block|,
name|lang_address_statement_enum
block|,
name|lang_wild_statement_enum
block|,
name|lang_input_section_enum
block|,
name|lang_object_symbols_statement_enum
block|,
name|lang_fill_statement_enum
block|,
name|lang_data_statement_enum
block|,
name|lang_reloc_statement_enum
block|,
name|lang_target_statement_enum
block|,
name|lang_output_statement_enum
block|,
name|lang_padding_statement_enum
block|,
name|lang_group_statement_enum
block|,
name|lang_afile_asection_pair_statement_enum
block|,
name|lang_constructors_statement_enum
block|}
name|type
enum|;
block|}
name|lang_statement_header_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
block|}
name|lang_assignment_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_target_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|}
name|lang_target_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_output_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|lang_output_statement_type
typedef|;
end_typedef

begin_comment
comment|/* Section types specified in a linker script.  */
end_comment

begin_enum
enum|enum
name|section_type
block|{
name|normal_section
block|,
name|dsect_section
block|,
name|copy_section
block|,
name|noload_section
block|,
name|info_section
block|,
name|overlay_section
block|}
enum|;
end_enum

begin_comment
comment|/* This structure holds a list of program headers describing    segments in which this section should be placed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lang_output_section_phdr_list
block|{
name|struct
name|lang_output_section_phdr_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|used
decl_stmt|;
block|}
name|lang_output_section_phdr_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_output_section_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
name|struct
name|lang_output_section_statement_struct
modifier|*
name|next
decl_stmt|;
name|struct
name|lang_output_section_statement_struct
modifier|*
name|prev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|region
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|lma_region
decl_stmt|;
name|fill_type
modifier|*
name|fill
decl_stmt|;
name|union
name|etree_union
modifier|*
name|addr_tree
decl_stmt|;
name|union
name|etree_union
modifier|*
name|load_base
decl_stmt|;
comment|/* If non-null, an expression to evaluate after setting the section's      size.  The expression is evaluated inside REGION (above) with '.'      set to the end of the section.  Used in the last overlay section      to move '.' past all the overlaid sections.  */
name|union
name|etree_union
modifier|*
name|update_dot_tree
decl_stmt|;
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
name|unsigned
name|int
name|block_value
decl_stmt|;
name|int
name|subsection_alignment
decl_stmt|;
comment|/* Alignment of components.  */
name|int
name|section_alignment
decl_stmt|;
comment|/* Alignment of start of section.  */
name|int
name|constraint
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|enum
name|section_type
name|sectype
decl_stmt|;
name|unsigned
name|int
name|processed
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|all_input_readonly
range|:
literal|1
decl_stmt|;
comment|/* If this section should be ignored.  */
name|unsigned
name|int
name|ignored
range|:
literal|1
decl_stmt|;
comment|/* If there is a symbol relative to this section.  */
name|unsigned
name|int
name|section_relative_symbol
range|:
literal|1
decl_stmt|;
block|}
name|lang_output_section_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
block|}
name|lang_common_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
block|}
name|lang_object_symbols_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|fill_type
modifier|*
name|fill
decl_stmt|;
name|int
name|size
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
block|}
name|lang_fill_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_vma
name|output_offset
decl_stmt|;
block|}
name|lang_data_statement_type
typedef|;
end_typedef

begin_comment
comment|/* Generate a reloc in the output file.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
comment|/* Reloc to generate.  */
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
comment|/* Reloc howto structure.  */
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* Section to generate reloc against.      Exactly one of section and name must be NULL.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Name of symbol to generate reloc against.      Exactly one of section and name must be NULL.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Expression for addend.  */
name|union
name|etree_union
modifier|*
name|addend_exp
decl_stmt|;
comment|/* Resolved addend.  */
name|bfd_vma
name|addend_value
decl_stmt|;
comment|/* Output section where reloc should be performed.  */
name|asection
modifier|*
name|output_section
decl_stmt|;
comment|/* Offset within output section.  */
name|bfd_vma
name|output_offset
decl_stmt|;
block|}
name|lang_reloc_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_input_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
comment|/* Name of this file.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name to use for the symbol giving address of text start.      Usually the same as filename, but for a file spec'd with      -l this is the -l switch itself rather than the filename.  */
specifier|const
name|char
modifier|*
name|local_sym_name
decl_stmt|;
name|bfd
modifier|*
name|the_bfd
decl_stmt|;
name|file_ptr
name|passive_position
decl_stmt|;
comment|/* Symbol table of the file.  */
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
comment|/* Point to the next file - whatever it is, wanders up and down      archives */
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
comment|/* Point to the next file, but skips archive contents.  */
name|union
name|lang_statement_union
modifier|*
name|next_real_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|unsigned
name|int
name|closed
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|is_archive
range|:
literal|1
decl_stmt|;
comment|/* 1 means search a set of directories for this file.  */
name|unsigned
name|int
name|search_dirs_flag
range|:
literal|1
decl_stmt|;
comment|/* 1 means this was found in a search directory marked as sysrooted,      if search_dirs_flag is false, otherwise, that it should be      searched in ld_sysroot before any other location, as long as it      starts with a slash.  */
name|unsigned
name|int
name|sysrooted
range|:
literal|1
decl_stmt|;
comment|/* 1 means this is base file of incremental load.      Do not load this file's text or data.      Also default text_start to after this file's bss.  */
name|unsigned
name|int
name|just_syms_flag
range|:
literal|1
decl_stmt|;
comment|/* Whether to search for this entry as a dynamic archive.  */
name|unsigned
name|int
name|dynamic
range|:
literal|1
decl_stmt|;
comment|/* Whether DT_NEEDED tags should be added for dynamic libraries in      DT_NEEDED tags from this entry.  */
name|unsigned
name|int
name|add_needed
range|:
literal|1
decl_stmt|;
comment|/* Whether this entry should cause a DT_NEEDED tag only when      satisfying references from regular files, or always.  */
name|unsigned
name|int
name|as_needed
range|:
literal|1
decl_stmt|;
comment|/* Whether to include the entire contents of an archive.  */
name|unsigned
name|int
name|whole_archive
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|loaded
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|real
range|:
literal|1
decl_stmt|;
block|}
name|lang_input_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|}
name|lang_input_section_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
name|file
decl_stmt|;
block|}
name|lang_afile_asection_pair_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|lang_wild_statement_struct
name|lang_wild_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|callback_t
function_decl|)
parameter_list|(
name|lang_wild_statement_type
modifier|*
parameter_list|,
name|struct
name|wildcard_list
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|lang_input_statement_type
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|walk_wild_section_handler_t
function_decl|)
parameter_list|(
name|lang_wild_statement_type
modifier|*
parameter_list|,
name|lang_input_statement_type
modifier|*
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|bfd_boolean
function_decl|(
modifier|*
name|lang_match_sec_type_func
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
specifier|const
name|asection
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|lang_wild_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|bfd_boolean
name|filenames_sorted
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|section_list
decl_stmt|;
name|bfd_boolean
name|keep_sections
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
name|walk_wild_section_handler_t
name|walk_wild_section_handler
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|handler_data
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|lang_address_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|union
name|etree_union
modifier|*
name|address
decl_stmt|;
specifier|const
name|segment_type
modifier|*
name|segment
decl_stmt|;
block|}
name|lang_address_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|bfd_vma
name|output_offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|fill_type
modifier|*
name|fill
decl_stmt|;
block|}
name|lang_padding_statement_type
typedef|;
end_typedef

begin_comment
comment|/* A group statement collects a set of libraries together.  The    libraries are searched multiple times, until no new undefined    symbols are found.  The effect is to search a group of libraries as    though they were a single library.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
block|}
name|lang_group_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
name|lang_statement_union
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|lang_wild_statement_type
name|wild_statement
decl_stmt|;
name|lang_data_statement_type
name|data_statement
decl_stmt|;
name|lang_reloc_statement_type
name|reloc_statement
decl_stmt|;
name|lang_address_statement_type
name|address_statement
decl_stmt|;
name|lang_output_section_statement_type
name|output_section_statement
decl_stmt|;
name|lang_afile_asection_pair_statement_type
name|afile_asection_pair_statement
decl_stmt|;
name|lang_assignment_statement_type
name|assignment_statement
decl_stmt|;
name|lang_input_statement_type
name|input_statement
decl_stmt|;
name|lang_target_statement_type
name|target_statement
decl_stmt|;
name|lang_output_statement_type
name|output_statement
decl_stmt|;
name|lang_input_section_type
name|input_section
decl_stmt|;
name|lang_common_statement_type
name|common_statement
decl_stmt|;
name|lang_object_symbols_statement_type
name|object_symbols_statement
decl_stmt|;
name|lang_fill_statement_type
name|fill_statement
decl_stmt|;
name|lang_padding_statement_type
name|padding_statement
decl_stmt|;
name|lang_group_statement_type
name|group_statement
decl_stmt|;
block|}
name|lang_statement_union_type
typedef|;
end_typedef

begin_comment
comment|/* This structure holds information about a program header, from the    PHDRS command in the linker script.  */
end_comment

begin_struct
struct|struct
name|lang_phdr
block|{
name|struct
name|lang_phdr
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|bfd_boolean
name|filehdr
decl_stmt|;
name|bfd_boolean
name|phdrs
decl_stmt|;
name|etree_type
modifier|*
name|at
decl_stmt|;
name|etree_type
modifier|*
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold a list of sections which may not    cross reference each other.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|lang_nocrossref
block|{
name|struct
name|lang_nocrossref
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|lang_nocrossref_type
typedef|;
end_typedef

begin_comment
comment|/* The list of nocrossref lists.  */
end_comment

begin_struct
struct|struct
name|lang_nocrossrefs
block|{
name|struct
name|lang_nocrossrefs
modifier|*
name|next
decl_stmt|;
name|lang_nocrossref_type
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|lang_nocrossrefs
modifier|*
name|nocrossref_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to hold a list of input section names which    will not match an output section in the linker script.  */
end_comment

begin_struct
struct|struct
name|unique_sections
block|{
name|struct
name|unique_sections
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure records symbols for which we need to keep track of    definedness for use in the DEFINED () test.  */
end_comment

begin_struct
struct|struct
name|lang_definedness_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|int
name|iteration
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used by place_orphan to keep track of orphan sections and statements.  */
end_comment

begin_struct
struct|struct
name|orphan_save
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|asection
modifier|*
modifier|*
name|section
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|stmt
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
modifier|*
name|os_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|abs_output_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
name|lang_output_section_statement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|lang_has_input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|etree_type
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
modifier|*
name|stat_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|delete_output_file_on_failure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_sym_chain
name|entry_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|entry_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|entry_from_cmdline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
name|file_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lang_statement_iteration
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|lang_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_finish
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_memory_region_type
modifier|*
name|lang_memory_region_lookup
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_memory_region_type
modifier|*
name|lang_memory_region_default
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_map
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_set_flags
parameter_list|(
name|lang_memory_region_type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|from_script
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_enter_output_section_statement
parameter_list|(
specifier|const
name|char
modifier|*
name|output_section_statement_name
parameter_list|,
name|etree_type
modifier|*
name|address_exp
parameter_list|,
name|enum
name|section_type
name|sectype
parameter_list|,
name|etree_type
modifier|*
name|align
parameter_list|,
name|etree_type
modifier|*
name|subalign
parameter_list|,
name|etree_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_final
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_process
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_section_start
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|union
name|etree_union
modifier|*
parameter_list|,
specifier|const
name|segment_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_entry
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_default_entry
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_target
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_wild
parameter_list|(
name|struct
name|wildcard_spec
modifier|*
parameter_list|,
name|struct
name|wildcard_list
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_map
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_fill
parameter_list|(
name|fill_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_assignment_statement_type
modifier|*
name|lang_add_assignment
parameter_list|(
name|union
name|etree_union
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_attribute
parameter_list|(
name|enum
name|statement_enum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_startup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_float
parameter_list|(
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_leave_output_section_statement
parameter_list|(
name|fill_type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_abs_symbol_at_end_of
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_abs_symbol_at_beginning_of
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_statement_append
parameter_list|(
name|lang_statement_list_type
modifier|*
parameter_list|,
name|lang_statement_union_type
modifier|*
parameter_list|,
name|lang_statement_union_type
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_for_each_input_file
parameter_list|(
name|void
function_decl|(
modifier|*
name|dothis
function_decl|)
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_for_each_file
parameter_list|(
name|void
function_decl|(
modifier|*
name|dothis
function_decl|)
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_reset_memory_regions
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_do_assignments
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LANG_FOR_EACH_INPUT_STATEMENT
parameter_list|(
name|statement
parameter_list|)
define|\
value|lang_input_statement_type *statement;					\   for (statement = (lang_input_statement_type *) file_chain.head;	\        statement != (lang_input_statement_type *) NULL;			\        statement = (lang_input_statement_type *) statement->next)	\  extern void lang_process
end_define

begin_expr_stmt
operator|(
name|void
operator|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|void
name|ldlang_add_file
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find_by_flags
parameter_list|(
specifier|const
name|asection
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
modifier|*
parameter_list|,
name|lang_match_sec_type_func
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_insert_orphan
parameter_list|(
name|asection
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
parameter_list|,
name|struct
name|orphan_save
modifier|*
parameter_list|,
name|etree_type
modifier|*
parameter_list|,
name|lang_statement_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_input_statement_type
modifier|*
name|lang_add_input_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|lang_input_file_enum_type
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_keepsyms_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|ldlang_add_undef
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_output_format
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_list_init
parameter_list|(
name|lang_statement_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_data
parameter_list|(
name|int
name|type
parameter_list|,
name|union
name|etree_union
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_reloc
parameter_list|(
name|bfd_reloc_code_real_type
parameter_list|,
name|reloc_howto_type
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|union
name|etree_union
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_for_each_statement
parameter_list|(
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|stat_alloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|strip_excluded_output_sections
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dprint_statement
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_size_sections
parameter_list|(
name|bfd_boolean
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|one_lang_size_sections_pass
parameter_list|(
name|bfd_boolean
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_enter_group
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_leave_group
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_section
parameter_list|(
name|lang_statement_list_type
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_new_phdr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|etree_type
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|bfd_boolean
parameter_list|,
name|etree_type
modifier|*
parameter_list|,
name|etree_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_nocrossref
parameter_list|(
name|lang_nocrossref_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_enter_overlay
parameter_list|(
name|etree_type
modifier|*
parameter_list|,
name|etree_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_enter_overlay_section
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_leave_overlay_section
parameter_list|(
name|fill_type
modifier|*
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_leave_overlay
parameter_list|(
name|etree_type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|fill_type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_elf_version_info
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_new_vers_pattern
parameter_list|(
name|struct
name|bfd_elf_version_expr
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_new_vers_node
parameter_list|(
name|struct
name|bfd_elf_version_expr
modifier|*
parameter_list|,
name|struct
name|bfd_elf_version_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|bfd_elf_version_deps
modifier|*
name|lang_add_vers_depend
parameter_list|(
name|struct
name|bfd_elf_version_deps
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_register_vers_node
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|bfd_elf_version_tree
modifier|*
parameter_list|,
name|struct
name|bfd_elf_version_deps
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bfd_boolean
name|unique_section_p
parameter_list|(
specifier|const
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_add_unique
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
specifier|const
name|char
modifier|*
name|lang_get_output_target
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_track_definedness
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|lang_symbol_definition_iteration
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lang_update_definedness
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_excluded_libs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

end_unit

