begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldlang.h - linker command language support    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDLANG_H
end_ifndef

begin_define
define|#
directive|define
name|LDLANG_H
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|lang_input_file_is_l_enum
block|,
name|lang_input_file_is_symbols_only_enum
block|,
name|lang_input_file_is_marker_enum
block|,
name|lang_input_file_is_fake_enum
block|,
name|lang_input_file_is_search_file_enum
block|,
name|lang_input_file_is_file_enum
block|}
name|lang_input_file_enum_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|fill_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|statement_list
block|{
name|union
name|lang_statement_union
modifier|*
name|head
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
modifier|*
name|tail
decl_stmt|;
block|}
name|lang_statement_list_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|memory_region_struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|memory_region_struct
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|origin
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
name|bfd_vma
name|current
decl_stmt|;
name|bfd_size_type
name|old_length
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|flagword
name|not_flags
decl_stmt|;
name|boolean
name|had_full_message
decl_stmt|;
block|}
name|lang_memory_region_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_statement_header_struct
block|{
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
enum|enum
name|statement_enum
block|{
name|lang_output_section_statement_enum
block|,
name|lang_assignment_statement_enum
block|,
name|lang_input_statement_enum
block|,
name|lang_address_statement_enum
block|,
name|lang_wild_statement_enum
block|,
name|lang_input_section_enum
block|,
name|lang_object_symbols_statement_enum
block|,
name|lang_fill_statement_enum
block|,
name|lang_data_statement_enum
block|,
name|lang_reloc_statement_enum
block|,
name|lang_target_statement_enum
block|,
name|lang_output_statement_enum
block|,
name|lang_padding_statement_enum
block|,
name|lang_group_statement_enum
block|,
name|lang_afile_asection_pair_statement_enum
block|,
name|lang_constructors_statement_enum
block|}
name|type
enum|;
block|}
name|lang_statement_header_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
block|}
name|lang_assignment_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_target_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|}
name|lang_target_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_output_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|lang_output_statement_type
typedef|;
end_typedef

begin_comment
comment|/* Section types specified in a linker script.  */
end_comment

begin_enum
enum|enum
name|section_type
block|{
name|normal_section
block|,
name|dsect_section
block|,
name|copy_section
block|,
name|noload_section
block|,
name|info_section
block|,
name|overlay_section
block|}
enum|;
end_enum

begin_comment
comment|/* This structure holds a list of program headers describing segments    in which this section should be placed.  */
end_comment

begin_struct
struct|struct
name|lang_output_section_phdr_list
block|{
name|struct
name|lang_output_section_phdr_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|used
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|lang_output_section_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|union
name|etree_union
modifier|*
name|addr_tree
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
specifier|const
name|char
modifier|*
name|memspec
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|processed
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
comment|/* Or together of all input sections */
name|enum
name|section_type
name|sectype
decl_stmt|;
name|struct
name|memory_region_struct
modifier|*
name|region
decl_stmt|;
name|struct
name|memory_region_struct
modifier|*
name|lma_region
decl_stmt|;
name|size_t
name|block_value
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|int
name|subsection_alignment
decl_stmt|;
comment|/* alignment of components */
name|int
name|section_alignment
decl_stmt|;
comment|/* alignment of start of section */
name|union
name|etree_union
modifier|*
name|load_base
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
block|}
name|lang_output_section_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
block|}
name|lang_common_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
block|}
name|lang_object_symbols_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|int
name|size
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
block|}
name|lang_fill_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_vma
name|output_vma
decl_stmt|;
block|}
name|lang_data_statement_type
typedef|;
end_typedef

begin_comment
comment|/* Generate a reloc in the output file.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
comment|/* Reloc to generate.  */
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
comment|/* Reloc howto structure.  */
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* Section to generate reloc against.  Exactly one of section and      name must be NULL.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Name of symbol to generate reloc against.  Exactly one of section      and name must be NULL.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Expression for addend.  */
name|union
name|etree_union
modifier|*
name|addend_exp
decl_stmt|;
comment|/* Resolved addend.  */
name|bfd_vma
name|addend_value
decl_stmt|;
comment|/* Output section where reloc should be performed.  */
name|asection
modifier|*
name|output_section
decl_stmt|;
comment|/* VMA within output section.  */
name|bfd_vma
name|output_vma
decl_stmt|;
block|}
name|lang_reloc_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_input_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
comment|/* Name of this file.  */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name to use for the symbol giving address of text start */
comment|/* Usually the same as filename, but for a file spec'd with -l      this is the -l switch itself rather than the filename.  */
specifier|const
name|char
modifier|*
name|local_sym_name
decl_stmt|;
name|bfd
modifier|*
name|the_bfd
decl_stmt|;
name|boolean
name|closed
decl_stmt|;
name|file_ptr
name|passive_position
decl_stmt|;
comment|/* Symbol table of the file.  */
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|unsigned
name|int
name|symbol_count
decl_stmt|;
comment|/* Point to the next file - whatever it is, wanders up and down      archives */
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
comment|/* Point to the next file, but skips archive contents */
name|union
name|lang_statement_union
modifier|*
name|next_real_file
decl_stmt|;
name|boolean
name|is_archive
decl_stmt|;
comment|/* 1 means search a set of directories for this file.  */
name|boolean
name|search_dirs_flag
decl_stmt|;
comment|/* 1 means this is base file of incremental load.      Do not load this file's text or data.      Also default text_start to after this file's bss.  */
name|boolean
name|just_syms_flag
decl_stmt|;
comment|/* Whether to search for this entry as a dynamic archive.  */
name|boolean
name|dynamic
decl_stmt|;
comment|/* Whether to include the entire contents of an archive.  */
name|boolean
name|whole_archive
decl_stmt|;
name|boolean
name|loaded
decl_stmt|;
if|#
directive|if
literal|0
block|unsigned int globals_in_this_file;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|boolean
name|real
decl_stmt|;
block|}
name|lang_input_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|ifile
decl_stmt|;
block|}
name|lang_input_section_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
name|file
decl_stmt|;
block|}
name|lang_afile_asection_pair_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_wild_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|boolean
name|sections_sorted
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|boolean
name|filenames_sorted
decl_stmt|;
name|boolean
name|keep_sections
decl_stmt|;
name|struct
name|name_list
modifier|*
name|exclude_filename_list
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
block|}
name|lang_wild_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lang_address_statement_struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|union
name|etree_union
modifier|*
name|address
decl_stmt|;
block|}
name|lang_address_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|bfd_vma
name|output_offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
block|}
name|lang_padding_statement_type
typedef|;
end_typedef

begin_comment
comment|/* A group statement collects a set of libraries together.  The    libraries are searched multiple times, until no new undefined    symbols are found.  The effect is to search a group of libraries as    though they were a single library.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|lang_statement_list_type
name|children
decl_stmt|;
block|}
name|lang_group_statement_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
name|lang_statement_union
block|{
name|lang_statement_header_type
name|header
decl_stmt|;
name|union
name|lang_statement_union
modifier|*
name|next
decl_stmt|;
name|lang_wild_statement_type
name|wild_statement
decl_stmt|;
name|lang_data_statement_type
name|data_statement
decl_stmt|;
name|lang_reloc_statement_type
name|reloc_statement
decl_stmt|;
name|lang_address_statement_type
name|address_statement
decl_stmt|;
name|lang_output_section_statement_type
name|output_section_statement
decl_stmt|;
name|lang_afile_asection_pair_statement_type
name|afile_asection_pair_statement
decl_stmt|;
name|lang_assignment_statement_type
name|assignment_statement
decl_stmt|;
name|lang_input_statement_type
name|input_statement
decl_stmt|;
name|lang_target_statement_type
name|target_statement
decl_stmt|;
name|lang_output_statement_type
name|output_statement
decl_stmt|;
name|lang_input_section_type
name|input_section
decl_stmt|;
name|lang_common_statement_type
name|common_statement
decl_stmt|;
name|lang_object_symbols_statement_type
name|object_symbols_statement
decl_stmt|;
name|lang_fill_statement_type
name|fill_statement
decl_stmt|;
name|lang_padding_statement_type
name|padding_statement
decl_stmt|;
name|lang_group_statement_type
name|group_statement
decl_stmt|;
block|}
name|lang_statement_union_type
typedef|;
end_typedef

begin_comment
comment|/* This structure holds information about a program header, from the    PHDRS command in the linker script.  */
end_comment

begin_struct
struct|struct
name|lang_phdr
block|{
name|struct
name|lang_phdr
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|boolean
name|filehdr
decl_stmt|;
name|boolean
name|phdrs
decl_stmt|;
name|etree_type
modifier|*
name|at
decl_stmt|;
name|etree_type
modifier|*
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold a list of sections which may not    cross reference each other.  */
end_comment

begin_struct
struct|struct
name|lang_nocrossref
block|{
name|struct
name|lang_nocrossref
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The list of nocrossref lists.  */
end_comment

begin_struct
struct|struct
name|lang_nocrossrefs
block|{
name|struct
name|lang_nocrossrefs
modifier|*
name|next
decl_stmt|;
name|struct
name|lang_nocrossref
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|lang_nocrossrefs
modifier|*
name|nocrossref_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to hold a list of input section names which    will not match an output section in the linker script.  */
end_comment

begin_struct
struct|struct
name|unique_sections
block|{
name|struct
name|unique_sections
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|unique_sections
modifier|*
name|unique_section_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|abs_output_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
name|lang_output_section_statement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|lang_has_input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|etree_type
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
modifier|*
name|stat_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|delete_output_file_on_failure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|entry_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|entry_from_cmdline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_statement_list_type
name|file_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|memory_region_struct
modifier|*
name|lang_memory_region_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|memory_region_struct
modifier|*
name|lang_memory_region_default
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_map
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_set_flags
name|PARAMS
argument_list|(
operator|(
name|lang_memory_region_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_output
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
name|from_script
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_enter_output_section_statement
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|output_section_statement_name
operator|,
name|etree_type
operator|*
name|address_exp
operator|,
expr|enum
name|section_type
name|sectype
operator|,
name|bfd_vma
name|block_value
operator|,
name|etree_type
operator|*
name|align
operator|,
name|etree_type
operator|*
name|subalign
operator|,
name|etree_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_final
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_process
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_section_start
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|union
name|etree_union
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_target
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_wild
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_map
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_fill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_assignment_statement_type
modifier|*
name|lang_add_assignment
name|PARAMS
argument_list|(
operator|(
expr|union
name|etree_union
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_attribute
name|PARAMS
argument_list|(
operator|(
expr|enum
name|statement_enum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_startup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_float
name|PARAMS
argument_list|(
operator|(
expr|enum
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_leave_output_section_statement
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|lang_output_section_phdr_list
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_abs_symbol_at_end_of
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_abs_symbol_at_beginning_of
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_statement_append
name|PARAMS
argument_list|(
operator|(
expr|struct
name|statement_list
operator|*
operator|,
expr|union
name|lang_statement_union
operator|*
operator|,
expr|union
name|lang_statement_union
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_for_each_input_file
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
name|dothis
argument_list|)
argument_list|(
name|lang_input_statement_type
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_for_each_file
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
name|dothis
argument_list|)
argument_list|(
name|lang_input_statement_type
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|lang_do_assignments
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|s
operator|,
name|lang_output_section_statement_type
operator|*
name|output_section_statement
operator|,
name|fill_type
name|fill
operator|,
name|bfd_vma
name|dot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LANG_FOR_EACH_INPUT_STATEMENT
parameter_list|(
name|statement
parameter_list|)
define|\
value|lang_input_statement_type *statement;				\   for (statement = (lang_input_statement_type *)file_chain.head;\        statement != (lang_input_statement_type *)NULL;		\        statement = (lang_input_statement_type *)statement->next)\  extern void lang_process PARAMS ((void));
end_define

begin_decl_stmt
specifier|extern
name|void
name|ldlang_add_file
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_input_statement_type
modifier|*
name|lang_add_input_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|lang_input_file_enum_type
name|file_type
operator|,
specifier|const
name|char
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_keepsyms_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
specifier|const
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldlang_add_undef
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
specifier|const
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_output_format
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
name|from_script
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_list_init
name|PARAMS
argument_list|(
operator|(
name|lang_statement_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_data
name|PARAMS
argument_list|(
operator|(
name|int
name|type
operator|,
expr|union
name|etree_union
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd_reloc_code_real_type
name|reloc
operator|,
name|reloc_howto_type
operator|*
name|howto
operator|,
name|asection
operator|*
name|section
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
expr|union
name|etree_union
operator|*
name|addend
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_for_each_statement
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|lang_statement_union_type
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR
name|stat_alloc
name|PARAMS
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dprint_statement
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_vma
name|lang_size_sections
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|s
operator|,
name|lang_output_section_statement_type
operator|*
name|output_section_statement
operator|,
name|lang_statement_union_type
operator|*
operator|*
name|prev
operator|,
name|fill_type
name|fill
operator|,
name|bfd_vma
name|dot
operator|,
name|boolean
name|relax
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_enter_group
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_leave_group
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|wild_doit
name|PARAMS
argument_list|(
operator|(
name|lang_statement_list_type
operator|*
name|ptr
operator|,
name|asection
operator|*
name|section
operator|,
name|lang_output_section_statement_type
operator|*
name|output
operator|,
name|lang_input_statement_type
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_new_phdr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|etree_type
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
name|etree_type
operator|*
operator|,
name|etree_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_nocrossref
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_nocrossref
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_enter_overlay
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
operator|,
name|etree_type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_enter_overlay_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_leave_overlay_section
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|lang_output_section_phdr_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_leave_overlay
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|lang_output_section_phdr_list
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_elf_version_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_new_vers_regex
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_new_vers_node
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|,
expr|struct
name|bfd_elf_version_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|bfd_elf_version_deps
modifier|*
name|lang_add_vers_depend
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_deps
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_register_vers_node
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|bfd_elf_version_tree
operator|*
operator|,
expr|struct
name|bfd_elf_version_deps
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|unique_section_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|lang_add_unique
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

