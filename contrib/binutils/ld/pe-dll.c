begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines to help build PEI-format DLLs (Win32 etc)    Copyright 1998, 1999, 2000 Free Software Foundation, Inc.    Written by DJ Delorie<dj@cygnus.com>     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"../bfd/libcoff.h"
end_include

begin_include
include|#
directive|include
file|"deffile.h"
end_include

begin_include
include|#
directive|include
file|"pe-dll.h"
end_include

begin_comment
comment|/************************************************************************   This file turns a regular Windows PE image into a DLL.  Because of  the complexity of this operation, it has been broken down into a  number of separate modules which are all called by the main function  at the end of this file.  This function is not re-entrant and is  normally only called once, so static variables are used to reduce  the number of parameters and return values required.   See also: ld/emultempl/pe.em   ************************************************************************/
end_comment

begin_comment
comment|/* for emultempl/pe.em */
end_comment

begin_decl_stmt
name|def_file
modifier|*
name|pe_def_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_export_everything
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_do_default_excludes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_kill_ats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_stdcall_aliases
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_warn_dup_exports
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_compat_implib
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************   static variables and types   ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|image_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|filler_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
name|edata_s
decl_stmt|,
modifier|*
name|reloc_s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|edata_d
decl_stmt|,
modifier|*
name|reloc_d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|edata_sz
decl_stmt|,
name|reloc_sz
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|target_name
decl_stmt|;
name|char
modifier|*
name|object_target
decl_stmt|;
name|unsigned
name|int
name|imagebase_reloc
decl_stmt|;
name|int
name|pe_arch
decl_stmt|;
name|int
name|bfd_arch
decl_stmt|;
name|int
name|underscored
decl_stmt|;
block|}
name|pe_details_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PE_ARCH_i386
value|1
end_define

begin_define
define|#
directive|define
name|PE_ARCH_sh
value|2
end_define

begin_define
define|#
directive|define
name|PE_ARCH_mips
value|3
end_define

begin_define
define|#
directive|define
name|PE_ARCH_arm
value|4
end_define

begin_decl_stmt
specifier|static
name|pe_details_type
name|pe_detail_list
index|[]
init|=
block|{
block|{
literal|"pei-i386"
block|,
literal|"pe-i386"
block|,
literal|7
comment|/* R_IMAGEBASE */
block|,
name|PE_ARCH_i386
block|,
name|bfd_arch_i386
block|,
literal|1
block|}
block|,
block|{
literal|"pei-shl"
block|,
literal|"pe-shl"
block|,
literal|16
comment|/* R_SH_IMAGEBASE */
block|,
name|PE_ARCH_sh
block|,
name|bfd_arch_sh
block|,
literal|1
block|}
block|,
block|{
literal|"pei-mips"
block|,
literal|"pe-mips"
block|,
literal|34
comment|/* MIPS_R_RVA */
block|,
name|PE_ARCH_mips
block|,
name|bfd_arch_mips
block|,
literal|0
block|}
block|,
block|{
literal|"pei-arm-little"
block|,
literal|"pe-arm-little"
block|,
literal|11
comment|/* ARM_RVA32 */
block|,
name|PE_ARCH_arm
block|,
name|bfd_arch_arm
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pe_details_type
modifier|*
name|pe_details
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|U
parameter_list|(
name|str
parameter_list|)
value|(pe_details->underscored ? "_" str : str)
end_define

begin_function
name|void
name|pe_dll_id_target
parameter_list|(
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|target_name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|target_name
argument_list|,
name|target
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|object_target
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pe_details
operator|=
name|pe_detail_list
operator|+
name|i
expr_stmt|;
return|return;
block|}
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XUnsupported PEI architecture: %s\n"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************   Helper functions for qsort.  Relocs must be sorted so that we can write  them out by pages.   ************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|char
name|type
decl_stmt|;
name|short
name|extra
decl_stmt|;
block|}
name|reloc_data_type
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|reloc_sort
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
specifier|const
name|void
modifier|*
name|va
decl_stmt|,
decl|*
name|vb
decl_stmt|;
end_function

begin_block
block|{
name|bfd_vma
name|a
init|=
operator|(
operator|(
name|reloc_data_type
operator|*
operator|)
name|va
operator|)
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|b
init|=
operator|(
operator|(
name|reloc_data_type
operator|*
operator|)
name|vb
operator|)
operator|->
name|vma
decl_stmt|;
return|return
operator|(
name|a
operator|>
name|b
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|pe_export_sort
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
specifier|const
name|void
modifier|*
name|va
decl_stmt|,
decl|*
name|vb
decl_stmt|;
end_function

begin_block
block|{
name|def_file_export
modifier|*
name|a
init|=
operator|(
name|def_file_export
operator|*
operator|)
name|va
decl_stmt|;
name|def_file_export
modifier|*
name|b
init|=
operator|(
name|def_file_export
operator|*
operator|)
name|vb
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************   Read and process the .DEF file   ************************************************************************/
end_comment

begin_comment
comment|/* These correspond to the entries in pe_def_file->exports[].  I use    exported_symbol_sections[i] to tag whether or not the symbol was    defined, since we can't export symbols we don't have.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
modifier|*
name|exported_symbol_offsets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sec
modifier|*
modifier|*
name|exported_symbol_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|export_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_exported
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_exported_byname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_with_ordinals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dll_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_ordinal
decl_stmt|,
name|max_ordinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|exported_symbols
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|exclude_list_struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|exclude_list_struct
modifier|*
name|next
decl_stmt|;
block|}
name|exclude_list_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|exclude_list_struct
modifier|*
name|excludes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pe_dll_add_excludes
parameter_list|(
name|new_excludes
parameter_list|)
specifier|const
name|char
modifier|*
name|new_excludes
decl_stmt|;
block|{
name|char
modifier|*
name|local_copy
decl_stmt|;
name|char
modifier|*
name|exclude_string
decl_stmt|;
name|local_copy
operator|=
name|xstrdup
argument_list|(
name|new_excludes
argument_list|)
expr_stmt|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|local_copy
argument_list|,
literal|",:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|exclude_string
condition|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|",:"
argument_list|)
control|)
block|{
name|struct
name|exclude_list_struct
modifier|*
name|new_exclude
decl_stmt|;
name|new_exclude
operator|=
operator|(
operator|(
expr|struct
name|exclude_list_struct
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|exclude_list_struct
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|new_exclude
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|exclude_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_exclude
operator|->
name|string
argument_list|,
name|exclude_string
argument_list|)
expr_stmt|;
name|new_exclude
operator|->
name|next
operator|=
name|excludes
expr_stmt|;
name|excludes
operator|=
name|new_exclude
expr_stmt|;
block|}
name|free
argument_list|(
name|local_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|auto_export
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|)
name|def_file
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|exclude_list_struct
modifier|*
name|ex
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|d
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pe_dll_do_default_excludes
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"DllMain@12"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"DllEntryPoint@0"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
literal|"impure_ptr"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|ex
operator|=
name|excludes
init|;
name|ex
condition|;
name|ex
operator|=
name|ex
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
name|ex
operator|->
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_def_file
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
name|bfd
modifier|*
name|b
decl_stmt|;
name|struct
name|sec
modifier|*
name|s
decl_stmt|;
name|def_file_export
modifier|*
name|e
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
condition|)
name|pe_def_file
operator|=
name|def_file_empty
argument_list|()
expr_stmt|;
comment|/* First, run around to all the objects looking for the .drectve      sections, and push those into the def file too.  */
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|b
argument_list|,
literal|".drectve"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|int
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|def_file_add_directive
argument_list|(
name|pe_def_file
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, maybe export everything else the default way.  */
if|if
condition|(
name|pe_dll_export_everything
operator|||
name|pe_def_file
operator|->
name|num_exports
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|int
name|nsyms
decl_stmt|,
name|symsize
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|b
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|++
control|)
block|{
comment|/* We should export symbols which are either global or not 	         anything at all.  (.bss data is the latter)  */
if|if
condition|(
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|||
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|==
name|BSF_NO_FLAGS
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sn
init|=
name|symbols
index|[
name|j
index|]
operator|->
name|name
decl_stmt|;
if|if
condition|(
operator|*
name|sn
operator|==
literal|'_'
condition|)
name|sn
operator|++
expr_stmt|;
if|if
condition|(
name|auto_export
argument_list|(
name|pe_def_file
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|def_file_export
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|def_file_add_export
argument_list|(
name|pe_def_file
argument_list|,
name|sn
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fill data flag properly, from dlltool.c */
name|p
operator|->
name|flag_data
operator|=
operator|!
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
undef|#
directive|undef
name|NE
define|#
directive|define
name|NE
value|pe_def_file->num_exports
comment|/* Canonicalize the export list.  */
if|if
condition|(
name|pe_dll_kill_ats
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* This will preserve internal_name, which may have been 	         pointing to the same memory as name, or might not 	         have.  */
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pe_dll_stdcall_aliases
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|auto_export
argument_list|(
name|pe_def_file
argument_list|,
name|tmp
argument_list|)
condition|)
name|def_file_add_export
argument_list|(
name|pe_def_file
argument_list|,
name|tmp
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Convenience, but watch out for it changing.  */
name|e
operator|=
name|pe_def_file
operator|->
name|exports
expr_stmt|;
name|exported_symbol_offsets
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|xmalloc
argument_list|(
name|NE
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
name|exported_symbol_sections
operator|=
operator|(
expr|struct
name|sec
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|NE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sec
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|exported_symbol_sections
argument_list|,
literal|0
argument_list|,
name|NE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sec
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|max_ordinal
operator|=
literal|0
expr_stmt|;
name|min_ordinal
operator|=
literal|65536
expr_stmt|;
name|count_exported
operator|=
literal|0
expr_stmt|;
name|count_exported_byname
operator|=
literal|0
expr_stmt|;
name|count_with_ordinals
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|pe_def_file
operator|->
name|exports
argument_list|,
name|NE
argument_list|,
sizeof|sizeof
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pe_export_sort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|e
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|e
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a duplicate.  */
if|if
condition|(
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|e
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|!=
name|e
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
block|{
if|if
condition|(
name|pe_dll_warn_dup_exports
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError, duplicate EXPORT with ordinals: %s (%d vs %d)\n"
argument_list|)
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|name
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
argument_list|,
name|e
index|[
name|i
index|]
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pe_dll_warn_dup_exports
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"Warning, duplicate EXPORT: %s\n"
argument_list|)
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|=
name|e
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_private
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_private
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_constant
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_constant
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_noname
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_noname
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_data
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_data
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|e
index|[
name|j
index|]
operator|=
name|e
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|pe_def_file
operator|->
name|num_exports
operator|=
name|j
expr_stmt|;
comment|/* == NE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe_details
operator|->
name|underscored
condition|)
block|{
operator|*
name|name
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
operator|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|)
condition|)
block|{
name|count_exported
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|flag_noname
condition|)
name|count_exported_byname
operator|++
expr_stmt|;
comment|/* Only fill in the sections. The actual offsets are computed 	     in fill_exported_offsets() after common symbols are laid 	     out.  */
if|if
condition|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|exported_symbol_sections
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|exported_symbol_sections
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|max_ordinal
operator|<
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
name|max_ordinal
operator|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
if|if
condition|(
name|min_ordinal
operator|>
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
name|min_ordinal
operator|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|count_with_ordinals
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol not defined\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blhe
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol wrong type (%d vs %d)\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|,
name|blhe
operator|->
name|type
argument_list|,
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol not found\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************   Build the bfd that will contain .edata and .reloc sections   ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|build_filler_bfd
parameter_list|(
name|include_edata
parameter_list|)
name|int
name|include_edata
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|filler_file
decl_stmt|;
name|filler_file
operator|=
name|lang_add_input_file
argument_list|(
literal|"dll stuff"
argument_list|,
name|lang_input_file_is_fake_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filler_file
operator|->
name|the_bfd
operator|=
name|filler_bfd
operator|=
name|bfd_create
argument_list|(
literal|"dll stuff"
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|filler_bfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_arch_mach
argument_list|(
name|filler_bfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create BFD %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|include_edata
condition|)
block|{
name|edata_s
operator|=
name|bfd_make_section_old_way
argument_list|(
name|filler_bfd
argument_list|,
literal|".edata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata_s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|filler_bfd
argument_list|,
name|edata_s
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
operator||
name|SEC_IN_MEMORY
operator|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create .edata section: %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|edata_s
argument_list|,
name|edata_sz
argument_list|)
expr_stmt|;
block|}
name|reloc_s
operator|=
name|bfd_make_section_old_way
argument_list|(
name|filler_bfd
argument_list|,
literal|".reloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
operator||
name|SEC_IN_MEMORY
operator|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create .reloc section: %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ldlang_add_file
argument_list|(
name|filler_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************   Gather all the exported symbols and build the .edata section   ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|generate_edata
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|next_ordinal
decl_stmt|;
name|int
name|name_table_size
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlnp
decl_stmt|;
comment|/* First, we need to know how many exported symbols there are,      and what the range of ordinals is.  */
if|if
condition|(
name|pe_def_file
operator|->
name|name
condition|)
block|{
name|dll_name
operator|=
name|pe_def_file
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|dll_name
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
for|for
control|(
name|dlnp
operator|=
name|dll_name
init|;
operator|*
name|dlnp
condition|;
name|dlnp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dlnp
operator|==
literal|'\\'
operator|||
operator|*
name|dlnp
operator|==
literal|'/'
operator|||
operator|*
name|dlnp
operator|==
literal|':'
condition|)
name|dll_name
operator|=
name|dlnp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count_with_ordinals
operator|&&
name|max_ordinal
operator|>
name|count_exported
condition|)
block|{
if|if
condition|(
name|min_ordinal
operator|>
name|max_ordinal
operator|-
name|count_exported
operator|+
literal|1
condition|)
name|min_ordinal
operator|=
name|max_ordinal
operator|-
name|count_exported
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min_ordinal
operator|=
literal|1
expr_stmt|;
name|max_ordinal
operator|=
name|count_exported
expr_stmt|;
block|}
name|export_table_size
operator|=
name|max_ordinal
operator|-
name|min_ordinal
operator|+
literal|1
expr_stmt|;
name|exported_symbols
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|export_table_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|export_table_size
condition|;
name|i
operator|++
control|)
name|exported_symbols
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now we need to assign ordinals to those that don't have them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|exported_symbol_sections
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ei
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|-
name|min_ordinal
decl_stmt|;
name|int
name|pi
init|=
name|exported_symbols
index|[
name|ei
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError, ordinal used twice: %d (%s vs %s)\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|pi
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|exported_symbols
index|[
name|ei
index|]
operator|=
name|i
expr_stmt|;
block|}
name|name_table_size
operator|+=
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|next_ordinal
operator|=
name|min_ordinal
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|exported_symbol_sections
index|[
name|i
index|]
condition|)
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|exported_symbols
index|[
name|next_ordinal
operator|-
name|min_ordinal
index|]
operator|!=
operator|-
literal|1
condition|)
name|next_ordinal
operator|++
expr_stmt|;
name|exported_symbols
index|[
name|next_ordinal
operator|-
name|min_ordinal
index|]
operator|=
name|i
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|=
name|next_ordinal
expr_stmt|;
block|}
comment|/* OK, now we can allocate some memory.  */
name|edata_sz
operator|=
operator|(
literal|40
comment|/* directory */
operator|+
literal|4
operator|*
name|export_table_size
comment|/* addresses */
operator|+
literal|4
operator|*
name|count_exported_byname
comment|/* name ptrs */
operator|+
literal|2
operator|*
name|count_exported_byname
comment|/* ordinals */
operator|+
name|name_table_size
operator|+
name|strlen
argument_list|(
name|dll_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill the exported symbol offsets. The preliminary work has already    been done in process_def_file().  */
end_comment

begin_function
specifier|static
name|void
name|fill_exported_offsets
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|pe_details
operator|->
name|underscored
condition|)
block|{
operator|*
name|name
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
operator|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|)
condition|)
block|{
name|exported_symbol_offsets
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_edata
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|hint
decl_stmt|;
name|unsigned
name|char
modifier|*
name|edirectory
decl_stmt|;
name|unsigned
name|long
modifier|*
name|eaddresses
decl_stmt|;
name|unsigned
name|long
modifier|*
name|enameptrs
decl_stmt|;
name|unsigned
name|short
modifier|*
name|eordinals
decl_stmt|;
name|unsigned
name|char
modifier|*
name|enamestr
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|edata_d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|edata_sz
argument_list|)
expr_stmt|;
comment|/* Note use of array pointer math here.  */
name|edirectory
operator|=
name|edata_d
expr_stmt|;
name|eaddresses
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|edata_d
operator|+
literal|40
operator|)
expr_stmt|;
name|enameptrs
operator|=
name|eaddresses
operator|+
name|export_table_size
expr_stmt|;
name|eordinals
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|enameptrs
operator|+
name|count_exported_byname
operator|)
expr_stmt|;
name|enamestr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|eordinals
operator|+
name|count_exported_byname
operator|)
expr_stmt|;
define|#
directive|define
name|ERVA
parameter_list|(
name|ptr
parameter_list|)
value|(((unsigned char *)(ptr) - edata_d) + edata_s->output_section->vma - image_base)
name|memset
argument_list|(
name|edata_d
argument_list|,
literal|0
argument_list|,
name|edata_sz
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|now
argument_list|,
name|edata_d
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|version_major
operator|!=
operator|-
literal|1
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|,
name|edata_d
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|pe_def_file
operator|->
name|version_minor
argument_list|,
name|edata_d
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enamestr
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|12
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|enamestr
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|enamestr
operator|+=
name|strlen
argument_list|(
name|enamestr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|min_ordinal
argument_list|,
name|edata_d
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|export_table_size
argument_list|,
name|edata_d
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|count_exported_byname
argument_list|,
name|edata_d
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|eaddresses
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|28
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enameptrs
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|32
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|eordinals
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|36
argument_list|)
expr_stmt|;
name|fill_exported_offsets
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Ok, now for the filling in part.  */
name|hint
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|export_table_size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|s
init|=
name|exported_symbols
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|sec
modifier|*
name|ssec
init|=
name|exported_symbol_sections
index|[
name|s
index|]
decl_stmt|;
name|unsigned
name|long
name|srva
init|=
operator|(
name|exported_symbol_offsets
index|[
name|s
index|]
operator|+
name|ssec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ssec
operator|->
name|output_offset
operator|)
decl_stmt|;
name|int
name|ord
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|ordinal
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|srva
operator|-
name|image_base
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|eaddresses
operator|+
name|ord
operator|-
name|min_ordinal
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|flag_noname
condition|)
block|{
name|char
modifier|*
name|ename
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|name
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enamestr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|enameptrs
argument_list|)
expr_stmt|;
name|enameptrs
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|enamestr
argument_list|,
name|ename
argument_list|)
expr_stmt|;
name|enamestr
operator|+=
name|strlen
argument_list|(
name|enamestr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|ord
operator|-
name|min_ordinal
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eordinals
argument_list|)
expr_stmt|;
name|eordinals
operator|++
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|hint
operator|=
name|hint
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/************************************************************************   Gather all the relocations and build the .reloc section   ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|generate_reloc
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* For .reloc stuff.  */
name|reloc_data_type
modifier|*
name|reloc_data
decl_stmt|;
name|int
name|total_relocs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|sec_page
init|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|page_ptr
decl_stmt|,
name|page_count
decl_stmt|;
name|int
name|bi
decl_stmt|;
name|bfd
modifier|*
name|b
decl_stmt|;
name|struct
name|sec
modifier|*
name|s
decl_stmt|;
name|total_relocs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
for|for
control|(
name|s
operator|=
name|b
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|total_relocs
operator|+=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|reloc_data
operator|=
operator|(
name|reloc_data_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|total_relocs
operator|*
sizeof|sizeof
argument_list|(
name|reloc_data_type
argument_list|)
argument_list|)
expr_stmt|;
name|total_relocs
operator|=
literal|0
expr_stmt|;
name|bi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
operator|,
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|bi
operator|++
operator|,
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|int
name|relsize
decl_stmt|,
name|nrelocs
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|long
name|sec_vma
init|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|int
name|nsyms
decl_stmt|,
name|symsize
decl_stmt|;
comment|/* If it's not loaded, we don't need to relocate it this way.  */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
continue|continue;
comment|/* I don't know why there would be a reloc for these, but I've 	     seen it happen - DJ  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
operator|&
name|bfd_abs_section
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|==
literal|0
condition|)
block|{
comment|/* Huh?  Shouldn't happen, but punt if it does.  */
name|einfo
argument_list|(
literal|"DJ: zero vma section reloc detected: `%s' #%d f=%d\n"
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|name
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|index
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|symbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|b
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|relsize
argument_list|)
expr_stmt|;
name|nrelocs
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|type
operator|!=
name|pe_details
operator|->
name|imagebase_reloc
condition|)
block|{
name|bfd_vma
name|sym_vma
decl_stmt|;
name|struct
name|symbol_cache_entry
modifier|*
name|sym
init|=
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|sym_vma
operator|=
operator|(
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|+
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
operator|+
name|sym
operator|->
name|section
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|vma
operator|=
name|sec_vma
operator|+
name|relocs
index|[
name|i
index|]
operator|->
name|address
expr_stmt|;
define|#
directive|define
name|BITS_AND_SHIFT
parameter_list|(
name|bits
parameter_list|,
name|shift
parameter_list|)
value|(bits * 1000 | shift)
switch|switch BITS_AND_SHIFT
condition|(
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|bitsize
operator|,
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|rightshift
condition|)
block|{
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|3
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|2
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|4
expr_stmt|;
comment|/* FIXME: we can't know the symbol's right value 			 yet, but we probably can safely assume that 			 CE will relocate us in 64k blocks, so leaving 			 it zero is safe.  */
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|26
argument_list|,
literal|2
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|5
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError: %d-bit reloc in dll\n"
argument_list|)
argument_list|,
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|bitsize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
comment|/* Warning: the allocated symbols are remembered in BFD and 	     reused later, so don't free them!  */
if|#
directive|if
literal|0
block|free (symbol);
endif|#
directive|endif
block|}
block|}
comment|/* At this point, we have total_relocs relocation addresses in      reloc_addresses, which are all suitable for the .reloc section.      We must now create the new sections.  */
name|qsort
argument_list|(
name|reloc_data
argument_list|,
name|total_relocs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reloc_data
argument_list|)
argument_list|,
name|reloc_sort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_relocs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|this_page
init|=
operator|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|vma
operator|>>
literal|12
operator|)
decl_stmt|;
if|if
condition|(
name|this_page
operator|!=
name|sec_page
condition|)
block|{
name|reloc_sz
operator|=
operator|(
name|reloc_sz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 4-byte align */
name|reloc_sz
operator|+=
literal|8
expr_stmt|;
name|sec_page
operator|=
name|this_page
expr_stmt|;
block|}
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|4
condition|)
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
block|}
name|reloc_sz
operator|=
operator|(
name|reloc_sz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 4-byte align */
name|reloc_d
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|reloc_sz
argument_list|)
expr_stmt|;
name|sec_page
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|reloc_sz
operator|=
literal|0
expr_stmt|;
name|page_ptr
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_relocs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|rva
init|=
name|reloc_data
index|[
name|i
index|]
operator|.
name|vma
operator|-
name|image_base
decl_stmt|;
name|unsigned
name|long
name|this_page
init|=
operator|(
name|rva
operator|&
operator|~
literal|0xfff
operator|)
decl_stmt|;
if|if
condition|(
name|this_page
operator|!=
name|sec_page
condition|)
block|{
while|while
condition|(
name|reloc_sz
operator|&
literal|3
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|page_ptr
operator|!=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_sz
operator|-
name|page_ptr
argument_list|,
name|reloc_d
operator|+
name|page_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|this_page
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|page_ptr
operator|=
name|reloc_sz
expr_stmt|;
name|reloc_sz
operator|+=
literal|8
expr_stmt|;
name|sec_page
operator|=
name|this_page
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|rva
operator|&
literal|0xfff
operator|)
operator|+
operator|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|<<
literal|12
operator|)
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|4
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|reloc_data
index|[
name|i
index|]
operator|.
name|extra
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
block|}
name|page_count
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|reloc_sz
operator|&
literal|3
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|page_ptr
operator|!=
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_sz
operator|-
name|page_ptr
argument_list|,
name|reloc_d
operator|+
name|page_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|reloc_sz
operator|<
name|reloc_s
operator|->
name|_raw_size
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************   Given the exiting def_file structure, print out a .DEF file that  corresponds to it.   ************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|quoteput
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|,
name|needs_quotes
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|needs_quotes
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\''
operator|||
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|';'
condition|)
name|needs_quotes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|needs_quotes
condition|)
block|{
name|putc
argument_list|(
literal|'"'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
operator|||
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_dll_generate_def_file
parameter_list|(
name|pe_out_def_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|pe_out_def_filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|fopen
argument_list|(
name|pe_out_def_filename
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%s: Can't open output def file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|pe_out_def_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|is_dll
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"LIBRARY "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"NAME "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" BASE=0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|description
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"DESCRIPTION "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|description
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|version_minor
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"VERSION %d.%d\n"
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|,
name|pe_def_file
operator|->
name|version_minor
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|version_major
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"VERSION %d\n"
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|stack_reserve
operator|!=
operator|-
literal|1
operator|||
name|pe_def_file
operator|->
name|heap_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|stack_commit
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"STACKSIZE 0x%x,0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|stack_reserve
argument_list|,
name|pe_def_file
operator|->
name|stack_commit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|stack_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"STACKSIZE 0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|stack_reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|heap_commit
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"HEAPSIZE 0x%x,0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|heap_reserve
argument_list|,
name|pe_def_file
operator|->
name|heap_commit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|heap_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"HEAPSIZE 0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|heap_reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|num_section_defs
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nSECTIONS\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_section_defs
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|class
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" CLASS "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_read
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" READ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_write
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" WRITE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_execute
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" EXECUTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_shared
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" SHARED"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|num_exports
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nEXPORTS\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
name|def_file_export
modifier|*
name|e
init|=
name|pe_def_file
operator|->
name|exports
operator|+
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|internal_name
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|internal_name
argument_list|,
name|e
operator|->
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|e
operator|->
name|internal_name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" @%d"
argument_list|,
name|e
operator|->
name|ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_private
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" PRIVATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_constant
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" CONSTANT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_noname
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" NONAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_data
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" DATA"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|num_imports
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nIMPORTS\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_imports
condition|;
name|i
operator|++
control|)
block|{
name|def_file_import
modifier|*
name|im
init|=
name|pe_def_file
operator|->
name|imports
operator|+
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|internal_name
operator|&&
operator|(
operator|!
name|im
operator|->
name|name
operator|||
name|strcmp
argument_list|(
name|im
operator|->
name|internal_name
argument_list|,
name|im
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|quoteput
argument_list|(
name|im
operator|->
name|internal_name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
block|}
name|quoteput
argument_list|(
name|im
operator|->
name|module
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|name
condition|)
name|quoteput
argument_list|(
name|im
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%d"
argument_list|,
name|im
operator|->
name|ordinal
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"; no contents available\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error closing file `%s'\n"
argument_list|)
argument_list|,
name|pe_out_def_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************   Generate the import library   ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tmp_seq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dll_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dll_symname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNDSEC
value|(asection *)&bfd_und_section
end_define

begin_function
specifier|static
name|asection
modifier|*
name|quick_section
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|align
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Remember to undo this before trying to link internally!  */
name|sec
operator|->
name|output_section
operator|=
name|sec
expr_stmt|;
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symtab
index|[
name|symptr
operator|++
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|sec
operator|->
name|name
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|sec
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quick_symbol
parameter_list|(
name|abfd
parameter_list|,
name|n1
parameter_list|,
name|n2
parameter_list|,
name|n3
parameter_list|,
name|sec
parameter_list|,
name|flags
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|n1
decl_stmt|;
name|char
modifier|*
name|n2
decl_stmt|;
name|char
modifier|*
name|n3
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|addr
decl_stmt|;
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|n1
argument_list|)
operator|+
name|strlen
argument_list|(
name|n2
argument_list|)
operator|+
name|strlen
argument_list|(
name|n3
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|n3
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|addr
expr_stmt|;
name|symtab
index|[
name|symptr
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|arelent
modifier|*
name|reltab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|relcount
init|=
literal|0
decl_stmt|,
name|relsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|quick_reloc
parameter_list|(
name|abfd
parameter_list|,
name|address
parameter_list|,
name|which_howto
parameter_list|,
name|symidx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|address
decl_stmt|;
name|int
name|which_howto
decl_stmt|;
name|int
name|symidx
decl_stmt|;
block|{
if|if
condition|(
name|relcount
operator|>=
operator|(
name|relsize
operator|-
literal|1
operator|)
condition|)
block|{
name|relsize
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|reltab
condition|)
name|reltab
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xrealloc
argument_list|(
name|reltab
argument_list|,
name|relsize
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reltab
operator|=
operator|(
name|arelent
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reltab
index|[
name|relcount
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|which_howto
argument_list|)
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|sym_ptr_ptr
operator|=
name|symtab
operator|+
name|symidx
expr_stmt|;
name|relcount
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sec
operator|->
name|relocation
operator|=
name|reltab
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|relcount
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|relcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
name|sec
operator|->
name|orelocation
index|[
name|i
index|]
operator|=
name|sec
operator|->
name|relocation
operator|+
name|i
expr_stmt|;
name|sec
operator|->
name|orelocation
index|[
name|relcount
index|]
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|reltab
operator|=
literal|0
expr_stmt|;
name|relcount
operator|=
name|relsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	.section	.idata$2  *	.global		__head_my_dll  * __head_my_dll:  *	.rva		hname  *	.long		0  *	.long		0  *	.rva		__my_dll_iname  *	.rva		fthunk  *  *	.section	.idata$5  *	.long		0  * fthunk:  *  *	.section	.idata$4  *	.long		0  * hname:  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_head
parameter_list|(
name|parent
parameter_list|)
name|bfd
modifier|*
name|parent
decl_stmt|;
block|{
name|asection
modifier|*
name|id2
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id4
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d2
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d4
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id2
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$2"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_head_"
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|""
argument_list|,
name|id2
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|"_iname"
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* OK, pay attention here.  I got confused myself looking back at      it.  We create a four-byte section to mark the beginning of the      list, and we include an offset of 4 in the section, so that the      pointer to the list points to the *end* of this section, which is      the start of the list of sections from other objects.  */
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id2
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|d2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|id2
operator|->
name|contents
operator|=
name|d2
expr_stmt|;
name|memset
argument_list|(
name|d2
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|d2
index|[
literal|0
index|]
operator|=
name|d2
index|[
literal|16
index|]
operator|=
literal|4
expr_stmt|;
comment|/* reloc addend */
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|16
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id2
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id2
argument_list|,
name|d2
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*  *	.section	.idata$4  *	.long		0  *	.section	.idata$5  *	.long		0  *	.section	idata$7  *	.global		__my_dll_iname  *__my_dll_iname:  *	.asciz		"my.dll"  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_tail
parameter_list|(
name|parent
parameter_list|)
name|bfd
modifier|*
name|parent
decl_stmt|;
block|{
name|asection
modifier|*
name|id4
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id7
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d4
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d7
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id7
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$7"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|"_iname"
argument_list|,
name|id7
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dll_filename
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d7
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|id7
operator|->
name|contents
operator|=
name|d7
expr_stmt|;
name|strcpy
argument_list|(
name|d7
argument_list|,
name|dll_filename
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|d7
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*  *	.text  *	.global		_function  *	.global		___imp_function  *	.global		__imp__function  *_function:  *	jmp		*__imp__function:  *  *	.section	idata$7  *	.long		__head_my_dll  *  *	.section	.idata$5  *___imp_function:  *__imp__function:  *iat?  *	.section	.idata$4  *iat?  *	.section	.idata$6  *ID<ordinal>:  *	.short<hint>  *	.asciz		"function" xlate? (add underscore, kill at)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_ix86_bytes
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *_function:  *	mov.l	ip+8,r0  *	mov.l	@r0,r0  *	jmp	@r0  *	nop  *	.dw	__imp_function  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_sh_bytes
index|[]
init|=
block|{
literal|0x01
block|,
literal|0xd0
block|,
literal|0x02
block|,
literal|0x60
block|,
literal|0x2b
block|,
literal|0x40
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *_function:  *	lui	$t0,<high:__imp_function>  *	lw	$t0,<low:__imp_function>  *	jr	$t0  *	nop  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_mips_bytes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x3c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x8d
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd
modifier|*
name|make_one
parameter_list|(
name|exp
parameter_list|,
name|parent
parameter_list|)
name|def_file_export
modifier|*
name|exp
decl_stmt|;
name|bfd
modifier|*
name|parent
decl_stmt|;
block|{
name|asection
modifier|*
name|tx
decl_stmt|,
modifier|*
name|id7
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id4
decl_stmt|,
modifier|*
name|id6
decl_stmt|;
name|unsigned
name|char
modifier|*
name|td
init|=
name|NULL
decl_stmt|,
modifier|*
name|d7
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d4
decl_stmt|,
modifier|*
name|d6
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|jmp_bytes
init|=
name|NULL
decl_stmt|;
name|int
name|jmp_byte_count
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pe_details
operator|->
name|pe_arch
condition|)
block|{
case|case
name|PE_ARCH_i386
case|:
name|jmp_bytes
operator|=
name|jmp_ix86_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_ix86_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_sh
case|:
name|jmp_bytes
operator|=
name|jmp_sh_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_sh_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_mips
case|:
name|jmp_bytes
operator|=
name|jmp_mips_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_mips_bytes
argument_list|)
expr_stmt|;
break|break;
block|}
name|oname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|,
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id7
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$7"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id6
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$6"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_data
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|tx
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_head_"
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_imp__"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id5
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_dll_compat_implib
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"__imp_"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id5
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_data
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|tx
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|tx
operator|->
name|contents
operator|=
name|td
expr_stmt|;
name|memcpy
argument_list|(
name|td
argument_list|,
name|jmp_bytes
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pe_details
operator|->
name|pe_arch
condition|)
block|{
case|case
name|PE_ARCH_i386
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_sh
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|8
argument_list|,
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_mips
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MIPS_R_PAIR */
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|save_relocs
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d7
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id7
operator|->
name|contents
operator|=
name|d7
expr_stmt|;
name|memset
argument_list|(
name|d7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id7
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|d5
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|d5
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|d5
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id5
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|d4
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|d4
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|d4
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|exp
operator|->
name|name
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d6
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|id6
operator|->
name|contents
operator|=
name|d6
expr_stmt|;
name|memset
argument_list|(
name|d6
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d6
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|hint
operator|&
literal|0xff
expr_stmt|;
name|d6
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|hint
operator|>>
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|d6
operator|+
literal|2
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|tx
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|d7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_noname
condition|)
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
name|d6
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
name|void
name|pe_dll_generate_implib
parameter_list|(
name|def
parameter_list|,
name|impfilename
parameter_list|)
name|def_file
modifier|*
name|def
decl_stmt|;
specifier|const
name|char
modifier|*
name|impfilename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd
modifier|*
name|ar_head
decl_stmt|;
name|bfd
modifier|*
name|ar_tail
decl_stmt|;
name|bfd
modifier|*
name|outarch
decl_stmt|;
name|bfd
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|dll_filename
operator|=
operator|(
name|def
operator|->
name|name
operator|)
condition|?
name|def
operator|->
name|name
else|:
name|dll_name
expr_stmt|;
name|dll_symname
operator|=
name|xstrdup
argument_list|(
name|dll_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dll_symname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|dll_symname
index|[
name|i
index|]
argument_list|)
condition|)
name|dll_symname
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|unlink
argument_list|(
name|impfilename
argument_list|)
expr_stmt|;
name|outarch
operator|=
name|bfd_openw
argument_list|(
name|impfilename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outarch
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCan't open .lib file: %s\n"
argument_list|)
argument_list|,
name|impfilename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"Creating library file: %s\n"
argument_list|)
argument_list|,
name|impfilename
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|outarch
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|outarch
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
comment|/* Work out a reasonable size of things to put onto one line.  */
name|ar_head
operator|=
name|make_head
argument_list|(
name|outarch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
comment|/* The import library doesn't know about the internal name.  */
name|char
modifier|*
name|internal
init|=
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
decl_stmt|;
name|bfd
modifier|*
name|n
decl_stmt|;
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|=
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|n
operator|=
name|make_one
argument_list|(
name|def
operator|->
name|exports
operator|+
name|i
argument_list|,
name|outarch
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|=
name|internal
expr_stmt|;
block|}
name|ar_tail
operator|=
name|make_tail
argument_list|(
name|outarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_head
operator|==
name|NULL
operator|||
name|ar_tail
operator|==
name|NULL
condition|)
return|return;
comment|/* Now stick them all into the archive.  */
name|ar_head
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|ar_tail
operator|->
name|next
operator|=
name|ar_head
expr_stmt|;
name|head
operator|=
name|ar_tail
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_archive_head
argument_list|(
name|outarch
argument_list|,
name|head
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xbfd_set_archive_head: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|outarch
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xbfd_close %s: %s\n"
argument_list|,
name|impfilename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|n
init|=
name|head
operator|->
name|next
decl_stmt|;
name|bfd_close
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_bfd_to_link
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|fake_file
decl_stmt|;
name|fake_file
operator|=
name|lang_add_input_file
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_fake_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fake_file
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|ldlang_add_file
argument_list|(
name|fake_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xaddsym %s: %s\n"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_process_import_defs
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|def_file_module
modifier|*
name|module
decl_stmt|;
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
condition|)
return|return;
for|for
control|(
name|module
operator|=
name|pe_def_file
operator|->
name|modules
init|;
name|module
condition|;
name|module
operator|=
name|module
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|,
name|do_this_dll
decl_stmt|;
name|dll_filename
operator|=
name|module
operator|->
name|name
expr_stmt|;
name|dll_symname
operator|=
name|xstrdup
argument_list|(
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dll_symname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|dll_symname
index|[
name|i
index|]
argument_list|)
condition|)
name|dll_symname
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|do_this_dll
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_imports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|module
operator|==
name|module
condition|)
block|{
name|def_file_export
name|exp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
comment|/* See if we need this import.  */
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
operator|+
literal|2
operator|+
literal|6
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blhe
operator|||
operator|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|"_imp__"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|bfd
modifier|*
name|one
decl_stmt|;
comment|/* We do.  */
if|if
condition|(
operator|!
name|do_this_dll
condition|)
block|{
name|bfd
modifier|*
name|ar_head
init|=
name|make_head
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|add_bfd_to_link
argument_list|(
name|ar_head
argument_list|,
name|ar_head
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
name|do_this_dll
operator|=
literal|1
expr_stmt|;
block|}
name|exp
operator|.
name|internal_name
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
expr_stmt|;
name|exp
operator|.
name|name
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|exp
operator|.
name|ordinal
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|exp
operator|.
name|hint
operator|=
name|exp
operator|.
name|ordinal
operator|>=
literal|0
condition|?
name|exp
operator|.
name|ordinal
else|:
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_private
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_constant
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_data
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_noname
operator|=
name|exp
operator|.
name|name
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|one
operator|=
name|make_one
argument_list|(
operator|&
name|exp
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|add_bfd_to_link
argument_list|(
name|one
argument_list|,
name|one
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_this_dll
condition|)
block|{
name|bfd
modifier|*
name|ar_tail
init|=
name|make_tail
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|add_bfd_to_link
argument_list|(
name|ar_tail
argument_list|,
name|ar_tail
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dll_symname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************   We were handed a *.DLL file.  Parse it and turn it into a set of  IMPORTS directives in the def file.  Return true if the file was  handled, false if not.   ************************************************************************/
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pe_get16
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|pe_get32
parameter_list|(
name|abfd
parameter_list|,
name|where
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not currently used.  */
end_comment

begin_endif
unit|static unsigned int pe_as16 (ptr)      void *ptr; {   unsigned char *b = ptr;   return b[0] + (b[1]<< 8); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|int
name|pe_as32
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|b
init|=
name|ptr
decl_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
name|boolean
name|pe_implied_import_dll
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|bfd
modifier|*
name|dll
decl_stmt|;
name|unsigned
name|long
name|pe_header_offset
decl_stmt|,
name|opthdr_ofs
decl_stmt|,
name|num_entries
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|export_rva
decl_stmt|,
name|export_size
decl_stmt|,
name|nsections
decl_stmt|,
name|secptr
decl_stmt|,
name|expptr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|expdata
decl_stmt|,
modifier|*
name|erva
decl_stmt|;
name|unsigned
name|long
name|name_rvas
decl_stmt|,
name|ordinals
decl_stmt|,
name|nexp
decl_stmt|,
name|ordbase
decl_stmt|;
specifier|const
name|char
modifier|*
name|dll_name
decl_stmt|;
comment|/* No, I can't use bfd here.  kernel32.dll puts its export table in      the middle of the .rdata section.  */
name|dll
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|pe_details
operator|->
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll
condition|)
block|{
name|einfo
argument_list|(
literal|"%Xopen %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* PEI dlls seem to be bfd_objects.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|dll
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%s: this doesn't appear to be a DLL\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|dll_name
operator|=
name|filename
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'/'
operator|||
name|filename
index|[
name|i
index|]
operator|==
literal|'\\'
operator|||
name|filename
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|dll_name
operator|=
name|filename
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|pe_header_offset
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|opthdr_ofs
operator|=
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
expr_stmt|;
name|num_entries
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_entries
operator|<
literal|1
condition|)
comment|/* no exports */
return|return
name|false
return|;
name|export_rva
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|96
argument_list|)
expr_stmt|;
name|export_size
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|100
argument_list|)
expr_stmt|;
name|nsections
operator|=
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|2
argument_list|)
expr_stmt|;
name|secptr
operator|=
operator|(
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
operator|+
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|16
argument_list|)
operator|)
expr_stmt|;
name|expptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|secptr1
init|=
name|secptr
operator|+
literal|40
operator|*
name|i
decl_stmt|;
name|unsigned
name|long
name|vaddr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|12
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vsize
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|16
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|fptr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|20
argument_list|)
decl_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
name|secptr1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|sname
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
operator|<=
name|export_rva
operator|&&
name|vaddr
operator|+
name|vsize
operator|>
name|export_rva
condition|)
block|{
name|expptr
operator|=
name|fptr
operator|+
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
if|if
condition|(
name|export_rva
operator|+
name|export_size
operator|>
name|vaddr
operator|+
name|vsize
condition|)
name|export_size
operator|=
name|vsize
operator|-
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|expdata
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|export_size
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
name|expptr
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_read
argument_list|(
name|expdata
argument_list|,
literal|1
argument_list|,
name|export_size
argument_list|,
name|dll
argument_list|)
expr_stmt|;
name|erva
operator|=
name|expdata
operator|-
name|export_rva
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|==
literal|0
condition|)
name|pe_def_file
operator|=
name|def_file_empty
argument_list|()
expr_stmt|;
name|nexp
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|24
argument_list|)
expr_stmt|;
name|name_rvas
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|32
argument_list|)
expr_stmt|;
name|ordinals
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|36
argument_list|)
expr_stmt|;
name|ordbase
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexp
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|name_rva
init|=
name|pe_as32
argument_list|(
name|erva
operator|+
name|name_rvas
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
name|def_file_import
modifier|*
name|imp
decl_stmt|;
name|imp
operator|=
name|def_file_add_import
argument_list|(
name|pe_def_file
argument_list|,
name|erva
operator|+
name|name_rva
argument_list|,
name|dll_name
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/************************************************************************   These are the main functions, called from the emulation.  The first  is called after the bfds are read, so we can guess at how much space  we need.  The second is called after everything is placed, so we  can put the right values in place.   ************************************************************************/
end_comment

begin_function
name|void
name|pe_dll_build_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|process_def_file
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|generate_edata
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|build_filler_bfd
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_exe_build_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|build_filler_bfd
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_dll_fill_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|image_base
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|generate_reloc
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_sz
operator|>
literal|0
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
name|reloc_sz
argument_list|)
expr_stmt|;
comment|/* Resize the sections.  */
name|lang_size_sections
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|stat_ptr
operator|->
name|head
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Redo special stuff.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Do the assignments again.  */
name|lang_do_assignments
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|fill_edata
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|dll
operator|=
literal|1
expr_stmt|;
name|edata_s
operator|->
name|contents
operator|=
name|edata_d
expr_stmt|;
name|reloc_s
operator|->
name|contents
operator|=
name|reloc_d
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_exe_fill_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|image_base
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|generate_reloc
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_sz
operator|>
literal|0
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
name|reloc_sz
argument_list|)
expr_stmt|;
comment|/* Resize the sections.  */
name|lang_size_sections
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|stat_ptr
operator|->
name|head
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Redo special stuff.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Do the assignments again.  */
name|lang_do_assignments
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|reloc_s
operator|->
name|contents
operator|=
name|reloc_d
expr_stmt|;
block|}
end_function

end_unit

