begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines to help build PEI-format DLLs (Win32 etc)    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Written by DJ Delorie<dj@cygnus.com>     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"../bfd/libcoff.h"
end_include

begin_include
include|#
directive|include
file|"deffile.h"
end_include

begin_include
include|#
directive|include
file|"pe-dll.h"
end_include

begin_comment
comment|/*  This file turns a regular Windows PE image into a DLL.  Because of     the complexity of this operation, it has been broken down into a     number of separate modules which are all called by the main function     at the end of this file.  This function is not re-entrant and is     normally only called once, so static variables are used to reduce     the number of parameters and return values required.      See also: ld/emultempl/pe.em.  */
end_comment

begin_comment
comment|/*  Auto-import feature by Paul Sokolovsky      Quick facts:      1. With this feature on, DLL clients can import variables from DLL     without any concern from their side (for example, without any source     code modifications).      2. This is done completely in bounds of the PE specification (to be fair,     there's a place where it pokes nose out of, but in practice it works).     So, resulting module can be used with any other PE compiler/linker.      3. Auto-import is fully compatible with standard import method and they     can be mixed together.      4. Overheads: space: 8 bytes per imported symbol, plus 20 for each     reference to it; load time: negligible; virtual/physical memory: should be     less than effect of DLL relocation, and I sincerely hope it doesn't affect     DLL sharability (too much).      Idea      The obvious and only way to get rid of dllimport insanity is to make client     access variable directly in the DLL, bypassing extra dereference. I.e.,     whenever client contains something like      mov dll_var,%eax,      address of dll_var in the command should be relocated to point into loaded     DLL. The aim is to make OS loader do so, and than make ld help with that.     Import section of PE made following way: there's a vector of structures     each describing imports from particular DLL. Each such structure points     to two other parallel vectors: one holding imported names, and one which     will hold address of corresponding imported name. So, the solution is     de-vectorize these structures, making import locations be sparse and     pointing directly into code. Before continuing, it is worth a note that,     while authors strives to make PE act ELF-like, there're some other people     make ELF act PE-like: elfvector, ;-) .      Implementation      For each reference of data symbol to be imported from DLL (to set of which     belong symbols with name<sym>, if __imp_<sym> is found in implib), the     import fixup entry is generated. That entry is of type     IMAGE_IMPORT_DESCRIPTOR and stored in .idata$3 subsection. Each     fixup entry contains pointer to symbol's address within .text section     (marked with __fuN_<sym> symbol, where N is integer), pointer to DLL name     (so, DLL name is referenced by multiple entries), and pointer to symbol     name thunk. Symbol name thunk is singleton vector (__nm_th_<symbol>)     pointing to IMAGE_IMPORT_BY_NAME structure (__nm_<symbol>) directly     containing imported name. Here comes that "om the edge" problem mentioned     above: PE specification rambles that name vector (OriginalFirstThunk)     should run in parallel with addresses vector (FirstThunk), i.e. that they     should have same number of elements and terminated with zero. We violate     this, since FirstThunk points directly into machine code. But in practice,     OS loader implemented the sane way: it goes thru OriginalFirstThunk and     puts addresses to FirstThunk, not something else. It once again should be     noted that dll and symbol name structures are reused across fixup entries     and should be there anyway to support standard import stuff, so sustained     overhead is 20 bytes per reference. Other question is whether having several     IMAGE_IMPORT_DESCRIPTORS for the same DLL is possible. Answer is yes, it is     done even by native compiler/linker (libth32's functions are in fact reside     in windows9x kernel32.dll, so if you use it, you have two     IMAGE_IMPORT_DESCRIPTORS for kernel32.dll). Yet other question is whether     referencing the same PE structures several times is valid. The answer is why     not, prohibiting that (detecting violation) would require more work on     behalf of loader than not doing it.      See also: ld/emultempl/pe.em.  */
end_comment

begin_function_decl
specifier|static
name|void
name|add_bfd_to_link
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* For emultempl/pe.em.  */
end_comment

begin_decl_stmt
name|def_file
modifier|*
name|pe_def_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_export_everything
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_do_default_excludes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_kill_ats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_stdcall_aliases
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_warn_dup_exports
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_compat_implib
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pe_dll_extra_pe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static variables and types.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|image_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|filler_bfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_section
modifier|*
name|edata_s
decl_stmt|,
modifier|*
name|reloc_s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|edata_d
decl_stmt|,
modifier|*
name|reloc_d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|edata_sz
decl_stmt|,
name|reloc_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|runtime_pseudo_relocs_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|target_name
decl_stmt|;
name|char
modifier|*
name|object_target
decl_stmt|;
name|unsigned
name|int
name|imagebase_reloc
decl_stmt|;
name|int
name|pe_arch
decl_stmt|;
name|int
name|bfd_arch
decl_stmt|;
name|int
name|underscored
decl_stmt|;
block|}
name|pe_details_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|autofilter_entry_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PE_ARCH_i386
value|1
end_define

begin_define
define|#
directive|define
name|PE_ARCH_sh
value|2
end_define

begin_define
define|#
directive|define
name|PE_ARCH_mips
value|3
end_define

begin_define
define|#
directive|define
name|PE_ARCH_arm
value|4
end_define

begin_define
define|#
directive|define
name|PE_ARCH_arm_epoc
value|5
end_define

begin_decl_stmt
specifier|static
name|pe_details_type
name|pe_detail_list
index|[]
init|=
block|{
block|{
literal|"pei-i386"
block|,
literal|"pe-i386"
block|,
literal|7
comment|/* R_IMAGEBASE */
block|,
name|PE_ARCH_i386
block|,
name|bfd_arch_i386
block|,
literal|1
block|}
block|,
block|{
literal|"pei-shl"
block|,
literal|"pe-shl"
block|,
literal|16
comment|/* R_SH_IMAGEBASE */
block|,
name|PE_ARCH_sh
block|,
name|bfd_arch_sh
block|,
literal|1
block|}
block|,
block|{
literal|"pei-mips"
block|,
literal|"pe-mips"
block|,
literal|34
comment|/* MIPS_R_RVA */
block|,
name|PE_ARCH_mips
block|,
name|bfd_arch_mips
block|,
literal|0
block|}
block|,
block|{
literal|"pei-arm-little"
block|,
literal|"pe-arm-little"
block|,
literal|11
comment|/* ARM_RVA32 */
block|,
name|PE_ARCH_arm
block|,
name|bfd_arch_arm
block|,
literal|1
block|}
block|,
block|{
literal|"epoc-pei-arm-little"
block|,
literal|"epoc-pe-arm-little"
block|,
literal|11
comment|/* ARM_RVA32 */
block|,
name|PE_ARCH_arm_epoc
block|,
name|bfd_arch_arm
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pe_details_type
modifier|*
name|pe_details
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|autofilter_entry_type
name|autofilter_symbollist
index|[]
init|=
block|{
block|{
literal|"DllMain@12"
block|,
literal|10
block|}
block|,
block|{
literal|"DllEntryPoint@0"
block|,
literal|15
block|}
block|,
block|{
literal|"DllMainCRTStartup@12"
block|,
literal|20
block|}
block|,
block|{
literal|"_cygwin_dll_entry@12"
block|,
literal|20
block|}
block|,
block|{
literal|"_cygwin_crt0_common@8"
block|,
literal|21
block|}
block|,
block|{
literal|"_cygwin_noncygwin_dll_entry@12"
block|,
literal|30
block|}
block|,
block|{
literal|"impure_ptr"
block|,
literal|10
block|}
block|,
block|{
literal|"_pei386_runtime_relocator"
block|,
literal|25
block|}
block|,
block|{
literal|"do_pseudo_reloc"
block|,
literal|15
block|}
block|,
block|{
literal|"cygwin_crt0"
block|,
literal|11
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not specify library suffix explicitly, to allow for dllized versions.  */
end_comment

begin_decl_stmt
specifier|static
name|autofilter_entry_type
name|autofilter_liblist
index|[]
init|=
block|{
block|{
literal|"libcygwin"
block|,
literal|9
block|}
block|,
block|{
literal|"libgcc"
block|,
literal|6
block|}
block|,
block|{
literal|"libstdc++"
block|,
literal|9
block|}
block|,
block|{
literal|"libmingw32"
block|,
literal|10
block|}
block|,
block|{
literal|"libmingwex"
block|,
literal|10
block|}
block|,
block|{
literal|"libg2c"
block|,
literal|6
block|}
block|,
block|{
literal|"libsupc++"
block|,
literal|9
block|}
block|,
block|{
literal|"libobjc"
block|,
literal|7
block|}
block|,
block|{
literal|"libgcj"
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|autofilter_entry_type
name|autofilter_objlist
index|[]
init|=
block|{
block|{
literal|"crt0.o"
block|,
literal|6
block|}
block|,
block|{
literal|"crt1.o"
block|,
literal|6
block|}
block|,
block|{
literal|"crt2.o"
block|,
literal|6
block|}
block|,
block|{
literal|"dllcrt1.o"
block|,
literal|9
block|}
block|,
block|{
literal|"dllcrt2.o"
block|,
literal|9
block|}
block|,
block|{
literal|"gcrt0.o"
block|,
literal|7
block|}
block|,
block|{
literal|"gcrt1.o"
block|,
literal|7
block|}
block|,
block|{
literal|"gcrt2.o"
block|,
literal|7
block|}
block|,
block|{
literal|"crtbegin.o"
block|,
literal|10
block|}
block|,
block|{
literal|"crtend.o"
block|,
literal|8
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|autofilter_entry_type
name|autofilter_symbolprefixlist
index|[]
init|=
block|{
comment|/*  { "__imp_", 6 }, */
comment|/* Do __imp_ explicitly to save time.  */
block|{
literal|"__rtti_"
block|,
literal|7
block|}
block|,
comment|/* Don't re-export auto-imported symbols.  */
block|{
literal|"_nm_"
block|,
literal|4
block|}
block|,
block|{
literal|"__builtin_"
block|,
literal|10
block|}
block|,
comment|/* Don't export symbols specifying internal DLL layout.  */
block|{
literal|"_head_"
block|,
literal|6
block|}
block|,
block|{
literal|"_fmode"
block|,
literal|6
block|}
block|,
block|{
literal|"_impure_ptr"
block|,
literal|11
block|}
block|,
block|{
literal|"cygwin_attach_dll"
block|,
literal|17
block|}
block|,
block|{
literal|"cygwin_premain0"
block|,
literal|15
block|}
block|,
block|{
literal|"cygwin_premain1"
block|,
literal|15
block|}
block|,
block|{
literal|"cygwin_premain2"
block|,
literal|15
block|}
block|,
block|{
literal|"cygwin_premain3"
block|,
literal|15
block|}
block|,
block|{
literal|"environ"
block|,
literal|7
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|autofilter_entry_type
name|autofilter_symbolsuffixlist
index|[]
init|=
block|{
block|{
literal|"_iname"
block|,
literal|6
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|U
parameter_list|(
name|str
parameter_list|)
value|(pe_details->underscored ? "_" str : str)
end_define

begin_function
name|void
name|pe_dll_id_target
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|target_name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|target_name
argument_list|,
name|target
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|pe_detail_list
index|[
name|i
index|]
operator|.
name|object_target
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pe_details
operator|=
name|pe_detail_list
operator|+
name|i
expr_stmt|;
return|return;
block|}
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XUnsupported PEI architecture: %s\n"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper functions for qsort.  Relocs must be sorted so that we can write    them out by pages.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|char
name|type
decl_stmt|;
name|short
name|extra
decl_stmt|;
block|}
name|reloc_data_type
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|reloc_sort
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
name|bfd_vma
name|a
init|=
operator|(
operator|(
specifier|const
name|reloc_data_type
operator|*
operator|)
name|va
operator|)
operator|->
name|vma
decl_stmt|;
name|bfd_vma
name|b
init|=
operator|(
operator|(
specifier|const
name|reloc_data_type
operator|*
operator|)
name|vb
operator|)
operator|->
name|vma
decl_stmt|;
return|return
operator|(
name|a
operator|>
name|b
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pe_export_sort
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|def_file_export
modifier|*
name|a
init|=
name|va
decl_stmt|;
specifier|const
name|def_file_export
modifier|*
name|b
init|=
name|vb
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read and process the .DEF file.  */
end_comment

begin_comment
comment|/* These correspond to the entries in pe_def_file->exports[].  I use    exported_symbol_sections[i] to tag whether or not the symbol was    defined, since we can't export symbols we don't have.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
modifier|*
name|exported_symbol_offsets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_section
modifier|*
modifier|*
name|exported_symbol_sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|export_table_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_exported
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_exported_byname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|count_with_ordinals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dll_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_ordinal
decl_stmt|,
name|max_ordinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|exported_symbols
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|exclude_list_struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|struct
name|exclude_list_struct
modifier|*
name|next
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
name|exclude_list_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|exclude_list_struct
modifier|*
name|excludes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pe_dll_add_excludes
parameter_list|(
specifier|const
name|char
modifier|*
name|new_excludes
parameter_list|,
specifier|const
name|int
name|type
parameter_list|)
block|{
name|char
modifier|*
name|local_copy
decl_stmt|;
name|char
modifier|*
name|exclude_string
decl_stmt|;
name|local_copy
operator|=
name|xstrdup
argument_list|(
name|new_excludes
argument_list|)
expr_stmt|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|local_copy
argument_list|,
literal|",:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|exclude_string
condition|;
name|exclude_string
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|",:"
argument_list|)
control|)
block|{
name|struct
name|exclude_list_struct
modifier|*
name|new_exclude
decl_stmt|;
name|new_exclude
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|exclude_list_struct
argument_list|)
argument_list|)
expr_stmt|;
name|new_exclude
operator|->
name|string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|exclude_string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_exclude
operator|->
name|string
argument_list|,
name|exclude_string
argument_list|)
expr_stmt|;
name|new_exclude
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_exclude
operator|->
name|next
operator|=
name|excludes
expr_stmt|;
name|excludes
operator|=
name|new_exclude
expr_stmt|;
block|}
name|free
argument_list|(
name|local_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* abfd is a bfd containing n (or NULL)    It can be used for contextual checks.  */
end_comment

begin_function
specifier|static
name|int
name|auto_export
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|def_file
modifier|*
name|d
parameter_list|,
specifier|const
name|char
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|exclude_list_struct
modifier|*
name|ex
decl_stmt|;
name|autofilter_entry_type
modifier|*
name|afptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|libname
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|abfd
operator|&&
name|abfd
operator|->
name|my_archive
condition|)
name|libname
operator|=
name|lbasename
argument_list|(
name|abfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* We should not re-export imported stuff.  */
if|if
condition|(
name|strncmp
argument_list|(
name|n
argument_list|,
literal|"_imp__"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|d
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pe_dll_do_default_excludes
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"considering exporting: %s, abfd=%p, abfd->my_arc=%p\n"
argument_list|,
name|n
argument_list|,
name|abfd
argument_list|,
name|abfd
operator|->
name|my_archive
argument_list|)
expr_stmt|;
comment|/* First of all, make context checks: 	 Don't export anything from standard libs.  */
if|if
condition|(
name|libname
condition|)
block|{
name|afptr
operator|=
name|autofilter_liblist
expr_stmt|;
while|while
condition|(
name|afptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|libname
argument_list|,
name|afptr
operator|->
name|name
argument_list|,
name|afptr
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|afptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Next, exclude symbols from certain startup objects.  */
if|if
condition|(
name|abfd
operator|&&
operator|(
name|p
operator|=
name|lbasename
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
operator|)
condition|)
block|{
name|afptr
operator|=
name|autofilter_objlist
expr_stmt|;
while|while
condition|(
name|afptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|afptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|afptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Don't try to blindly exclude all symbols 	 that begin with '__'; this was tried and 	 it is too restrictive.  */
comment|/* Then, exclude specific symbols.  */
name|afptr
operator|=
name|autofilter_symbollist
expr_stmt|;
while|while
condition|(
name|afptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
name|afptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|afptr
operator|++
expr_stmt|;
block|}
comment|/* Next, exclude symbols starting with ...  */
name|afptr
operator|=
name|autofilter_symbolprefixlist
expr_stmt|;
while|while
condition|(
name|afptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|n
argument_list|,
name|afptr
operator|->
name|name
argument_list|,
name|afptr
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|afptr
operator|++
expr_stmt|;
block|}
comment|/* Finally, exclude symbols ending with ...  */
name|len
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|afptr
operator|=
name|autofilter_symbolsuffixlist
expr_stmt|;
while|while
condition|(
name|afptr
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|>=
name|afptr
operator|->
name|len
operator|)
comment|/* Add 1 to insure match with trailing '\0'.  */
operator|&&
name|strncmp
argument_list|(
name|n
operator|+
name|len
operator|-
name|afptr
operator|->
name|len
argument_list|,
name|afptr
operator|->
name|name
argument_list|,
name|afptr
operator|->
name|len
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|afptr
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|ex
operator|=
name|excludes
init|;
name|ex
condition|;
name|ex
operator|=
name|ex
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ex
operator|->
name|type
operator|==
literal|1
condition|)
comment|/* exclude-libs */
block|{
if|if
condition|(
name|libname
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|libname
argument_list|,
name|ex
operator|->
name|string
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
literal|"ALL"
argument_list|,
name|ex
operator|->
name|string
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
name|ex
operator|->
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_def_file
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
name|bfd
modifier|*
name|b
decl_stmt|;
name|struct
name|bfd_section
modifier|*
name|s
decl_stmt|;
name|def_file_export
modifier|*
name|e
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
condition|)
name|pe_def_file
operator|=
name|def_file_empty
argument_list|()
expr_stmt|;
comment|/* First, run around to all the objects looking for the .drectve      sections, and push those into the def file too.  */
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|b
argument_list|,
literal|".drectve"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|int
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|def_file_add_directive
argument_list|(
name|pe_def_file
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are not building a DLL, when there are no exports      we do not build an export table at all.  */
if|if
condition|(
operator|!
name|pe_dll_export_everything
operator|&&
name|pe_def_file
operator|->
name|num_exports
operator|==
literal|0
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
return|return;
comment|/* Now, maybe export everything else the default way.  */
if|if
condition|(
name|pe_dll_export_everything
operator|||
name|pe_def_file
operator|->
name|num_exports
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|int
name|nsyms
decl_stmt|,
name|symsize
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|b
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsyms
condition|;
name|j
operator|++
control|)
block|{
comment|/* We should export symbols which are either global or not 		 anything at all.  (.bss data is the latter) 		 We should not export undefined symbols.  */
if|if
condition|(
name|symbols
index|[
name|j
index|]
operator|->
name|section
operator|!=
operator|&
name|bfd_und_section
operator|&&
operator|(
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|BSF_GLOBAL
operator|)
operator|||
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|==
name|BFD_FORT_COMM_DEFAULT_VALUE
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sn
init|=
name|symbols
index|[
name|j
index|]
operator|->
name|name
decl_stmt|;
comment|/* We should not re-export imported stuff.  */
block|{
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|sn
argument_list|)
operator|+
literal|2
operator|+
literal|6
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|"_imp_"
argument_list|)
argument_list|,
name|sn
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
continue|continue;
block|}
if|if
condition|(
operator|*
name|sn
operator|==
literal|'_'
condition|)
name|sn
operator|++
expr_stmt|;
if|if
condition|(
name|auto_export
argument_list|(
name|b
argument_list|,
name|pe_def_file
argument_list|,
name|sn
argument_list|)
condition|)
block|{
name|def_file_export
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|def_file_add_export
argument_list|(
name|pe_def_file
argument_list|,
name|sn
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fill data flag properly, from dlltool.c.  */
name|p
operator|->
name|flag_data
operator|=
operator|!
operator|(
name|symbols
index|[
name|j
index|]
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
undef|#
directive|undef
name|NE
define|#
directive|define
name|NE
value|pe_def_file->num_exports
comment|/* Canonicalize the export list.  */
if|if
condition|(
name|pe_dll_kill_ats
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* This will preserve internal_name, which may have been 		 pointing to the same memory as name, or might not 		 have.  */
name|int
name|lead_at
init|=
operator|(
operator|*
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|==
literal|'@'
operator|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|+
name|lead_at
argument_list|)
decl_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pe_dll_stdcall_aliases
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
name|int
name|lead_at
init|=
operator|(
operator|*
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|==
literal|'@'
operator|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
operator|+
name|lead_at
argument_list|)
decl_stmt|;
operator|*
operator|(
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|auto_export
argument_list|(
name|NULL
argument_list|,
name|pe_def_file
argument_list|,
name|tmp
argument_list|)
condition|)
name|def_file_add_export
argument_list|(
name|pe_def_file
argument_list|,
name|tmp
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Convenience, but watch out for it changing.  */
name|e
operator|=
name|pe_def_file
operator|->
name|exports
expr_stmt|;
name|exported_symbol_offsets
operator|=
name|xmalloc
argument_list|(
name|NE
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
name|exported_symbol_sections
operator|=
name|xmalloc
argument_list|(
name|NE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_section
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|exported_symbol_sections
argument_list|,
literal|0
argument_list|,
name|NE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_section
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|max_ordinal
operator|=
literal|0
expr_stmt|;
name|min_ordinal
operator|=
literal|65536
expr_stmt|;
name|count_exported
operator|=
literal|0
expr_stmt|;
name|count_exported_byname
operator|=
literal|0
expr_stmt|;
name|count_with_ordinals
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|pe_def_file
operator|->
name|exports
argument_list|,
name|NE
argument_list|,
sizeof|sizeof
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pe_export_sort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|strcmp
argument_list|(
name|e
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|e
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a duplicate.  */
if|if
condition|(
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|e
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
operator|&&
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|!=
name|e
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
block|{
if|if
condition|(
name|pe_dll_warn_dup_exports
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError, duplicate EXPORT with ordinals: %s (%d vs %d)\n"
argument_list|)
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|name
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
argument_list|,
name|e
index|[
name|i
index|]
operator|.
name|ordinal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pe_dll_warn_dup_exports
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"Warning, duplicate EXPORT: %s\n"
argument_list|)
argument_list|,
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|ordinal
operator|=
name|e
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_private
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_private
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_constant
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_constant
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_noname
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_noname
expr_stmt|;
name|e
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|flag_data
operator||=
name|e
index|[
name|i
index|]
operator|.
name|flag_data
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|e
index|[
name|j
index|]
operator|=
name|e
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
name|pe_def_file
operator|->
name|num_exports
operator|=
name|j
expr_stmt|;
comment|/* == NE */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_details
operator|->
name|underscored
operator|&&
operator|(
operator|*
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|!=
literal|'@'
operator|)
condition|)
block|{
operator|*
name|name
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
operator|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|)
condition|)
block|{
name|count_exported
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|flag_noname
condition|)
name|count_exported_byname
operator|++
expr_stmt|;
comment|/* Only fill in the sections. The actual offsets are computed 	     in fill_exported_offsets() after common symbols are laid 	     out.  */
if|if
condition|(
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|exported_symbol_sections
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|exported_symbol_sections
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|max_ordinal
operator|<
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
name|max_ordinal
operator|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
if|if
condition|(
name|min_ordinal
operator|>
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
condition|)
name|min_ordinal
operator|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|count_with_ordinals
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol not defined\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blhe
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol wrong type (%d vs %d)\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|,
name|blhe
operator|->
name|type
argument_list|,
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCannot export %s: symbol not found\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the bfd that will contain .edata and .reloc sections.  */
end_comment

begin_function
specifier|static
name|void
name|build_filler_bfd
parameter_list|(
name|int
name|include_edata
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|filler_file
decl_stmt|;
name|filler_file
operator|=
name|lang_add_input_file
argument_list|(
literal|"dll stuff"
argument_list|,
name|lang_input_file_is_fake_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filler_file
operator|->
name|the_bfd
operator|=
name|filler_bfd
operator|=
name|bfd_create
argument_list|(
literal|"dll stuff"
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|filler_bfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_arch_mach
argument_list|(
name|filler_bfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create BFD %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|include_edata
condition|)
block|{
name|edata_s
operator|=
name|bfd_make_section_old_way
argument_list|(
name|filler_bfd
argument_list|,
literal|".edata"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edata_s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|filler_bfd
argument_list|,
name|edata_s
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
operator||
name|SEC_IN_MEMORY
operator|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create .edata section: %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|edata_s
argument_list|,
name|edata_sz
argument_list|)
expr_stmt|;
block|}
name|reloc_s
operator|=
name|bfd_make_section_old_way
argument_list|(
name|filler_bfd
argument_list|,
literal|".reloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
operator||
name|SEC_IN_MEMORY
operator|)
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: can not create .reloc section: %E\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ldlang_add_file
argument_list|(
name|filler_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gather all the exported symbols and build the .edata section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_edata
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|next_ordinal
decl_stmt|;
name|int
name|name_table_size
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|dlnp
decl_stmt|;
comment|/* First, we need to know how many exported symbols there are,      and what the range of ordinals is.  */
if|if
condition|(
name|pe_def_file
operator|->
name|name
condition|)
name|dll_name
operator|=
name|pe_def_file
operator|->
name|name
expr_stmt|;
else|else
block|{
name|dll_name
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
for|for
control|(
name|dlnp
operator|=
name|dll_name
init|;
operator|*
name|dlnp
condition|;
name|dlnp
operator|++
control|)
if|if
condition|(
operator|*
name|dlnp
operator|==
literal|'\\'
operator|||
operator|*
name|dlnp
operator|==
literal|'/'
operator|||
operator|*
name|dlnp
operator|==
literal|':'
condition|)
name|dll_name
operator|=
name|dlnp
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count_with_ordinals
operator|&&
name|max_ordinal
operator|>
name|count_exported
condition|)
block|{
if|if
condition|(
name|min_ordinal
operator|>
name|max_ordinal
operator|-
name|count_exported
operator|+
literal|1
condition|)
name|min_ordinal
operator|=
name|max_ordinal
operator|-
name|count_exported
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|min_ordinal
operator|=
literal|1
expr_stmt|;
name|max_ordinal
operator|=
name|count_exported
expr_stmt|;
block|}
name|export_table_size
operator|=
name|max_ordinal
operator|-
name|min_ordinal
operator|+
literal|1
expr_stmt|;
name|exported_symbols
operator|=
name|xmalloc
argument_list|(
name|export_table_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|export_table_size
condition|;
name|i
operator|++
control|)
name|exported_symbols
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now we need to assign ordinals to those that don't have them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|exported_symbol_sections
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ei
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|-
name|min_ordinal
decl_stmt|;
name|int
name|pi
init|=
name|exported_symbols
index|[
name|ei
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError, ordinal used twice: %d (%s vs %s)\n"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|pi
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|exported_symbols
index|[
name|ei
index|]
operator|=
name|i
expr_stmt|;
block|}
name|name_table_size
operator|+=
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|next_ordinal
operator|=
name|min_ordinal
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|exported_symbol_sections
index|[
name|i
index|]
condition|)
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|exported_symbols
index|[
name|next_ordinal
operator|-
name|min_ordinal
index|]
operator|!=
operator|-
literal|1
condition|)
name|next_ordinal
operator|++
expr_stmt|;
name|exported_symbols
index|[
name|next_ordinal
operator|-
name|min_ordinal
index|]
operator|=
name|i
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|ordinal
operator|=
name|next_ordinal
expr_stmt|;
block|}
comment|/* OK, now we can allocate some memory.  */
name|edata_sz
operator|=
operator|(
literal|40
comment|/* directory */
operator|+
literal|4
operator|*
name|export_table_size
comment|/* addresses */
operator|+
literal|4
operator|*
name|count_exported_byname
comment|/* name ptrs */
operator|+
literal|2
operator|*
name|count_exported_byname
comment|/* ordinals */
operator|+
name|name_table_size
operator|+
name|strlen
argument_list|(
name|dll_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill the exported symbol offsets. The preliminary work has already    been done in process_def_file().  */
end_comment

begin_function
specifier|static
name|void
name|fill_exported_offsets
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_details
operator|->
name|underscored
operator|&&
operator|*
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|!=
literal|'@'
condition|)
block|{
operator|*
name|name
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|name
argument_list|,
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|exported_symbol_offsets
index|[
name|i
index|]
operator|=
name|blhe
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_edata
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|hint
decl_stmt|;
name|unsigned
name|char
modifier|*
name|edirectory
decl_stmt|;
name|unsigned
name|char
modifier|*
name|eaddresses
decl_stmt|;
name|unsigned
name|char
modifier|*
name|enameptrs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|eordinals
decl_stmt|;
name|unsigned
name|char
modifier|*
name|enamestr
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|edata_d
operator|=
name|xmalloc
argument_list|(
name|edata_sz
argument_list|)
expr_stmt|;
comment|/* Note use of array pointer math here.  */
name|edirectory
operator|=
name|edata_d
expr_stmt|;
name|eaddresses
operator|=
name|edata_d
operator|+
literal|40
expr_stmt|;
name|enameptrs
operator|=
name|eaddresses
operator|+
literal|4
operator|*
name|export_table_size
expr_stmt|;
name|eordinals
operator|=
name|enameptrs
operator|+
literal|4
operator|*
name|count_exported_byname
expr_stmt|;
name|enamestr
operator|=
name|eordinals
operator|+
literal|2
operator|*
name|count_exported_byname
expr_stmt|;
define|#
directive|define
name|ERVA
parameter_list|(
name|ptr
parameter_list|)
value|(((unsigned char *)(ptr) - edata_d) \ 		   + edata_s->output_section->vma - image_base)
name|memset
argument_list|(
name|edata_d
argument_list|,
literal|0
argument_list|,
name|edata_sz
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|now
argument_list|,
name|edata_d
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|version_major
operator|!=
operator|-
literal|1
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|,
name|edata_d
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|pe_def_file
operator|->
name|version_minor
argument_list|,
name|edata_d
operator|+
literal|10
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enamestr
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|12
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|enamestr
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
name|enamestr
operator|+=
name|strlen
argument_list|(
name|enamestr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|min_ordinal
argument_list|,
name|edata_d
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|export_table_size
argument_list|,
name|edata_d
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|count_exported_byname
argument_list|,
name|edata_d
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|eaddresses
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|28
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enameptrs
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|32
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|eordinals
argument_list|)
argument_list|,
name|edata_d
operator|+
literal|36
argument_list|)
expr_stmt|;
name|fill_exported_offsets
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Ok, now for the filling in part.      Scan alphabetically - ie the ordering in the exports[] table,      rather than by ordinal - the ordering in the exported_symbol[]      table.  See dlltool.c and:         http://sources.redhat.com/ml/binutils/2003-04/msg00379.html      for more information.  */
name|hint
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|NE
condition|;
name|s
operator|++
control|)
block|{
name|struct
name|bfd_section
modifier|*
name|ssec
init|=
name|exported_symbol_sections
index|[
name|s
index|]
decl_stmt|;
if|if
condition|(
name|ssec
operator|&&
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|ordinal
operator|!=
operator|-
literal|1
condition|)
block|{
name|unsigned
name|long
name|srva
init|=
operator|(
name|exported_symbol_offsets
index|[
name|s
index|]
operator|+
name|ssec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ssec
operator|->
name|output_offset
operator|)
decl_stmt|;
name|int
name|ord
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|ordinal
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|srva
operator|-
name|image_base
argument_list|,
name|eaddresses
operator|+
literal|4
operator|*
operator|(
name|ord
operator|-
name|min_ordinal
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|flag_noname
condition|)
block|{
name|char
modifier|*
name|ename
init|=
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|name
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|ERVA
argument_list|(
name|enamestr
argument_list|)
argument_list|,
name|enameptrs
argument_list|)
expr_stmt|;
name|enameptrs
operator|+=
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|enamestr
argument_list|,
name|ename
argument_list|)
expr_stmt|;
name|enamestr
operator|+=
name|strlen
argument_list|(
name|enamestr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|ord
operator|-
name|min_ordinal
argument_list|,
name|eordinals
argument_list|)
expr_stmt|;
name|eordinals
operator|+=
literal|2
expr_stmt|;
name|pe_def_file
operator|->
name|exports
index|[
name|s
index|]
operator|.
name|hint
operator|=
name|hint
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bfd_section
modifier|*
name|current_sec
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pe_walk_relocs_of_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|arelent
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
parameter_list|)
block|{
name|bfd
modifier|*
name|b
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|int
name|nsyms
decl_stmt|,
name|symsize
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|b
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|int
name|relsize
decl_stmt|,
name|nrelocs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
decl_stmt|;
comment|/* Skip discarded linkonce sections.  */
if|if
condition|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|&&
name|s
operator|->
name|output_section
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
name|current_sec
operator|=
name|s
expr_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|nrelocs
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelocs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bfd_symbol
modifier|*
name|sym
init|=
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|sym
operator|->
name|name
argument_list|)
condition|)
name|cb
argument_list|(
name|relocs
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
comment|/* Warning: the allocated symbols are remembered in BFD and reused 	     later, so don't free them! */
comment|/* free (symbols); */
block|}
block|}
block|}
end_function

begin_comment
comment|/* Gather all the relocations and build the .reloc section.  */
end_comment

begin_function
specifier|static
name|void
name|generate_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* For .reloc stuff.  */
name|reloc_data_type
modifier|*
name|reloc_data
decl_stmt|;
name|int
name|total_relocs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|sec_page
init|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|page_ptr
decl_stmt|,
name|page_count
decl_stmt|;
name|int
name|bi
decl_stmt|;
name|bfd
modifier|*
name|b
decl_stmt|;
name|struct
name|bfd_section
modifier|*
name|s
decl_stmt|;
name|total_relocs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|link_next
control|)
for|for
control|(
name|s
operator|=
name|b
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|total_relocs
operator|+=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|reloc_data
operator|=
name|xmalloc
argument_list|(
name|total_relocs
operator|*
sizeof|sizeof
argument_list|(
name|reloc_data_type
argument_list|)
argument_list|)
expr_stmt|;
name|total_relocs
operator|=
literal|0
expr_stmt|;
name|bi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bi
operator|=
literal|0
operator|,
name|b
operator|=
name|info
operator|->
name|input_bfds
init|;
name|b
condition|;
name|bi
operator|++
operator|,
name|b
operator|=
name|b
operator|->
name|link_next
control|)
block|{
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
name|int
name|relsize
decl_stmt|,
name|nrelocs
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|s
operator|=
name|b
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|unsigned
name|long
name|sec_vma
init|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|int
name|nsyms
decl_stmt|,
name|symsize
decl_stmt|;
comment|/* If it's not loaded, we don't need to relocate it this way.  */
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
continue|continue;
comment|/* I don't know why there would be a reloc for these, but I've 	     seen it happen - DJ  */
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
operator|&
name|bfd_abs_section
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|==
literal|0
condition|)
block|{
comment|/* Huh?  Shouldn't happen, but punt if it does.  */
name|einfo
argument_list|(
literal|"DJ: zero vma section reloc detected: `%s' #%d f=%d\n"
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|name
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|index
argument_list|,
name|s
operator|->
name|output_section
operator|->
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|symbols
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|b
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|nrelocs
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrelocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
block|{
name|struct
name|bfd_symbol
modifier|*
name|sym
init|=
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|printf
argument_list|(
literal|"rel: %s\n"
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|pc_relative
operator|&&
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|type
operator|!=
name|pe_details
operator|->
name|imagebase_reloc
condition|)
block|{
name|bfd_vma
name|sym_vma
decl_stmt|;
name|struct
name|bfd_symbol
modifier|*
name|sym
init|=
operator|*
name|relocs
index|[
name|i
index|]
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|sym_vma
operator|=
operator|(
name|relocs
index|[
name|i
index|]
operator|->
name|addend
operator|+
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
operator|+
name|sym
operator|->
name|section
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|vma
operator|=
name|sec_vma
operator|+
name|relocs
index|[
name|i
index|]
operator|->
name|address
expr_stmt|;
define|#
directive|define
name|BITS_AND_SHIFT
parameter_list|(
name|bits
parameter_list|,
name|shift
parameter_list|)
value|(bits * 1000 | shift)
switch|switch BITS_AND_SHIFT
condition|(
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|bitsize
operator|,
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|rightshift
condition|)
block|{
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|3
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|2
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|4
expr_stmt|;
comment|/* FIXME: we can't know the symbol's right value 			 yet, but we probably can safely assume that 			 CE will relocate us in 64k blocks, so leaving 			 it zero is safe.  */
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|26
argument_list|,
literal|2
argument_list|)
case|:
name|reloc_data
index|[
name|total_relocs
index|]
operator|.
name|type
operator|=
literal|5
expr_stmt|;
name|total_relocs
operator|++
expr_stmt|;
break|break;
case|case
name|BITS_AND_SHIFT
argument_list|(
literal|24
argument_list|,
literal|2
argument_list|)
case|:
comment|/* FIXME: 0 is ARM_26D, it is defined in bfd/coff-arm.c 			 Those ARM_xxx definitions should go in proper 			 header someday.  */
if|if
condition|(
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|type
operator|==
literal|0
comment|/* Older GNU linkers used 5 instead of 0 for this reloc.  */
operator|||
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|type
operator|==
literal|5
condition|)
comment|/* This is an ARM_26D reloc, which is an ARM_26 reloc 			   that has already been fully processed during a 			   previous link stage, so ignore it here.  */
break|break;
comment|/* Fall through.  */
default|default:
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XError: %d-bit reloc in dll\n"
argument_list|)
argument_list|,
name|relocs
index|[
name|i
index|]
operator|->
name|howto
operator|->
name|bitsize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
comment|/* Warning: the allocated symbols are remembered in BFD and 	     reused later, so don't free them!  */
if|#
directive|if
literal|0
block|free (symbol);
endif|#
directive|endif
block|}
block|}
comment|/* At this point, we have total_relocs relocation addresses in      reloc_addresses, which are all suitable for the .reloc section.      We must now create the new sections.  */
name|qsort
argument_list|(
name|reloc_data
argument_list|,
name|total_relocs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reloc_data
argument_list|)
argument_list|,
name|reloc_sort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_relocs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|this_page
init|=
operator|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|vma
operator|>>
literal|12
operator|)
decl_stmt|;
if|if
condition|(
name|this_page
operator|!=
name|sec_page
condition|)
block|{
name|reloc_sz
operator|=
operator|(
name|reloc_sz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 4-byte align.  */
name|reloc_sz
operator|+=
literal|8
expr_stmt|;
name|sec_page
operator|=
name|this_page
expr_stmt|;
block|}
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|4
condition|)
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
block|}
name|reloc_sz
operator|=
operator|(
name|reloc_sz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 4-byte align.  */
name|reloc_d
operator|=
name|xmalloc
argument_list|(
name|reloc_sz
argument_list|)
expr_stmt|;
name|sec_page
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|reloc_sz
operator|=
literal|0
expr_stmt|;
name|page_ptr
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_relocs
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|rva
init|=
name|reloc_data
index|[
name|i
index|]
operator|.
name|vma
operator|-
name|image_base
decl_stmt|;
name|unsigned
name|long
name|this_page
init|=
operator|(
name|rva
operator|&
operator|~
literal|0xfff
operator|)
decl_stmt|;
if|if
condition|(
name|this_page
operator|!=
name|sec_page
condition|)
block|{
while|while
condition|(
name|reloc_sz
operator|&
literal|3
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|page_ptr
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_sz
operator|-
name|page_ptr
argument_list|,
name|reloc_d
operator|+
name|page_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|this_page
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|page_ptr
operator|=
name|reloc_sz
expr_stmt|;
name|reloc_sz
operator|+=
literal|8
expr_stmt|;
name|sec_page
operator|=
name|this_page
expr_stmt|;
name|page_count
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|rva
operator|&
literal|0xfff
operator|)
operator|+
operator|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|<<
literal|12
operator|)
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|reloc_data
index|[
name|i
index|]
operator|.
name|type
operator|==
literal|4
condition|)
block|{
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|reloc_data
index|[
name|i
index|]
operator|.
name|extra
argument_list|,
name|reloc_d
operator|+
name|reloc_sz
argument_list|)
expr_stmt|;
name|reloc_sz
operator|+=
literal|2
expr_stmt|;
block|}
name|page_count
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|reloc_sz
operator|&
literal|3
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|page_ptr
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|reloc_sz
operator|-
name|page_ptr
argument_list|,
name|reloc_d
operator|+
name|page_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|reloc_sz
operator|<
name|reloc_s
operator|->
name|_raw_size
condition|)
name|reloc_d
index|[
name|reloc_sz
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the exiting def_file structure, print out a .DEF file that    corresponds to it.  */
end_comment

begin_function
specifier|static
name|void
name|quoteput
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|needs_quotes
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|s
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\''
operator|||
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|||
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|','
operator|||
operator|*
name|cp
operator|==
literal|';'
condition|)
name|needs_quotes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|needs_quotes
condition|)
block|{
name|putc
argument_list|(
literal|'"'
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
operator|||
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'"'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|s
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_dll_generate_def_file
parameter_list|(
specifier|const
name|char
modifier|*
name|pe_out_def_filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|fopen
argument_list|(
name|pe_out_def_filename
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%s: Can't open output def file %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|pe_out_def_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|name
condition|)
block|{
if|if
condition|(
name|pe_def_file
operator|->
name|is_dll
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"LIBRARY "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"NAME "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" BASE=0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pe_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|description
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"DESCRIPTION "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|description
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|version_minor
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"VERSION %d.%d\n"
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|,
name|pe_def_file
operator|->
name|version_minor
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|version_major
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"VERSION %d\n"
argument_list|,
name|pe_def_file
operator|->
name|version_major
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|stack_reserve
operator|!=
operator|-
literal|1
operator|||
name|pe_def_file
operator|->
name|heap_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|stack_commit
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"STACKSIZE 0x%x,0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|stack_reserve
argument_list|,
name|pe_def_file
operator|->
name|stack_commit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|stack_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"STACKSIZE 0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|stack_reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|heap_commit
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"HEAPSIZE 0x%x,0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|heap_reserve
argument_list|,
name|pe_def_file
operator|->
name|heap_commit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pe_def_file
operator|->
name|heap_reserve
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"HEAPSIZE 0x%x\n"
argument_list|,
name|pe_def_file
operator|->
name|heap_reserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|num_section_defs
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nSECTIONS\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_section_defs
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|class
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" CLASS "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_read
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" READ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_write
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" WRITE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_execute
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" EXECUTE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|section_defs
index|[
name|i
index|]
operator|.
name|flag_shared
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" SHARED"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|num_exports
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"EXPORTS\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
name|def_file_export
modifier|*
name|e
init|=
name|pe_def_file
operator|->
name|exports
operator|+
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|internal_name
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|internal_name
argument_list|,
name|e
operator|->
name|name
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
name|quoteput
argument_list|(
name|e
operator|->
name|internal_name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|ordinal
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" @%d"
argument_list|,
name|e
operator|->
name|ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_private
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" PRIVATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_constant
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" CONSTANT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_noname
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" NONAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flag_data
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" DATA"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pe_def_file
operator|->
name|num_imports
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nIMPORTS\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_imports
condition|;
name|i
operator|++
control|)
block|{
name|def_file_import
modifier|*
name|im
init|=
name|pe_def_file
operator|->
name|imports
operator|+
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|internal_name
operator|&&
operator|(
operator|!
name|im
operator|->
name|name
operator|||
name|strcmp
argument_list|(
name|im
operator|->
name|internal_name
argument_list|,
name|im
operator|->
name|name
argument_list|)
operator|)
condition|)
block|{
name|quoteput
argument_list|(
name|im
operator|->
name|internal_name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
block|}
name|quoteput
argument_list|(
name|im
operator|->
name|module
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|im
operator|->
name|name
condition|)
name|quoteput
argument_list|(
name|im
operator|->
name|name
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%d"
argument_list|,
name|im
operator|->
name|ordinal
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
name|_
argument_list|(
literal|"; no contents available\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error closing file `%s'\n"
argument_list|)
argument_list|,
name|pe_out_def_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the import library.  */
end_comment

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tmp_seq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dll_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dll_symname
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNDSEC
value|(asection *)&bfd_und_section
end_define

begin_function
specifier|static
name|asection
modifier|*
name|quick_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|flags
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_KEEP
argument_list|)
expr_stmt|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Remember to undo this before trying to link internally!  */
name|sec
operator|->
name|output_section
operator|=
name|sec
expr_stmt|;
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symtab
index|[
name|symptr
operator|++
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|sec
operator|->
name|name
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|sec
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|quick_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|n1
parameter_list|,
specifier|const
name|char
modifier|*
name|n2
parameter_list|,
specifier|const
name|char
modifier|*
name|n3
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|n1
argument_list|)
operator|+
name|strlen
argument_list|(
name|n2
argument_list|)
operator|+
name|strlen
argument_list|(
name|n3
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|n3
argument_list|)
expr_stmt|;
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|sec
expr_stmt|;
name|sym
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|sym
operator|->
name|value
operator|=
name|addr
expr_stmt|;
name|symtab
index|[
name|symptr
operator|++
index|]
operator|=
name|sym
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|arelent
modifier|*
name|reltab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|relcount
init|=
literal|0
decl_stmt|,
name|relsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|quick_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|address
parameter_list|,
name|int
name|which_howto
parameter_list|,
name|int
name|symidx
parameter_list|)
block|{
if|if
condition|(
name|relcount
operator|>=
name|relsize
operator|-
literal|1
condition|)
block|{
name|relsize
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|reltab
condition|)
name|reltab
operator|=
name|xrealloc
argument_list|(
name|reltab
argument_list|,
name|relsize
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reltab
operator|=
name|xmalloc
argument_list|(
name|relsize
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reltab
index|[
name|relcount
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|which_howto
argument_list|)
expr_stmt|;
name|reltab
index|[
name|relcount
index|]
operator|.
name|sym_ptr_ptr
operator|=
name|symtab
operator|+
name|symidx
expr_stmt|;
name|relcount
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sec
operator|->
name|relocation
operator|=
name|reltab
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|=
name|relcount
expr_stmt|;
name|sec
operator|->
name|orelocation
operator|=
name|xmalloc
argument_list|(
operator|(
name|relcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relcount
condition|;
name|i
operator|++
control|)
name|sec
operator|->
name|orelocation
index|[
name|i
index|]
operator|=
name|sec
operator|->
name|relocation
operator|+
name|i
expr_stmt|;
name|sec
operator|->
name|orelocation
index|[
name|relcount
index|]
operator|=
literal|0
expr_stmt|;
name|sec
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|reltab
operator|=
literal|0
expr_stmt|;
name|relcount
operator|=
name|relsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*	.section	.idata$2  	.global		__head_my_dll    __head_my_dll:  	.rva		hname  	.long		0  	.long		0  	.rva		__my_dll_iname  	.rva		fthunk   	.section	.idata$5  	.long		0    fthunk:   	.section	.idata$4  	.long		0    hname:                              */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_head
parameter_list|(
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|id2
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id4
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d2
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d4
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id2
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$2"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_head_"
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|""
argument_list|,
name|id2
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|"_iname"
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* OK, pay attention here.  I got confused myself looking back at      it.  We create a four-byte section to mark the beginning of the      list, and we include an offset of 4 in the section, so that the      pointer to the list points to the *end* of this section, which is      the start of the list of sections from other objects.  */
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id2
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|d2
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|id2
operator|->
name|contents
operator|=
name|d2
expr_stmt|;
name|memset
argument_list|(
name|d2
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|d2
index|[
literal|0
index|]
operator|=
name|d2
index|[
literal|16
index|]
operator|=
literal|4
expr_stmt|;
comment|/* Reloc addend.  */
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|16
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id2
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id2
argument_list|,
name|d2
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*	.section	.idata$4  	.long		0  	.section	.idata$5  	.long		0  	.section	idata$7  	.global		__my_dll_iname   __my_dll_iname:  	.asciz		"my.dll"       */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_tail
parameter_list|(
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|id4
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id7
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d4
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d7
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id7
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$7"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|"_iname"
argument_list|,
name|id7
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dll_filename
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d7
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|id7
operator|->
name|contents
operator|=
name|d7
expr_stmt|;
name|strcpy
argument_list|(
name|d7
argument_list|,
name|dll_filename
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|d7
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*	.text  	.global		_function  	.global		___imp_function  	.global		__imp__function   _function:  	jmp		*__imp__function:   	.section	idata$7  	.long		__head_my_dll   	.section	.idata$5   ___imp_function:   __imp__function:   iat?   	.section	.idata$4   iat?  	.section	.idata$6   ID<ordinal>:  	.short<hint>  	.asciz		"function" xlate? (add underscore, kill at)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_ix86_bytes
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x90
block|,
literal|0x90
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _function:  	mov.l	ip+8,r0  	mov.l	@r0,r0  	jmp	@r0  	nop  	.dw	__imp_function   */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_sh_bytes
index|[]
init|=
block|{
literal|0x01
block|,
literal|0xd0
block|,
literal|0x02
block|,
literal|0x60
block|,
literal|0x2b
block|,
literal|0x40
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _function:  	lui	$t0,<high:__imp_function>  	lw	$t0,<low:__imp_function>  	jr	$t0  	nop                              */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|jmp_mips_bytes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x3c
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x08
block|,
literal|0x8d
block|,
literal|0x08
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd
modifier|*
name|make_one
parameter_list|(
name|def_file_export
modifier|*
name|exp
parameter_list|,
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|tx
decl_stmt|,
modifier|*
name|id7
decl_stmt|,
modifier|*
name|id5
decl_stmt|,
modifier|*
name|id4
decl_stmt|,
modifier|*
name|id6
decl_stmt|;
name|unsigned
name|char
modifier|*
name|td
init|=
name|NULL
decl_stmt|,
modifier|*
name|d7
decl_stmt|,
modifier|*
name|d5
decl_stmt|,
modifier|*
name|d4
decl_stmt|,
modifier|*
name|d6
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|jmp_bytes
init|=
name|NULL
decl_stmt|;
name|int
name|jmp_byte_count
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pe_details
operator|->
name|pe_arch
condition|)
block|{
case|case
name|PE_ARCH_i386
case|:
name|jmp_bytes
operator|=
name|jmp_ix86_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_ix86_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_sh
case|:
name|jmp_bytes
operator|=
name|jmp_sh_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_sh_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_mips
case|:
name|jmp_bytes
operator|=
name|jmp_mips_bytes
expr_stmt|;
name|jmp_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|jmp_mips_bytes
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"d%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|11
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|,
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id7
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$7"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id5
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$5"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|id6
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$6"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|exp
operator|->
name|internal_name
operator|==
literal|'@'
condition|)
block|{
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_head_"
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_data
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
literal|""
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|tx
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_imp_"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id5
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fastcall applies only to functions, 	 so no need for auto-import symbol.  */
block|}
else|else
block|{
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_head_"
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_data
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|tx
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_imp__"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id5
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Symbol to reference ord/name of imported 	 data symbol, used to implement auto-import.  */
if|if
condition|(
name|exp
operator|->
name|flag_data
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_nm__"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id6
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pe_dll_compat_implib
condition|)
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"__imp_"
argument_list|)
argument_list|,
name|exp
operator|->
name|internal_name
argument_list|,
literal|""
argument_list|,
name|id5
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_data
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|tx
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|td
operator|=
name|xmalloc
argument_list|(
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|tx
operator|->
name|contents
operator|=
name|td
expr_stmt|;
name|memcpy
argument_list|(
name|td
argument_list|,
name|jmp_bytes
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pe_details
operator|->
name|pe_arch
condition|)
block|{
case|case
name|PE_ARCH_i386
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_sh
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|8
argument_list|,
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PE_ARCH_mips
case|:
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_HI16_S
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MIPS_R_PAIR */
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|BFD_RELOC_LO16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|save_relocs
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d7
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id7
operator|->
name|contents
operator|=
name|d7
expr_stmt|;
name|memset
argument_list|(
name|d7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id7
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d5
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id5
operator|->
name|contents
operator|=
name|d5
expr_stmt|;
name|memset
argument_list|(
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|d5
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|d5
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|d5
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id5
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|d4
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|d4
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|ordinal
expr_stmt|;
name|d4
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|ordinal
operator|>>
literal|8
expr_stmt|;
name|d4
index|[
literal|3
index|]
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|->
name|flag_noname
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|exp
operator|->
name|name
argument_list|)
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d6
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|id6
operator|->
name|contents
operator|=
name|d6
expr_stmt|;
name|memset
argument_list|(
name|d6
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|d6
index|[
literal|0
index|]
operator|=
name|exp
operator|->
name|hint
operator|&
literal|0xff
expr_stmt|;
name|d6
index|[
literal|1
index|]
operator|=
name|exp
operator|->
name|hint
operator|>>
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|d6
operator|+
literal|2
argument_list|,
name|exp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|tx
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
name|jmp_byte_count
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id7
argument_list|,
name|d7
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id5
argument_list|,
name|d5
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|flag_noname
condition|)
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id6
argument_list|,
name|d6
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
specifier|static
name|bfd
modifier|*
name|make_singleton_name_thunk
parameter_list|(
specifier|const
name|char
modifier|*
name|import
parameter_list|,
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
comment|/* Name thunks go to idata$4.  */
name|asection
modifier|*
name|id4
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d4
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"nmth%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id4
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$4"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_nm_thnk_"
argument_list|)
argument_list|,
name|import
argument_list|,
literal|""
argument_list|,
name|id4
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_nm_"
argument_list|)
argument_list|,
name|import
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|d4
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|id4
operator|->
name|contents
operator|=
name|d4
expr_stmt|;
name|memset
argument_list|(
name|d4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id4
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id4
argument_list|,
name|d4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|make_import_fixup_mark
parameter_list|(
name|arelent
modifier|*
name|rel
parameter_list|)
block|{
comment|/* We convert reloc to symbol, for later reference.  */
specifier|static
name|int
name|counter
decl_stmt|;
specifier|static
name|char
modifier|*
name|fixup_name
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|buffer_len
init|=
literal|0
decl_stmt|;
name|struct
name|bfd_symbol
modifier|*
name|sym
init|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|bfd_asymbol_bfd
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
if|if
condition|(
operator|!
name|fixup_name
condition|)
block|{
name|fixup_name
operator|=
name|xmalloc
argument_list|(
literal|384
argument_list|)
expr_stmt|;
name|buffer_len
operator|=
literal|384
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
operator|+
literal|25
operator|>
name|buffer_len
condition|)
comment|/* Assume 25 chars for "__fu" + counter + "_".  If counter is      bigger than 20 digits long, we've got worse problems than      overflowing this buffer...  */
block|{
name|free
argument_list|(
name|fixup_name
argument_list|)
expr_stmt|;
comment|/* New buffer size is length of symbol, plus 25, but 	 then rounded up to the nearest multiple of 128.  */
name|buffer_len
operator|=
operator|(
operator|(
name|strlen
argument_list|(
name|sym
operator|->
name|name
argument_list|)
operator|+
literal|25
operator|)
operator|+
literal|127
operator|)
operator|&
operator|~
literal|127
expr_stmt|;
name|fixup_name
operator|=
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|fixup_name
argument_list|,
literal|"__fu%d_%s"
argument_list|,
name|counter
operator|++
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
name|bfd_coff_link_add_one_symbol
argument_list|(
operator|&
name|link_info
argument_list|,
name|abfd
argument_list|,
name|fixup_name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|current_sec
argument_list|,
comment|/* sym->section, */
name|rel
operator|->
name|address
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|myh
decl_stmt|;
name|myh
operator|=
operator|(
expr|struct
name|coff_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|printf
argument_list|(
literal|"type:%d\n"
argument_list|,
name|myh
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|myh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|fixup_name
return|;
block|}
end_function

begin_comment
comment|/*	.section	.idata$3   	.rva		__nm_thnk_SYM (singleton thunk with name of func)  	.long		0  	.long		0  	.rva		__my_dll_iname (name of dll)  	.rva		__fuNN_SYM (pointer to reference (address) in text)  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_import_fixup_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|fixup_name
parameter_list|,
specifier|const
name|char
modifier|*
name|dll_symname
parameter_list|,
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|id3
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d3
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"fu%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|id3
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".idata$3"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|quick_symbol (abfd, U ("_head_"), dll_symname, "", id2, BSF_GLOBAL, 0);
endif|#
directive|endif
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|"_nm_thnk_"
argument_list|)
argument_list|,
name|name
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|dll_symname
argument_list|,
literal|"_iname"
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
literal|""
argument_list|,
name|fixup_name
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|id3
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|d3
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|id3
operator|->
name|contents
operator|=
name|d3
expr_stmt|;
name|memset
argument_list|(
name|d3
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|12
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|16
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|id3
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|id3
argument_list|,
name|d3
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*	.section	.rdata_runtime_pseudo_reloc  	.long		addend  	.rva		__fuNN_SYM (pointer to reference (address) in text)  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|make_runtime_pseudo_reloc
parameter_list|(
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|fixup_name
parameter_list|,
name|int
name|addend
parameter_list|,
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|rt_rel
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rt_rel_d
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"rtr%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rt_rel
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".rdata_runtime_pseudo_reloc"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
literal|""
argument_list|,
name|fixup_name
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|rt_rel
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|rt_rel_d
operator|=
name|xmalloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|rt_rel
operator|->
name|contents
operator|=
name|rt_rel_d
expr_stmt|;
name|memset
argument_list|(
name|rt_rel_d
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|rt_rel_d
argument_list|)
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|rt_rel
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|rt_rel
argument_list|,
name|rt_rel_d
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_comment
comment|/*	.section	.rdata  	.rva		__pei386_runtime_relocator  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|pe_create_runtime_relocator_reference
parameter_list|(
name|bfd
modifier|*
name|parent
parameter_list|)
block|{
name|asection
modifier|*
name|extern_rt_rel
decl_stmt|;
name|unsigned
name|char
modifier|*
name|extern_rt_rel_d
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|oname
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|oname
argument_list|,
literal|"ertr%06d.o"
argument_list|,
name|tmp_seq
argument_list|)
expr_stmt|;
name|tmp_seq
operator|++
expr_stmt|;
name|abfd
operator|=
name|bfd_create
argument_list|(
name|oname
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|bfd_find_target
argument_list|(
name|pe_details
operator|->
name|object_target
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_make_writable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|pe_details
operator|->
name|bfd_arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symptr
operator|=
literal|0
expr_stmt|;
name|symtab
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|extern_rt_rel
operator|=
name|quick_section
argument_list|(
name|abfd
argument_list|,
literal|".rdata"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quick_symbol
argument_list|(
name|abfd
argument_list|,
literal|""
argument_list|,
literal|"__pei386_runtime_relocator"
argument_list|,
literal|""
argument_list|,
name|UNDSEC
argument_list|,
name|BSF_NO_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|extern_rt_rel
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extern_rt_rel_d
operator|=
name|xmalloc
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|extern_rt_rel
operator|->
name|contents
operator|=
name|extern_rt_rel_d
expr_stmt|;
name|quick_reloc
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|BFD_RELOC_RVA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|save_relocs
argument_list|(
name|extern_rt_rel
argument_list|)
expr_stmt|;
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|symtab
argument_list|,
name|symptr
argument_list|)
expr_stmt|;
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|extern_rt_rel
argument_list|,
name|extern_rt_rel_d
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bfd_make_readable
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
return|;
block|}
end_function

begin_function
name|void
name|pe_create_import_fixup
parameter_list|(
name|arelent
modifier|*
name|rel
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|int
name|addend
parameter_list|)
block|{
name|char
name|buf
index|[
literal|300
index|]
decl_stmt|;
name|struct
name|bfd_symbol
modifier|*
name|sym
init|=
operator|*
name|rel
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|name_thunk_sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|fixup_name
init|=
name|make_import_fixup_mark
argument_list|(
name|rel
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|b
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|U
argument_list|(
literal|"_nm_thnk_%s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name_thunk_sym
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name_thunk_sym
operator|||
name|name_thunk_sym
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
block|{
name|bfd
modifier|*
name|b
init|=
name|make_singleton_name_thunk
argument_list|(
name|name
argument_list|,
name|output_bfd
argument_list|)
decl_stmt|;
name|add_bfd_to_link
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|filename
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
comment|/* If we ever use autoimport, we have to cast text section writable.  */
name|config
operator|.
name|text_read_only
operator|=
name|FALSE
expr_stmt|;
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
block|}
if|if
condition|(
name|addend
operator|==
literal|0
operator|||
name|link_info
operator|.
name|pei386_runtime_pseudo_reloc
condition|)
block|{
specifier|extern
name|char
modifier|*
name|pe_data_import_dll
decl_stmt|;
name|char
modifier|*
name|dll_symname
init|=
name|pe_data_import_dll
condition|?
name|pe_data_import_dll
else|:
literal|"unknown"
decl_stmt|;
name|b
operator|=
name|make_import_fixup_entry
argument_list|(
name|name
argument_list|,
name|fixup_name
argument_list|,
name|dll_symname
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|add_bfd_to_link
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|filename
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|link_info
operator|.
name|pei386_runtime_pseudo_reloc
condition|)
block|{
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"creating runtime pseudo-reloc entry for %s (addend=%d)\n"
argument_list|,
name|fixup_name
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|b
operator|=
name|make_runtime_pseudo_reloc
argument_list|(
name|name
argument_list|,
name|fixup_name
argument_list|,
name|addend
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|add_bfd_to_link
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|filename
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|runtime_pseudo_relocs_created
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|pe_create_runtime_relocator_reference
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|add_bfd_to_link
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|filename
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
name|runtime_pseudo_relocs_created
operator|++
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%C: variable '%T' can't be auto-imported. Please read the documentation for ld's --enable-auto-import for details.\n"
argument_list|)
argument_list|,
name|s
operator|->
name|owner
argument_list|,
name|s
argument_list|,
name|rel
operator|->
name|address
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%X"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|pe_dll_generate_implib
parameter_list|(
name|def_file
modifier|*
name|def
parameter_list|,
specifier|const
name|char
modifier|*
name|impfilename
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd
modifier|*
name|ar_head
decl_stmt|;
name|bfd
modifier|*
name|ar_tail
decl_stmt|;
name|bfd
modifier|*
name|outarch
decl_stmt|;
name|bfd
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|dll_filename
operator|=
operator|(
name|def
operator|->
name|name
operator|)
condition|?
name|def
operator|->
name|name
else|:
name|dll_name
expr_stmt|;
name|dll_symname
operator|=
name|xstrdup
argument_list|(
name|dll_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dll_symname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|dll_symname
index|[
name|i
index|]
argument_list|)
condition|)
name|dll_symname
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|unlink
argument_list|(
name|impfilename
argument_list|)
expr_stmt|;
name|outarch
operator|=
name|bfd_openw
argument_list|(
name|impfilename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outarch
condition|)
block|{
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%XCan't open .lib file: %s\n"
argument_list|)
argument_list|,
name|impfilename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* xgettext:c-format */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"Creating library file: %s\n"
argument_list|)
argument_list|,
name|impfilename
argument_list|)
expr_stmt|;
name|bfd_set_format
argument_list|(
name|outarch
argument_list|,
name|bfd_archive
argument_list|)
expr_stmt|;
name|outarch
operator|->
name|has_armap
operator|=
literal|1
expr_stmt|;
comment|/* Work out a reasonable size of things to put onto one line.  */
name|ar_head
operator|=
name|make_head
argument_list|(
name|outarch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def
operator|->
name|num_exports
condition|;
name|i
operator|++
control|)
block|{
comment|/* The import library doesn't know about the internal name.  */
name|char
modifier|*
name|internal
init|=
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
decl_stmt|;
name|bfd
modifier|*
name|n
decl_stmt|;
comment|/* Don't add PRIVATE entries to import lib.  */
if|if
condition|(
name|pe_def_file
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|flag_private
condition|)
continue|continue;
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|=
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|n
operator|=
name|make_one
argument_list|(
name|def
operator|->
name|exports
operator|+
name|i
argument_list|,
name|outarch
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
name|def
operator|->
name|exports
index|[
name|i
index|]
operator|.
name|internal_name
operator|=
name|internal
expr_stmt|;
block|}
name|ar_tail
operator|=
name|make_tail
argument_list|(
name|outarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_head
operator|==
name|NULL
operator|||
name|ar_tail
operator|==
name|NULL
condition|)
return|return;
comment|/* Now stick them all into the archive.  */
name|ar_head
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|ar_tail
operator|->
name|next
operator|=
name|ar_head
expr_stmt|;
name|head
operator|=
name|ar_tail
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_archive_head
argument_list|(
name|outarch
argument_list|,
name|head
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xbfd_set_archive_head: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|outarch
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xbfd_close %s: %s\n"
argument_list|,
name|impfilename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|bfd
modifier|*
name|n
init|=
name|head
operator|->
name|next
decl_stmt|;
name|bfd_close
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_bfd_to_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|fake_file
decl_stmt|;
name|fake_file
operator|=
name|lang_add_input_file
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_fake_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fake_file
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|ldlang_add_file
argument_list|(
name|fake_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%Xaddsym %s: %s\n"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_process_import_defs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|def_file_module
modifier|*
name|module
decl_stmt|;
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pe_def_file
condition|)
return|return;
for|for
control|(
name|module
operator|=
name|pe_def_file
operator|->
name|modules
init|;
name|module
condition|;
name|module
operator|=
name|module
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|,
name|do_this_dll
decl_stmt|;
name|dll_filename
operator|=
name|module
operator|->
name|name
expr_stmt|;
name|dll_symname
operator|=
name|xstrdup
argument_list|(
name|module
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dll_symname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|dll_symname
index|[
name|i
index|]
argument_list|)
condition|)
name|dll_symname
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|do_this_dll
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pe_def_file
operator|->
name|num_imports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|module
operator|==
name|module
condition|)
block|{
name|def_file_export
name|exp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|blhe
decl_stmt|;
name|int
name|lead_at
init|=
operator|(
operator|*
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
operator|==
literal|'@'
operator|)
decl_stmt|;
comment|/* See if we need this import.  */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
operator|+
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|lead_at
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
literal|""
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|""
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blhe
operator|||
operator|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
if|if
condition|(
name|lead_at
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|"_imp_"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|U
argument_list|(
literal|"_imp__"
argument_list|)
argument_list|,
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
argument_list|)
expr_stmt|;
name|blhe
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|blhe
operator|&&
name|blhe
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|bfd
modifier|*
name|one
decl_stmt|;
comment|/* We do.  */
if|if
condition|(
operator|!
name|do_this_dll
condition|)
block|{
name|bfd
modifier|*
name|ar_head
init|=
name|make_head
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|add_bfd_to_link
argument_list|(
name|ar_head
argument_list|,
name|ar_head
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
name|do_this_dll
operator|=
literal|1
expr_stmt|;
block|}
name|exp
operator|.
name|internal_name
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|internal_name
expr_stmt|;
name|exp
operator|.
name|name
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|exp
operator|.
name|ordinal
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|ordinal
expr_stmt|;
name|exp
operator|.
name|hint
operator|=
name|exp
operator|.
name|ordinal
operator|>=
literal|0
condition|?
name|exp
operator|.
name|ordinal
else|:
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_private
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_constant
operator|=
literal|0
expr_stmt|;
name|exp
operator|.
name|flag_data
operator|=
name|pe_def_file
operator|->
name|imports
index|[
name|i
index|]
operator|.
name|data
expr_stmt|;
name|exp
operator|.
name|flag_noname
operator|=
name|exp
operator|.
name|name
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|one
operator|=
name|make_one
argument_list|(
operator|&
name|exp
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|add_bfd_to_link
argument_list|(
name|one
argument_list|,
name|one
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_this_dll
condition|)
block|{
name|bfd
modifier|*
name|ar_tail
init|=
name|make_tail
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|add_bfd_to_link
argument_list|(
name|ar_tail
argument_list|,
name|ar_tail
operator|->
name|filename
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dll_symname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We were handed a *.DLL file.  Parse it and turn it into a set of    IMPORTS directives in the def file.  Return TRUE if the file was    handled, FALSE if not.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|pe_get16
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|2
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|pe_get32
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|b
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is not currently used.  */
end_comment

begin_endif
unit|static unsigned int pe_as16 (void *ptr) {   unsigned char *b = ptr;    return b[0] + (b[1]<< 8); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|int
name|pe_as32
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|b
init|=
name|ptr
decl_stmt|;
return|return
name|b
index|[
literal|0
index|]
operator|+
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|pe_implied_import_dll
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd
modifier|*
name|dll
decl_stmt|;
name|unsigned
name|long
name|pe_header_offset
decl_stmt|,
name|opthdr_ofs
decl_stmt|,
name|num_entries
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
name|export_rva
decl_stmt|,
name|export_size
decl_stmt|,
name|nsections
decl_stmt|,
name|secptr
decl_stmt|,
name|expptr
decl_stmt|;
name|unsigned
name|long
name|exp_funcbase
decl_stmt|;
name|unsigned
name|char
modifier|*
name|expdata
decl_stmt|,
modifier|*
name|erva
decl_stmt|;
name|unsigned
name|long
name|name_rvas
decl_stmt|,
name|ordinals
decl_stmt|,
name|nexp
decl_stmt|,
name|ordbase
decl_stmt|;
specifier|const
name|char
modifier|*
name|dll_name
decl_stmt|;
comment|/* Initialization with start> end guarantees that is_data      will not be set by mistake, and avoids compiler warning.  */
name|unsigned
name|long
name|data_start
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|data_end
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rdata_start
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|rdata_end
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|bss_start
init|=
literal|1
decl_stmt|;
name|unsigned
name|long
name|bss_end
init|=
literal|0
decl_stmt|;
comment|/* No, I can't use bfd here.  kernel32.dll puts its export table in      the middle of the .rdata section.  */
name|dll
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|pe_details
operator|->
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll
condition|)
block|{
name|einfo
argument_list|(
literal|"%Xopen %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* PEI dlls seem to be bfd_objects.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|dll
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%s: this doesn't appear to be a DLL\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Get pe_header, optional header and numbers of export entries.  */
name|pe_header_offset
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
literal|0x3c
argument_list|)
expr_stmt|;
name|opthdr_ofs
operator|=
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
expr_stmt|;
name|num_entries
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|92
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_entries
operator|<
literal|1
condition|)
comment|/* No exports.  */
return|return
name|FALSE
return|;
name|export_rva
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|96
argument_list|)
expr_stmt|;
name|export_size
operator|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|opthdr_ofs
operator|+
literal|100
argument_list|)
expr_stmt|;
name|nsections
operator|=
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|2
argument_list|)
expr_stmt|;
name|secptr
operator|=
operator|(
name|pe_header_offset
operator|+
literal|4
operator|+
literal|20
operator|+
name|pe_get16
argument_list|(
name|dll
argument_list|,
name|pe_header_offset
operator|+
literal|4
operator|+
literal|16
argument_list|)
operator|)
expr_stmt|;
name|expptr
operator|=
literal|0
expr_stmt|;
comment|/* Get the rva and size of the export section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|secptr1
init|=
name|secptr
operator|+
literal|40
operator|*
name|i
decl_stmt|;
name|unsigned
name|long
name|vaddr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|12
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vsize
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|16
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|fptr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|20
argument_list|)
decl_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|secptr1
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|sname
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
operator|<=
name|export_rva
operator|&&
name|vaddr
operator|+
name|vsize
operator|>
name|export_rva
condition|)
block|{
name|expptr
operator|=
name|fptr
operator|+
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
if|if
condition|(
name|export_rva
operator|+
name|export_size
operator|>
name|vaddr
operator|+
name|vsize
condition|)
name|export_size
operator|=
name|vsize
operator|-
operator|(
name|export_rva
operator|-
name|vaddr
operator|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Scan sections and store the base and size of the      data and bss segments in data/base_start/end.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsections
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|secptr1
init|=
name|secptr
operator|+
literal|40
operator|*
name|i
decl_stmt|;
name|unsigned
name|long
name|vsize
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|8
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|vaddr
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|12
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
name|pe_get32
argument_list|(
name|dll
argument_list|,
name|secptr1
operator|+
literal|36
argument_list|)
decl_stmt|;
name|char
name|sec_name
index|[
literal|9
index|]
decl_stmt|;
name|sec_name
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|secptr1
operator|+
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|sec_name
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|8
argument_list|,
name|dll
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data_start
operator|=
name|vaddr
expr_stmt|;
name|data_end
operator|=
name|vaddr
operator|+
name|vsize
expr_stmt|;
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"%s %s: 0x%08lx-0x%08lx (0x%08lx)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sec_name
argument_list|,
name|vaddr
argument_list|,
name|vaddr
operator|+
name|vsize
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec_name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rdata_start
operator|=
name|vaddr
expr_stmt|;
name|rdata_end
operator|=
name|vaddr
operator|+
name|vsize
expr_stmt|;
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"%s %s: 0x%08lx-0x%08lx (0x%08lx)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sec_name
argument_list|,
name|vaddr
argument_list|,
name|vaddr
operator|+
name|vsize
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bss_start
operator|=
name|vaddr
expr_stmt|;
name|bss_end
operator|=
name|vaddr
operator|+
name|vsize
expr_stmt|;
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"%s %s: 0x%08lx-0x%08lx (0x%08lx)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sec_name
argument_list|,
name|vaddr
argument_list|,
name|vaddr
operator|+
name|vsize
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|expdata
operator|=
name|xmalloc
argument_list|(
name|export_size
argument_list|)
expr_stmt|;
name|bfd_seek
argument_list|(
name|dll
argument_list|,
operator|(
name|file_ptr
operator|)
name|expptr
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bfd_bread
argument_list|(
name|expdata
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|export_size
argument_list|,
name|dll
argument_list|)
expr_stmt|;
name|erva
operator|=
name|expdata
operator|-
name|export_rva
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|==
literal|0
condition|)
name|pe_def_file
operator|=
name|def_file_empty
argument_list|()
expr_stmt|;
name|nexp
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|24
argument_list|)
expr_stmt|;
name|name_rvas
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|32
argument_list|)
expr_stmt|;
name|ordinals
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|36
argument_list|)
expr_stmt|;
name|ordbase
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|16
argument_list|)
expr_stmt|;
name|exp_funcbase
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* Use internal dll name instead of filename      to enable symbolic dll linking.  */
name|dll_name
operator|=
name|pe_as32
argument_list|(
name|expdata
operator|+
literal|12
argument_list|)
operator|+
name|erva
expr_stmt|;
comment|/* Check to see if the dll has already been added to      the definition list and if so return without error.      This avoids multiple symbol definitions.  */
if|if
condition|(
name|def_get_module
argument_list|(
name|pe_def_file
argument_list|,
name|dll_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"%s is already loaded\n"
argument_list|,
name|dll_name
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Iterate through the list of symbols.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexp
condition|;
name|i
operator|++
control|)
block|{
comment|/* Pointer to the names vector.  */
name|unsigned
name|long
name|name_rva
init|=
name|pe_as32
argument_list|(
name|erva
operator|+
name|name_rvas
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
name|def_file_import
modifier|*
name|imp
decl_stmt|;
comment|/* Pointer to the function address vector.  */
name|unsigned
name|long
name|func_rva
init|=
name|pe_as32
argument_list|(
name|erva
operator|+
name|exp_funcbase
operator|+
name|i
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
name|is_data
init|=
literal|0
decl_stmt|;
comment|/* Skip unwanted symbols, which are 	 exported in buggy auto-import releases.  */
if|if
condition|(
name|strncmp
argument_list|(
name|erva
operator|+
name|name_rva
argument_list|,
literal|"_nm_"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* is_data is true if the address is in the data, rdata or bss 	     segment.  */
name|is_data
operator|=
operator|(
name|func_rva
operator|>=
name|data_start
operator|&&
name|func_rva
operator|<
name|data_end
operator|)
operator|||
operator|(
name|func_rva
operator|>=
name|rdata_start
operator|&&
name|func_rva
operator|<
name|rdata_end
operator|)
operator|||
operator|(
name|func_rva
operator|>=
name|bss_start
operator|&&
name|func_rva
operator|<
name|bss_end
operator|)
expr_stmt|;
name|imp
operator|=
name|def_file_add_import
argument_list|(
name|pe_def_file
argument_list|,
name|erva
operator|+
name|name_rva
argument_list|,
name|dll_name
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark symbol type.  */
name|imp
operator|->
name|data
operator|=
name|is_data
expr_stmt|;
if|if
condition|(
name|pe_dll_extra_pe_debug
condition|)
name|printf
argument_list|(
literal|"%s dll-name: %s sym: %s addr: 0x%lx %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dll_name
argument_list|,
name|erva
operator|+
name|name_rva
argument_list|,
name|func_rva
argument_list|,
name|is_data
condition|?
literal|"(data)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* These are the main functions, called from the emulation.  The first    is called after the bfds are read, so we can guess at how much space    we need.  The second is called after everything is placed, so we    can put the right values in place.  */
end_comment

begin_function
name|void
name|pe_dll_build_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|process_def_file
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe_def_file
operator|->
name|num_exports
operator|==
literal|0
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
return|return;
name|generate_edata
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|build_filler_bfd
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_exe_build_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|build_filler_bfd
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_dll_fill_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|image_base
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|generate_reloc
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_sz
operator|>
literal|0
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
name|reloc_sz
argument_list|)
expr_stmt|;
comment|/* Resize the sections.  */
name|lang_size_sections
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|stat_ptr
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Redo special stuff.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Do the assignments again.  */
name|lang_do_assignments
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fill_edata
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|dll
operator|=
literal|1
expr_stmt|;
name|edata_s
operator|->
name|contents
operator|=
name|edata_d
expr_stmt|;
name|reloc_s
operator|->
name|contents
operator|=
name|reloc_d
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe_exe_fill_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|pe_dll_id_target
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|image_base
operator|=
name|pe_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|pe_opthdr
operator|.
name|ImageBase
expr_stmt|;
name|generate_reloc
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_sz
operator|>
literal|0
condition|)
block|{
name|bfd_set_section_size
argument_list|(
name|filler_bfd
argument_list|,
name|reloc_s
argument_list|,
name|reloc_sz
argument_list|)
expr_stmt|;
comment|/* Resize the sections.  */
name|lang_size_sections
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|stat_ptr
operator|->
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Redo special stuff.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Do the assignments again.  */
name|lang_do_assignments
argument_list|(
name|stat_ptr
operator|->
name|head
argument_list|,
name|abs_output_section
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|reloc_s
operator|->
name|contents
operator|=
name|reloc_d
expr_stmt|;
block|}
end_function

end_unit

