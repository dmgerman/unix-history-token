begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This module handles expression trees.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support<sac@cygnus.com>.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module is in charge of working out the contents of expressions.     It has to keep track of the relative/absness of a symbol etc. This    is done by keeping all values in a struct (an etree_value_type)    which contains a value, a section to which it is relative and a    valid bit.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_function_decl
specifier|static
name|etree_value_type
name|exp_fold_tree_no_dot
parameter_list|(
name|etree_type
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
parameter_list|,
name|lang_phase_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|align_n
parameter_list|(
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|exp_data_seg
name|exp_data_seg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the string representation of the given token.  Surround it    with spaces if INFIX_P is TRUE.  */
end_comment

begin_function
specifier|static
name|void
name|exp_print_token
parameter_list|(
name|token_code_type
name|code
parameter_list|,
name|int
name|infix_p
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|token_code_type
name|code
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
block|{
name|INT
block|,
literal|"int"
block|}
block|,
block|{
name|NAME
block|,
literal|"NAME"
block|}
block|,
block|{
name|PLUSEQ
block|,
literal|"+="
block|}
block|,
block|{
name|MINUSEQ
block|,
literal|"-="
block|}
block|,
block|{
name|MULTEQ
block|,
literal|"*="
block|}
block|,
block|{
name|DIVEQ
block|,
literal|"/="
block|}
block|,
block|{
name|LSHIFTEQ
block|,
literal|"<<="
block|}
block|,
block|{
name|RSHIFTEQ
block|,
literal|">>="
block|}
block|,
block|{
name|ANDEQ
block|,
literal|"&="
block|}
block|,
block|{
name|OREQ
block|,
literal|"|="
block|}
block|,
block|{
name|OROR
block|,
literal|"||"
block|}
block|,
block|{
name|ANDAND
block|,
literal|"&&"
block|}
block|,
block|{
name|EQ
block|,
literal|"=="
block|}
block|,
block|{
name|NE
block|,
literal|"!="
block|}
block|,
block|{
name|LE
block|,
literal|"<="
block|}
block|,
block|{
name|GE
block|,
literal|">="
block|}
block|,
block|{
name|LSHIFT
block|,
literal|"<<"
block|}
block|,
block|{
name|RSHIFT
block|,
literal|">>"
block|}
block|,
block|{
name|ALIGN_K
block|,
literal|"ALIGN"
block|}
block|,
block|{
name|BLOCK
block|,
literal|"BLOCK"
block|}
block|,
block|{
name|QUAD
block|,
literal|"QUAD"
block|}
block|,
block|{
name|SQUAD
block|,
literal|"SQUAD"
block|}
block|,
block|{
name|LONG
block|,
literal|"LONG"
block|}
block|,
block|{
name|SHORT
block|,
literal|"SHORT"
block|}
block|,
block|{
name|BYTE
block|,
literal|"BYTE"
block|}
block|,
block|{
name|SECTIONS
block|,
literal|"SECTIONS"
block|}
block|,
block|{
name|SIZEOF_HEADERS
block|,
literal|"SIZEOF_HEADERS"
block|}
block|,
block|{
name|MEMORY
block|,
literal|"MEMORY"
block|}
block|,
block|{
name|DEFINED
block|,
literal|"DEFINED"
block|}
block|,
block|{
name|TARGET_K
block|,
literal|"TARGET"
block|}
block|,
block|{
name|SEARCH_DIR
block|,
literal|"SEARCH_DIR"
block|}
block|,
block|{
name|MAP
block|,
literal|"MAP"
block|}
block|,
block|{
name|ENTRY
block|,
literal|"ENTRY"
block|}
block|,
block|{
name|NEXT
block|,
literal|"NEXT"
block|}
block|,
block|{
name|SIZEOF
block|,
literal|"SIZEOF"
block|}
block|,
block|{
name|ADDR
block|,
literal|"ADDR"
block|}
block|,
block|{
name|LOADADDR
block|,
literal|"LOADADDR"
block|}
block|,
block|{
name|MAX_K
block|,
literal|"MAX_K"
block|}
block|,
block|{
name|REL
block|,
literal|"relocatable"
block|}
block|,
block|{
name|DATA_SEGMENT_ALIGN
block|,
literal|"DATA_SEGMENT_ALIGN"
block|}
block|,
block|{
name|DATA_SEGMENT_END
block|,
literal|"DATA_SEGMENT_END"
block|}
block|}
struct|;
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|table
index|[
name|idx
index|]
operator|.
name|code
operator|==
name|code
condition|)
break|break;
if|if
condition|(
name|infix_p
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|ARRAY_SIZE
argument_list|(
name|table
argument_list|)
condition|)
name|fputs
argument_list|(
name|table
index|[
name|idx
index|]
operator|.
name|name
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|<
literal|127
condition|)
name|fputc
argument_list|(
name|code
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"<code %d>"
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|infix_p
condition|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_abs
parameter_list|(
name|etree_value_type
modifier|*
name|ptr
parameter_list|)
block|{
name|asection
modifier|*
name|s
init|=
name|ptr
operator|->
name|section
operator|->
name|bfd_section
decl_stmt|;
name|ptr
operator|->
name|value
operator|+=
name|s
operator|->
name|vma
expr_stmt|;
name|ptr
operator|->
name|section
operator|=
name|abs_output_section
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_abs
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|abs_output_section
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_intop
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|INT
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_bigintop
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|INT
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing an unnamed relocatable value.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_relop
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|etree_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|REL
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_rel
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_rel
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|section
parameter_list|)
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|section
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_rel_from_section
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|section
parameter_list|)
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|.
name|value
operator|-=
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_unary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|,
name|bfd_vma
name|dot
parameter_list|,
name|bfd_vma
modifier|*
name|dotp
parameter_list|)
block|{
name|etree_value_type
name|result
decl_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
block|{
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ALIGN_K
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
name|result
operator|=
name|new_rel_from_section
argument_list|(
name|align_n
argument_list|(
name|dot
argument_list|,
name|result
operator|.
name|value
argument_list|)
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ABSOLUTE
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|result
operator|.
name|value
operator|+=
name|result
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|result
operator|.
name|section
operator|=
name|abs_output_section
expr_stmt|;
block|}
else|else
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|~
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|!
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|-
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
comment|/* Return next place aligned to value.  */
if|if
condition|(
name|allocation_done
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|dot
argument_list|,
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DATA_SEGMENT_END
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
operator|&&
name|current_section
operator|==
name|abs_output_section
operator|&&
operator|(
name|exp_data_seg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
operator|||
name|exp_data_seg
operator|.
name|phase
operator|==
name|exp_dataseg_adjust
operator|||
name|allocation_done
operator|!=
name|lang_allocating_phase_enum
operator|)
condition|)
block|{
if|if
condition|(
name|exp_data_seg
operator|.
name|phase
operator|==
name|exp_dataseg_align_seen
condition|)
block|{
name|exp_data_seg
operator|.
name|phase
operator|=
name|exp_dataseg_end_seen
expr_stmt|;
name|exp_data_seg
operator|.
name|end
operator|=
name|result
operator|.
name|value
expr_stmt|;
block|}
block|}
else|else
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_binary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|,
name|bfd_vma
name|dot
parameter_list|,
name|bfd_vma
modifier|*
name|dotp
parameter_list|)
block|{
name|etree_value_type
name|result
decl_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
block|{
name|etree_value_type
name|other
decl_stmt|;
name|other
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|valid_p
condition|)
block|{
comment|/* If the values are from different sections, or this is an 	     absolute expression, make both the source arguments 	     absolute.  However, adding or subtracting an absolute 	     value from a relative value is meaningful, and is an 	     exception.  */
if|if
condition|(
name|current_section
operator|!=
name|abs_output_section
operator|&&
operator|(
name|other
operator|.
name|section
operator|==
name|abs_output_section
operator|||
operator|(
name|result
operator|.
name|section
operator|==
name|abs_output_section
operator|&&
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
operator|)
operator|)
operator|&&
operator|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
operator|||
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|section
operator|!=
name|abs_output_section
condition|)
block|{
comment|/* Keep the section of the other term.  */
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
condition|)
name|other
operator|.
name|value
operator|=
name|result
operator|.
name|value
operator|+
name|other
operator|.
name|value
expr_stmt|;
else|else
name|other
operator|.
name|value
operator|=
name|result
operator|.
name|value
operator|-
name|other
operator|.
name|value
expr_stmt|;
return|return
name|other
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|section
operator|!=
name|other
operator|.
name|section
operator|||
name|current_section
operator|==
name|abs_output_section
condition|)
block|{
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|make_abs
argument_list|(
operator|&
name|other
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
name|other
operator|.
name|value
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S %% by zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|result
operator|.
name|value
operator|%
operator|(
name|bfd_signed_vma
operator|)
name|other
operator|.
name|value
operator|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|other
operator|.
name|value
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S / by zero\n"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|result
operator|.
name|value
operator|/
operator|(
name|bfd_signed_vma
operator|)
name|other
operator|.
name|value
operator|)
expr_stmt|;
break|break;
define|#
directive|define
name|BOP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|case x : result.value = result.value y other.value; break;
name|BOP
argument_list|(
literal|'+'
argument_list|,
operator|+
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'*'
argument_list|,
operator|*
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'-'
argument_list|,
operator|-
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LSHIFT
argument_list|,
operator|<<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|RSHIFT
argument_list|,
operator|>>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|EQ
argument_list|,
operator|==
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|NE
argument_list|,
operator|!=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'<'
argument_list|,
operator|<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'>'
argument_list|,
operator|>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LE
argument_list|,
operator|<=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|GE
argument_list|,
operator|>=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'&'
argument_list|,
operator|&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'^'
argument_list|,
operator|^
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'|'
argument_list|,
operator||
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|ANDAND
argument_list|,
operator|&&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|OROR
argument_list|,
operator|||
argument_list|)
expr_stmt|;
case|case
name|MAX_K
case|:
if|if
condition|(
name|result
operator|.
name|value
operator|<
name|other
operator|.
name|value
condition|)
name|result
operator|=
name|other
expr_stmt|;
break|break;
case|case
name|MIN_K
case|:
if|if
condition|(
name|result
operator|.
name|value
operator|>
name|other
operator|.
name|value
condition|)
name|result
operator|=
name|other
expr_stmt|;
break|break;
case|case
name|ALIGN_K
case|:
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|result
operator|.
name|value
argument_list|,
name|other
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_SEGMENT_ALIGN
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
operator|&&
name|current_section
operator|==
name|abs_output_section
operator|&&
operator|(
name|exp_data_seg
operator|.
name|phase
operator|==
name|exp_dataseg_none
operator|||
name|exp_data_seg
operator|.
name|phase
operator|==
name|exp_dataseg_adjust
operator|||
name|allocation_done
operator|!=
name|lang_allocating_phase_enum
operator|)
condition|)
block|{
name|bfd_vma
name|maxpage
init|=
name|result
operator|.
name|value
decl_stmt|;
name|result
operator|.
name|value
operator|=
name|align_n
argument_list|(
name|dot
argument_list|,
name|maxpage
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_data_seg
operator|.
name|phase
operator|!=
name|exp_dataseg_adjust
condition|)
block|{
name|result
operator|.
name|value
operator|+=
name|dot
operator|&
operator|(
name|maxpage
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|allocation_done
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|exp_data_seg
operator|.
name|phase
operator|=
name|exp_dataseg_align_seen
expr_stmt|;
name|exp_data_seg
operator|.
name|base
operator|=
name|result
operator|.
name|value
expr_stmt|;
name|exp_data_seg
operator|.
name|pagesize
operator|=
name|other
operator|.
name|value
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|other
operator|.
name|value
operator|<
name|maxpage
condition|)
name|result
operator|.
name|value
operator|+=
operator|(
name|dot
operator|+
name|other
operator|.
name|value
operator|-
literal|1
operator|)
operator|&
operator|(
name|maxpage
operator|-
name|other
operator|.
name|value
operator|)
expr_stmt|;
block|}
else|else
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_trinary
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|,
name|bfd_vma
name|dot
parameter_list|,
name|bfd_vma
modifier|*
name|dotp
parameter_list|)
block|{
name|etree_value_type
name|result
decl_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
name|result
operator|=
name|exp_fold_tree
argument_list|(
operator|(
name|result
operator|.
name|value
condition|?
name|tree
operator|->
name|trinary
operator|.
name|lhs
else|:
name|tree
operator|->
name|trinary
operator|.
name|rhs
operator|)
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_name
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|,
name|bfd_vma
name|dot
parameter_list|)
block|{
name|etree_value_type
name|result
decl_stmt|;
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|SIZEOF_HEADERS
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
name|result
operator|=
name|new_abs
argument_list|(
name|bfd_sizeof_headers
argument_list|(
name|output_bfd
argument_list|,
name|link_info
operator|.
name|relocatable
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINED
case|:
if|if
condition|(
name|allocation_done
operator|==
name|lang_first_phase_enum
condition|)
name|lang_track_definedness
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|def_iteration
init|=
name|lang_symbol_definition_iteration
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|&&
operator|(
name|def_iteration
operator|==
name|lang_statement_iteration
operator|||
name|def_iteration
operator|==
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|section
operator|=
name|abs_output_section
expr_stmt|;
name|result
operator|.
name|valid_p
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|NAME
case|:
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
name|result
operator|=
name|new_rel_from_section
argument_list|(
name|dot
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
name|result
operator|=
name|new_abs
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allocation_done
operator|==
name|lang_final_phase_enum
operator|||
name|allocation_done
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|output_section
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%S: unresolvable symbol `%s' referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|(
name|lang_output_section_statement_lookup
argument_list|(
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* FIXME: Is this correct if this section is 			 being linked with -R?  */
name|result
operator|=
name|new_rel
argument_list|(
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|allocation_done
operator|==
name|lang_final_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: undefined symbol `%s' referenced in expression\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ADDR
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|&&
name|os
operator|->
name|processed
operator|>
literal|0
condition|)
name|result
operator|=
name|new_rel
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOADADDR
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|&&
name|os
operator|->
name|processed
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|result
operator|=
name|new_rel
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|os
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|os
operator|->
name|load_base
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIZEOF
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|int
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|&&
name|os
operator|->
name|processed
operator|>
literal|0
condition|)
name|result
operator|=
name|new_abs
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|/
name|opb
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|etree_value_type
name|exp_fold_tree
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|,
name|bfd_vma
name|dot
parameter_list|,
name|bfd_vma
modifier|*
name|dotp
parameter_list|)
block|{
name|etree_value_type
name|result
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|result
operator|=
name|new_rel
argument_list|(
name|tree
operator|->
name|value
operator|.
name|value
argument_list|,
name|tree
operator|->
name|value
operator|.
name|str
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_rel
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_final_phase_enum
condition|)
name|result
operator|.
name|valid_p
operator|=
name|FALSE
expr_stmt|;
else|else
name|result
operator|=
name|new_rel
argument_list|(
operator|(
name|tree
operator|->
name|rel
operator|.
name|value
operator|+
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_offset
operator|)
argument_list|,
name|NULL
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assert
case|:
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|assert_s
operator|.
name|child
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|value
condition|)
name|einfo
argument_list|(
literal|"%F%P: %s\n"
argument_list|,
name|tree
operator|->
name|assert_s
operator|.
name|message
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
case|case
name|etree_unary
case|:
name|result
operator|=
name|fold_unary
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|result
operator|=
name|fold_binary
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|result
operator|=
name|fold_trinary
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assign
case|:
case|case
name|etree_provide
case|:
case|case
name|etree_provided
case|:
if|if
condition|(
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Assignment to dot can only be done during allocation.  */
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_assign
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S can not PROVIDE assignment to location counter\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocation_done
operator|==
name|lang_allocating_phase_enum
operator|||
operator|(
name|allocation_done
operator|==
name|lang_final_phase_enum
operator|&&
name|current_section
operator|==
name|abs_output_section
operator|)
condition|)
block|{
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|valid_p
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S invalid assignment to location counter\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_section
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S assignment to location counter invalid outside of SECTION\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|nextdot
decl_stmt|;
name|nextdot
operator|=
operator|(
name|result
operator|.
name|value
operator|+
name|current_section
operator|->
name|bfd_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|nextdot
operator|<
name|dot
operator|&&
name|current_section
operator|!=
name|abs_output_section
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S cannot move location counter backwards (from %V to %V)\n"
argument_list|)
argument_list|,
name|dot
argument_list|,
name|nextdot
argument_list|)
expr_stmt|;
else|else
operator|*
name|dotp
operator|=
name|nextdot
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
block|{
name|bfd_boolean
name|create
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_assign
condition|)
name|create
operator|=
name|TRUE
expr_stmt|;
else|else
name|create
operator|=
name|FALSE
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|create
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|create
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: hash creation failed\n"
argument_list|)
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_new
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
block|{
comment|/* Do nothing.  The symbol was defined by some 		     object.  */
block|}
else|else
block|{
comment|/* FIXME: Should we worry if the symbol is already 		     defined?  */
name|lang_update_definedness
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|result
operator|.
name|value
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|result
operator|.
name|section
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
condition|)
name|tree
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_provided
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|etree_name
case|:
name|result
operator|=
name|fold_name
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|exp_fold_tree_no_dot
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|current_section
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|)
block|{
return|return
name|exp_fold_tree
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_binop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|lhs
parameter_list|,
name|etree_type
modifier|*
name|rhs
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_binary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|abs_output_section
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid_p
condition|)
block|{
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
block|}
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_trinop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|cond
parameter_list|,
name|etree_type
modifier|*
name|lhs
parameter_list|,
name|etree_type
modifier|*
name|rhs
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|cond
operator|=
name|cond
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_trinary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_unop
parameter_list|(
name|int
name|code
parameter_list|,
name|etree_type
modifier|*
name|child
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_unary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|abs_output_section
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_nameop
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_name
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|NULL
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid_p
condition|)
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_assop
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|etree_type
modifier|*
name|src
parameter_list|)
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|assign
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_assign
expr_stmt|;
if|#
directive|if
literal|0
block|if (exp_fold_tree_no_dot (&value,&result))     return exp_intop (result);
endif|#
directive|endif
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Handle PROVIDE.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_provide
parameter_list|(
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|etree_type
modifier|*
name|src
parameter_list|)
block|{
name|etree_type
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|n
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_code
operator|=
literal|'='
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_provide
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Handle ASSERT.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_assert
parameter_list|(
name|etree_type
modifier|*
name|exp
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|etree_type
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|n
operator|->
name|assert_s
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|type
operator|.
name|node_code
operator|=
literal|'!'
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_assert
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|child
operator|=
name|exp
expr_stmt|;
name|n
operator|->
name|assert_s
operator|.
name|message
operator|=
name|message
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|exp_print_tree
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|)
block|{
if|if
condition|(
name|config
operator|.
name|map_file
operator|==
name|NULL
condition|)
name|config
operator|.
name|map_file
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|minfo
argument_list|(
literal|"NULL TREE\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|minfo
argument_list|(
literal|"0x%v"
argument_list|,
name|tree
operator|->
name|value
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_rel
case|:
if|if
condition|(
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%B:"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s+0x%v"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|name
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_assign
case|:
if|#
directive|if
literal|0
block|if (tree->assign.dst->sdefs != NULL) 	fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name, 		 tree->assign.dst->sdefs->value);       else 	fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
endif|#
directive|endif
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_provide
case|:
case|case
name|etree_provided
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"PROVIDE (%s, "
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_print_token
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|type
operator|.
name|node_code
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|unary
operator|.
name|child
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|etree_assert
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"ASSERT ("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assert_s
operator|.
name|child
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|", %s)"
argument_list|,
name|tree
operator|->
name|assert_s
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_undef
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"????????"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
name|NAME
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
condition|)
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" (%s)"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_vma
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|bfd_vma
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|)
block|{
name|etree_value_type
name|r
decl_stmt|;
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|valid_p
operator|&&
name|name
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S nonconstant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|r
operator|.
name|value
return|;
block|}
else|else
return|return
name|def
return|;
block|}
end_function

begin_function
name|int
name|exp_get_value_int
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|int
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|)
block|{
return|return
name|exp_get_vma
argument_list|(
name|tree
argument_list|,
name|def
argument_list|,
name|name
argument_list|,
name|allocation_done
argument_list|)
return|;
block|}
end_function

begin_function
name|fill_type
modifier|*
name|exp_get_fill
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|fill_type
modifier|*
name|def
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|)
block|{
name|fill_type
modifier|*
name|fill
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return
name|def
return|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|valid_p
operator|&&
name|name
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S nonconstant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|str
operator|!=
name|NULL
operator|&&
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|str
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|fill
operator|=
name|xmalloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fill
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fill
operator|->
name|size
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|dst
operator|=
name|fill
operator|->
name|data
expr_stmt|;
name|s
operator|=
name|r
operator|.
name|str
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|digit
decl_stmt|;
name|digit
operator|=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
name|digit
operator|=
operator|(
name|digit
operator|-
literal|'A'
operator|+
literal|'0'
operator|+
literal|10
operator|)
operator|&
literal|0xf
expr_stmt|;
name|val
operator|<<=
literal|4
expr_stmt|;
name|val
operator|+=
name|digit
expr_stmt|;
operator|--
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
name|fill
operator|=
name|xmalloc
argument_list|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fill
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|r
operator|.
name|value
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|0
index|]
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|2
index|]
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|data
index|[
literal|3
index|]
operator|=
operator|(
name|val
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fill
operator|->
name|size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|fill
return|;
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_abs_int
parameter_list|(
name|etree_type
modifier|*
name|tree
parameter_list|,
name|int
name|def
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|lang_phase_type
name|allocation_done
parameter_list|)
block|{
name|etree_value_type
name|res
decl_stmt|;
name|res
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|valid_p
condition|)
name|res
operator|.
name|value
operator|+=
name|res
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S non constant expression for %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|res
operator|.
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|align_n
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|bfd_vma
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
return|return
name|value
return|;
name|value
operator|=
operator|(
name|value
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
expr_stmt|;
return|return
name|value
operator|*
name|align
return|;
block|}
end_function

end_unit

