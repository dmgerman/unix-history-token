begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This module handles expression trees. Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc. Written by Steve Chamberlain of Cygnus Support (sac@cygnus.com).  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module is in charge of working out the contents of expressions.  It has to keep track of the relative/absness of a symbol etc. This is done by keeping all values in a struct (an etree_value_type) which contains a value, a section to which it is relative and a valid bit.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|exp_print_token
name|PARAMS
argument_list|(
operator|(
name|token_code_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_abs
name|PARAMS
argument_list|(
operator|(
name|etree_value_type
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|new_abs
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
name|os
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|op
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|new_rel
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|value
operator|,
name|lang_output_section_statement_type
operator|*
name|section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|new_rel_from_section
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|value
operator|,
name|lang_output_section_statement_type
operator|*
name|section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|fold_binary
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
name|tree
operator|,
name|lang_output_section_statement_type
operator|*
name|current_section
operator|,
name|lang_phase_type
name|allocation_done
operator|,
name|bfd_vma
name|dot
operator|,
name|bfd_vma
operator|*
name|dotp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|fold_name
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
name|tree
operator|,
name|lang_output_section_statement_type
operator|*
name|current_section
operator|,
name|lang_phase_type
name|allocation_done
operator|,
name|bfd_vma
name|dot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|etree_value_type
name|exp_fold_tree_no_dot
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
name|tree
operator|,
name|lang_output_section_statement_type
operator|*
name|current_section
operator|,
name|lang_phase_type
name|allocation_done
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|exp_print_token
parameter_list|(
name|code
parameter_list|)
name|token_code_type
name|code
decl_stmt|;
block|{
specifier|static
name|CONST
expr|struct
block|{
name|token_code_type
name|code
block|;
name|char
operator|*
name|name
block|;     }
name|table
index|[]
operator|=
block|{
block|{
name|INT
block|,
literal|"int"
block|}
block|,
block|{
name|REL
block|,
literal|"relocateable"
block|}
block|,
block|{
name|NAME
block|,
literal|"NAME"
block|}
block|,
block|{
name|PLUSEQ
block|,
literal|"+="
block|}
block|,
block|{
name|MINUSEQ
block|,
literal|"-="
block|}
block|,
block|{
name|MULTEQ
block|,
literal|"*="
block|}
block|,
block|{
name|DIVEQ
block|,
literal|"/="
block|}
block|,
block|{
name|LSHIFTEQ
block|,
literal|"<<="
block|}
block|,
block|{
name|RSHIFTEQ
block|,
literal|">>="
block|}
block|,
block|{
name|ANDEQ
block|,
literal|"&="
block|}
block|,
block|{
name|OREQ
block|,
literal|"|="
block|}
block|,
block|{
name|OROR
block|,
literal|"||"
block|}
block|,
block|{
name|ANDAND
block|,
literal|"&&"
block|}
block|,
block|{
name|EQ
block|,
literal|"=="
block|}
block|,
block|{
name|NE
block|,
literal|"!="
block|}
block|,
block|{
name|LE
block|,
literal|"<="
block|}
block|,
block|{
name|GE
block|,
literal|">="
block|}
block|,
block|{
name|LSHIFT
block|,
literal|"<<"
block|}
block|,
block|{
name|RSHIFT
block|,
literal|">>="
block|}
block|,
block|{
name|ALIGN_K
block|,
literal|"ALIGN"
block|}
block|,
block|{
name|BLOCK
block|,
literal|"BLOCK"
block|}
block|,
block|{
name|SECTIONS
block|,
literal|"SECTIONS"
block|}
block|,
block|{
name|SIZEOF_HEADERS
block|,
literal|"SIZEOF_HEADERS"
block|}
block|,
block|{
name|NEXT
block|,
literal|"NEXT"
block|}
block|,
block|{
name|SIZEOF
block|,
literal|"SIZEOF"
block|}
block|,
block|{
name|ADDR
block|,
literal|"ADDR"
block|}
block|,
block|{
name|LOADADDR
block|,
literal|"LOADADDR"
block|}
block|,
block|{
name|MEMORY
block|,
literal|"MEMORY"
block|}
block|,
block|{
name|DEFINED
block|,
literal|"DEFINED"
block|}
block|,
block|{
name|TARGET_K
block|,
literal|"TARGET"
block|}
block|,
block|{
name|SEARCH_DIR
block|,
literal|"SEARCH_DIR"
block|}
block|,
block|{
name|MAP
block|,
literal|"MAP"
block|}
block|,
block|{
name|QUAD
block|,
literal|"QUAD"
block|}
block|,
block|{
name|LONG
block|,
literal|"LONG"
block|}
block|,
block|{
name|SHORT
block|,
literal|"SHORT"
block|}
block|,
block|{
name|BYTE
block|,
literal|"BYTE"
block|}
block|,
block|{
name|ENTRY
block|,
literal|"ENTRY"
block|}
block|,
block|{
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
expr_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|table
index|[
name|idx
index|]
operator|.
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|idx
index|]
operator|.
name|code
operator|==
name|code
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|table
index|[
name|idx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Not in table, just print it alone */
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%c"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_abs
parameter_list|(
name|ptr
parameter_list|)
name|etree_value_type
modifier|*
name|ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|s
init|=
name|ptr
operator|->
name|section
operator|->
name|bfd_section
decl_stmt|;
name|ptr
operator|->
name|value
operator|+=
name|s
operator|->
name|vma
expr_stmt|;
name|ptr
operator|->
name|section
operator|=
name|abs_output_section
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_abs
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid
operator|=
name|true
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|abs_output_section
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check
parameter_list|(
name|os
parameter_list|,
name|name
parameter_list|,
name|op
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
block|{
if|if
condition|(
name|os
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%F%P: %s uses undefined section %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|os
operator|->
name|processed
condition|)
name|einfo
argument_list|(
literal|"%F%P: %s forward reference of section %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_intop
parameter_list|(
name|value
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
block|{
name|etree_type
modifier|*
name|new
init|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|INT
expr_stmt|;
name|new
operator|->
name|value
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Build an expression representing an unnamed relocateable value.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_relop
parameter_list|(
name|section
parameter_list|,
name|value
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|etree_type
modifier|*
name|new
init|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|rel
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|type
operator|.
name|node_code
operator|=
name|REL
expr_stmt|;
name|new
operator|->
name|type
operator|.
name|node_class
operator|=
name|etree_rel
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|->
name|rel
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_rel
parameter_list|(
name|value
parameter_list|,
name|section
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|section
decl_stmt|;
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid
operator|=
name|true
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|section
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|new_rel_from_section
parameter_list|(
name|value
parameter_list|,
name|section
parameter_list|)
name|bfd_vma
name|value
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|section
decl_stmt|;
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid
operator|=
name|true
expr_stmt|;
name|new
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|new
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|.
name|value
operator|-=
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_binary
parameter_list|(
name|tree
parameter_list|,
name|current_section
parameter_list|,
name|allocation_done
parameter_list|,
name|dot
parameter_list|,
name|dotp
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|bfd_vma
modifier|*
name|dotp
decl_stmt|;
block|{
name|etree_value_type
name|result
decl_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid
condition|)
block|{
name|etree_value_type
name|other
decl_stmt|;
name|other
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|valid
condition|)
block|{
comment|/* If the values are from different sections, or this is an 	     absolute expression, make both the source arguments 	     absolute.  However, adding or subtracting an absolute 	     value from a relative value is meaningful, and is an 	     exception.  */
if|if
condition|(
name|current_section
operator|!=
name|abs_output_section
operator|&&
operator|(
name|other
operator|.
name|section
operator|==
name|abs_output_section
operator|||
operator|(
name|result
operator|.
name|section
operator|==
name|abs_output_section
operator|&&
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
operator|)
operator|)
operator|&&
operator|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'+'
operator|||
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
literal|'-'
operator|)
condition|)
block|{
name|etree_value_type
name|hold
decl_stmt|;
comment|/* If there is only one absolute term, make sure it is the 		 second one.  */
if|if
condition|(
name|other
operator|.
name|section
operator|!=
name|abs_output_section
condition|)
block|{
name|hold
operator|=
name|result
expr_stmt|;
name|result
operator|=
name|other
expr_stmt|;
name|other
operator|=
name|hold
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|.
name|section
operator|!=
name|other
operator|.
name|section
operator|||
name|current_section
operator|==
name|abs_output_section
condition|)
block|{
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|make_abs
argument_list|(
operator|&
name|other
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
name|other
operator|.
name|value
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%F%S %% by zero\n"
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|result
operator|.
name|value
operator|%
operator|(
name|bfd_signed_vma
operator|)
name|other
operator|.
name|value
operator|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|other
operator|.
name|value
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%F%S / by zero\n"
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|)
name|result
operator|.
name|value
operator|/
operator|(
name|bfd_signed_vma
operator|)
name|other
operator|.
name|value
operator|)
expr_stmt|;
break|break;
define|#
directive|define
name|BOP
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|case x : result.value = result.value y other.value; break;
name|BOP
argument_list|(
literal|'+'
argument_list|,
operator|+
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'*'
argument_list|,
operator|*
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'-'
argument_list|,
operator|-
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LSHIFT
argument_list|,
operator|<<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|RSHIFT
argument_list|,
operator|>>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|EQ
argument_list|,
operator|==
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|NE
argument_list|,
operator|!=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'<'
argument_list|,
operator|<
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'>'
argument_list|,
operator|>
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|LE
argument_list|,
operator|<=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|GE
argument_list|,
operator|>=
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'&'
argument_list|,
operator|&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'^'
argument_list|,
operator|^
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
literal|'|'
argument_list|,
operator||
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|ANDAND
argument_list|,
operator|&&
argument_list|)
expr_stmt|;
name|BOP
argument_list|(
name|OROR
argument_list|,
operator|||
argument_list|)
expr_stmt|;
case|case
name|MAX
case|:
if|if
condition|(
name|result
operator|.
name|value
operator|<
name|other
operator|.
name|value
condition|)
name|result
operator|=
name|other
expr_stmt|;
break|break;
case|case
name|MIN
case|:
if|if
condition|(
name|result
operator|.
name|value
operator|>
name|other
operator|.
name|value
condition|)
name|result
operator|=
name|other
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|etree_value_type
name|invalid
parameter_list|()
block|{
name|etree_value_type
name|new
decl_stmt|;
name|new
operator|.
name|valid
operator|=
name|false
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|fold_name
parameter_list|(
name|tree
parameter_list|,
name|current_section
parameter_list|,
name|allocation_done
parameter_list|,
name|dot
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
name|etree_value_type
name|result
decl_stmt|;
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|SIZEOF_HEADERS
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|result
operator|=
name|new_abs
argument_list|(
operator|(
name|bfd_vma
operator|)
name|bfd_sizeof_headers
argument_list|(
name|output_bfd
argument_list|,
name|link_info
operator|.
name|relocateable
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
name|DEFINED
case|:
if|if
condition|(
name|allocation_done
operator|==
name|lang_first_phase_enum
condition|)
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|valid
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|NAME
case|:
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|name
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
name|result
operator|=
name|new_rel_from_section
argument_list|(
name|dot
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|invalid
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
name|result
operator|=
name|new_abs
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|allocation_done
operator|==
name|lang_final_phase_enum
operator|||
name|allocation_done
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|(
name|lang_output_section_statement_lookup
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|name
argument_list|)
operator|)
expr_stmt|;
comment|/* FIXME: Is this correct if this section is being 		       linked with -R?  */
name|result
operator|=
name|new_rel
argument_list|(
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|allocation_done
operator|==
name|lang_final_phase_enum
condition|)
name|einfo
argument_list|(
literal|"%F%S: undefined symbol `%s' referenced in expression\n"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ADDR
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|os
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
literal|"ADDR"
argument_list|)
expr_stmt|;
name|result
operator|=
name|new_rel
argument_list|(
literal|0
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|invalid
argument_list|()
expr_stmt|;
break|break;
case|case
name|LOADADDR
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|os
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
literal|"LOADADDR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|result
operator|=
name|new_rel
argument_list|(
literal|0
argument_list|,
name|os
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|os
operator|->
name|load_base
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|invalid
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIZEOF
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
name|check
argument_list|(
name|os
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|,
literal|"SIZEOF"
argument_list|)
expr_stmt|;
name|result
operator|=
name|new_abs
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|invalid
argument_list|()
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|etree_value_type
name|exp_fold_tree
parameter_list|(
name|tree
parameter_list|,
name|current_section
parameter_list|,
name|allocation_done
parameter_list|,
name|dot
parameter_list|,
name|dotp
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|bfd_vma
modifier|*
name|dotp
decl_stmt|;
block|{
name|etree_value_type
name|result
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
return|return
name|result
return|;
block|}
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|result
operator|=
name|new_rel
argument_list|(
name|tree
operator|->
name|value
operator|.
name|value
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_rel
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_final_phase_enum
condition|)
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
else|else
name|result
operator|=
name|new_rel
argument_list|(
operator|(
name|tree
operator|->
name|rel
operator|.
name|value
operator|+
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|output_offset
operator|)
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid
condition|)
block|{
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ALIGN_K
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
condition|)
name|result
operator|=
name|new_rel_from_section
argument_list|(
name|ALIGN_N
argument_list|(
name|dot
argument_list|,
name|result
operator|.
name|value
argument_list|)
argument_list|,
name|current_section
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|ABSOLUTE
case|:
if|if
condition|(
name|allocation_done
operator|!=
name|lang_first_phase_enum
operator|&&
name|result
operator|.
name|valid
condition|)
block|{
name|result
operator|.
name|value
operator|+=
name|result
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|result
operator|.
name|section
operator|=
name|abs_output_section
expr_stmt|;
block|}
else|else
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|~
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|!
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
operator|-
name|result
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
comment|/* Return next place aligned to value.  */
if|if
condition|(
name|allocation_done
operator|==
name|lang_allocating_phase_enum
condition|)
block|{
name|make_abs
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|value
operator|=
name|ALIGN_N
argument_list|(
name|dot
argument_list|,
name|result
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|.
name|valid
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|etree_trinary
case|:
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid
condition|)
name|result
operator|=
name|exp_fold_tree
argument_list|(
operator|(
name|result
operator|.
name|value
condition|?
name|tree
operator|->
name|trinary
operator|.
name|lhs
else|:
name|tree
operator|->
name|trinary
operator|.
name|rhs
operator|)
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|result
operator|=
name|fold_binary
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assign
case|:
case|case
name|etree_provide
case|:
if|if
condition|(
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tree
operator|->
name|assign
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Assignment to dot can only be done during allocation */
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
condition|)
name|einfo
argument_list|(
literal|"%F%S can not PROVIDE assignment to location counter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocation_done
operator|==
name|lang_allocating_phase_enum
operator|||
operator|(
name|allocation_done
operator|==
name|lang_final_phase_enum
operator|&&
name|current_section
operator|==
name|abs_output_section
operator|)
condition|)
block|{
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|,
name|current_section
argument_list|,
name|lang_allocating_phase_enum
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|.
name|valid
condition|)
name|einfo
argument_list|(
literal|"%F%S invalid assignment to location counter\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_section
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%F%S assignment to location counter invalid outside of SECTION\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|nextdot
decl_stmt|;
name|nextdot
operator|=
operator|(
name|result
operator|.
name|value
operator|+
name|current_section
operator|->
name|bfd_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|nextdot
operator|<
name|dot
operator|&&
name|current_section
operator|!=
name|abs_output_section
condition|)
block|{
name|einfo
argument_list|(
literal|"%F%S cannot move location counter backwards (from %V to %V)\n"
argument_list|,
name|dot
argument_list|,
name|nextdot
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|dotp
operator|=
name|nextdot
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|,
name|dotp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid
condition|)
block|{
name|boolean
name|create
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_assign
condition|)
name|create
operator|=
name|true
expr_stmt|;
else|else
name|create
operator|=
name|false
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|create
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_assign
condition|)
name|einfo
argument_list|(
literal|"%P%F:%s: hash creation failed\n"
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_provide
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
block|{
comment|/* Do nothing.  The symbol was defined by some 		     object.  */
block|}
else|else
block|{
comment|/* FIXME: Should we worry if the symbol is already 		     defined?  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|result
operator|.
name|value
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|result
operator|.
name|section
operator|->
name|bfd_section
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|etree_name
case|:
name|result
operator|=
name|fold_name
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|etree_value_type
name|exp_fold_tree_no_dot
parameter_list|(
name|tree
parameter_list|,
name|current_section
parameter_list|,
name|allocation_done
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
block|{
return|return
name|exp_fold_tree
argument_list|(
name|tree
argument_list|,
name|current_section
argument_list|,
name|allocation_done
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_binop
parameter_list|(
name|code
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|int
name|code
decl_stmt|;
name|etree_type
modifier|*
name|lhs
decl_stmt|;
name|etree_type
modifier|*
name|rhs
decl_stmt|;
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|binary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_binary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|abs_output_section
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid
condition|)
block|{
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
block|}
name|new
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|binary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_trinop
parameter_list|(
name|code
parameter_list|,
name|cond
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
name|int
name|code
decl_stmt|;
name|etree_type
modifier|*
name|cond
decl_stmt|;
name|etree_type
modifier|*
name|lhs
decl_stmt|;
name|etree_type
modifier|*
name|rhs
decl_stmt|;
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|lhs
operator|=
name|lhs
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|cond
operator|=
name|cond
expr_stmt|;
name|value
operator|.
name|trinary
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|value
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_trinary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid
condition|)
block|{
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
block|}
name|new
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|trinary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_unop
parameter_list|(
name|code
parameter_list|,
name|child
parameter_list|)
name|int
name|code
decl_stmt|;
name|etree_type
modifier|*
name|child
decl_stmt|;
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|child
operator|=
name|child
expr_stmt|;
name|value
operator|.
name|unary
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_unary
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
name|abs_output_section
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid
condition|)
block|{
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
block|}
name|new
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|unary
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_nameop
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|int
name|code
decl_stmt|;
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|etree_value_type
name|r
decl_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|value
operator|.
name|name
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_name
expr_stmt|;
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
operator|&
name|value
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
argument_list|,
name|lang_first_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid
condition|)
block|{
return|return
name|exp_intop
argument_list|(
name|r
operator|.
name|value
argument_list|)
return|;
block|}
name|new
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|etree_type
modifier|*
name|exp_assop
parameter_list|(
name|code
parameter_list|,
name|dst
parameter_list|,
name|src
parameter_list|)
name|int
name|code
decl_stmt|;
name|CONST
name|char
modifier|*
name|dst
decl_stmt|;
name|etree_type
modifier|*
name|src
decl_stmt|;
block|{
name|etree_type
name|value
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|value
operator|.
name|assign
operator|.
name|type
operator|.
name|node_code
operator|=
name|code
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|value
operator|.
name|assign
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_assign
expr_stmt|;
if|#
directive|if
literal|0
block|if (exp_fold_tree_no_dot(&value,&result)) {     return exp_intop(result);   }
endif|#
directive|endif
name|new
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|new
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|new
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Handle PROVIDE.  */
end_comment

begin_function
name|etree_type
modifier|*
name|exp_provide
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
specifier|const
name|char
modifier|*
name|dst
decl_stmt|;
name|etree_type
modifier|*
name|src
decl_stmt|;
block|{
name|etree_type
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|n
operator|->
name|assign
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_code
operator|=
literal|'='
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|type
operator|.
name|node_class
operator|=
name|etree_provide
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|n
operator|->
name|assign
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|exp_print_tree
parameter_list|(
name|tree
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
block|{
switch|switch
condition|(
name|tree
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_value
case|:
name|minfo
argument_list|(
literal|"0x%v"
argument_list|,
name|tree
operator|->
name|value
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_rel
case|:
if|if
condition|(
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%B:"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s+0x%v"
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|section
operator|->
name|name
argument_list|,
name|tree
operator|->
name|rel
operator|.
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|etree_assign
case|:
if|#
directive|if
literal|0
block|if (tree->assign.dst->sdefs != (asymbol *)NULL){       fprintf(config.map_file,"%s (%x) ",tree->assign.dst->name, 	      tree->assign.dst->sdefs->value);     }     else {       fprintf(config.map_file,"%s (UNDEFINED)",tree->assign.dst->name);     }
endif|#
directive|endif
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_provide
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"PROVIDE (%s, "
argument_list|,
name|tree
operator|->
name|assign
operator|.
name|dst
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_print_token
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|type
operator|.
name|node_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|unary
operator|.
name|child
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|tree
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|etree_undef
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"????????"
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
if|if
condition|(
name|tree
operator|->
name|type
operator|.
name|node_code
operator|==
name|NAME
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%s"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exp_print_token
argument_list|(
name|tree
operator|->
name|type
operator|.
name|node_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|name
operator|.
name|name
condition|)
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"(%s)"
argument_list|,
name|tree
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_vma
parameter_list|(
name|tree
parameter_list|,
name|def
parameter_list|,
name|name
parameter_list|,
name|allocation_done
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|bfd_vma
name|def
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
block|{
name|etree_value_type
name|r
decl_stmt|;
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|.
name|valid
operator|&&
name|name
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%F%S nonconstant expression for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|r
operator|.
name|value
return|;
block|}
else|else
return|return
name|def
return|;
block|}
end_function

begin_function
name|int
name|exp_get_value_int
parameter_list|(
name|tree
parameter_list|,
name|def
parameter_list|,
name|name
parameter_list|,
name|allocation_done
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|int
name|def
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|exp_get_vma
argument_list|(
name|tree
argument_list|,
operator|(
name|bfd_vma
operator|)
name|def
argument_list|,
name|name
argument_list|,
name|allocation_done
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_vma
name|exp_get_abs_int
parameter_list|(
name|tree
parameter_list|,
name|def
parameter_list|,
name|name
parameter_list|,
name|allocation_done
parameter_list|)
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|int
name|def
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|lang_phase_type
name|allocation_done
decl_stmt|;
block|{
name|etree_value_type
name|res
decl_stmt|;
name|res
operator|=
name|exp_fold_tree_no_dot
argument_list|(
name|tree
argument_list|,
name|abs_output_section
argument_list|,
name|allocation_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|valid
condition|)
block|{
name|res
operator|.
name|value
operator|+=
name|res
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
literal|"%F%S non constant expression for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|res
operator|.
name|value
return|;
block|}
end_function

end_unit

