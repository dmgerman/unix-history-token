begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linker command language support.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"fnmatch.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((size_t)& (((TYPE*) 0)->MEMBER))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Locals variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|stat_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|map_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|startup_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|input_file_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|placed_commons
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|stripped_excluded_sections
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|default_common_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|map_option_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|print_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|first_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lang_phdr
modifier|*
name|lang_phdr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_table
name|lang_definedness_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|exp_init_os
parameter_list|(
name|etree_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_map_userdata
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|load_symbols
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|,
name|lang_statement_list_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|lang_definedness_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_undefined
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_all_symbols
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sort_def_symbol
parameter_list|(
name|struct
name|bfd_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_statement
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_statement_list
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|,
name|lang_output_section_statement_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_statements
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_input_section
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|lang_one_common
parameter_list|(
name|struct
name|bfd_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lang_record_phdrs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lang_do_version_exports_section
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Exported variables.  */
end_comment

begin_decl_stmt
name|lang_output_section_statement_type
modifier|*
name|abs_output_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
name|lang_output_section_statement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
modifier|*
name|stat_ptr
init|=
operator|&
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
name|file_chain
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_sym_chain
name|entry_symbol
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|entry_symbol_default
init|=
literal|"start"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|entry_section
init|=
literal|".text"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|entry_from_cmdline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|lang_has_input_file
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|had_output_filename
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|lang_float_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|delete_output_file_on_failure
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lang_nocrossrefs
modifier|*
name|nocrossref_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unique_sections
modifier|*
name|unique_section_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ldlang_sysrooted_script
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions that traverse the linker script and might evaluate     DEFINED() need to increment this.  */
end_comment

begin_decl_stmt
name|int
name|lang_statement_iteration
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|etree_type
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocation base - or null */
end_comment

begin_comment
comment|/* Return TRUE if the PATTERN argument is a wildcard pattern.    Although backslashes are treated specially if a pattern contains    wildcards, we do not consider the mere presence of a backslash to    be enough to cause the pattern to be treated as a wildcard.    That lets us handle DOS filenames more naturally.  */
end_comment

begin_define
define|#
directive|define
name|wildcardp
parameter_list|(
name|pattern
parameter_list|)
value|(strpbrk ((pattern), "?*[") != NULL)
end_define

begin_define
define|#
directive|define
name|new_stat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(x##_type *) new_statement (x##_enum, sizeof (x##_type), y)
end_define

begin_define
define|#
directive|define
name|outside_section_address
parameter_list|(
name|q
parameter_list|)
define|\
value|((q)->output_offset + (q)->output_section->vma)
end_define

begin_define
define|#
directive|define
name|outside_symbol_address
parameter_list|(
name|q
parameter_list|)
define|\
value|((q)->value + outside_section_address (q->section))
end_define

begin_define
define|#
directive|define
name|SECTION_NAME_MAP_LENGTH
value|(16)
end_define

begin_function
name|void
modifier|*
name|stat_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|stat_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|unique_section_p
parameter_list|(
specifier|const
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|unique_sections
modifier|*
name|unam
decl_stmt|;
specifier|const
name|char
modifier|*
name|secnam
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocatable
operator|&&
name|sec
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|bfd_is_group_section
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|secnam
operator|=
name|sec
operator|->
name|name
expr_stmt|;
for|for
control|(
name|unam
operator|=
name|unique_section_list
init|;
name|unam
condition|;
name|unam
operator|=
name|unam
operator|->
name|next
control|)
if|if
condition|(
name|wildcardp
argument_list|(
name|unam
operator|->
name|name
argument_list|)
condition|?
name|fnmatch
argument_list|(
name|unam
operator|->
name|name
argument_list|,
name|secnam
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
else|:
name|strcmp
argument_list|(
name|unam
operator|->
name|name
argument_list|,
name|secnam
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Generic traversal routines for finding matching sections.  */
end_comment

begin_comment
comment|/* Try processing a section against a wildcard.  This just calls    the callback unless the filename exclusion list is present    and excludes the file.  It's hardly ever present so this    function is very fast.  */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_consider_section
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bfd_boolean
name|skip
init|=
name|FALSE
decl_stmt|;
name|struct
name|name_list
modifier|*
name|list_tmp
decl_stmt|;
comment|/* Don't process sections from files which were      excluded.  */
for|for
control|(
name|list_tmp
operator|=
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
init|;
name|list_tmp
condition|;
name|list_tmp
operator|=
name|list_tmp
operator|->
name|next
control|)
block|{
name|bfd_boolean
name|is_wildcard
init|=
name|wildcardp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_wildcard
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|filename
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* If this file is part of an archive, and the archive is 	 excluded, exclude this file.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|file
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|is_wildcard
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|s
argument_list|,
name|file
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lowest common denominator routine that can handle everything correctly,    but slowly.  */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_section_general
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|sec
operator|=
name|ptr
operator|->
name|section_list
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|s
argument_list|,
name|file
argument_list|,
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|skip
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|wildcardp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|sec
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Routines to find a single section given its name.  If there's more    than one section with that name, we report that.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|asection
modifier|*
name|found_section
decl_stmt|;
name|bfd_boolean
name|multiple_sections_found
decl_stmt|;
block|}
name|section_iterator_callback_data
typedef|;
end_typedef

begin_function
specifier|static
name|bfd_boolean
name|section_iterator_callback
parameter_list|(
name|bfd
modifier|*
name|bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|section_iterator_callback_data
modifier|*
name|d
init|=
name|data
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|found_section
operator|!=
name|NULL
condition|)
block|{
name|d
operator|->
name|multiple_sections_found
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|d
operator|->
name|found_section
operator|=
name|s
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|find_section
parameter_list|(
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
parameter_list|,
name|bfd_boolean
modifier|*
name|multiple_sections_found
parameter_list|)
block|{
name|section_iterator_callback_data
name|cb_data
init|=
block|{
name|NULL
block|,
name|FALSE
block|}
decl_stmt|;
name|bfd_get_section_by_name_if
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|section_iterator_callback
argument_list|,
operator|&
name|cb_data
argument_list|)
expr_stmt|;
operator|*
name|multiple_sections_found
operator|=
name|cb_data
operator|.
name|multiple_sections_found
expr_stmt|;
return|return
name|cb_data
operator|.
name|found_section
return|;
block|}
end_function

begin_comment
comment|/* Code for handling simple wildcards without going through fnmatch,    which can be expensive because of charset translations etc.  */
end_comment

begin_comment
comment|/* A simple wild is a literal string followed by a single '*',    where the literal part is at least 4 characters long.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_simple_wild
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strcspn
argument_list|(
name|name
argument_list|,
literal|"*?["
argument_list|)
decl_stmt|;
return|return
name|len
operator|>=
literal|4
operator|&&
name|name
index|[
name|len
index|]
operator|==
literal|'*'
operator|&&
name|name
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|'\0'
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|match_simple_wild
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* The first four characters of the pattern are guaranteed valid      non-wildcard characters.  So we can go faster.  */
if|if
condition|(
name|pattern
index|[
literal|0
index|]
operator|!=
name|name
index|[
literal|0
index|]
operator|||
name|pattern
index|[
literal|1
index|]
operator|!=
name|name
index|[
literal|1
index|]
operator|||
name|pattern
index|[
literal|2
index|]
operator|!=
name|name
index|[
literal|2
index|]
operator|||
name|pattern
index|[
literal|3
index|]
operator|!=
name|name
index|[
literal|3
index|]
condition|)
return|return
name|FALSE
return|;
name|pattern
operator|+=
literal|4
expr_stmt|;
name|name
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
operator|*
name|pattern
operator|!=
literal|'*'
condition|)
if|if
condition|(
operator|*
name|name
operator|++
operator|!=
operator|*
name|pattern
operator|++
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Specialized, optimized routines for handling different kinds of    wildcards */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_section_specs1_wild0
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* We can just do a hash lookup for the section with the right name.      But if that lookup discovers more than one section with the name      (should be rare), we fall back to the general algorithm because      we would otherwise have to sort the sections to make sure they      get processed in the bfd's order.  */
name|bfd_boolean
name|multiple_sections_found
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec0
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|0
index|]
decl_stmt|;
name|asection
modifier|*
name|s0
init|=
name|find_section
argument_list|(
name|file
argument_list|,
name|sec0
argument_list|,
operator|&
name|multiple_sections_found
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiple_sections_found
condition|)
name|walk_wild_section_general
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s0
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s0
argument_list|,
name|sec0
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild_section_specs1_wild1
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec0
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_boolean
name|skip
init|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec0
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec0
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild_section_specs2_wild1
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec0
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec1
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|1
index|]
decl_stmt|;
name|bfd_boolean
name|multiple_sections_found
decl_stmt|;
name|asection
modifier|*
name|s0
init|=
name|find_section
argument_list|(
name|file
argument_list|,
name|sec0
argument_list|,
operator|&
name|multiple_sections_found
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiple_sections_found
condition|)
block|{
name|walk_wild_section_general
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Note that if the section was not found, s0 is NULL and      we'll simply never succeed the s == s0 test below.  */
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Recall that in this code path, a section cannot satisfy more 	 than one spec, so if s == s0 then it cannot match 	 wildspec1.  */
if|if
condition|(
name|s
operator|==
name|s0
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|sec0
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_boolean
name|skip
init|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec1
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec1
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild_section_specs3_wild2
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec0
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec1
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec2
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|2
index|]
decl_stmt|;
name|bfd_boolean
name|multiple_sections_found
decl_stmt|;
name|asection
modifier|*
name|s0
init|=
name|find_section
argument_list|(
name|file
argument_list|,
name|sec0
argument_list|,
operator|&
name|multiple_sections_found
argument_list|)
decl_stmt|;
if|if
condition|(
name|multiple_sections_found
condition|)
block|{
name|walk_wild_section_general
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|==
name|s0
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|sec0
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_boolean
name|skip
init|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec1
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec1
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|skip
operator|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec2
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec2
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild_section_specs4_wild2
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec0
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec1
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec2
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|wildsec3
init|=
name|ptr
operator|->
name|handler_data
index|[
literal|3
index|]
decl_stmt|;
name|bfd_boolean
name|multiple_sections_found
decl_stmt|;
name|asection
modifier|*
name|s0
init|=
name|find_section
argument_list|(
name|file
argument_list|,
name|sec0
argument_list|,
operator|&
name|multiple_sections_found
argument_list|)
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
if|if
condition|(
name|multiple_sections_found
condition|)
block|{
name|walk_wild_section_general
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|s1
operator|=
name|find_section
argument_list|(
name|file
argument_list|,
name|sec1
argument_list|,
operator|&
name|multiple_sections_found
argument_list|)
expr_stmt|;
if|if
condition|(
name|multiple_sections_found
condition|)
block|{
name|walk_wild_section_general
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|==
name|s0
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|sec0
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|s1
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|sec1
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_boolean
name|skip
init|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec2
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec2
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|skip
operator|=
operator|!
name|match_simple_wild
argument_list|(
name|wildsec3
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|walk_wild_consider_section
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|s
argument_list|,
name|wildsec3
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild_section
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|just_syms_flag
condition|)
return|return;
call|(
modifier|*
name|ptr
operator|->
name|walk_wild_section_handler
call|)
argument_list|(
name|ptr
argument_list|,
name|file
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns TRUE when name1 is a wildcard spec that might match    something name2 can match.  We're conservative: we return FALSE    only if the prefixes of name1 and name2 are different up to the    first wildcard character.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|wild_spec_can_overlap
parameter_list|(
specifier|const
name|char
modifier|*
name|name1
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|)
block|{
name|size_t
name|prefix1_len
init|=
name|strcspn
argument_list|(
name|name1
argument_list|,
literal|"?*["
argument_list|)
decl_stmt|;
name|size_t
name|prefix2_len
init|=
name|strcspn
argument_list|(
name|name2
argument_list|,
literal|"?*["
argument_list|)
decl_stmt|;
name|size_t
name|min_prefix_len
decl_stmt|;
comment|/* Note that if there is no wildcard character, then we treat the      terminating 0 as part of the prefix.  Thus ".text" won't match      ".text." or ".text.*", for example.  */
if|if
condition|(
name|name1
index|[
name|prefix1_len
index|]
operator|==
literal|'\0'
condition|)
name|prefix1_len
operator|++
expr_stmt|;
if|if
condition|(
name|name2
index|[
name|prefix2_len
index|]
operator|==
literal|'\0'
condition|)
name|prefix2_len
operator|++
expr_stmt|;
name|min_prefix_len
operator|=
name|prefix1_len
operator|<
name|prefix2_len
condition|?
name|prefix1_len
else|:
name|prefix2_len
expr_stmt|;
return|return
name|memcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|,
name|min_prefix_len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Select specialized code to handle various kinds of wildcard    statements.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_walk_wild_section_handler
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|sec_count
init|=
literal|0
decl_stmt|;
name|int
name|wild_name_count
init|=
literal|0
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|int
name|signature
decl_stmt|;
name|int
name|data_counter
decl_stmt|;
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_general
expr_stmt|;
comment|/* Count how many wildcard_specs there are, and how many of those      actually use wildcards in the name.  Also, bail out if any of the      wildcard names are NULL. (Can this actually happen?      walk_wild_section used to test for it.)  And bail out if any      of the wildcards are more complex than a simple string      ending in a single '*'.  */
for|for
control|(
name|sec
operator|=
name|ptr
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
operator|++
name|sec_count
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|wildcardp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|wild_name_count
expr_stmt|;
if|if
condition|(
operator|!
name|is_simple_wild
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/* The zero-spec case would be easy to optimize but it doesn't      happen in practice.  Likewise, more than 4 specs doesn't      happen in practice.  */
if|if
condition|(
name|sec_count
operator|==
literal|0
operator|||
name|sec_count
operator|>
literal|4
condition|)
return|return;
comment|/* Check that no two specs can match the same section.  */
for|for
control|(
name|sec
operator|=
name|ptr
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|wildcard_list
modifier|*
name|sec2
decl_stmt|;
for|for
control|(
name|sec2
operator|=
name|sec
operator|->
name|next
init|;
name|sec2
operator|!=
name|NULL
condition|;
name|sec2
operator|=
name|sec2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|wild_spec_can_overlap
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sec2
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
return|return;
block|}
block|}
name|signature
operator|=
operator|(
name|sec_count
operator|<<
literal|8
operator|)
operator|+
name|wild_name_count
expr_stmt|;
switch|switch
condition|(
name|signature
condition|)
block|{
case|case
literal|0x0100
case|:
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_specs1_wild0
expr_stmt|;
break|break;
case|case
literal|0x0101
case|:
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_specs1_wild1
expr_stmt|;
break|break;
case|case
literal|0x0201
case|:
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_specs2_wild1
expr_stmt|;
break|break;
case|case
literal|0x0302
case|:
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_specs3_wild2
expr_stmt|;
break|break;
case|case
literal|0x0402
case|:
name|ptr
operator|->
name|walk_wild_section_handler
operator|=
name|walk_wild_section_specs4_wild2
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* Now fill the data array with pointers to the specs, first the      specs with non-wildcard names, then the specs with wildcard      names.  It's OK to process the specs in different order from the      given order, because we've already determined that no section      will match more than one spec.  */
name|data_counter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|ptr
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|wildcardp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
name|ptr
operator|->
name|handler_data
index|[
name|data_counter
operator|++
index|]
operator|=
name|sec
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|ptr
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|wildcardp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
name|ptr
operator|->
name|handler_data
index|[
name|data_counter
operator|++
index|]
operator|=
name|sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a wild statement for a single file F.  */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_file
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|s
parameter_list|,
name|lang_input_statement_type
modifier|*
name|f
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|f
operator|->
name|the_bfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_check_format
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|walk_wild_section
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|member
decl_stmt|;
comment|/* This is an archive file.  We must map each member of the 	 archive separately.  */
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
comment|/* When lookup_name is called, it will call the add_symbols 	     entry point for the archive.  For each element of the 	     archive which is included, BFD will call ldlang_add_file, 	     which will set the usrdata field of the member to the 	     lang_input_statement.  */
if|if
condition|(
name|member
operator|->
name|usrdata
operator|!=
name|NULL
condition|)
block|{
name|walk_wild_section
argument_list|(
name|s
argument_list|,
name|member
operator|->
name|usrdata
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|s
parameter_list|,
name|callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|file_spec
init|=
name|s
operator|->
name|filename
decl_stmt|;
if|if
condition|(
name|file_spec
operator|==
name|NULL
condition|)
block|{
comment|/* Perform the iteration over all files in the list.  */
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wildcardp
argument_list|(
name|file_spec
argument_list|)
condition|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|file_spec
argument_list|,
name|f
operator|->
name|filename
argument_list|,
name|FNM_FILE_NAME
argument_list|)
operator|==
literal|0
condition|)
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
comment|/* Perform the iteration over a single file.  */
name|f
operator|=
name|lookup_name
argument_list|(
name|file_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* lang_for_each_statement walks the parse tree and calls the provided    function for each node.  */
end_comment

begin_function
specifier|static
name|void
name|lang_for_each_statement_worker
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|)
parameter_list|,
name|lang_statement_union_type
modifier|*
name|s
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
name|func
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_input_statement_enum
case|:
case|case
name|lang_assignment_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_address_statement_enum
case|:
case|case
name|lang_fill_statement_enum
case|:
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|lang_for_each_statement
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|lang_statement_union_type
modifier|*
parameter_list|)
parameter_list|)
block|{
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lang_list_init
parameter_list|(
name|lang_statement_list_type
modifier|*
name|list
parameter_list|)
block|{
name|list
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|list
operator|->
name|tail
operator|=
operator|&
name|list
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a new statement node for the parse tree.  */
end_comment

begin_function
specifier|static
name|lang_statement_union_type
modifier|*
name|new_statement
parameter_list|(
name|enum
name|statement_enum
name|type
parameter_list|,
name|size_t
name|size
parameter_list|,
name|lang_statement_list_type
modifier|*
name|list
parameter_list|)
block|{
name|lang_statement_union_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|stat_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|lang_statement_append
argument_list|(
name|list
argument_list|,
name|new
argument_list|,
operator|&
name|new
operator|->
name|header
operator|.
name|next
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Build a new input file node for the language.  There are several    ways in which we treat an input file, eg, we only look at symbols,    or prefix it with a -l etc.     We can be supplied with requests for input files more than once;    they may, for example be split over several lines like foo.o(.text)    foo.o(.data) etc, so when asked for a file we check that we haven't    got it already so we don't duplicate the bfd.  */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|new_afile
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|lang_input_file_enum_type
name|file_type
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|bfd_boolean
name|add_to_list
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|add_to_list
condition|)
name|p
operator|=
name|new_stat
argument_list|(
name|lang_input_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_input_statement_type
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|header
operator|.
name|type
operator|=
name|lang_input_statement_enum
expr_stmt|;
name|p
operator|->
name|header
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|lang_has_input_file
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|p
operator|->
name|sysrooted
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|file_type
condition|)
block|{
case|case
name|lang_input_file_is_symbols_only_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_fake_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_l_enum
case|:
name|p
operator|->
name|is_archive
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_marker_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_search_file_enum
case|:
name|p
operator|->
name|sysrooted
operator|=
name|ldlang_sysrooted_script
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_file_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|TRUE
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|FALSE
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|asymbols
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|next_real_file
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|symbol_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|dynamic
operator|=
name|config
operator|.
name|dynamic_link
expr_stmt|;
name|p
operator|->
name|add_needed
operator|=
name|add_needed
expr_stmt|;
name|p
operator|->
name|as_needed
operator|=
name|as_needed
expr_stmt|;
name|p
operator|->
name|whole_archive
operator|=
name|whole_archive
expr_stmt|;
name|p
operator|->
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|input_file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|p
argument_list|,
operator|&
name|p
operator|->
name|next_real_file
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|lang_input_statement_type
modifier|*
name|lang_add_input_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|lang_input_file_enum_type
name|file_type
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
name|lang_has_input_file
operator|=
name|TRUE
expr_stmt|;
return|return
name|new_afile
argument_list|(
name|name
argument_list|,
name|file_type
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|out_section_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|lang_statement_union_type
name|s
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_table
name|output_section_statement_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support routines for the hash table used by lang_output_section_find,    initialize the table, fill in an entry and remove the table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|output_section_statement_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|lang_output_section_statement_type
modifier|*
modifier|*
name|nextp
decl_stmt|;
name|struct
name|out_section_hash_entry
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
name|ret
operator|=
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
operator|->
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|s
operator|.
name|header
operator|.
name|type
operator|=
name|lang_output_section_statement_enum
expr_stmt|;
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|subsection_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|section_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|block_value
operator|=
literal|1
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|children
argument_list|)
expr_stmt|;
name|lang_statement_append
argument_list|(
name|stat_ptr
argument_list|,
operator|&
name|ret
operator|->
name|s
argument_list|,
operator|&
name|ret
operator|->
name|s
operator|.
name|header
operator|.
name|next
argument_list|)
expr_stmt|;
comment|/* For every output section statement added to the list, except the      first one, lang_output_section_statement.tail points to the "next"      field of the last element of the list.  */
if|if
condition|(
name|lang_output_section_statement
operator|.
name|head
operator|!=
name|NULL
condition|)
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|prev
operator|=
operator|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|lang_output_section_statement
operator|.
name|tail
operator|-
name|offsetof
argument_list|(
name|lang_output_section_statement_type
argument_list|,
name|next
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* GCC's strict aliasing rules prevent us from just casting the      address, so we store the pointer in a variable and cast that      instead.  */
name|nextp
operator|=
operator|&
name|ret
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|next
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|,
operator|&
name|ret
operator|->
name|s
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|*
operator|)
name|nextp
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_section_statement_table_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|output_section_statement_table
argument_list|,
name|output_section_statement_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|out_section_hash_entry
argument_list|)
argument_list|,
literal|61
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can not create hash table: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_section_statement_table_free
parameter_list|(
name|void
parameter_list|)
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|output_section_statement_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build enough state so that the parser can build its tree.  */
end_comment

begin_function
name|void
name|lang_init
parameter_list|(
name|void
parameter_list|)
block|{
name|obstack_begin
argument_list|(
operator|&
name|stat_obstack
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
name|output_section_statement_table_init
argument_list|()
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|input_file_chain
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|file_chain
argument_list|)
expr_stmt|;
name|first_file
operator|=
name|lang_add_input_file
argument_list|(
name|NULL
argument_list|,
name|lang_input_file_is_marker_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abs_output_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|BFD_ABS_SECTION_NAME
argument_list|)
expr_stmt|;
name|abs_output_section
operator|->
name|bfd_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
comment|/* The value "3" is ad-hoc, somewhat related to the expected number of      DEFINED expressions in a linker script.  For most default linker      scripts, there are none.  Why a hash table then?  Well, it's somewhat      simpler to re-use working machinery than using a linked list in terms      of code-complexity here in ld, besides the initialization which just      looks like other code here.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|lang_definedness_table
argument_list|,
name|lang_definedness_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_definedness_hash_entry
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can not create hash table: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|output_section_statement_table_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   A region is an area of memory declared with the   MEMORY {  name:org=exp, len=exp ... }   syntax.    We maintain a list of all the regions here.    If no regions are specified in the script, then the default is used   which is created when looked up to be the entire data space.    If create is true we are creating a region inside a MEMORY block.   In this case it is probably an error to create a region that has   already been created.  If we are not inside a MEMORY block it is   dubious to use an undeclared region name (except DEFAULT_MEMORY_REGION)   and so we issue a warning.  */
end_comment

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
modifier|*
name|lang_memory_region_list_tail
init|=
operator|&
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_function
name|lang_memory_region_type
modifier|*
name|lang_memory_region_lookup
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|,
name|bfd_boolean
name|create
parameter_list|)
block|{
name|lang_memory_region_type
modifier|*
name|p
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|new
decl_stmt|;
comment|/* NAME is NULL for LMA memspecs if no region was specified.  */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|create
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P:%S: warning: redeclaration of memory region '%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
operator|!
name|create
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P:%S: warning: memory region %s not declared\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|new
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_memory_region_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lang_memory_region_list_tail
operator|=
name|new
expr_stmt|;
name|lang_memory_region_list_tail
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|not_flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|length
operator|=
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
expr_stmt|;
name|new
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|had_full_message
operator|=
name|FALSE
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_default
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|lang_memory_region_type
modifier|*
name|p
decl_stmt|;
name|flagword
name|sec_flags
init|=
name|section
operator|->
name|flags
decl_stmt|;
comment|/* Override SEC_DATA to mean a writable section.  */
if|if
condition|(
operator|(
name|sec_flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
name|sec_flags
operator||=
name|SEC_DATA
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|sec_flags
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|not_flags
operator|&
name|sec_flags
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
return|return
name|lang_memory_region_lookup
argument_list|(
name|DEFAULT_MEMORY_REGION
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|)
block|{
name|struct
name|out_section_hash_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|entry
operator|=
operator|(
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|output_section_statement_table
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hash
operator|=
name|entry
operator|->
name|root
operator|.
name|hash
expr_stmt|;
do|do
block|{
if|if
condition|(
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|constraint
operator|!=
operator|-
literal|1
condition|)
return|return
operator|&
name|entry
operator|->
name|s
operator|.
name|output_section_statement
return|;
name|entry
operator|=
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|entry
operator|->
name|root
operator|.
name|next
expr_stmt|;
block|}
do|while
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|root
operator|.
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup_1
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|,
name|int
name|constraint
parameter_list|)
block|{
name|struct
name|out_section_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|out_section_hash_entry
modifier|*
name|last_ent
decl_stmt|;
name|unsigned
name|long
name|hash
decl_stmt|;
name|entry
operator|=
operator|(
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|output_section_statement_table
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: failed creating section `%s': %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* We have a section of this name, but it might not have the correct 	 constraint.  */
name|hash
operator|=
name|entry
operator|->
name|root
operator|.
name|hash
expr_stmt|;
do|do
block|{
if|if
condition|(
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|constraint
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|constraint
operator|==
literal|0
operator|||
operator|(
name|constraint
operator|==
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|constraint
operator|&&
name|constraint
operator|!=
name|SPECIAL
operator|)
operator|)
condition|)
return|return
operator|&
name|entry
operator|->
name|s
operator|.
name|output_section_statement
return|;
name|last_ent
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|entry
operator|->
name|root
operator|.
name|next
expr_stmt|;
block|}
do|while
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|root
operator|.
name|hash
operator|==
name|hash
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
do|;
name|entry
operator|=
operator|(
operator|(
expr|struct
name|out_section_hash_entry
operator|*
operator|)
name|output_section_statement_newfunc
argument_list|(
name|NULL
argument_list|,
operator|&
name|output_section_statement_table
argument_list|,
name|name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: failed creating section `%s': %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|entry
operator|->
name|root
operator|=
name|last_ent
operator|->
name|root
expr_stmt|;
name|last_ent
operator|->
name|root
operator|.
name|next
operator|=
operator|&
name|entry
operator|->
name|root
expr_stmt|;
block|}
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|->
name|s
operator|.
name|output_section_statement
operator|.
name|constraint
operator|=
name|constraint
expr_stmt|;
return|return
operator|&
name|entry
operator|->
name|s
operator|.
name|output_section_statement
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|)
block|{
return|return
name|lang_output_section_statement_lookup_1
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A variant of lang_output_section_find used by place_orphan.    Returns the output statement that should precede a new output    statement for SEC.  If an exact match is found on certain flags,    sets *EXACT too.  */
end_comment

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find_by_flags
parameter_list|(
specifier|const
name|asection
modifier|*
name|sec
parameter_list|,
name|lang_output_section_statement_type
modifier|*
modifier|*
name|exact
parameter_list|,
name|lang_match_sec_type_func
name|match_type
parameter_list|)
block|{
name|lang_output_section_statement_type
modifier|*
name|first
decl_stmt|,
modifier|*
name|look
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
comment|/* We know the first statement on this list is *ABS*.  May as well      skip it.  */
name|first
operator|=
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|next
expr_stmt|;
comment|/* First try for an exact match.  */
name|found
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|exact
operator|!=
name|NULL
condition|)
operator|*
name|exact
operator|=
name|found
expr_stmt|;
return|return
name|found
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
comment|/* Try for a rw code section.  */
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_THREAD_LOCAL
operator|)
condition|)
block|{
comment|/* .rodata can go after .text, .sdata2 after .rodata.  */
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
operator|)
operator|&&
operator|!
operator|(
name|look
operator|->
name|flags
operator|&
operator|(
name|SEC_SMALL_DATA
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
block|{
comment|/* .sdata goes after .data, .sbss after .sdata.  */
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
operator|||
operator|(
operator|(
name|look
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
operator|)
operator|&&
operator|!
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
comment|/* .data goes after .rodata.  */
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_SMALL_DATA
operator||
name|SEC_THREAD_LOCAL
operator|)
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* .bss goes last.  */
for|for
control|(
name|look
operator|=
name|first
init|;
name|look
condition|;
name|look
operator|=
name|look
operator|->
name|next
control|)
block|{
name|flags
operator|=
name|look
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|look
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|flags
operator|=
name|look
operator|->
name|bfd_section
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|match_type
operator|&&
operator|!
name|match_type
argument_list|(
name|output_bfd
argument_list|,
name|look
operator|->
name|bfd_section
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
condition|)
continue|continue;
block|}
name|flags
operator|^=
name|sec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
name|found
operator|=
name|look
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|||
operator|!
name|match_type
condition|)
return|return
name|found
return|;
return|return
name|lang_output_section_find_by_flags
argument_list|(
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the last output section before given output statement.    Used by place_orphan.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|output_prev_sec_find
parameter_list|(
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
name|lang_output_section_statement_type
modifier|*
name|lookup
decl_stmt|;
for|for
control|(
name|lookup
operator|=
name|os
operator|->
name|prev
init|;
name|lookup
operator|!=
name|NULL
condition|;
name|lookup
operator|=
name|lookup
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|lookup
operator|->
name|constraint
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|lookup
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|lookup
operator|->
name|bfd_section
operator|->
name|owner
operator|!=
name|NULL
condition|)
return|return
name|lookup
operator|->
name|bfd_section
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_insert_orphan
parameter_list|(
name|asection
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|secname
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|after
parameter_list|,
name|struct
name|orphan_save
modifier|*
name|place
parameter_list|,
name|etree_type
modifier|*
name|address
parameter_list|,
name|lang_statement_list_type
modifier|*
name|add_child
parameter_list|)
block|{
name|lang_statement_list_type
modifier|*
name|old
decl_stmt|;
name|lang_statement_list_type
name|add
decl_stmt|;
specifier|const
name|char
modifier|*
name|ps
decl_stmt|;
name|etree_type
modifier|*
name|load_base
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
modifier|*
name|os_tail
decl_stmt|;
comment|/* Start building a list of statements for this section.      First save the current statement pointer.  */
name|old
operator|=
name|stat_ptr
expr_stmt|;
comment|/* If we have found an appropriate place for the output section      statements for this orphan, add them to our own private list,      inserting them later into the global statement list.  */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
block|{
name|stat_ptr
operator|=
operator|&
name|add
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_info
operator|.
name|relocatable
operator|||
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|==
literal|0
condition|)
name|address
operator|=
name|exp_intop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|load_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
operator|&&
name|after
operator|->
name|load_base
operator|!=
name|NULL
condition|)
block|{
name|etree_type
modifier|*
name|lma_from_vma
decl_stmt|;
name|lma_from_vma
operator|=
name|exp_binop
argument_list|(
literal|'-'
argument_list|,
name|after
operator|->
name|load_base
argument_list|,
name|exp_nameop
argument_list|(
name|ADDR
argument_list|,
name|after
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|load_base
operator|=
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|lma_from_vma
argument_list|,
name|exp_nameop
argument_list|(
name|ADDR
argument_list|,
name|secname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|os_tail
operator|=
operator|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|*
operator|)
name|lang_output_section_statement
operator|.
name|tail
operator|)
expr_stmt|;
name|os
operator|=
name|lang_enter_output_section_statement
argument_list|(
name|secname
argument_list|,
name|address
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|load_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ps
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|build_constructors
operator|&&
operator|*
name|os_tail
operator|==
name|os
condition|)
block|{
comment|/* If the name of the section is representable in C, then create 	 symbols to mark the start and the end of the section.  */
for|for
control|(
name|ps
operator|=
name|secname
init|;
operator|*
name|ps
operator|!=
literal|'\0'
condition|;
name|ps
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ps
argument_list|)
operator|&&
operator|*
name|ps
operator|!=
literal|'_'
condition|)
break|break;
if|if
condition|(
operator|*
name|ps
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|symname
decl_stmt|;
name|etree_type
modifier|*
name|e_align
decl_stmt|;
name|symname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ps
operator|-
name|secname
operator|+
sizeof|sizeof
expr|"__start_"
operator|+
literal|1
argument_list|)
expr_stmt|;
name|symname
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|symname
operator|+
operator|(
name|symname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
argument_list|,
literal|"__start_%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|e_align
operator|=
name|exp_unop
argument_list|(
name|ALIGN_K
argument_list|,
name|exp_intop
argument_list|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|s
operator|->
name|alignment_power
argument_list|)
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
literal|"."
argument_list|,
name|e_align
argument_list|)
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|symname
argument_list|,
name|exp_nameop
argument_list|(
name|NAME
argument_list|,
literal|"."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|add_child
operator|==
name|NULL
condition|)
name|add_child
operator|=
operator|&
name|os
operator|->
name|children
expr_stmt|;
name|lang_add_section
argument_list|(
name|add_child
argument_list|,
name|s
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|lang_leave_output_section_statement
argument_list|(
literal|0
argument_list|,
literal|"*default*"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|build_constructors
operator|&&
operator|*
name|ps
operator|==
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|symname
decl_stmt|;
comment|/* lang_leave_ouput_section_statement resets stat_ptr. 	 Put stat_ptr back where we want it.  */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
name|stat_ptr
operator|=
operator|&
name|add
expr_stmt|;
name|symname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|ps
operator|-
name|secname
operator|+
sizeof|sizeof
expr|"__stop_"
operator|+
literal|1
argument_list|)
expr_stmt|;
name|symname
index|[
literal|0
index|]
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|symname
operator|+
operator|(
name|symname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
argument_list|,
literal|"__stop_%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|symname
argument_list|,
name|exp_nameop
argument_list|(
name|NAME
argument_list|,
literal|"."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the global list pointer.  */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
name|stat_ptr
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|after
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|snew
decl_stmt|,
modifier|*
name|as
decl_stmt|;
name|snew
operator|=
name|os
operator|->
name|bfd_section
expr_stmt|;
comment|/* Shuffle the bfd section list to make the output file look 	 neater.  This is really only cosmetic.  */
if|if
condition|(
name|place
operator|->
name|section
operator|==
name|NULL
operator|&&
name|after
operator|!=
operator|(
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
operator|)
condition|)
block|{
name|asection
modifier|*
name|bfd_section
init|=
name|after
operator|->
name|bfd_section
decl_stmt|;
comment|/* If the output statement hasn't been used to place any input 	     sections (and thus doesn't have an output bfd_section), 	     look for the closest prior output statement having an 	     output section.  */
if|if
condition|(
name|bfd_section
operator|==
name|NULL
condition|)
name|bfd_section
operator|=
name|output_prev_sec_find
argument_list|(
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_section
operator|!=
name|NULL
operator|&&
name|bfd_section
operator|!=
name|snew
condition|)
name|place
operator|->
name|section
operator|=
operator|&
name|bfd_section
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|place
operator|->
name|section
operator|==
name|NULL
condition|)
name|place
operator|->
name|section
operator|=
operator|&
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|as
operator|=
operator|*
name|place
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|as
operator|!=
name|snew
operator|&&
name|as
operator|->
name|prev
operator|!=
name|snew
condition|)
block|{
comment|/* Unlink the section.  */
name|bfd_section_list_remove
argument_list|(
name|output_bfd
argument_list|,
name|snew
argument_list|)
expr_stmt|;
comment|/* Now tack it back on in the right place.  */
name|bfd_section_list_insert_before
argument_list|(
name|output_bfd
argument_list|,
name|as
argument_list|,
name|snew
argument_list|)
expr_stmt|;
block|}
comment|/* Save the end of this list.  Further ophans of this type will 	 follow the one we've just added.  */
name|place
operator|->
name|section
operator|=
operator|&
name|snew
operator|->
name|next
expr_stmt|;
comment|/* The following is non-cosmetic.  We try to put the output 	 statements in some sort of reasonable order here, because they 	 determine the final load addresses of the orphan sections. 	 In addition, placing output statements in the wrong order may 	 require extra segments.  For instance, given a typical 	 situation of all read-only sections placed in one segment and 	 following that a segment containing all the read-write 	 sections, we wouldn't want to place an orphan read/write 	 section before or amongst the read-only ones.  */
if|if
condition|(
name|add
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|newly_added_os
decl_stmt|;
if|if
condition|(
name|place
operator|->
name|stmt
operator|==
name|NULL
condition|)
block|{
name|lang_statement_union_type
modifier|*
modifier|*
name|where
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|assign
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|ignore_first
decl_stmt|;
comment|/* Look for a suitable place for the new statement list. 		 The idea is to skip over anything that might be inside 		 a SECTIONS {} statement in a script, before we find 		 another output_section_statement.  Assignments to "dot" 		 before an output section statement are assumed to 		 belong to it.  An exception to this rule is made for 		 the first assignment to dot, otherwise we might put an 		 orphan before . = . + SIZEOF_HEADERS or similar 		 assignments that set the initial address.  */
name|ignore_first
operator|=
name|after
operator|==
operator|(
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
operator|)
expr_stmt|;
for|for
control|(
name|where
operator|=
operator|&
name|after
operator|->
name|header
operator|.
name|next
init|;
operator|*
name|where
operator|!=
name|NULL
condition|;
name|where
operator|=
operator|&
operator|(
operator|*
name|where
operator|)
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|where
operator|)
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_assignment_statement_enum
case|:
if|if
condition|(
name|assign
operator|==
name|NULL
condition|)
block|{
name|lang_assignment_statement_type
modifier|*
name|ass
decl_stmt|;
name|ass
operator|=
operator|&
operator|(
operator|*
name|where
operator|)
operator|->
name|assignment_statement
expr_stmt|;
if|if
condition|(
name|ass
operator|->
name|exp
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_assert
operator|&&
name|ass
operator|->
name|exp
operator|->
name|assign
operator|.
name|dst
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ass
operator|->
name|exp
operator|->
name|assign
operator|.
name|dst
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|!
name|ignore_first
condition|)
name|assign
operator|=
name|where
expr_stmt|;
block|}
name|ignore_first
operator|=
name|FALSE
expr_stmt|;
continue|continue;
case|case
name|lang_wild_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_fill_statement_enum
case|:
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_constructors_statement_enum
case|:
name|assign
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
name|lang_output_section_statement_enum
case|:
if|if
condition|(
name|assign
operator|!=
name|NULL
condition|)
name|where
operator|=
name|assign
expr_stmt|;
case|case
name|lang_input_statement_enum
case|:
case|case
name|lang_address_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_group_statement_enum
case|:
case|case
name|lang_afile_asection_pair_statement_enum
case|:
break|break;
block|}
break|break;
block|}
operator|*
name|add
operator|.
name|tail
operator|=
operator|*
name|where
expr_stmt|;
operator|*
name|where
operator|=
name|add
operator|.
name|head
expr_stmt|;
name|place
operator|->
name|os_tail
operator|=
operator|&
name|after
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* Put it after the last orphan statement we added.  */
operator|*
name|add
operator|.
name|tail
operator|=
operator|*
name|place
operator|->
name|stmt
expr_stmt|;
operator|*
name|place
operator|->
name|stmt
operator|=
name|add
operator|.
name|head
expr_stmt|;
block|}
comment|/* Fix the global list pointer if we happened to tack our 	     new list at the tail.  */
if|if
condition|(
operator|*
name|old
operator|->
name|tail
operator|==
name|add
operator|.
name|head
condition|)
name|old
operator|->
name|tail
operator|=
name|add
operator|.
name|tail
expr_stmt|;
comment|/* Save the end of this list.  */
name|place
operator|->
name|stmt
operator|=
name|add
operator|.
name|tail
expr_stmt|;
comment|/* Do the same for the list of output section statements.  */
name|newly_added_os
operator|=
operator|*
name|os_tail
expr_stmt|;
operator|*
name|os_tail
operator|=
name|NULL
expr_stmt|;
name|newly_added_os
operator|->
name|prev
operator|=
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|place
operator|->
name|os_tail
operator|-
name|offsetof
argument_list|(
name|lang_output_section_statement_type
argument_list|,
name|next
argument_list|)
operator|)
expr_stmt|;
name|newly_added_os
operator|->
name|next
operator|=
operator|*
name|place
operator|->
name|os_tail
expr_stmt|;
if|if
condition|(
name|newly_added_os
operator|->
name|next
operator|!=
name|NULL
condition|)
name|newly_added_os
operator|->
name|next
operator|->
name|prev
operator|=
name|newly_added_os
expr_stmt|;
operator|*
name|place
operator|->
name|os_tail
operator|=
name|newly_added_os
expr_stmt|;
name|place
operator|->
name|os_tail
operator|=
operator|&
name|newly_added_os
operator|->
name|next
expr_stmt|;
comment|/* Fixing the global list pointer here is a little different. 	     We added to the list in lang_enter_output_section_statement, 	     trimmed off the new output_section_statment above when 	     assigning *os_tail = NULL, but possibly added it back in 	     the same place when assigning *place->os_tail.  */
if|if
condition|(
operator|*
name|os_tail
operator|==
name|NULL
condition|)
name|lang_output_section_statement
operator|.
name|tail
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|*
operator|)
name|os_tail
expr_stmt|;
block|}
block|}
return|return
name|os
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_map_flags
parameter_list|(
name|flagword
name|flag
parameter_list|)
block|{
if|if
condition|(
name|flag
operator|&
name|SEC_ALLOC
condition|)
name|minfo
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_CODE
condition|)
name|minfo
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_READONLY
condition|)
name|minfo
argument_list|(
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_DATA
condition|)
name|minfo
argument_list|(
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_LOAD
condition|)
name|minfo
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_map
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_memory_region_type
modifier|*
name|m
decl_stmt|;
name|bfd_boolean
name|dis_header_printed
init|=
name|FALSE
decl_stmt|;
name|bfd
modifier|*
name|p
decl_stmt|;
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|file
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|->
name|the_bfd
operator|->
name|flags
operator|&
operator|(
name|BFD_LINKER_CREATED
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
operator|||
name|file
operator|->
name|just_syms_flag
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|s
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|dis_header_printed
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|_
argument_list|(
literal|"\nDiscarded input sections\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dis_header_printed
operator|=
name|TRUE
expr_stmt|;
block|}
name|print_input_section
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nMemory Configuration\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s %-18s %-18s %s\n"
argument_list|,
name|_
argument_list|(
literal|"Name"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Origin"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Length"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Attributes"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|lang_memory_region_list
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s "
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|origin
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V"
argument_list|,
name|m
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|||
name|m
operator|->
name|not_flags
condition|)
block|{
ifndef|#
directive|ifndef
name|BFD64
name|minfo
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|flags
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|lang_map_flags
argument_list|(
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|not_flags
condition|)
block|{
name|minfo
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
name|lang_map_flags
argument_list|(
name|m
operator|->
name|not_flags
argument_list|)
expr_stmt|;
block|}
block|}
name|print_nl
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|_
argument_list|(
literal|"\nLinker script and memory map\n\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command_line
operator|.
name|reduce_memory_overheads
condition|)
block|{
name|obstack_begin
argument_list|(
operator|&
name|map_obstack
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|link_info
operator|.
name|input_bfds
init|;
name|p
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|link_next
control|)
name|bfd_map_over_sections
argument_list|(
name|p
argument_list|,
name|init_map_userdata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|sort_def_symbol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|print_statements
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_map_userdata
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|fat_section_userdata_type
modifier|*
name|new_data
init|=
operator|(
operator|(
name|fat_section_userdata_type
operator|*
operator|)
operator|(
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fat_section_userdata_type
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|get_userdata
argument_list|(
name|sec
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|get_userdata
argument_list|(
name|sec
argument_list|)
operator|=
name|new_data
expr_stmt|;
name|new_data
operator|->
name|map_symbol_def_tail
operator|=
operator|&
name|new_data
operator|->
name|map_symbol_def_head
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sort_def_symbol
parameter_list|(
name|hash_entry
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|hash_entry
decl_stmt|;
name|void
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|struct
name|fat_user_section_struct
modifier|*
name|ud
decl_stmt|;
name|struct
name|map_symbol_def
modifier|*
name|def
decl_stmt|;
name|ud
operator|=
name|get_userdata
argument_list|(
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ud
condition|)
block|{
comment|/* ??? What do we have to do to initialize this beforehand?  */
comment|/* The first time we get here is bfd_abs_section...  */
name|init_map_userdata
argument_list|(
literal|0
argument_list|,
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ud
operator|=
name|get_userdata
argument_list|(
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ud
operator|->
name|map_symbol_def_tail
condition|)
name|ud
operator|->
name|map_symbol_def_tail
operator|=
operator|&
name|ud
operator|->
name|map_symbol_def_head
expr_stmt|;
name|def
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|map_obstack
argument_list|,
sizeof|sizeof
expr|*
name|def
argument_list|)
expr_stmt|;
name|def
operator|->
name|entry
operator|=
name|hash_entry
expr_stmt|;
operator|*
operator|(
name|ud
operator|->
name|map_symbol_def_tail
operator|)
operator|=
name|def
expr_stmt|;
name|ud
operator|->
name|map_symbol_def_tail
operator|=
operator|&
name|def
operator|->
name|next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Initialize an output section.  */
end_comment

begin_function
specifier|static
name|void
name|init_os
parameter_list|(
name|lang_output_section_statement_type
modifier|*
name|s
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Illegal use of `%s' section\n"
argument_list|)
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
expr_stmt|;
name|s
operator|->
name|bfd_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|s
operator|->
name|bfd_section
operator|=
name|bfd_make_section
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: output format %s cannot represent section called %s\n"
argument_list|)
argument_list|,
name|output_bfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|bfd_section
operator|->
name|output_section
operator|=
name|s
operator|->
name|bfd_section
expr_stmt|;
name|s
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|command_line
operator|.
name|reduce_memory_overheads
condition|)
block|{
name|fat_section_userdata_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fat_section_userdata_type
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fat_section_userdata_type
argument_list|)
argument_list|)
expr_stmt|;
name|get_userdata
argument_list|(
name|s
operator|->
name|bfd_section
argument_list|)
operator|=
name|new
expr_stmt|;
block|}
comment|/* If there is a base address, make sure that any sections it might      mention are initialized.  */
if|if
condition|(
name|s
operator|->
name|addr_tree
operator|!=
name|NULL
condition|)
name|exp_init_os
argument_list|(
name|s
operator|->
name|addr_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|load_base
operator|!=
name|NULL
condition|)
name|exp_init_os
argument_list|(
name|s
operator|->
name|load_base
argument_list|)
expr_stmt|;
comment|/* If supplied an alignment, set it.  */
if|if
condition|(
name|s
operator|->
name|section_alignment
operator|!=
operator|-
literal|1
condition|)
name|s
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|s
operator|->
name|section_alignment
expr_stmt|;
if|if
condition|(
name|isec
condition|)
name|bfd_init_private_section_data
argument_list|(
name|isec
operator|->
name|owner
argument_list|,
name|isec
argument_list|,
name|output_bfd
argument_list|,
name|s
operator|->
name|bfd_section
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that all output sections mentioned in an expression are    initialized.  */
end_comment

begin_function
specifier|static
name|void
name|exp_init_os
parameter_list|(
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_assign
case|:
case|case
name|etree_provide
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_assert
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|assert_s
operator|.
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ADDR
case|:
case|case
name|LOADADDR
case|:
case|case
name|SIZEOF
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|exp
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|section_already_linked
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|entry
init|=
name|data
decl_stmt|;
comment|/* If we are only reading symbols from this object, then we want to      discard all sections.  */
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
block|{
name|bfd_link_just_syms
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
condition|)
name|bfd_section_already_linked
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The wild routines.     These expand statements like *(.text) and foo.o to a list of    explicit actions, like foo.o(.text), bar.o(.text) and    foo.o(.text, .data).  */
end_comment

begin_comment
comment|/* Add SECTION to the output section OUTPUT.  Do this by creating a    lang_input_section statement which is placed at PTR.  FILE is the    input file which holds SECTION.  */
end_comment

begin_function
name|void
name|lang_add_section
parameter_list|(
name|lang_statement_list_type
modifier|*
name|ptr
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|section
operator|->
name|flags
decl_stmt|;
name|bfd_boolean
name|discard
decl_stmt|;
comment|/* Discard sections marked with SEC_EXCLUDE.  */
name|discard
operator|=
operator|(
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Discard input sections which are assigned to a section named      DISCARD_SECTION_NAME.  */
if|if
condition|(
name|strcmp
argument_list|(
name|output
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|discard
operator|=
name|TRUE
expr_stmt|;
comment|/* Discard debugging sections if we are stripping debugging      information.  */
if|if
condition|(
operator|(
name|link_info
operator|.
name|strip
operator|==
name|strip_debugger
operator|||
name|link_info
operator|.
name|strip
operator|==
name|strip_all
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|discard
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|discard
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
comment|/* This prevents future calls from assigning this section.  */
name|section
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|bfd_boolean
name|first
decl_stmt|;
name|lang_input_section_type
modifier|*
name|new
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|first
operator|=
operator|!
name|output
operator|->
name|bfd_section
operator|->
name|linker_has_input
expr_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|linker_has_input
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
operator|&&
operator|!
name|stripped_excluded_sections
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|output
operator|->
name|bfd_section
operator|->
name|map_tail
operator|.
name|s
decl_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|map_tail
operator|.
name|s
operator|=
name|section
expr_stmt|;
name|section
operator|->
name|map_head
operator|.
name|s
operator|=
name|NULL
expr_stmt|;
name|section
operator|->
name|map_tail
operator|.
name|s
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|map_head
operator|.
name|s
operator|=
name|section
expr_stmt|;
else|else
name|output
operator|->
name|bfd_section
operator|->
name|map_head
operator|.
name|s
operator|=
name|section
expr_stmt|;
block|}
comment|/* Add a section reference to the list.  */
name|new
operator|=
name|new_stat
argument_list|(
name|lang_input_section
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|section
operator|->
name|output_section
operator|=
name|output
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|section
operator|->
name|flags
expr_stmt|;
comment|/* We don't copy the SEC_NEVER_LOAD flag from an input section 	 to an output section, because we want to be able to include a 	 SEC_NEVER_LOAD section in the middle of an otherwise loaded 	 section (I don't know why we want to do this, but we do). 	 build_link_order in ldwrite.c handles this case by turning 	 the embedded SEC_NEVER_LOAD section into a fill.  */
name|flags
operator|&=
operator|~
name|SEC_NEVER_LOAD
expr_stmt|;
comment|/* If final link, don't copy the SEC_LINK_ONCE flags, they've 	 already been processed.  One reason to do this is that on pe 	 format targets, .text$foo sections go into .text and it's odd 	 to see .text with SEC_LINK_ONCE set.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
condition|)
name|flags
operator|&=
operator|~
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES
operator|)
expr_stmt|;
comment|/* If this is not the first input section, and the SEC_READONLY 	 flag is not currently set, then don't set it just because the 	 input section has it set.  */
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
comment|/* Keep SEC_MERGE and SEC_STRINGS only if they are the same.  */
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
operator|(
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
operator|)
operator|!=
operator|(
name|flags
operator|&
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|output
operator|->
name|bfd_section
operator|->
name|entsize
operator|!=
name|section
operator|->
name|entsize
operator|)
operator|)
condition|)
block|{
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
expr_stmt|;
block|}
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_MERGE
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|entsize
operator|=
name|section
operator|->
name|entsize
expr_stmt|;
comment|/* If SEC_READONLY is not set in the input section, then clear 	 it from the output section.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
switch|switch
condition|(
name|output
operator|->
name|sectype
condition|)
block|{
case|case
name|normal_section
case|:
break|break;
case|case
name|dsect_section
case|:
case|case
name|copy_section
case|:
case|case
name|info_section
case|:
case|case
name|overlay_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
name|noload_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
block|}
comment|/* Copy over SEC_SMALL_DATA.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|alignment_power
operator|>
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|section
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_arch_tic54x
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_TIC54X_BLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_TIC54X_BLOCK
expr_stmt|;
comment|/* FIXME: This value should really be obtained from the bfd...  */
name|output
operator|->
name|block_value
operator|=
literal|128
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compare sections ASEC and BSEC according to SORT.  */
end_comment

begin_function
specifier|static
name|int
name|compare_section
parameter_list|(
name|sort_type
name|sort
parameter_list|,
name|asection
modifier|*
name|asec
parameter_list|,
name|asection
modifier|*
name|bsec
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
switch|switch
condition|(
name|sort
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|by_alignment_name
case|:
name|ret
operator|=
operator|(
name|bfd_section_alignment
argument_list|(
name|bsec
operator|->
name|owner
argument_list|,
name|bsec
argument_list|)
operator|-
name|bfd_section_alignment
argument_list|(
name|asec
operator|->
name|owner
argument_list|,
name|asec
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|by_name
case|:
name|ret
operator|=
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|asec
operator|->
name|owner
argument_list|,
name|asec
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|bsec
operator|->
name|owner
argument_list|,
name|bsec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|by_name_alignment
case|:
name|ret
operator|=
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|asec
operator|->
name|owner
argument_list|,
name|asec
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|bsec
operator|->
name|owner
argument_list|,
name|bsec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|by_alignment
case|:
name|ret
operator|=
operator|(
name|bfd_section_alignment
argument_list|(
name|bsec
operator|->
name|owner
argument_list|,
name|bsec
argument_list|)
operator|-
name|bfd_section_alignment
argument_list|(
name|asec
operator|->
name|owner
argument_list|,
name|asec
argument_list|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle wildcard sorting.  This returns the lang_input_section which    should follow the one we are going to create for SECTION and FILE,    based on the sorting requirements of WILD.  It returns NULL if the    new section should just go at the end of the current list.  */
end_comment

begin_function
specifier|static
name|lang_statement_union_type
modifier|*
name|wild_sort
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|wild
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|wild
operator|->
name|filenames_sorted
operator|&&
operator|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|==
name|none
operator|)
condition|)
return|return
name|NULL
return|;
name|section_name
operator|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|wild
operator|->
name|children
operator|.
name|head
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|header
operator|.
name|next
control|)
block|{
name|lang_input_section_type
modifier|*
name|ls
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|header
operator|.
name|type
operator|!=
name|lang_input_section_enum
condition|)
continue|continue;
name|ls
operator|=
operator|&
name|l
operator|->
name|input_section
expr_stmt|;
comment|/* Sorting by filename takes precedence over sorting by section 	 name.  */
if|if
condition|(
name|wild
operator|->
name|filenames_sorted
condition|)
block|{
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|ln
decl_stmt|;
name|bfd_boolean
name|fa
decl_stmt|,
name|la
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The PE support for the .idata section as generated by 	     dlltool assumes that files will be sorted by the name of 	     the archive and then the name of the file within the 	     archive.  */
if|if
condition|(
name|file
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|bfd_my_archive
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fn
operator|=
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|fa
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|fn
operator|=
name|file
operator|->
name|filename
expr_stmt|;
name|fa
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|ls
operator|->
name|section
operator|->
name|owner
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ln
operator|=
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|ls
operator|->
name|section
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|ls
operator|->
name|section
operator|->
name|owner
operator|->
name|filename
expr_stmt|;
name|la
operator|=
name|FALSE
expr_stmt|;
block|}
name|i
operator|=
name|strcmp
argument_list|(
name|fn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|fa
operator|||
name|la
condition|)
block|{
if|if
condition|(
name|fa
condition|)
name|fn
operator|=
name|file
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|la
condition|)
name|ln
operator|=
name|ls
operator|->
name|section
operator|->
name|owner
operator|->
name|filename
expr_stmt|;
name|i
operator|=
name|strcmp
argument_list|(
name|fn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Here either the files are not sorted by name, or we are 	 looking at the sections for this file.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|!=
name|none
condition|)
if|if
condition|(
name|compare_section
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|sorted
argument_list|,
name|section
argument_list|,
name|ls
operator|->
name|section
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Expand a wild statement for a particular FILE.  SECTION may be    NULL, in which case it is a wild card.  */
end_comment

begin_function
specifier|static
name|void
name|output_section_callback
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|output
parameter_list|)
block|{
name|lang_statement_union_type
modifier|*
name|before
decl_stmt|;
comment|/* Exclude sections that match UNIQUE_SECTION_LIST.  */
if|if
condition|(
name|unique_section_p
argument_list|(
name|section
argument_list|)
condition|)
return|return;
name|before
operator|=
name|wild_sort
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* Here BEFORE points to the lang_input_section which      should follow the one we are about to add.  If BEFORE      is NULL, then the section should just go at the end      of the current list.  */
if|if
condition|(
name|before
operator|==
name|NULL
condition|)
name|lang_add_section
argument_list|(
operator|&
name|ptr
operator|->
name|children
argument_list|,
name|section
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|output
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_statement_list_type
name|list
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|pp
decl_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|lang_add_section
argument_list|(
operator|&
name|list
argument_list|,
name|section
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|output
argument_list|)
expr_stmt|;
comment|/* If we are discarding the section, LIST.HEAD will 	 be NULL.  */
if|if
condition|(
name|list
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|list
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|ptr
operator|->
name|children
operator|.
name|head
init|;
operator|*
name|pp
operator|!=
name|before
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|header
operator|.
name|next
control|)
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|list
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|list
operator|.
name|head
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check if all sections in a wild statement for a particular FILE    are readonly.  */
end_comment

begin_function
specifier|static
name|void
name|check_section_callback
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Exclude sections that match UNIQUE_SECTION_LIST.  */
if|if
condition|(
name|unique_section_p
argument_list|(
name|section
argument_list|)
condition|)
return|return;
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|&&
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
operator|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|data
operator|)
operator|->
name|all_input_readonly
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is passed a file name which must have been seen already and    added to the statement tree.  We will see if it has been opened    already and had its symbols read.  If not then we'll read it.  */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|search
decl_stmt|;
for|for
control|(
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|search
operator|!=
name|NULL
condition|;
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|search
operator|->
name|next_real_file
control|)
block|{
comment|/* Use the local_sym_name as the name of the file that has 	 already been loaded as filename might have been transformed 	 via the search directory lookup mechanism.  */
specifier|const
name|char
modifier|*
name|filename
init|=
name|search
operator|->
name|local_sym_name
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
name|name
operator|==
name|NULL
condition|)
return|return
name|search
return|;
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|search
operator|==
name|NULL
condition|)
name|search
operator|=
name|new_afile
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_search_file_enum
argument_list|,
name|default_target
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If we have already added this file, or this file is not real      (FIXME: can that ever actually happen?) or the name is NULL      (FIXME: can that ever actually happen?) don't add this file.  */
if|if
condition|(
name|search
operator|->
name|loaded
operator|||
operator|!
name|search
operator|->
name|real
operator|||
name|search
operator|->
name|filename
operator|==
name|NULL
condition|)
return|return
name|search
return|;
if|if
condition|(
operator|!
name|load_symbols
argument_list|(
name|search
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Save LIST as a list of libraries whose symbols should not be exported.  */
end_comment

begin_struct
struct|struct
name|excluded_lib
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|excluded_lib
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|excluded_lib
modifier|*
name|excluded_libs
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_excluded_libs
parameter_list|(
specifier|const
name|char
modifier|*
name|list
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|list
decl_stmt|,
modifier|*
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|excluded_lib
modifier|*
name|entry
decl_stmt|;
name|end
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|",:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
name|end
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|excluded_libs
expr_stmt|;
name|entry
operator|->
name|name
operator|=
name|xmalloc
argument_list|(
name|end
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|)
expr_stmt|;
name|entry
operator|->
name|name
index|[
name|end
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|excluded_libs
operator|=
name|entry
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_excluded_libs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|excluded_lib
modifier|*
name|lib
init|=
name|excluded_libs
decl_stmt|;
while|while
condition|(
name|lib
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|lib
operator|->
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|lbasename
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lib
operator|->
name|name
argument_list|,
literal|"ALL"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|abfd
operator|->
name|no_export
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|lib
operator|->
name|name
argument_list|,
name|filename
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|filename
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|filename
index|[
name|len
index|]
operator|==
literal|'.'
operator|&&
name|filename
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|filename
index|[
name|len
operator|+
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|abfd
operator|->
name|no_export
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|lib
operator|=
name|lib
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the symbols for an input file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|load_symbols
parameter_list|(
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|,
name|lang_statement_list_type
modifier|*
name|place
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|loaded
condition|)
return|return
name|TRUE
return|;
name|ldfile_open_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
operator|&&
operator|!
name|bfd_check_format_matches
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_error_type
name|err
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|hold
decl_stmt|;
name|bfd_boolean
name|bad_load
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|save_ldlang_sysrooted_script
decl_stmt|;
name|bfd_boolean
name|save_as_needed
decl_stmt|,
name|save_add_needed
decl_stmt|;
name|err
operator|=
name|bfd_get_error
argument_list|()
expr_stmt|;
comment|/* See if the emulation has some special knowledge.  */
if|if
condition|(
name|ldemul_unrecognized_file
argument_list|(
name|entry
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|err
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: file not recognized: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: matching formats:"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|matching
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|einfo
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%F\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|bfd_error_file_not_recognized
operator|||
name|place
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: file not recognized: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
else|else
name|bad_load
operator|=
name|FALSE
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
comment|/* Try to interpret the file as a linker script.  */
name|ldfile_open_command_file
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|hold
operator|=
name|stat_ptr
expr_stmt|;
name|stat_ptr
operator|=
name|place
expr_stmt|;
name|save_ldlang_sysrooted_script
operator|=
name|ldlang_sysrooted_script
expr_stmt|;
name|ldlang_sysrooted_script
operator|=
name|entry
operator|->
name|sysrooted
expr_stmt|;
name|save_as_needed
operator|=
name|as_needed
expr_stmt|;
name|as_needed
operator|=
name|entry
operator|->
name|as_needed
expr_stmt|;
name|save_add_needed
operator|=
name|add_needed
expr_stmt|;
name|add_needed
operator|=
name|entry
operator|->
name|add_needed
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|TRUE
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
comment|/* We want to use the same -Bdynamic/-Bstatic as the one for 	 ENTRY.  */
name|config
operator|.
name|dynamic_link
operator|=
name|entry
operator|->
name|dynamic
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|FALSE
expr_stmt|;
name|ldlang_sysrooted_script
operator|=
name|save_ldlang_sysrooted_script
expr_stmt|;
name|as_needed
operator|=
name|save_as_needed
expr_stmt|;
name|add_needed
operator|=
name|save_add_needed
expr_stmt|;
name|stat_ptr
operator|=
name|hold
expr_stmt|;
return|return
operator|!
name|bad_load
return|;
block|}
if|if
condition|(
name|ldemul_recognized_file
argument_list|(
name|entry
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* We don't call ldlang_add_file for an archive.  Instead, the      add_symbols entry point will call ldlang_add_file, via the      add_archive_element callback, for each element of the archive      which is used.  */
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_object
case|:
name|ldlang_add_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
operator|||
name|trace_file_tries
condition|)
name|info_msg
argument_list|(
literal|"%I\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_archive
case|:
name|check_excluded_libs
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|whole_archive
condition|)
block|{
name|bfd
modifier|*
name|member
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|loaded
init|=
name|TRUE
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|member
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: member %B in archive is not an object\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|.
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
operator|&
name|link_info
argument_list|,
name|member
argument_list|,
literal|"--whole-archive"
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|member
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|loaded
operator|=
name|loaded
expr_stmt|;
return|return
name|loaded
return|;
block|}
break|break;
block|}
if|if
condition|(
name|bfd_link_add_symbols
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
name|entry
operator|->
name|loaded
operator|=
name|TRUE
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|loaded
return|;
block|}
end_function

begin_comment
comment|/* Handle a wild statement.  S->FILENAME or S->SECTION_LIST or both    may be NULL, indicating that it is a wildcard.  Separate    lang_input_section statements are created for each part of the    expansion; they are added after the wild statement S.  OUTPUT is    the output section.  */
end_comment

begin_function
specifier|static
name|void
name|wild
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|target
name|ATTRIBUTE_UNUSED
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output
parameter_list|)
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|walk_wild
argument_list|(
name|s
argument_list|,
name|output_section_callback
argument_list|,
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|s
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|default_common_section
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember the section that common is going to in case we 	     later get something which doesn't know where to put it.  */
name|default_common_section
operator|=
name|output
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return TRUE iff target is the sought target.  */
end_comment

begin_function
specifier|static
name|int
name|get_target
parameter_list|(
specifier|const
name|bfd_target
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sought
init|=
name|data
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|target
operator|->
name|name
argument_list|,
name|sought
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like strcpy() but convert to lower case as well.  */
end_comment

begin_function
specifier|static
name|void
name|stricpy
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|0
condition|)
operator|*
name|dest
operator|++
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the first occurrence of needle (if any) in haystack    from haystack.  */
end_comment

begin_function
specifier|static
name|void
name|strcut
parameter_list|(
name|char
modifier|*
name|haystack
parameter_list|,
name|char
modifier|*
name|needle
parameter_list|)
block|{
name|haystack
operator|=
name|strstr
argument_list|(
name|haystack
argument_list|,
name|needle
argument_list|)
expr_stmt|;
if|if
condition|(
name|haystack
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
for|for
control|(
name|src
operator|=
name|haystack
operator|+
name|strlen
argument_list|(
name|needle
argument_list|)
init|;
operator|*
name|src
condition|;
control|)
operator|*
name|haystack
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|haystack
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two target format name strings.    Return a value indicating how "similar" they are.  */
end_comment

begin_function
specifier|static
name|int
name|name_compare
parameter_list|(
name|char
modifier|*
name|first
parameter_list|,
name|char
modifier|*
name|second
parameter_list|)
block|{
name|char
modifier|*
name|copy1
decl_stmt|;
name|char
modifier|*
name|copy2
decl_stmt|;
name|int
name|result
decl_stmt|;
name|copy1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|first
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|second
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Convert the names to lower case.  */
name|stricpy
argument_list|(
name|copy1
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|stricpy
argument_list|(
name|copy2
argument_list|,
name|second
argument_list|)
expr_stmt|;
comment|/* Remove size and endian strings from the name.  */
name|strcut
argument_list|(
name|copy1
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy1
argument_list|,
literal|"little"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy2
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy2
argument_list|,
literal|"little"
argument_list|)
expr_stmt|;
comment|/* Return a value based on how many characters match,      starting from the beginning.   If both strings are      the same then return 10 * their length.  */
for|for
control|(
name|result
operator|=
literal|0
init|;
name|copy1
index|[
name|result
index|]
operator|==
name|copy2
index|[
name|result
index|]
condition|;
name|result
operator|++
control|)
if|if
condition|(
name|copy1
index|[
name|result
index|]
operator|==
literal|0
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|copy1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy2
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Set by closest_target_match() below.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|winner
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan all the valid bfd targets looking for one that has the endianness    requirement that was specified on the command line, and is the nearest    match to the original output target.  */
end_comment

begin_function
specifier|static
name|int
name|closest_target_match
parameter_list|(
specifier|const
name|bfd_target
modifier|*
name|target
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|bfd_target
modifier|*
name|original
init|=
name|data
decl_stmt|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
operator|&&
name|target
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_BIG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
operator|&&
name|target
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_LITTLE
condition|)
return|return
literal|0
return|;
comment|/* Must be the same flavour.  */
if|if
condition|(
name|target
operator|->
name|flavour
operator|!=
name|original
operator|->
name|flavour
condition|)
return|return
literal|0
return|;
comment|/* If we have not found a potential winner yet, then record this one.  */
if|if
condition|(
name|winner
operator|==
name|NULL
condition|)
block|{
name|winner
operator|=
name|target
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Oh dear, we now have two potential candidates for a successful match.      Compare their names and choose the better one.  */
if|if
condition|(
name|name_compare
argument_list|(
name|target
operator|->
name|name
argument_list|,
name|original
operator|->
name|name
argument_list|)
operator|>
name|name_compare
argument_list|(
name|winner
operator|->
name|name
argument_list|,
name|original
operator|->
name|name
argument_list|)
condition|)
name|winner
operator|=
name|target
expr_stmt|;
comment|/* Keep on searching until wqe have checked them all.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the BFD target format of the first input file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_first_input_target
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|s
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|header
operator|.
name|type
operator|==
name|lang_input_statement_enum
operator|&&
name|s
operator|->
name|real
condition|)
block|{
name|ldfile_open_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|bfd_check_format
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|target
operator|=
name|bfd_get_target
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|lang_get_output_target
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
comment|/* Has the user told us which output format to use?  */
if|if
condition|(
name|output_target
operator|!=
name|NULL
condition|)
return|return
name|output_target
return|;
comment|/* No - has the current target been set to something other than      the default?  */
if|if
condition|(
name|current_target
operator|!=
name|default_target
condition|)
return|return
name|current_target
return|;
comment|/* No - can we determine the format of the first input file?  */
name|target
operator|=
name|get_first_input_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
return|return
name|target
return|;
comment|/* Failed - use the default output target.  */
return|return
name|default_target
return|;
block|}
end_function

begin_comment
comment|/* Open the output file.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|open_output
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|bfd
modifier|*
name|output
decl_stmt|;
name|output_target
operator|=
name|lang_get_output_target
argument_list|()
expr_stmt|;
comment|/* Has the user requested a particular endianness on the command      line?  */
if|if
condition|(
name|command_line
operator|.
name|endian
operator|!=
name|ENDIAN_UNSET
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
name|enum
name|bfd_endian
name|desired_endian
decl_stmt|;
comment|/* Get the chosen target.  */
name|target
operator|=
name|bfd_search_for_target
argument_list|(
name|get_target
argument_list|,
operator|(
name|void
operator|*
operator|)
name|output_target
argument_list|)
expr_stmt|;
comment|/* If the target is not supported, we cannot do anything.  */
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
condition|)
name|desired_endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
else|else
name|desired_endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
comment|/* See if the target has the wrong endianness.  This should 	     not happen if the linker script has provided big and 	     little endian alternatives, but some scrips don't do 	     this.  */
if|if
condition|(
name|target
operator|->
name|byteorder
operator|!=
name|desired_endian
condition|)
block|{
comment|/* If it does, then see if the target provides 		 an alternative with the correct endianness.  */
if|if
condition|(
name|target
operator|->
name|alternative_target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|alternative_target
operator|->
name|byteorder
operator|==
name|desired_endian
operator|)
condition|)
name|output_target
operator|=
name|target
operator|->
name|alternative_target
operator|->
name|name
expr_stmt|;
else|else
block|{
comment|/* Try to find a target as similar as possible to 		     the default target, but which has the desired 		     endian characteristic.  */
name|bfd_search_for_target
argument_list|(
name|closest_target_match
argument_list|,
operator|(
name|void
operator|*
operator|)
name|target
argument_list|)
expr_stmt|;
comment|/* Oh dear - we could not find any targets that 		     satisfy our requirements.  */
if|if
condition|(
name|winner
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: could not find any targets"
literal|" that match endianness requirement\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_target
operator|=
name|winner
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
block|}
name|output
operator|=
name|bfd_openw
argument_list|(
name|name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_target
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: target %s not found\n"
argument_list|)
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open output file %s: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|delete_output_file_on_failure
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|output
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can not make object file: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|output
argument_list|,
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can not set architecture: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|hash
operator|=
name|bfd_link_hash_table_create
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|hash
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can not create hash table: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|output
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ldlang_open_output
parameter_list|(
name|lang_statement_union_type
modifier|*
name|statement
parameter_list|)
block|{
switch|switch
condition|(
name|statement
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_statement_enum
case|:
name|ASSERT
argument_list|(
name|output_bfd
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|open_output
argument_list|(
name|statement
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
name|ldemul_set_output_arch
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|magic_demand_paged
operator|&&
operator|!
name|link_info
operator|.
name|relocatable
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|text_read_only
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|traditional_format
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|statement
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Convert between addresses in bytes and sizes in octets.    For currently supported targets, octets_per_byte is always a power    of two, so we can use shifts.  */
end_comment

begin_define
define|#
directive|define
name|TO_ADDR
parameter_list|(
name|X
parameter_list|)
value|((X)>> opb_shift)
end_define

begin_define
define|#
directive|define
name|TO_SIZE
parameter_list|(
name|X
parameter_list|)
value|((X)<< opb_shift)
end_define

begin_comment
comment|/* Support the above.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|opb_shift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_opb
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|x
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
name|opb_shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|1
condition|)
while|while
condition|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|x
operator|>>=
literal|1
expr_stmt|;
operator|++
name|opb_shift
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|x
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open all the input files.  */
end_comment

begin_function
specifier|static
name|void
name|open_input_bfds
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|bfd_boolean
name|force
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
comment|/* Maybe we should load the file's symbols.  */
if|if
condition|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
operator|&&
operator|!
name|wildcardp
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
condition|)
name|lookup_name
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs
decl_stmt|;
comment|/* We must continually search the entries in the group 	       until no new symbols are added to the list of undefined 	       symbols.  */
do|do
block|{
name|undefs
operator|=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|undefs
operator|!=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
condition|)
do|;
block|}
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|s
operator|->
name|input_statement
operator|.
name|real
condition|)
block|{
name|lang_statement_list_type
name|add
decl_stmt|;
name|s
operator|->
name|input_statement
operator|.
name|target
operator|=
name|current_target
expr_stmt|;
comment|/* If we are being called from within a group, and this 		 is an archive which has already been searched, then 		 force it to be researched unless the whole archive 		 has been loaded already.  */
if|if
condition|(
name|force
operator|&&
operator|!
name|s
operator|->
name|input_statement
operator|.
name|whole_archive
operator|&&
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|&&
name|bfd_check_format
argument_list|(
name|s
operator|->
name|input_statement
operator|.
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|=
name|FALSE
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_symbols
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|,
operator|&
name|add
argument_list|)
condition|)
name|config
operator|.
name|make_executable
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|add
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
operator|*
name|add
operator|.
name|tail
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
name|s
operator|->
name|header
operator|.
name|next
operator|=
name|add
operator|.
name|head
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a symbol to a hash of symbols used in DEFINED (NAME) expressions.  */
end_comment

begin_function
name|void
name|lang_track_definedness
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
operator|&
name|lang_definedness_table
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup failed creating symbol %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* New-function for the definedness hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|lang_definedness_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|lang_definedness_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|lang_definedness_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
expr|struct
name|lang_definedness_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_definedness_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_allocate failed creating symbol %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|iteration
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Return the iteration when the definition of NAME was last updated.  A    value of -1 means that the symbol is not defined in the linker script    or the command line, but may be defined in the linker symbol table.  */
end_comment

begin_function
name|int
name|lang_symbol_definition_iteration
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|lang_definedness_hash_entry
modifier|*
name|defentry
init|=
operator|(
expr|struct
name|lang_definedness_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|lang_definedness_table
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* We've already created this one on the presence of DEFINED in the      script, so it can't be NULL unless something is borked elsewhere in      the code.  */
if|if
condition|(
name|defentry
operator|==
name|NULL
condition|)
name|FAIL
argument_list|()
expr_stmt|;
return|return
name|defentry
operator|->
name|iteration
return|;
block|}
end_function

begin_comment
comment|/* Update the definedness state of NAME.  */
end_comment

begin_function
name|void
name|lang_update_definedness
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|lang_definedness_hash_entry
modifier|*
name|defentry
init|=
operator|(
expr|struct
name|lang_definedness_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|lang_definedness_table
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* We don't keep track of symbols not tested with DEFINED.  */
if|if
condition|(
name|defentry
operator|==
name|NULL
condition|)
return|return;
comment|/* If the symbol was already defined, and not from an earlier statement      iteration, don't update the definedness iteration, because that'd      make the symbol seem defined in the linker script at this point, and      it wasn't; it was defined in some object.  If we do anyway, DEFINED      would start to yield false before this point and the construct "sym =      DEFINED (sym) ? sym : X;" would change sym to X despite being defined      in an object.  */
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_new
operator|&&
name|defentry
operator|->
name|iteration
operator|==
operator|-
literal|1
condition|)
return|return;
name|defentry
operator|->
name|iteration
operator|=
name|lang_statement_iteration
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the supplied name to the symbol table as an undefined reference.    This is a two step process as the symbol table doesn't even exist at    the time the ld command line is processed.  First we put the name    on a list, then, once the output file has been opened, transfer the    name to the symbol table.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|bfd_sym_chain
name|ldlang_undef_chain_list_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ldlang_undef_chain_list_head
value|entry_symbol.next
end_define

begin_function
name|void
name|ldlang_add_undef
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|name
parameter_list|)
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|new
init|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ldlang_undef_chain_list_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
name|ldlang_undef_chain_list_head
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|insert_undefined
argument_list|(
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert NAME as undefined in the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|insert_undefined
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Run through the list of undefineds created above and place them    into the linker hash table as undefined symbols belonging to the    script file.  */
end_comment

begin_function
specifier|static
name|void
name|lang_place_undefineds
parameter_list|(
name|void
parameter_list|)
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|ldlang_undef_chain_list_head
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|insert_undefined
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check for all readonly or some readwrite sections.  */
end_comment

begin_function
specifier|static
name|void
name|check_input_sections
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|walk_wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|check_section_callback
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_section_statement
operator|->
name|all_input_readonly
condition|)
return|return;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|check_input_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_section_statement
operator|->
name|all_input_readonly
condition|)
return|return;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|check_input_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_section_statement
operator|->
name|all_input_readonly
condition|)
return|return;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Update wildcard statements if needed.  */
end_comment

begin_function
specifier|static
name|void
name|update_wild_statements
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
switch|switch
condition|(
name|sort_section
condition|)
block|{
default|default:
name|FAIL
argument_list|()
expr_stmt|;
case|case
name|none
case|:
break|break;
case|case
name|by_name
case|:
case|case
name|by_alignment
case|:
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|sec
operator|=
name|s
operator|->
name|wild_statement
operator|.
name|section_list
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
block|{
case|case
name|none
case|:
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|=
name|sort_section
expr_stmt|;
break|break;
case|case
name|by_name
case|:
if|if
condition|(
name|sort_section
operator|==
name|by_alignment
condition|)
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|=
name|by_name_alignment
expr_stmt|;
break|break;
case|case
name|by_alignment
case|:
if|if
condition|(
name|sort_section
operator|==
name|by_name
condition|)
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|=
name|by_alignment_name
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|update_wild_statements
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|update_wild_statements
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|update_wild_statements
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Open input files and attach to output sections.  */
end_comment

begin_function
specifier|static
name|void
name|map_input_to_output_sections
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|target
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
if|if
condition|(
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
operator|!=
name|ONLY_IF_RW
operator|&&
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
operator|!=
name|ONLY_IF_RO
condition|)
break|break;
name|s
operator|->
name|output_section_statement
operator|.
name|all_input_readonly
operator|=
name|TRUE
expr_stmt|;
name|check_input_sections
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|output_section_statement
operator|.
name|all_input_readonly
operator|&&
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
operator|==
name|ONLY_IF_RW
operator|)
operator|||
operator|(
operator|!
name|s
operator|->
name|output_section_statement
operator|.
name|all_input_readonly
operator|&&
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
operator|==
name|ONLY_IF_RO
operator|)
condition|)
block|{
name|s
operator|->
name|output_section_statement
operator|.
name|constraint
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
break|break;
case|case
name|lang_target_statement_enum
case|:
name|target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
comment|/* Make sure that any sections mentioned in the expression 	     are initialized.  */
name|exp_init_os
argument_list|(
name|s
operator|->
name|data_statement
operator|.
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The output section gets contents, and then we inspect for 	     any flags set in the input script which override any ALLOC.  */
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|os
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
condition|)
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Make sure that any sections mentioned in the assignment 	     are initialized.  */
name|exp_init_os
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
comment|/* Mark the specified section with the supplied address.    	     If this section was actually a segment marker, then the 	     directive is ignored if the linker script explicitly 	     processed the segment marker.  Originally, the linker 	     treated segment directives (like -Ttext on the 	     command-line) as section directives.  We honor the 	     section directive semantics for backwards compatibilty; 	     linker scripts that do not specifically check for 	     SEGMENT_START automatically get the old semantics.  */
if|if
condition|(
operator|!
name|s
operator|->
name|address_statement
operator|.
name|segment
operator|||
operator|!
name|s
operator|->
name|address_statement
operator|.
name|segment
operator|->
name|used
condition|)
block|{
name|lang_output_section_statement_type
modifier|*
name|aos
init|=
operator|(
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|address_statement
operator|.
name|section_name
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|aos
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|aos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|aos
operator|->
name|addr_tree
operator|=
name|s
operator|->
name|address_statement
operator|.
name|address
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* An output section might have been removed after its statement was    added.  For example, ldemul_before_allocation can remove dynamic    sections if they turn out to be not needed.  Clean them up here.  */
end_comment

begin_function
name|void
name|strip_excluded_output_sections
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
comment|/* Run lang_size_sections (if not already done).  */
if|if
condition|(
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
block|{
name|expld
operator|.
name|phase
operator|=
name|lang_mark_phase_enum
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_none
expr_stmt|;
name|one_lang_size_sections_pass
argument_list|(
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lang_reset_memory_regions
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|os
operator|=
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
init|;
name|os
operator|!=
name|NULL
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_boolean
name|exclude
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|constraint
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|output_section
operator|=
name|os
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
continue|continue;
name|exclude
operator|=
operator|(
name|output_section
operator|->
name|rawsize
operator|==
literal|0
operator|&&
operator|(
name|output_section
operator|->
name|flags
operator|&
name|SEC_KEEP
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bfd_section_removed_from_list
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
operator|)
expr_stmt|;
comment|/* Some sections have not yet been sized, notably .gnu.version, 	 .dynsym, .dynstr and .hash.  These all have SEC_LINKER_CREATED 	 input sections, so don't drop output sections that have such 	 input sections unless they are also marked SEC_EXCLUDE.  */
if|if
condition|(
name|exclude
operator|&&
name|output_section
operator|->
name|map_head
operator|.
name|s
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|output_section
operator|->
name|map_head
operator|.
name|s
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|map_head
operator|.
name|s
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|)
block|{
name|exclude
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
comment|/* TODO: Don't just junk map_head.s, turn them into link_orders.  */
name|output_section
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
name|output_section
operator|->
name|map_tail
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exclude
condition|)
block|{
comment|/* We don't set bfd_section to NULL since bfd_section of the 	     removed output section statement may still be used.  */
name|os
operator|->
name|ignored
operator|=
name|TRUE
expr_stmt|;
name|output_section
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|bfd_section_list_remove
argument_list|(
name|output_bfd
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
name|output_bfd
operator|->
name|section_count
operator|--
expr_stmt|;
block|}
block|}
comment|/* Stop future calls to lang_add_section from messing with map_head      and map_tail link_order fields.  */
name|stripped_excluded_sections
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_output_section_statement
parameter_list|(
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
parameter_list|)
block|{
name|asection
modifier|*
name|section
init|=
name|output_section_statement
operator|->
name|bfd_section
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|output_section_statement
operator|!=
name|abs_output_section
condition|)
block|{
name|minfo
argument_list|(
literal|"\n%s"
argument_list|,
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
name|print_dot
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W"
argument_list|,
name|section
operator|->
name|vma
argument_list|,
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_section_statement
operator|->
name|load_base
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|exp_get_abs_int
argument_list|(
name|output_section_statement
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
name|_
argument_list|(
literal|" load address 0x%V"
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|print_nl
argument_list|()
expr_stmt|;
block|}
name|print_statement_list
argument_list|(
name|output_section_statement
operator|->
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan for the use of the destination in the right hand side    of an expression.  In such cases we will not compute the    correct expression, since the value of DST that is used on    the right hand side will be its final value, not its value    just before this expression is evaluated.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|scan_for_self_assignment
parameter_list|(
specifier|const
name|char
modifier|*
name|dst
parameter_list|,
name|etree_type
modifier|*
name|rhs
parameter_list|)
block|{
if|if
condition|(
name|rhs
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|rhs
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_binary
case|:
return|return
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|binary
operator|.
name|lhs
argument_list|)
operator|||
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|binary
operator|.
name|rhs
argument_list|)
return|;
case|case
name|etree_trinary
case|:
return|return
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
operator|||
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
return|;
case|case
name|etree_assign
case|:
case|case
name|etree_provided
case|:
case|case
name|etree_provide
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|assign
operator|.
name|dst
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|assign
operator|.
name|src
argument_list|)
return|;
case|case
name|etree_unary
case|:
return|return
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|unary
operator|.
name|child
argument_list|)
return|;
case|case
name|etree_value
case|:
if|if
condition|(
name|rhs
operator|->
name|value
operator|.
name|str
condition|)
return|return
name|strcmp
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|value
operator|.
name|str
argument_list|)
operator|==
literal|0
return|;
return|return
name|FALSE
return|;
case|case
name|etree_name
case|:
if|if
condition|(
name|rhs
operator|->
name|name
operator|.
name|name
condition|)
return|return
name|strcmp
argument_list|(
name|dst
argument_list|,
name|rhs
operator|->
name|name
operator|.
name|name
argument_list|)
operator|==
literal|0
return|;
return|return
name|FALSE
return|;
default|default:
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_assignment
parameter_list|(
name|lang_assignment_statement_type
modifier|*
name|assignment
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output_section
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_boolean
name|is_dot
decl_stmt|;
name|bfd_boolean
name|computation_is_valid
init|=
name|TRUE
decl_stmt|;
name|etree_type
modifier|*
name|tree
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|assignment
operator|->
name|exp
operator|->
name|type
operator|.
name|node_class
operator|==
name|etree_assert
condition|)
block|{
name|is_dot
operator|=
name|FALSE
expr_stmt|;
name|tree
operator|=
name|assignment
operator|->
name|exp
operator|->
name|assert_s
operator|.
name|child
expr_stmt|;
name|computation_is_valid
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|dst
init|=
name|assignment
operator|->
name|exp
operator|->
name|assign
operator|.
name|dst
decl_stmt|;
name|is_dot
operator|=
operator|(
name|dst
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dst
index|[
literal|1
index|]
operator|==
literal|0
operator|)
expr_stmt|;
name|tree
operator|=
name|assignment
operator|->
name|exp
operator|->
name|assign
operator|.
name|src
expr_stmt|;
name|computation_is_valid
operator|=
name|is_dot
operator|||
operator|(
name|scan_for_self_assignment
argument_list|(
name|dst
argument_list|,
name|tree
argument_list|)
operator|==
name|FALSE
operator|)
expr_stmt|;
block|}
name|exp_fold_tree
argument_list|(
name|tree
argument_list|,
name|output_section
operator|->
name|bfd_section
argument_list|,
operator|&
name|print_dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|computation_is_valid
condition|)
block|{
name|value
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|section
condition|)
name|value
operator|+=
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dot
condition|)
name|print_dot
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|assignment
operator|->
name|exp
operator|->
name|assign
operator|.
name|dst
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
block|{
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|section
condition|)
name|value
operator|+=
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
expr_stmt|;
name|minfo
argument_list|(
literal|"[0x%V]"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|minfo
argument_list|(
literal|"[unresolved]"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|minfo
argument_list|(
literal|"*undef*   "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|minfo
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|minfo
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|assignment
operator|->
name|exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_input_statement
parameter_list|(
name|lang_input_statement_type
modifier|*
name|statm
parameter_list|)
block|{
if|if
condition|(
name|statm
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"LOAD %s\n"
argument_list|,
name|statm
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print all symbols defined in a particular section.  This is called    via bfd_link_hash_traverse, or by print_all_symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|print_one_symbol
parameter_list|(
name|struct
name|bfd_link_hash_entry
modifier|*
name|hash_entry
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|asection
modifier|*
name|sec
init|=
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sec
operator|==
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V   "
argument_list|,
operator|(
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"             %T\n"
argument_list|,
name|hash_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_all_symbols
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|fat_user_section_struct
modifier|*
name|ud
init|=
name|get_userdata
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|map_symbol_def
modifier|*
name|def
decl_stmt|;
if|if
condition|(
operator|!
name|ud
condition|)
return|return;
operator|*
name|ud
operator|->
name|map_symbol_def_tail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|def
operator|=
name|ud
operator|->
name|map_symbol_def_head
init|;
name|def
condition|;
name|def
operator|=
name|def
operator|->
name|next
control|)
name|print_one_symbol
argument_list|(
name|def
operator|->
name|entry
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information about an input section to the map file.  */
end_comment

begin_function
specifier|static
name|void
name|print_input_section
parameter_list|(
name|asection
modifier|*
name|i
parameter_list|)
block|{
name|bfd_size_type
name|size
init|=
name|i
operator|->
name|size
decl_stmt|;
name|init_opb
argument_list|()
expr_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|i
operator|->
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
condition|)
name|addr
operator|=
name|i
operator|->
name|output_section
operator|->
name|vma
operator|+
name|i
operator|->
name|output_offset
expr_stmt|;
else|else
block|{
name|addr
operator|=
name|print_dot
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %B\n"
argument_list|,
name|addr
argument_list|,
name|TO_ADDR
argument_list|(
name|size
argument_list|)
argument_list|,
name|i
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|i
operator|->
name|rawsize
operator|&&
name|i
operator|->
name|rawsize
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|SECTION_NAME_MAP_LENGTH
operator|+
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|len
operator|+=
literal|16
expr_stmt|;
else|#
directive|else
name|len
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
name|_
argument_list|(
literal|"%W (size before relaxing)\n"
argument_list|)
argument_list|,
name|i
operator|->
name|rawsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|i
operator|->
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|reduce_memory_overheads
condition|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|print_one_symbol
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|print_all_symbols
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_fill_statement
parameter_list|(
name|lang_fill_statement_type
modifier|*
name|fill
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|fputs
argument_list|(
literal|" FILL mask 0x"
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fill
operator|->
name|fill
operator|->
name|data
operator|,
name|size
operator|=
name|fill
operator|->
name|fill
operator|->
name|size
init|;
name|size
operator|!=
literal|0
condition|;
name|p
operator|++
operator|,
name|size
operator|--
control|)
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|config
operator|.
name|map_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_data_statement
parameter_list|(
name|lang_data_statement_type
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|init_opb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|data
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|data
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
name|name
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
name|name
operator|=
literal|"SHORT"
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
name|name
operator|=
literal|"LONG"
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
name|name
operator|=
literal|"QUAD"
expr_stmt|;
break|break;
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
name|name
operator|=
literal|"SQUAD"
expr_stmt|;
break|break;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %s 0x%v"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|name
argument_list|,
name|data
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|exp
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_value
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|exp_print_tree
argument_list|(
name|data
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an address statement.  These are generated by options like    -Ttext.  */
end_comment

begin_function
specifier|static
name|void
name|print_address_statement
parameter_list|(
name|lang_address_statement_type
modifier|*
name|address
parameter_list|)
block|{
name|minfo
argument_list|(
name|_
argument_list|(
literal|"Address of section %s set to "
argument_list|)
argument_list|,
name|address
operator|->
name|section_name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|address
operator|->
name|address
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a reloc statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_reloc_statement
parameter_list|(
name|lang_reloc_statement_type
modifier|*
name|reloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|init_opb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|reloc
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|reloc
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc
operator|->
name|howto
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W RELOC %s "
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|reloc
operator|->
name|addend_exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_padding_statement
parameter_list|(
name|lang_padding_statement_type
modifier|*
name|s
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|init_opb
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|" *fill*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
expr|" *fill*"
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|addr
operator|=
name|s
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|s
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W "
argument_list|,
name|addr
argument_list|,
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fill
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
operator|->
name|fill
operator|->
name|data
operator|,
name|size
operator|=
name|s
operator|->
name|fill
operator|->
name|size
init|;
name|size
operator|!=
literal|0
condition|;
name|p
operator|++
operator|,
name|size
operator|--
control|)
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|TO_ADDR
argument_list|(
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_wild_statement
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|w
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|print_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filenames_sorted
condition|)
name|minfo
argument_list|(
literal|"SORT("
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|w
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filenames_sorted
condition|)
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|w
operator|->
name|section_list
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
name|minfo
argument_list|(
literal|"SORT("
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|!=
name|NULL
condition|)
block|{
name|name_list
modifier|*
name|tmp
decl_stmt|;
name|minfo
argument_list|(
literal|"EXCLUDE_FILE(%s"
argument_list|,
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|->
name|next
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|minfo
argument_list|(
literal|" %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|next
condition|)
name|minfo
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_statement_list
argument_list|(
name|w
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a group statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_group
parameter_list|(
name|lang_group_statement_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"START GROUP\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|s
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"END GROUP\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the list of statements in S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement_list
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the first statement in statement list S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|_
argument_list|(
literal|"Fail with %d\n"
argument_list|)
argument_list|,
name|s
operator|->
name|header
operator|.
name|type
argument_list|)
expr_stmt|;
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
if|if
condition|(
name|constructor_list
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|constructors_sorted
condition|)
name|minfo
argument_list|(
literal|" SORT (CONSTRUCTORS)\n"
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|" CONSTRUCTORS\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|print_wild_statement
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
name|print_address_statement
argument_list|(
operator|&
name|s
operator|->
name|address_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|minfo
argument_list|(
literal|" CREATE_OBJECT_SYMBOLS\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|print_fill_statement
argument_list|(
operator|&
name|s
operator|->
name|fill_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
name|print_data_statement
argument_list|(
operator|&
name|s
operator|->
name|data_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_reloc_statement_enum
case|:
name|print_reloc_statement
argument_list|(
operator|&
name|s
operator|->
name|reloc_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
name|print_input_section
argument_list|(
name|s
operator|->
name|input_section
operator|.
name|section
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|print_padding_statement
argument_list|(
operator|&
name|s
operator|->
name|padding_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|print_output_section_statement
argument_list|(
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
name|print_assignment
argument_list|(
operator|&
name|s
operator|->
name|assignment_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"TARGET(%s)\n"
argument_list|,
name|s
operator|->
name|target_statement
operator|.
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
name|minfo
argument_list|(
literal|"OUTPUT(%s"
argument_list|,
name|s
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_target
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|" %s"
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
name|print_input_statement
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|print_group
argument_list|(
operator|&
name|s
operator|->
name|group_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_statements
parameter_list|(
name|void
parameter_list|)
block|{
name|print_statement_list
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the first N statements in statement list S to STDERR.    If N == 0, nothing is printed.    If N< 0, the entire list is printed.    Intended to be called from GDB.  */
end_comment

begin_function
name|void
name|dprint_statement
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|FILE
modifier|*
name|map_save
init|=
name|config
operator|.
name|map_file
decl_stmt|;
name|config
operator|.
name|map_file
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|print_statement_list
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|s
operator|&&
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
block|}
name|config
operator|.
name|map_file
operator|=
name|map_save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_pad
parameter_list|(
name|lang_statement_union_type
modifier|*
modifier|*
name|ptr
parameter_list|,
name|fill_type
modifier|*
name|fill
parameter_list|,
name|unsigned
name|int
name|alignment_needed
parameter_list|,
name|asection
modifier|*
name|output_section
parameter_list|,
name|bfd_vma
name|dot
parameter_list|)
block|{
specifier|static
name|fill_type
name|zero_fill
init|=
block|{
literal|1
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|pad
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|&
name|statement_list
operator|.
name|head
condition|)
name|pad
operator|=
operator|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
name|offsetof
argument_list|(
name|lang_statement_union_type
argument_list|,
name|header
operator|.
name|next
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
name|NULL
operator|&&
name|pad
operator|->
name|header
operator|.
name|type
operator|==
name|lang_padding_statement_enum
operator|&&
name|pad
operator|->
name|padding_statement
operator|.
name|output_section
operator|==
name|output_section
condition|)
block|{
comment|/* Use the existing pad statement.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|pad
operator|=
operator|*
name|ptr
operator|)
operator|!=
name|NULL
operator|&&
name|pad
operator|->
name|header
operator|.
name|type
operator|==
name|lang_padding_statement_enum
operator|&&
name|pad
operator|->
name|padding_statement
operator|.
name|output_section
operator|==
name|output_section
condition|)
block|{
comment|/* Use the existing pad statement.  */
block|}
else|else
block|{
comment|/* Make a new padding statement, linked into existing chain.  */
name|pad
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_padding_statement_type
argument_list|)
argument_list|)
expr_stmt|;
name|pad
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
name|pad
expr_stmt|;
name|pad
operator|->
name|header
operator|.
name|type
operator|=
name|lang_padding_statement_enum
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|output_section
operator|=
name|output_section
expr_stmt|;
if|if
condition|(
name|fill
operator|==
name|NULL
condition|)
name|fill
operator|=
operator|&
name|zero_fill
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|fill
operator|=
name|fill
expr_stmt|;
block|}
name|pad
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section
operator|->
name|vma
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|size
operator|=
name|alignment_needed
expr_stmt|;
name|output_section
operator|->
name|size
operator|+=
name|alignment_needed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work out how much this section will move the dot point.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|size_input_section
parameter_list|(
name|lang_statement_union_type
modifier|*
modifier|*
name|this_ptr
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
parameter_list|,
name|fill_type
modifier|*
name|fill
parameter_list|,
name|bfd_vma
name|dot
parameter_list|)
block|{
name|lang_input_section_type
modifier|*
name|is
init|=
operator|&
operator|(
operator|(
operator|*
name|this_ptr
operator|)
operator|->
name|input_section
operator|)
decl_stmt|;
name|asection
modifier|*
name|i
init|=
name|is
operator|->
name|section
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|i
operator|->
name|owner
operator|->
name|usrdata
operator|)
operator|->
name|just_syms_flag
operator|&&
operator|(
name|i
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|alignment_needed
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* Align this section first to the input sections requirement, 	 then to the output section's requirement.  If this alignment 	 is greater than any seen before, then record it too.  Perform 	 the alignment by inserting a magic 'padding' statement.  */
if|if
condition|(
name|output_section_statement
operator|->
name|subsection_alignment
operator|!=
operator|-
literal|1
condition|)
name|i
operator|->
name|alignment_power
operator|=
name|output_section_statement
operator|->
name|subsection_alignment
expr_stmt|;
name|o
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|alignment_power
operator|<
name|i
operator|->
name|alignment_power
condition|)
name|o
operator|->
name|alignment_power
operator|=
name|i
operator|->
name|alignment_power
expr_stmt|;
name|alignment_needed
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|i
operator|->
name|alignment_power
argument_list|)
operator|-
name|dot
expr_stmt|;
if|if
condition|(
name|alignment_needed
operator|!=
literal|0
condition|)
block|{
name|insert_pad
argument_list|(
name|this_ptr
argument_list|,
name|fill
argument_list|,
name|TO_SIZE
argument_list|(
name|alignment_needed
argument_list|)
argument_list|,
name|o
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|alignment_needed
expr_stmt|;
block|}
comment|/* Remember where in the output section this input section goes.  */
name|i
operator|->
name|output_offset
operator|=
name|dot
operator|-
name|o
operator|->
name|vma
expr_stmt|;
comment|/* Mark how big the output section must be to contain this now.  */
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|i
operator|->
name|size
argument_list|)
expr_stmt|;
name|o
operator|->
name|size
operator|=
name|TO_SIZE
argument_list|(
name|dot
operator|-
name|o
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|output_offset
operator|=
name|i
operator|->
name|vma
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sort_sections_by_lma
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|asection
modifier|*
name|sec1
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
name|sec2
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
name|bfd_section_lma
argument_list|(
name|sec1
operator|->
name|owner
argument_list|,
name|sec1
argument_list|)
operator|<
name|bfd_section_lma
argument_list|(
name|sec2
operator|->
name|owner
argument_list|,
name|sec2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|bfd_section_lma
argument_list|(
name|sec1
operator|->
name|owner
argument_list|,
name|sec1
argument_list|)
operator|>
name|bfd_section_lma
argument_list|(
name|sec2
operator|->
name|owner
argument_list|,
name|sec2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IGNORE_SECTION
parameter_list|(
name|s
parameter_list|)
define|\
value|((s->flags& SEC_NEVER_LOAD) != 0				\    || (s->flags& SEC_ALLOC) == 0				\    || ((s->flags& SEC_THREAD_LOCAL) != 0			\&& (s->flags& SEC_LOAD) == 0))
end_define

begin_comment
comment|/* Check to see if any allocated sections overlap with other allocated    sections.  This can happen if a linker script specifies the output    section addresses of the two sections.  */
end_comment

begin_function
specifier|static
name|void
name|lang_check_section_addresses
parameter_list|(
name|void
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|os
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|,
modifier|*
modifier|*
name|spp
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_vma
name|s_start
decl_stmt|;
name|bfd_vma
name|s_end
decl_stmt|;
name|bfd_vma
name|os_start
decl_stmt|;
name|bfd_vma
name|os_end
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|<=
literal|1
condition|)
return|return;
name|amt
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|xmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
comment|/* Scan all sections in the output list.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* Only consider loadable sections with real contents.  */
if|if
condition|(
name|IGNORE_SECTION
argument_list|(
name|s
argument_list|)
operator|||
name|s
operator|->
name|size
operator|==
literal|0
condition|)
continue|continue;
name|sections
index|[
name|count
index|]
operator|=
name|s
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
return|return;
name|qsort
argument_list|(
name|sections
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|sort_sections_by_lma
argument_list|)
expr_stmt|;
name|spp
operator|=
name|sections
expr_stmt|;
name|s
operator|=
operator|*
name|spp
operator|++
expr_stmt|;
name|s_start
operator|=
name|bfd_section_lma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s_end
operator|=
name|s_start
operator|+
name|TO_ADDR
argument_list|(
name|s
operator|->
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|count
operator|--
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
comment|/* We must check the sections' LMA addresses not their VMA 	 addresses because overlay sections can have overlapping VMAs 	 but they must have distinct LMAs.  */
name|os
operator|=
name|s
expr_stmt|;
name|os_start
operator|=
name|s_start
expr_stmt|;
name|os_end
operator|=
name|s_end
expr_stmt|;
name|s
operator|=
operator|*
name|spp
operator|++
expr_stmt|;
name|s_start
operator|=
name|bfd_section_lma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s_end
operator|=
name|s_start
operator|+
name|TO_ADDR
argument_list|(
name|s
operator|->
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Look for an overlap.  */
if|if
condition|(
name|s_end
operator|>=
name|os_start
operator|&&
name|s_start
operator|<=
name|os_end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"
argument_list|)
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s_start
argument_list|,
name|s_end
argument_list|,
name|os
operator|->
name|name
argument_list|,
name|os_start
argument_list|,
name|os_end
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure the new address is within the region.  We explicitly permit the    current address to be at the exact end of the region when the address is    non-zero, in case the region is at the end of addressable memory and the    calculation wraps around.  */
end_comment

begin_function
specifier|static
name|void
name|os_region_check
parameter_list|(
name|lang_output_section_statement_type
modifier|*
name|os
parameter_list|,
name|lang_memory_region_type
modifier|*
name|region
parameter_list|,
name|etree_type
modifier|*
name|tree
parameter_list|,
name|bfd_vma
name|base
parameter_list|)
block|{
if|if
condition|(
operator|(
name|region
operator|->
name|current
operator|<
name|region
operator|->
name|origin
operator|||
operator|(
name|region
operator|->
name|current
operator|-
name|region
operator|->
name|origin
operator|>
name|region
operator|->
name|length
operator|)
operator|)
operator|&&
operator|(
operator|(
name|region
operator|->
name|current
operator|!=
name|region
operator|->
name|origin
operator|+
name|region
operator|->
name|length
operator|)
operator|||
name|base
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tree
operator|!=
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: address 0x%v of %B section %s"
literal|" is not within region %s\n"
argument_list|)
argument_list|,
name|region
operator|->
name|current
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|,
name|region
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: region %s is full (%B section %s)\n"
argument_list|)
argument_list|,
name|region
operator|->
name|name
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the region pointer.  */
name|region
operator|->
name|current
operator|=
name|region
operator|->
name|origin
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the sizes for all the output sections.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|lang_size_sections_1
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
parameter_list|,
name|lang_statement_union_type
modifier|*
modifier|*
name|prev
parameter_list|,
name|fill_type
modifier|*
name|fill
parameter_list|,
name|bfd_vma
name|dot
parameter_list|,
name|bfd_boolean
modifier|*
name|relax
parameter_list|,
name|bfd_boolean
name|check_regions
parameter_list|)
block|{
comment|/* Size up the sections from their constituent parts.  */
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|bfd_vma
name|newdot
decl_stmt|,
name|after
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|&
name|s
operator|->
name|output_section_statement
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|!=
name|NULL
condition|)
block|{
name|os
operator|->
name|processed
operator|=
name|FALSE
expr_stmt|;
name|exp_fold_tree
argument_list|(
name|os
operator|->
name|addr_tree
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expld
operator|.
name|result
operator|.
name|valid_p
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: non constant or forward reference"
literal|" address expression for section %s\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
name|dot
operator|=
name|expld
operator|.
name|result
operator|.
name|value
operator|+
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
comment|/* This section was removed or never actually created.  */
break|break;
comment|/* If this is a COFF shared library section, use the size and 	       address from the input section.  FIXME: This is COFF 	       specific; it would be cleaner if there were some other way 	       to do this, but nothing simple comes to mind.  */
if|if
condition|(
operator|(
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|bfd_target_ecoff_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|bfd_target_coff_flavour
operator|)
operator|&&
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|input
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|children
operator|.
name|head
operator|==
name|NULL
operator|||
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|!=
name|NULL
operator|||
operator|(
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|header
operator|.
name|type
operator|!=
name|lang_input_section_enum
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: Internal error on COFF shared library"
literal|" section %s\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
name|input
operator|=
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|bfd_section_vma
argument_list|(
name|input
operator|->
name|owner
argument_list|,
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|size
operator|=
name|input
operator|->
name|size
expr_stmt|;
break|break;
block|}
name|newdot
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
condition|)
block|{
comment|/* No matter what happens, an abs section starts at zero.  */
name|ASSERT
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
name|NULL
condition|)
block|{
comment|/* No address specified for this section, get one 		       from the region specification.  */
if|if
condition|(
name|os
operator|->
name|region
operator|==
name|NULL
operator|||
operator|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|&&
name|os
operator|->
name|region
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|strcmp
argument_list|(
name|os
operator|->
name|region
operator|->
name|name
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|os
operator|->
name|region
operator|=
name|lang_memory_default
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
block|}
comment|/* If a loadable section is using the default memory 		       region, and some non default memory regions were 		       defined, issue an error message.  */
if|if
condition|(
operator|!
name|os
operator|->
name|ignored
operator|&&
operator|!
name|IGNORE_SECTION
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
operator|&&
operator|!
name|link_info
operator|.
name|relocatable
operator|&&
name|check_regions
operator|&&
name|strcmp
argument_list|(
name|os
operator|->
name|region
operator|->
name|name
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|)
operator|==
literal|0
operator|&&
name|lang_memory_region_list
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|lang_memory_region_list
operator|->
name|name
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|)
operator|!=
literal|0
operator|||
name|lang_memory_region_list
operator|->
name|next
operator|!=
name|NULL
operator|)
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
block|{
comment|/* By default this is an error rather than just a 			   warning because if we allocate the section to the 			   default memory region we can end up creating an 			   excessively large binary, or even seg faulting when 			   attempting to perform a negative seek.  See 			   sources.redhat.com/ml/binutils/2003-04/msg00423.html 			   for an example of this.  This behaviour can be 			   overridden by the using the --no-check-sections 			   switch.  */
if|if
condition|(
name|command_line
operator|.
name|check_section_addresses
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: error: no memory region specified"
literal|" for loadable section `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: no memory region specified"
literal|" for loadable section `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newdot
operator|=
name|os
operator|->
name|region
operator|->
name|current
expr_stmt|;
name|align
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|alignment_power
expr_stmt|;
block|}
else|else
name|align
operator|=
name|os
operator|->
name|section_alignment
expr_stmt|;
comment|/* Align to what the section needs.  */
if|if
condition|(
name|align
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|savedot
init|=
name|newdot
decl_stmt|;
name|newdot
operator|=
name|align_power
argument_list|(
name|newdot
argument_list|,
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdot
operator|!=
name|savedot
operator|&&
operator|(
name|config
operator|.
name|warn_section_align
operator|||
name|os
operator|->
name|addr_tree
operator|!=
name|NULL
operator|)
operator|&&
name|expld
operator|.
name|phase
operator|!=
name|lang_mark_phase_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: changing start of section"
literal|" %s by %lu bytes\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|newdot
operator|-
name|savedot
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfd_set_section_vma
argument_list|(
literal|0
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|newdot
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
name|lang_size_sections_1
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
operator|&
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|newdot
argument_list|,
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
name|os
operator|->
name|processed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
operator|||
name|os
operator|->
name|ignored
condition|)
block|{
name|ASSERT
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
comment|/* Put the section within the requested block size, or 	       align at the block boundary.  */
name|after
operator|=
operator|(
operator|(
name|dot
operator|+
name|TO_ADDR
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
argument_list|)
operator|+
name|os
operator|->
name|block_value
operator|-
literal|1
operator|)
operator|&
operator|-
operator|(
name|bfd_vma
operator|)
name|os
operator|->
name|block_value
operator|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|size
operator|=
name|TO_SIZE
argument_list|(
name|after
operator|-
name|os
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
comment|/* .tbss sections effectively have zero size.  */
if|if
condition|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|==
literal|0
operator|||
name|link_info
operator|.
name|relocatable
condition|)
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|update_dot_tree
operator|!=
literal|0
condition|)
name|exp_fold_tree
argument_list|(
name|os
operator|->
name|update_dot_tree
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
comment|/* Update dot in the region ? 	       We only do this if the section is going to be allocated, 	       since unallocated sections do not contribute to the region's 	       overall size in memory.  	       If the SEC_NEVER_LOAD bit is not set, it will affect the 	       addresses of sections after it. We have to update 	       dot.  */
if|if
condition|(
name|os
operator|->
name|region
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|)
condition|)
block|{
name|os
operator|->
name|region
operator|->
name|current
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|check_regions
condition|)
comment|/* Make sure the new address is within the region.  */
name|os_region_check
argument_list|(
name|os
argument_list|,
name|os
operator|->
name|region
argument_list|,
name|os
operator|->
name|addr_tree
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
comment|/* If there's no load address specified, use the run 		   region as the load region.  */
if|if
condition|(
name|os
operator|->
name|lma_region
operator|==
name|NULL
operator|&&
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|os
operator|->
name|lma_region
operator|=
name|os
operator|->
name|region
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|lma_region
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|lma_region
operator|!=
name|os
operator|->
name|region
condition|)
block|{
comment|/* Set load_base, which will be handled later.  */
name|os
operator|->
name|load_base
operator|=
name|exp_intop
argument_list|(
name|os
operator|->
name|lma_region
operator|->
name|current
argument_list|)
expr_stmt|;
name|os
operator|->
name|lma_region
operator|->
name|current
operator|+=
name|TO_ADDR
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_regions
condition|)
name|os_region_check
argument_list|(
name|os
argument_list|,
name|os
operator|->
name|lma_region
argument_list|,
name|NULL
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|lma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections_1
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
comment|/* We might refer to provided symbols in the expression, and 	       need to mark them as needed.  */
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|data_statement
operator|.
name|exp
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|<
name|TO_SIZE
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
condition|)
name|size
operator|=
name|TO_SIZE
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|int
name|size
decl_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections_1
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|link_info
operator|.
name|create_object_symbols_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|i
decl_stmt|;
name|i
operator|=
operator|(
operator|*
name|prev
operator|)
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|relax
condition|)
block|{
name|bfd_boolean
name|again
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_relax_section
argument_list|(
name|i
operator|->
name|owner
argument_list|,
name|i
argument_list|,
operator|&
name|link_info
argument_list|,
operator|&
name|again
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't relax section: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
operator|*
name|relax
operator|=
name|TRUE
expr_stmt|;
block|}
name|dot
operator|=
name|size_input_section
argument_list|(
name|prev
argument_list|,
name|output_section_statement
argument_list|,
name|output_section_statement
operator|->
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|s
operator|->
name|fill_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
block|{
name|bfd_vma
name|newdot
init|=
name|dot
decl_stmt|;
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
operator|->
name|bfd_section
argument_list|,
operator|&
name|newdot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_section_statement
operator|->
name|ignored
condition|)
block|{
if|if
condition|(
name|output_section_statement
operator|==
name|abs_output_section
condition|)
block|{
comment|/* If we don't have an output section, then just adjust 		       the default memory address.  */
name|lang_memory_region_lookup
argument_list|(
name|DEFAULT_MEMORY_REGION
argument_list|,
name|FALSE
argument_list|)
operator|->
name|current
operator|=
name|newdot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newdot
operator|!=
name|dot
condition|)
block|{
comment|/* Insert a pad after this statement.  We can't 		       put the pad before when relaxing, in case the 		       assignment references dot.  */
name|insert_pad
argument_list|(
operator|&
name|s
operator|->
name|header
operator|.
name|next
argument_list|,
name|fill
argument_list|,
name|TO_SIZE
argument_list|(
name|newdot
operator|-
name|dot
argument_list|)
argument_list|,
name|output_section_statement
operator|->
name|bfd_section
argument_list|,
name|dot
argument_list|)
expr_stmt|;
comment|/* Don't neuter the pad below when relaxing.  */
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
comment|/* If dot is advanced, this implies that the section 		       should have space allocated to it, unless the 		       user has explicitly stated that the section 		       should never be loaded.  */
if|if
condition|(
operator|!
operator|(
name|output_section_statement
operator|->
name|flags
operator|&
operator|(
name|SEC_NEVER_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
condition|)
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
block|}
name|dot
operator|=
name|newdot
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
comment|/* If this is the first time lang_size_sections is called, 	     we won't have any padding statements.  If this is the 	     second or later passes when relaxing, we should allow 	     padding to shrink.  If padding is needed on this pass, it 	     will be added back in.  */
name|s
operator|->
name|padding_statement
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Make sure output_offset is valid.  If relaxation shrinks 	     the section and this pad isn't needed, it's possible to 	     have output_offset larger than the final size of the 	     section.  bfd_set_section_contents will complain even for 	     a pad size of zero.  */
name|s
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections_1
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
comment|/* We can only get here when relaxing is turned on.  */
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
name|prev
operator|=
operator|&
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_function
name|void
name|one_lang_size_sections_pass
parameter_list|(
name|bfd_boolean
modifier|*
name|relax
parameter_list|,
name|bfd_boolean
name|check_regions
parameter_list|)
block|{
name|lang_statement_iteration
operator|++
expr_stmt|;
name|lang_size_sections_1
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|statement_list
operator|.
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_size_sections
parameter_list|(
name|bfd_boolean
modifier|*
name|relax
parameter_list|,
name|bfd_boolean
name|check_regions
parameter_list|)
block|{
name|expld
operator|.
name|phase
operator|=
name|lang_allocating_phase_enum
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_none
expr_stmt|;
name|one_lang_size_sections_pass
argument_list|(
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_end_seen
operator|&&
name|link_info
operator|.
name|relro
operator|&&
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
condition|)
block|{
comment|/* If DATA_SEGMENT_ALIGN DATA_SEGMENT_RELRO_END pair was seen, try 	 to put expld.dataseg.relro on a (common) page boundary.  */
name|bfd_vma
name|old_min_base
decl_stmt|,
name|relro_end
decl_stmt|,
name|maxpage
decl_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_relro_adjust
expr_stmt|;
name|old_min_base
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|min_base
expr_stmt|;
name|maxpage
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|maxpagesize
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|+=
operator|(
operator|-
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Compute the expected PT_GNU_RELRO segment end.  */
name|relro_end
operator|=
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|+
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|old_min_base
operator|+
name|maxpage
operator|<
name|expld
operator|.
name|dataseg
operator|.
name|base
condition|)
block|{
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|-=
name|maxpage
expr_stmt|;
name|relro_end
operator|-=
name|maxpage
expr_stmt|;
block|}
name|one_lang_size_sections_pass
argument_list|(
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|>
name|relro_end
condition|)
block|{
comment|/* The alignment of sections between DATA_SEGMENT_ALIGN 	     and DATA_SEGMENT_RELRO_END caused huge padding to be 	     inserted at DATA_SEGMENT_RELRO_END.  Try some other base.  */
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|max_alignment_power
init|=
literal|0
decl_stmt|;
comment|/* Find maximum alignment power of sections between 	     DATA_SEGMENT_ALIGN and DATA_SEGMENT_RELRO_END.  */
for|for
control|(
name|sec
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
name|sec
operator|->
name|vma
operator|>=
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|&&
name|sec
operator|->
name|vma
operator|<
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
operator|&&
name|sec
operator|->
name|alignment_power
operator|>
name|max_alignment_power
condition|)
name|max_alignment_power
operator|=
name|sec
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
name|max_alignment_power
operator|)
operator|<
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
condition|)
block|{
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|-
operator|(
literal|1
operator|<<
name|max_alignment_power
operator|)
operator|<
name|old_min_base
condition|)
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|+=
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
expr_stmt|;
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|-=
operator|(
literal|1
operator|<<
name|max_alignment_power
operator|)
expr_stmt|;
name|one_lang_size_sections_pass
argument_list|(
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
block|}
block|}
name|link_info
operator|.
name|relro_start
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|base
expr_stmt|;
name|link_info
operator|.
name|relro_end
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|relro_end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|==
name|exp_dataseg_end_seen
condition|)
block|{
comment|/* If DATA_SEGMENT_ALIGN DATA_SEGMENT_END pair was seen, check whether 	 a page could be saved in the data segment.  */
name|bfd_vma
name|first
decl_stmt|,
name|last
decl_stmt|;
name|first
operator|=
operator|-
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
name|last
operator|=
name|expld
operator|.
name|dataseg
operator|.
name|end
operator|&
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|last
operator|&&
operator|(
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|base
operator|&
operator|~
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|end
operator|&
operator|~
operator|(
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
name|first
operator|+
name|last
operator|<=
name|expld
operator|.
name|dataseg
operator|.
name|pagesize
condition|)
block|{
name|expld
operator|.
name|dataseg
operator|.
name|phase
operator|=
name|exp_dataseg_adjust
expr_stmt|;
name|one_lang_size_sections_pass
argument_list|(
name|relax
argument_list|,
name|check_regions
argument_list|)
expr_stmt|;
block|}
block|}
name|expld
operator|.
name|phase
operator|=
name|lang_final_phase_enum
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for lang_do_assignments.  Recursiveness goes here.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|lang_do_assignments_1
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|,
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
parameter_list|,
name|fill_type
modifier|*
name|fill
parameter_list|,
name|bfd_vma
name|dot
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments_1
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|&
operator|(
name|s
operator|->
name|output_section_statement
operator|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
operator|!
name|os
operator|->
name|ignored
condition|)
block|{
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|lang_do_assignments_1
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
comment|/* .tbss sections effectively have zero size.  */
if|if
condition|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_THREAD_LOCAL
operator|)
operator|==
literal|0
operator|||
name|link_info
operator|.
name|relocatable
condition|)
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|load_base
condition|)
block|{
comment|/* If nothing has been placed into the output section then 		   it won't have a bfd_section.  */
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|&&
operator|!
name|os
operator|->
name|ignored
condition|)
block|{
name|os
operator|->
name|bfd_section
operator|->
name|lma
operator|=
name|exp_get_abs_int
argument_list|(
name|os
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments_1
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
break|break;
case|case
name|lang_data_statement_enum
case|:
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|data_statement
operator|.
name|exp
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
name|s
operator|->
name|data_statement
operator|.
name|value
operator|=
operator|(
name|expld
operator|.
name|result
operator|.
name|value
operator|+
name|expld
operator|.
name|result
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid data statement\n"
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|<
name|TO_SIZE
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
condition|)
name|size
operator|=
name|TO_SIZE
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|addend_exp
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|expld
operator|.
name|result
operator|.
name|valid_p
condition|)
name|s
operator|->
name|reloc_statement
operator|.
name|addend_value
operator|=
name|expld
operator|.
name|result
operator|.
name|value
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid reloc statement\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|in
init|=
name|s
operator|->
name|input_section
operator|.
name|section
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|)
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|in
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
operator|->
name|bfd_section
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|dot
operator|+=
name|TO_ADDR
argument_list|(
name|s
operator|->
name|padding_statement
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments_1
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
block|}
return|return
name|dot
return|;
block|}
end_function

begin_function
name|void
name|lang_do_assignments
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_statement_iteration
operator|++
expr_stmt|;
name|lang_do_assignments_1
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix any .startof. or .sizeof. symbols.  When the assemblers see the    operator .startof. (section_name), it produces an undefined symbol    .startof.section_name.  Similarly, when it sees    .sizeof. (section_name), it produces an undefined symbol    .sizeof.section_name.  For all the output sections, we look for    such symbols, and set them to the correct value.  */
end_comment

begin_function
specifier|static
name|void
name|lang_set_startof
parameter_list|(
name|void
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocatable
condition|)
return|return;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|secname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|TO_ADDR
argument_list|(
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lang_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|warn
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocatable
operator|||
name|link_info
operator|.
name|shared
condition|)
name|warn
operator|=
name|FALSE
expr_stmt|;
else|else
name|warn
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|entry_symbol
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* No entry has been specified.  Look for the default entry, but 	 don't warn if we don't find it.  */
name|entry_symbol
operator|.
name|name
operator|=
name|entry_symbol_default
expr_stmt|;
name|warn
operator|=
name|FALSE
expr_stmt|;
block|}
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|entry_symbol
operator|.
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can't set start address\n"
argument_list|)
argument_list|,
name|entry_symbol
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|send
decl_stmt|;
comment|/* We couldn't find the entry symbol.  Try parsing it as a 	 number.  */
name|val
operator|=
name|bfd_scan_vma
argument_list|(
name|entry_symbol
operator|.
name|name
argument_list|,
operator|&
name|send
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|send
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't set start address\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|ts
decl_stmt|;
comment|/* Can't find the entry symbol, and it's not a number.  Use 	     the first address in the text section.  */
name|ts
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|entry_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: cannot find entry symbol %s;"
literal|" defaulting to %V\n"
argument_list|)
argument_list|,
name|entry_symbol
operator|.
name|name
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't set start address\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: cannot find entry symbol %s;"
literal|" not setting start address\n"
argument_list|)
argument_list|,
name|entry_symbol
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Don't bfd_hash_table_free (&lang_definedness_table);      map file output may result in a call of lang_track_definedness.  */
block|}
end_function

begin_comment
comment|/* This is a small function used when we want to ignore errors from    BFD.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_bfd_errors
parameter_list|(
specifier|const
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* Don't do anything.  */
block|}
end_function

begin_comment
comment|/* Check that the architecture of all the input files is compatible    with the output file.  Also call the backend to let it do any    other checking that is needed.  */
end_comment

begin_function
specifier|static
name|void
name|lang_check
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_statement_union_type
modifier|*
name|file
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|compatible
decl_stmt|;
for|for
control|(
name|file
operator|=
name|file_chain
operator|.
name|head
init|;
name|file
operator|!=
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|input_statement
operator|.
name|next
control|)
block|{
name|input_bfd
operator|=
name|file
operator|->
name|input_statement
operator|.
name|the_bfd
expr_stmt|;
name|compatible
operator|=
name|bfd_arch_get_compatible
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|command_line
operator|.
name|accept_unknown_input_arch
argument_list|)
expr_stmt|;
comment|/* In general it is not possible to perform a relocatable 	 link between differing object formats when the input 	 file has relocations, because the relocations in the 	 input format may not have equivalent representations in 	 the output format (and besides BFD does not translate 	 relocs for other link purposes than a final link).  */
if|if
condition|(
operator|(
name|link_info
operator|.
name|relocatable
operator|||
name|link_info
operator|.
name|emitrelocations
operator|)
operator|&&
operator|(
name|compatible
operator|==
name|NULL
operator|||
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|)
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|input_bfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Relocatable linking with relocations from"
literal|" format %s (%B) to format %s (%B) is not supported\n"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* einfo with %F exits.  */
block|}
if|if
condition|(
name|compatible
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|warn_mismatch
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: %s architecture of input file `%B'"
literal|" is incompatible with %s output\n"
argument_list|)
argument_list|,
name|bfd_printable_name
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* If the input bfd has no contents, it shouldn't set the 	     private data of the output bfd.  */
name|bfd_error_handler_type
name|pfn
init|=
name|NULL
decl_stmt|;
comment|/* If we aren't supposed to warn about mismatched input 	     files, temporarily set the BFD error handler to a 	     function which will do nothing.  We still want to call 	     bfd_merge_private_bfd_data, since it may set up 	     information which is needed in the output file.  */
if|if
condition|(
operator|!
name|command_line
operator|.
name|warn_mismatch
condition|)
name|pfn
operator|=
name|bfd_set_error_handler
argument_list|(
name|ignore_bfd_errors
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_merge_private_bfd_data
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|warn_mismatch
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: failed to merge target specific data"
literal|" of file %B\n"
argument_list|)
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|command_line
operator|.
name|warn_mismatch
condition|)
name|bfd_set_error_handler
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look through all the global common symbols and attach them to the    correct section.  The -sort-common command line switch may be used    to roughly sort the entries by size.  */
end_comment

begin_function
specifier|static
name|void
name|lang_common
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|command_line
operator|.
name|inhibit_common_definition
condition|)
return|return;
if|if
condition|(
name|link_info
operator|.
name|relocatable
operator|&&
operator|!
name|command_line
operator|.
name|force_common_definition
condition|)
return|return;
if|if
condition|(
operator|!
name|config
operator|.
name|sort_common
condition|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|power
decl_stmt|;
for|for
control|(
name|power
operator|=
literal|4
init|;
name|power
operator|>=
literal|0
condition|;
name|power
operator|--
control|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
operator|&
name|power
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Place one common symbol in the correct section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lang_one_common
parameter_list|(
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
return|return
name|TRUE
return|;
name|size
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
name|power_of_two
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|sort_common
operator|&&
name|power_of_two
operator|<
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|info
condition|)
return|return
name|TRUE
return|;
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
comment|/* Increase the size of the section to align the common sym.  */
name|section
operator|->
name|size
operator|+=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|power_of_two
operator|+
name|opb_shift
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|section
operator|->
name|size
operator|&=
operator|(
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|power_of_two
operator|+
name|opb_shift
operator|)
operator|)
expr_stmt|;
comment|/* Adjust the alignment if necessary.  */
if|if
condition|(
name|power_of_two
operator|>
name|section
operator|->
name|alignment_power
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|power_of_two
expr_stmt|;
comment|/* Change the symbol from common to defined.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|section
operator|->
name|size
expr_stmt|;
comment|/* Increase the size of the section.  */
name|section
operator|->
name|size
operator|+=
name|size
expr_stmt|;
comment|/* Make sure the section is allocated in memory, and make sure that      it is no longer a common section.  */
name|section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|bfd_boolean
name|header_printed
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nAllocating common symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
name|_
argument_list|(
literal|"Common symbol       size              file\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|TRUE
expr_stmt|;
block|}
name|name
operator|=
name|demangle
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|19
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|20
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0xffffffff
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%B\n"
argument_list|,
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Run through the input files and ensure that every input section has    somewhere to go.  If one is found without a destination then create    an input request and place it into the statement tree.  */
end_comment

begin_function
specifier|static
name|void
name|lang_place_orphans
parameter_list|(
name|void
parameter_list|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|file
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
comment|/* This section of the file is not attached, root 		 around for a sensible place for it to go.  */
if|if
condition|(
name|file
operator|->
name|just_syms_flag
condition|)
name|bfd_link_just_syms
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a lonely common section which must have 		     come from an archive.  We attach to the section 		     with the wildcard.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
operator|||
name|command_line
operator|.
name|force_common_definition
condition|)
block|{
if|if
condition|(
name|default_common_section
operator|==
name|NULL
condition|)
block|{
name|default_common_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
literal|".bss"
argument_list|)
expr_stmt|;
block|}
name|lang_add_section
argument_list|(
operator|&
name|default_common_section
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|default_common_section
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ldemul_place_orphan
argument_list|(
name|s
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|lang_add_section
argument_list|(
operator|&
name|os
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|lang_set_flags
parameter_list|(
name|lang_memory_region_type
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|flags
parameter_list|,
name|int
name|invert
parameter_list|)
block|{
name|flagword
modifier|*
name|ptr_flags
decl_stmt|;
name|ptr_flags
operator|=
name|invert
condition|?
operator|&
name|ptr
operator|->
name|not_flags
else|:
operator|&
name|ptr
operator|->
name|flags
expr_stmt|;
while|while
condition|(
operator|*
name|flags
condition|)
block|{
switch|switch
condition|(
operator|*
name|flags
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_LOAD
expr_stmt|;
break|break;
default|default:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid syntax in flags\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call a function on each input file.  This function will be called    on an archive, but not on the elements.  */
end_comment

begin_function
name|void
name|lang_for_each_input_file
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|)
parameter_list|)
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next_real_file
control|)
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call a function on each file.  The function will be called on all    the elements of an archive which are included in the link, but will    not be called on the archive file itself.  */
end_comment

begin_function
name|void
name|lang_for_each_file
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|lang_input_statement_type
modifier|*
parameter_list|)
parameter_list|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ldlang_add_file
parameter_list|(
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
name|bfd
modifier|*
modifier|*
name|pp
decl_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* The BFD linker needs to have a list of all input BFDs involved in      a link.  */
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|->
name|link_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|!=
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|link_info
operator|.
name|input_bfds
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|link_next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|entry
operator|->
name|the_bfd
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|->
name|usrdata
operator|=
name|entry
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
comment|/* Look through the sections and check for any which should not be      included in the link.  We need to do this now, so that we can      notice when the backend linker tries to report multiple      definition errors for symbols which are in sections we aren't      going to link.  FIXME: It might be better to entirely ignore      symbols which are defined in sections which are going to be      discarded.  This would require modifying the backend linker for      each backend which might set the SEC_LINK_ONCE flag.  If we do      this, we should probably handle SEC_EXCLUDE in the same way.  */
name|bfd_map_over_sections
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|section_already_linked
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_output
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_script
parameter_list|)
block|{
comment|/* Make -o on command line override OUTPUT in script.  */
if|if
condition|(
operator|!
name|had_output_filename
operator|||
operator|!
name|from_script
condition|)
block|{
name|output_filename
operator|=
name|name
expr_stmt|;
name|had_output_filename
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|topower
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
literal|32
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|x
condition|)
return|return
name|l
return|;
name|i
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_enter_output_section_statement
parameter_list|(
specifier|const
name|char
modifier|*
name|output_section_statement_name
parameter_list|,
name|etree_type
modifier|*
name|address_exp
parameter_list|,
name|enum
name|section_type
name|sectype
parameter_list|,
name|etree_type
modifier|*
name|align
parameter_list|,
name|etree_type
modifier|*
name|subalign
parameter_list|,
name|etree_type
modifier|*
name|ebase
parameter_list|,
name|int
name|constraint
parameter_list|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_statement_lookup_1
argument_list|(
name|output_section_statement_name
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|current_section
operator|=
name|os
expr_stmt|;
comment|/* Make next things chain into subchain of this.  */
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
name|NULL
condition|)
block|{
name|os
operator|->
name|addr_tree
operator|=
name|address_exp
expr_stmt|;
block|}
name|os
operator|->
name|sectype
operator|=
name|sectype
expr_stmt|;
if|if
condition|(
name|sectype
operator|!=
name|noload_section
condition|)
name|os
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
else|else
name|os
operator|->
name|flags
operator|=
name|SEC_NEVER_LOAD
expr_stmt|;
name|os
operator|->
name|block_value
operator|=
literal|1
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|os
operator|->
name|children
expr_stmt|;
name|os
operator|->
name|subsection_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|subalign
argument_list|,
operator|-
literal|1
argument_list|,
literal|"subsection alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|section_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|align
argument_list|,
operator|-
literal|1
argument_list|,
literal|"section alignment"
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|load_base
operator|=
name|ebase
expr_stmt|;
return|return
name|os
return|;
block|}
end_function

begin_function
name|void
name|lang_final
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_output_statement_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|new_stat
argument_list|(
name|lang_output_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|output_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the current counters in the regions.  */
end_comment

begin_function
name|void
name|lang_reset_memory_regions
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_memory_region_type
modifier|*
name|p
init|=
name|lang_memory_region_list
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|old_length
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|->
name|current
operator|-
name|p
operator|->
name|origin
argument_list|)
expr_stmt|;
name|p
operator|->
name|current
operator|=
name|p
operator|->
name|origin
expr_stmt|;
block|}
for|for
control|(
name|os
operator|=
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
init|;
name|os
operator|!=
name|NULL
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
name|os
operator|->
name|processed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|o
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Save the last size for possible use by bfd_relax_section.  */
name|o
operator|->
name|rawsize
operator|=
name|o
operator|->
name|size
expr_stmt|;
name|o
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Worker for lang_gc_sections_1.  */
end_comment

begin_function
specifier|static
name|void
name|gc_section_callback
parameter_list|(
name|lang_wild_statement_type
modifier|*
name|ptr
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|lang_input_statement_type
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If the wild pattern was marked KEEP, the member sections      should be as well.  */
if|if
condition|(
name|ptr
operator|->
name|keep_sections
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Iterate over sections marking them against GC.  */
end_comment

begin_function
specifier|static
name|void
name|lang_gc_sections_1
parameter_list|(
name|lang_statement_union_type
modifier|*
name|s
parameter_list|)
block|{
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|walk_wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|gc_section_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lang_gc_sections
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|ldlang_undef_chain_list_type
modifier|*
name|ulist
decl_stmt|;
comment|/* Keep all sections so marked in the link script.  */
name|lang_gc_sections_1
argument_list|(
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* Keep all sections containing symbols undefined on the command-line,      and the section containing the entry symbol.  */
for|for
control|(
name|ulist
operator|=
name|link_info
operator|.
name|gc_sym_list
init|;
name|ulist
condition|;
name|ulist
operator|=
name|ulist
operator|->
name|next
control|)
block|{
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|ulist
operator|->
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
block|}
block|}
comment|/* SEC_EXCLUDE is ignored when doing a relocatable link, except in      the special case of debug info.  (See bfd/stabs.c)      Twiddle the flag here, to simplify later linker code.  */
if|if
condition|(
name|link_info
operator|.
name|relocatable
condition|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|f
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|==
literal|0
condition|)
name|sec
operator|->
name|flags
operator|&=
operator|~
name|SEC_EXCLUDE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_info
operator|.
name|gc_sections
condition|)
name|bfd_gc_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relax all sections until bfd_relax_section gives up.  */
end_comment

begin_function
specifier|static
name|void
name|relax_sections
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Keep relaxing until bfd_relax_section gives up.  */
name|bfd_boolean
name|relax_again
decl_stmt|;
do|do
block|{
name|relax_again
operator|=
name|FALSE
expr_stmt|;
comment|/* Note: pe-dll.c does something like this also.  If you find 	 you need to change this code, you probably need to change 	 pe-dll.c also.  DJ  */
comment|/* Do all the assignments with our current guesses as to 	 section sizes.  */
name|lang_do_assignments
argument_list|()
expr_stmt|;
comment|/* We must do this after lang_do_assignments, because it uses 	 size.  */
name|lang_reset_memory_regions
argument_list|()
expr_stmt|;
comment|/* Perform another relax pass - this time we know where the 	 globals are, so can make a better guess.  */
name|lang_size_sections
argument_list|(
operator|&
name|relax_again
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|relax_again
condition|)
do|;
block|}
end_function

begin_function
name|void
name|lang_process
parameter_list|(
name|void
parameter_list|)
block|{
name|current_target
operator|=
name|default_target
expr_stmt|;
comment|/* Open the output file.  */
name|lang_for_each_statement
argument_list|(
name|ldlang_open_output
argument_list|)
expr_stmt|;
name|init_opb
argument_list|()
expr_stmt|;
name|ldemul_create_output_section_statements
argument_list|()
expr_stmt|;
comment|/* Add to the hash table all undefineds on the command line.  */
name|lang_place_undefineds
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_section_already_linked_table_init
argument_list|()
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Failed to create hash table\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a bfd for each input file.  */
name|current_target
operator|=
name|default_target
expr_stmt|;
name|open_input_bfds
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|gc_sym_list
operator|=
operator|&
name|entry_symbol
expr_stmt|;
if|if
condition|(
name|entry_symbol
operator|.
name|name
operator|==
name|NULL
condition|)
name|link_info
operator|.
name|gc_sym_list
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
name|ldemul_after_open
argument_list|()
expr_stmt|;
name|bfd_section_already_linked_table_free
argument_list|()
expr_stmt|;
comment|/* Make sure that we're not mixing architectures.  We call this      after all the input files have been opened, but before we do any      other processing, so that any operations merge_private_bfd_data      does on the output file will be known during the rest of the      link.  */
name|lang_check
argument_list|()
expr_stmt|;
comment|/* Handle .exports instead of a version script if we're told to do so.  */
if|if
condition|(
name|command_line
operator|.
name|version_exports_section
condition|)
name|lang_do_version_exports_section
argument_list|()
expr_stmt|;
comment|/* Build all sets based on the information gathered from the input      files.  */
name|ldctor_build_sets
argument_list|()
expr_stmt|;
comment|/* Remove unreferenced sections if asked to.  */
name|lang_gc_sections
argument_list|()
expr_stmt|;
comment|/* Size up the common data.  */
name|lang_common
argument_list|()
expr_stmt|;
comment|/* Update wild statements.  */
name|update_wild_statements
argument_list|(
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* Run through the contours of the script and attach input sections      to the correct output sections.  */
name|map_input_to_output_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find any sections not attached explicitly and handle them.  */
name|lang_place_orphans
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
condition|)
block|{
name|asection
modifier|*
name|found
decl_stmt|;
comment|/* Merge SEC_MERGE sections.  This has to be done after GC of 	 sections, so that GCed sections are not merged, but before 	 assigning dynamic symbols, since removing whole input sections 	 is hard then.  */
name|bfd_merge_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
comment|/* Look for a text section and set the readonly attribute in it.  */
name|found
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|config
operator|.
name|text_read_only
condition|)
name|found
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
else|else
name|found
operator|->
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
block|}
block|}
comment|/* Do anything special before sizing sections.  This is where ELF      and other back-ends size dynamic sections.  */
name|ldemul_before_allocation
argument_list|()
expr_stmt|;
comment|/* We must record the program headers before we try to fix the      section positions, since they will affect SIZEOF_HEADERS.  */
name|lang_record_phdrs
argument_list|()
expr_stmt|;
comment|/* Size up the sections.  */
name|lang_size_sections
argument_list|(
name|NULL
argument_list|,
operator|!
name|command_line
operator|.
name|relax
argument_list|)
expr_stmt|;
comment|/* Now run around and relax if we can.  */
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
block|{
comment|/* We may need more than one relaxation pass.  */
name|int
name|i
init|=
name|link_info
operator|.
name|relax_pass
decl_stmt|;
comment|/* The backend can use it to determine the current pass.  */
name|link_info
operator|.
name|relax_pass
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|relax_sections
argument_list|()
expr_stmt|;
name|link_info
operator|.
name|relax_pass
operator|++
expr_stmt|;
block|}
comment|/* Final extra sizing to report errors.  */
name|lang_do_assignments
argument_list|()
expr_stmt|;
name|lang_reset_memory_regions
argument_list|()
expr_stmt|;
name|lang_size_sections
argument_list|(
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* See if anything special should be done now we know how big      everything is.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Fix any .startof. or .sizeof. symbols.  */
name|lang_set_startof
argument_list|()
expr_stmt|;
comment|/* Do all the assignments, now that we know the final resting places      of all the symbols.  */
name|lang_do_assignments
argument_list|()
expr_stmt|;
comment|/* Make sure that the section addresses make sense.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
operator|&&
name|command_line
operator|.
name|check_section_addresses
condition|)
name|lang_check_section_addresses
argument_list|()
expr_stmt|;
comment|/* Final stuffs.  */
name|ldemul_finish
argument_list|()
expr_stmt|;
name|lang_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXPORTED TO YACC */
end_comment

begin_function
name|void
name|lang_add_wild
parameter_list|(
name|struct
name|wildcard_spec
modifier|*
name|filespec
parameter_list|,
name|struct
name|wildcard_list
modifier|*
name|section_list
parameter_list|,
name|bfd_boolean
name|keep_sections
parameter_list|)
block|{
name|struct
name|wildcard_list
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|lang_wild_statement_type
modifier|*
name|new
decl_stmt|;
comment|/* Reverse the list as the parser puts it back to front.  */
for|for
control|(
name|curr
operator|=
name|section_list
operator|,
name|section_list
operator|=
name|NULL
init|;
name|curr
operator|!=
name|NULL
condition|;
name|section_list
operator|=
name|curr
operator|,
name|curr
operator|=
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|curr
operator|->
name|spec
operator|.
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
name|placed_commons
operator|=
name|TRUE
expr_stmt|;
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|section_list
expr_stmt|;
block|}
if|if
condition|(
name|filespec
operator|!=
name|NULL
operator|&&
name|filespec
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|filespec
operator|->
name|name
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|filespec
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wildcardp
argument_list|(
name|filespec
operator|->
name|name
argument_list|)
condition|)
name|lang_has_input_file
operator|=
name|TRUE
expr_stmt|;
block|}
name|new
operator|=
name|new_stat
argument_list|(
name|lang_wild_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|filenames_sorted
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|filespec
operator|!=
name|NULL
condition|)
block|{
name|new
operator|->
name|filename
operator|=
name|filespec
operator|->
name|name
expr_stmt|;
name|new
operator|->
name|filenames_sorted
operator|=
name|filespec
operator|->
name|sorted
operator|==
name|by_name
expr_stmt|;
block|}
name|new
operator|->
name|section_list
operator|=
name|section_list
expr_stmt|;
name|new
operator|->
name|keep_sections
operator|=
name|keep_sections
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|new
operator|->
name|children
argument_list|)
expr_stmt|;
name|analyze_walk_wild_section_handler
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_section_start
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|address
parameter_list|,
specifier|const
name|segment_type
modifier|*
name|segment
parameter_list|)
block|{
name|lang_address_statement_type
modifier|*
name|ad
decl_stmt|;
name|ad
operator|=
name|new_stat
argument_list|(
name|lang_address_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|ad
operator|->
name|section_name
operator|=
name|name
expr_stmt|;
name|ad
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|ad
operator|->
name|segment
operator|=
name|segment
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the start symbol to NAME.  CMDLINE is nonzero if this is called    because of a -e argument on the command line, or zero if this is    called by ENTRY in a linker script.  Command line arguments take    precedence.  */
end_comment

begin_function
name|void
name|lang_add_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|cmdline
parameter_list|)
block|{
if|if
condition|(
name|entry_symbol
operator|.
name|name
operator|==
name|NULL
operator|||
name|cmdline
operator|||
operator|!
name|entry_from_cmdline
condition|)
block|{
name|entry_symbol
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|entry_from_cmdline
operator|=
name|cmdline
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the default start symbol to NAME.  .em files should use this,    not lang_add_entry, to override the use of "start" if neither the    linker script nor the command line specifies an entry point.  NAME    must be permanently allocated.  */
end_comment

begin_function
name|void
name|lang_default_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|entry_symbol_default
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_target
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|lang_target_statement_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|new_stat
argument_list|(
name|lang_target_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|target
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_map
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
while|while
condition|(
operator|*
name|name
condition|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'F'
case|:
name|map_option_f
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|name
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_add_fill
parameter_list|(
name|fill_type
modifier|*
name|fill
parameter_list|)
block|{
name|lang_fill_statement_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|new_stat
argument_list|(
name|lang_fill_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_data
parameter_list|(
name|int
name|type
parameter_list|,
name|union
name|etree_union
modifier|*
name|exp
parameter_list|)
block|{
name|lang_data_statement_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|new_stat
argument_list|(
name|lang_data_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new reloc statement.  RELOC is the BFD relocation type to    generate.  HOWTO is the corresponding howto structure (we could    look this up, but the caller has already done so).  SECTION is the    section to generate a reloc against, or NAME is the name of the    symbol to generate a reloc against.  Exactly one of SECTION and    NAME must be NULL.  ADDEND is an expression for the addend.  */
end_comment

begin_function
name|void
name|lang_add_reloc
parameter_list|(
name|bfd_reloc_code_real_type
name|reloc
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|union
name|etree_union
modifier|*
name|addend
parameter_list|)
block|{
name|lang_reloc_statement_type
modifier|*
name|p
init|=
name|new_stat
argument_list|(
name|lang_reloc_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|addend_exp
operator|=
name|addend
expr_stmt|;
name|p
operator|->
name|addend_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|lang_assignment_statement_type
modifier|*
name|lang_add_assignment
parameter_list|(
name|etree_type
modifier|*
name|exp
parameter_list|)
block|{
name|lang_assignment_statement_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|new_stat
argument_list|(
name|lang_assignment_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|void
name|lang_add_attribute
parameter_list|(
name|enum
name|statement_enum
name|attribute
parameter_list|)
block|{
name|new_statement
argument_list|(
name|attribute
argument_list|,
sizeof|sizeof
argument_list|(
name|lang_statement_header_type
argument_list|)
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_startup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|startup_file
operator|!=
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: multiple STARTUP files\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first_file
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|real
operator|=
name|TRUE
expr_stmt|;
name|startup_file
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_float
parameter_list|(
name|bfd_boolean
name|maybe
parameter_list|)
block|{
name|lang_float_flag
operator|=
name|maybe
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work out the load- and run-time regions from a script statement, and    store them in *LMA_REGION and *REGION respectively.     MEMSPEC is the name of the run-time region, or the value of    DEFAULT_MEMORY_REGION if the statement didn't specify one.    LMA_MEMSPEC is the name of the load-time region, or null if the    statement didn't specify one.HAVE_LMA_P is TRUE if the statement    had an explicit load address.     It is an error to specify both a load region and a load address.  */
end_comment

begin_function
specifier|static
name|void
name|lang_get_regions
parameter_list|(
name|lang_memory_region_type
modifier|*
modifier|*
name|region
parameter_list|,
name|lang_memory_region_type
modifier|*
modifier|*
name|lma_region
parameter_list|,
specifier|const
name|char
modifier|*
name|memspec
parameter_list|,
specifier|const
name|char
modifier|*
name|lma_memspec
parameter_list|,
name|bfd_boolean
name|have_lma
parameter_list|,
name|bfd_boolean
name|have_vma
parameter_list|)
block|{
operator|*
name|lma_region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|lma_memspec
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If no runtime region or VMA has been specified, but the load region      has been specified, then use the load region for the runtime region      as well.  */
if|if
condition|(
name|lma_memspec
operator|!=
name|NULL
operator|&&
operator|!
name|have_vma
operator|&&
name|strcmp
argument_list|(
name|memspec
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|region
operator|=
operator|*
name|lma_region
expr_stmt|;
else|else
operator|*
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|memspec
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_lma
operator|&&
name|lma_memspec
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P:%S: section has both a load address and a load region\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_leave_output_section_statement
parameter_list|(
name|fill_type
modifier|*
name|fill
parameter_list|,
specifier|const
name|char
modifier|*
name|memspec
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
name|phdrs
parameter_list|,
specifier|const
name|char
modifier|*
name|lma_memspec
parameter_list|)
block|{
name|lang_get_regions
argument_list|(
operator|&
name|current_section
operator|->
name|region
argument_list|,
operator|&
name|current_section
operator|->
name|lma_region
argument_list|,
name|memspec
argument_list|,
name|lma_memspec
argument_list|,
name|current_section
operator|->
name|load_base
operator|!=
name|NULL
argument_list|,
name|current_section
operator|->
name|addr_tree
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|current_section
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
name|current_section
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an absolute symbol with the given name with the value of the    address of first byte of the section named.     If the symbol already exists, then do nothing.  */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_beginning_of
parameter_list|(
specifier|const
name|char
modifier|*
name|secname
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create an absolute symbol with the given name with the value of the    address of the first byte after the end of the section named.     If the symbol already exists, then do nothing.  */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_end_of
parameter_list|(
specifier|const
name|char
modifier|*
name|secname
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
operator|+
name|TO_ADDR
argument_list|(
name|sec
operator|->
name|size
argument_list|)
operator|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_statement_append
parameter_list|(
name|lang_statement_list_type
modifier|*
name|list
parameter_list|,
name|lang_statement_union_type
modifier|*
name|element
parameter_list|,
name|lang_statement_union_type
modifier|*
modifier|*
name|field
parameter_list|)
block|{
operator|*
operator|(
name|list
operator|->
name|tail
operator|)
operator|=
name|element
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output format type.  -oformat overrides scripts.  */
end_comment

begin_function
name|void
name|lang_add_output_format
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|big
parameter_list|,
specifier|const
name|char
modifier|*
name|little
parameter_list|,
name|int
name|from_script
parameter_list|)
block|{
if|if
condition|(
name|output_target
operator|==
name|NULL
operator|||
operator|!
name|from_script
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
operator|&&
name|big
operator|!=
name|NULL
condition|)
name|format
operator|=
name|big
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
operator|&&
name|little
operator|!=
name|NULL
condition|)
name|format
operator|=
name|little
expr_stmt|;
name|output_target
operator|=
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter a group.  This creates a new lang_group_statement, and sets    stat_ptr to build new statements within the group.  */
end_comment

begin_function
name|void
name|lang_enter_group
parameter_list|(
name|void
parameter_list|)
block|{
name|lang_group_statement_type
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|new_stat
argument_list|(
name|lang_group_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|g
operator|->
name|children
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|g
operator|->
name|children
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leave a group.  This just resets stat_ptr to start writing to the    regular list of statements again.  Note that this will not work if    groups can occur inside anything else which can adjust stat_ptr,    but currently they can't.  */
end_comment

begin_function
name|void
name|lang_leave_group
parameter_list|(
name|void
parameter_list|)
block|{
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new program header.  This is called for each entry in a PHDRS    command in a linker script.  */
end_comment

begin_function
name|void
name|lang_new_phdr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|etree_type
modifier|*
name|type
parameter_list|,
name|bfd_boolean
name|filehdr
parameter_list|,
name|bfd_boolean
name|phdrs
parameter_list|,
name|etree_type
modifier|*
name|at
parameter_list|,
name|etree_type
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|lang_phdr
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|n
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_phdr
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|exp_get_value_int
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|"program header type"
argument_list|)
expr_stmt|;
name|n
operator|->
name|filehdr
operator|=
name|filehdr
expr_stmt|;
name|n
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|n
operator|->
name|at
operator|=
name|at
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_phdr_list
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the program header information in the output BFD.  FIXME: We    should not be calling an ELF specific function here.  */
end_comment

begin_function
specifier|static
name|void
name|lang_record_phdrs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|alc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
name|lang_output_section_phdr_list
modifier|*
name|last
decl_stmt|;
name|struct
name|lang_phdr
modifier|*
name|l
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|alc
operator|=
literal|10
expr_stmt|;
name|secs
operator|=
name|xmalloc
argument_list|(
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
name|lang_phdr_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_vma
name|at
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|os
operator|=
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
init|;
name|os
operator|!=
name|NULL
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|constraint
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|pl
operator|=
name|os
operator|->
name|phdrs
expr_stmt|;
if|if
condition|(
name|pl
operator|!=
name|NULL
condition|)
name|last
operator|=
name|pl
expr_stmt|;
else|else
block|{
if|if
condition|(
name|os
operator|->
name|sectype
operator|==
name|noload_section
operator|||
name|os
operator|->
name|bfd_section
operator|==
name|NULL
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pl
operator|=
name|last
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
name|l
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|alc
condition|)
block|{
name|alc
operator|*=
literal|2
expr_stmt|;
name|secs
operator|=
name|xrealloc
argument_list|(
name|secs
argument_list|,
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|secs
index|[
name|c
index|]
operator|=
name|os
operator|->
name|bfd_section
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|pl
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|l
operator|->
name|flags
operator|==
name|NULL
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|flags
argument_list|,
literal|0
argument_list|,
literal|"phdr flags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|at
operator|==
name|NULL
condition|)
name|at
operator|=
literal|0
expr_stmt|;
else|else
name|at
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|at
argument_list|,
literal|0
argument_list|,
literal|"phdr load address"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_record_phdr
argument_list|(
name|output_bfd
argument_list|,
name|l
operator|->
name|type
argument_list|,
name|l
operator|->
name|flags
operator|!=
name|NULL
argument_list|,
name|flags
argument_list|,
name|l
operator|->
name|at
operator|!=
name|NULL
argument_list|,
name|at
argument_list|,
name|l
operator|->
name|filehdr
argument_list|,
name|l
operator|->
name|phdrs
argument_list|,
name|c
argument_list|,
name|secs
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_record_phdr failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|secs
argument_list|)
expr_stmt|;
comment|/* Make sure all the phdr assignments succeeded.  */
for|for
control|(
name|os
operator|=
operator|&
name|lang_output_section_statement
operator|.
name|head
operator|->
name|output_section_statement
init|;
name|os
operator|!=
name|NULL
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|constraint
operator|==
operator|-
literal|1
operator|||
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|pl
operator|=
name|os
operator|->
name|phdrs
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|pl
operator|->
name|used
operator|&&
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
literal|"NONE"
argument_list|)
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: section `%s' assigned to non-existent phdr `%s'\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|,
name|pl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a list of sections which may not be cross referenced.  */
end_comment

begin_function
name|void
name|lang_add_nocrossref
parameter_list|(
name|lang_nocrossref_type
modifier|*
name|l
parameter_list|)
block|{
name|struct
name|lang_nocrossrefs
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|nocrossref_list
expr_stmt|;
name|n
operator|->
name|list
operator|=
name|l
expr_stmt|;
name|nocrossref_list
operator|=
name|n
expr_stmt|;
comment|/* Set notice_all so that we get informed about all symbols.  */
name|link_info
operator|.
name|notice_all
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Overlay handling.  We handle overlays with some static variables.  */
end_comment

begin_comment
comment|/* The overlay virtual address.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_vma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And subsection alignment.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_subalign
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An expression for the maximum section size seen so far.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all the sections in this overlay.  */
end_comment

begin_struct
struct|struct
name|overlay_list
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|overlay_list
modifier|*
name|overlay_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start handling an overlay.  */
end_comment

begin_function
name|void
name|lang_enter_overlay
parameter_list|(
name|etree_type
modifier|*
name|vma_expr
parameter_list|,
name|etree_type
modifier|*
name|subalign
parameter_list|)
block|{
comment|/* The grammar should prevent nested overlays from occurring.  */
name|ASSERT
argument_list|(
name|overlay_vma
operator|==
name|NULL
operator|&&
name|overlay_subalign
operator|==
name|NULL
operator|&&
name|overlay_max
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|vma_expr
expr_stmt|;
name|overlay_subalign
operator|=
name|subalign
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a section in an overlay.  We handle this by calling    lang_enter_output_section_statement with the correct VMA.    lang_leave_overlay sets up the LMA and memory regions.  */
end_comment

begin_function
name|void
name|lang_enter_overlay_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|overlay_list
modifier|*
name|n
decl_stmt|;
name|etree_type
modifier|*
name|size
decl_stmt|;
name|lang_enter_output_section_statement
argument_list|(
name|name
argument_list|,
name|overlay_vma
argument_list|,
name|normal_section
argument_list|,
literal|0
argument_list|,
name|overlay_subalign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is the first section, then base the VMA of future      sections on this one.  This will work correctly even if `.' is      used in the addresses.  */
if|if
condition|(
name|overlay_list
operator|==
name|NULL
condition|)
name|overlay_vma
operator|=
name|exp_nameop
argument_list|(
name|ADDR
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Remember the section.  */
name|n
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|os
operator|=
name|current_section
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|overlay_list
expr_stmt|;
name|overlay_list
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Arrange to work out the maximum section end address.  */
if|if
condition|(
name|overlay_max
operator|==
name|NULL
condition|)
name|overlay_max
operator|=
name|size
expr_stmt|;
else|else
name|overlay_max
operator|=
name|exp_binop
argument_list|(
name|MAX_K
argument_list|,
name|overlay_max
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a section in an overlay.  There isn't any special to do    here.  */
end_comment

begin_function
name|void
name|lang_leave_overlay_section
parameter_list|(
name|fill_type
modifier|*
name|fill
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
name|phdrs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|clean
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|name
operator|=
name|current_section
operator|->
name|name
expr_stmt|;
comment|/* For now, assume that DEFAULT_MEMORY_REGION is the run-time memory      region and that no load-time region has been specified.  It doesn't      really matter what we say here, since lang_leave_overlay will      override it.  */
name|lang_leave_output_section_statement
argument_list|(
name|fill
argument_list|,
name|DEFAULT_MEMORY_REGION
argument_list|,
name|phdrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Define the magic symbols.  */
name|clean
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|clean
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|name
init|;
operator|*
name|s1
operator|!=
literal|'\0'
condition|;
name|s1
operator|++
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|s1
argument_list|)
operator|||
operator|*
name|s1
operator|==
literal|'_'
condition|)
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_start_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_start_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_stop_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_stop_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|,
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an overlay.  If there are any overlay wide settings, this    looks through all the sections in the overlay and sets them.  */
end_comment

begin_function
name|void
name|lang_leave_overlay
parameter_list|(
name|etree_type
modifier|*
name|lma_expr
parameter_list|,
name|int
name|nocrossrefs
parameter_list|,
name|fill_type
modifier|*
name|fill
parameter_list|,
specifier|const
name|char
modifier|*
name|memspec
parameter_list|,
name|lang_output_section_phdr_list
modifier|*
name|phdrs
parameter_list|,
specifier|const
name|char
modifier|*
name|lma_memspec
parameter_list|)
block|{
name|lang_memory_region_type
modifier|*
name|region
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|lma_region
decl_stmt|;
name|struct
name|overlay_list
modifier|*
name|l
decl_stmt|;
name|lang_nocrossref_type
modifier|*
name|nocrossref
decl_stmt|;
name|lang_get_regions
argument_list|(
operator|&
name|region
argument_list|,
operator|&
name|lma_region
argument_list|,
name|memspec
argument_list|,
name|lma_memspec
argument_list|,
name|lma_expr
operator|!=
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nocrossref
operator|=
name|NULL
expr_stmt|;
comment|/* After setting the size of the last section, set '.' to end of the      overlay region.  */
if|if
condition|(
name|overlay_list
operator|!=
name|NULL
condition|)
name|overlay_list
operator|->
name|os
operator|->
name|update_dot_tree
operator|=
name|exp_assop
argument_list|(
literal|'='
argument_list|,
literal|"."
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|overlay_vma
argument_list|,
name|overlay_max
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|overlay_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|fill
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|fill
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
name|l
operator|->
name|os
operator|->
name|region
operator|=
name|region
expr_stmt|;
name|l
operator|->
name|os
operator|->
name|lma_region
operator|=
name|lma_region
expr_stmt|;
comment|/* The first section has the load address specified in the 	 OVERLAY statement.  The rest are worked out from that. 	 The base address is not needed (and should be null) if 	 an LMA region was specified.  */
if|if
condition|(
name|l
operator|->
name|next
operator|==
literal|0
condition|)
name|l
operator|->
name|os
operator|->
name|load_base
operator|=
name|lma_expr
expr_stmt|;
elseif|else
if|if
condition|(
name|lma_region
operator|==
literal|0
condition|)
name|l
operator|->
name|os
operator|->
name|load_base
operator|=
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|l
operator|->
name|next
operator|->
name|os
operator|->
name|name
argument_list|)
argument_list|,
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|l
operator|->
name|next
operator|->
name|os
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdrs
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|phdrs
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
if|if
condition|(
name|nocrossrefs
condition|)
block|{
name|lang_nocrossref_type
modifier|*
name|nc
decl_stmt|;
name|nc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nc
argument_list|)
expr_stmt|;
name|nc
operator|->
name|name
operator|=
name|l
operator|->
name|os
operator|->
name|name
expr_stmt|;
name|nc
operator|->
name|next
operator|=
name|nocrossref
expr_stmt|;
name|nocrossref
operator|=
name|nc
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|nocrossref
operator|!=
name|NULL
condition|)
name|lang_add_nocrossref
argument_list|(
name|nocrossref
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|NULL
expr_stmt|;
name|overlay_list
operator|=
name|NULL
expr_stmt|;
name|overlay_max
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Version handling.  This is only useful for ELF.  */
end_comment

begin_comment
comment|/* This global variable holds the version tree that we build.  */
end_comment

begin_decl_stmt
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_elf_version_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If PREV is NULL, return first version pattern matching particular symbol.    If PREV is non-NULL, return first version pattern matching particular    symbol after PREV (previously returned by lang_vers_match).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_vers_match
parameter_list|(
name|struct
name|bfd_elf_version_expr_head
modifier|*
name|head
parameter_list|,
name|struct
name|bfd_elf_version_expr
modifier|*
name|prev
parameter_list|,
specifier|const
name|char
modifier|*
name|sym
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cxx_sym
init|=
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|java_sym
init|=
name|sym
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|expr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|mask
operator|&
name|BFD_ELF_VERSION_CXX_TYPE
condition|)
block|{
name|cxx_sym
operator|=
name|cplus_demangle
argument_list|(
name|sym
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cxx_sym
condition|)
name|cxx_sym
operator|=
name|sym
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|->
name|mask
operator|&
name|BFD_ELF_VERSION_JAVA_TYPE
condition|)
block|{
name|java_sym
operator|=
name|cplus_demangle
argument_list|(
name|sym
argument_list|,
name|DMGL_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|java_sym
condition|)
name|java_sym
operator|=
name|sym
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|->
name|htab
operator|&&
operator|(
name|prev
operator|==
name|NULL
operator|||
name|prev
operator|->
name|symbol
operator|)
condition|)
block|{
name|struct
name|bfd_elf_version_expr
name|e
decl_stmt|;
switch|switch
condition|(
name|prev
condition|?
name|prev
operator|->
name|mask
else|:
literal|0
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|head
operator|->
name|mask
operator|&
name|BFD_ELF_VERSION_C_TYPE
condition|)
block|{
name|e
operator|.
name|symbol
operator|=
name|sym
expr_stmt|;
name|expr
operator|=
name|htab_find
argument_list|(
name|head
operator|->
name|htab
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
name|strcmp
argument_list|(
name|expr
operator|->
name|symbol
argument_list|,
name|sym
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|expr
operator|->
name|mask
operator|==
name|BFD_ELF_VERSION_C_TYPE
condition|)
goto|goto
name|out_ret
goto|;
else|else
name|expr
operator|=
name|expr
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fallthrough */
case|case
name|BFD_ELF_VERSION_C_TYPE
case|:
if|if
condition|(
name|head
operator|->
name|mask
operator|&
name|BFD_ELF_VERSION_CXX_TYPE
condition|)
block|{
name|e
operator|.
name|symbol
operator|=
name|cxx_sym
expr_stmt|;
name|expr
operator|=
name|htab_find
argument_list|(
name|head
operator|->
name|htab
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
name|strcmp
argument_list|(
name|expr
operator|->
name|symbol
argument_list|,
name|cxx_sym
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|expr
operator|->
name|mask
operator|==
name|BFD_ELF_VERSION_CXX_TYPE
condition|)
goto|goto
name|out_ret
goto|;
else|else
name|expr
operator|=
name|expr
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fallthrough */
case|case
name|BFD_ELF_VERSION_CXX_TYPE
case|:
if|if
condition|(
name|head
operator|->
name|mask
operator|&
name|BFD_ELF_VERSION_JAVA_TYPE
condition|)
block|{
name|e
operator|.
name|symbol
operator|=
name|java_sym
expr_stmt|;
name|expr
operator|=
name|htab_find
argument_list|(
name|head
operator|->
name|htab
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
name|strcmp
argument_list|(
name|expr
operator|->
name|symbol
argument_list|,
name|java_sym
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|expr
operator|->
name|mask
operator|==
name|BFD_ELF_VERSION_JAVA_TYPE
condition|)
goto|goto
name|out_ret
goto|;
else|else
name|expr
operator|=
name|expr
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fallthrough */
default|default:
break|break;
block|}
block|}
comment|/* Finally, try the wildcards.  */
if|if
condition|(
name|prev
operator|==
name|NULL
operator|||
name|prev
operator|->
name|symbol
condition|)
name|expr
operator|=
name|head
operator|->
name|remaining
expr_stmt|;
else|else
name|expr
operator|=
name|prev
operator|->
name|next
expr_stmt|;
for|for
control|(
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|expr
operator|->
name|pattern
condition|)
continue|continue;
if|if
condition|(
name|expr
operator|->
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|expr
operator|->
name|pattern
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|expr
operator|->
name|mask
operator|==
name|BFD_ELF_VERSION_JAVA_TYPE
condition|)
name|s
operator|=
name|java_sym
expr_stmt|;
elseif|else
if|if
condition|(
name|expr
operator|->
name|mask
operator|==
name|BFD_ELF_VERSION_CXX_TYPE
condition|)
name|s
operator|=
name|cxx_sym
expr_stmt|;
else|else
name|s
operator|=
name|sym
expr_stmt|;
if|if
condition|(
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|out_ret
label|:
if|if
condition|(
name|cxx_sym
operator|!=
name|sym
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cxx_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|java_sym
operator|!=
name|sym
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|java_sym
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return NULL if the PATTERN argument is a glob pattern, otherwise,    return a string pointing to the symbol name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|realsymbol
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|bfd_boolean
name|changed
init|=
name|FALSE
decl_stmt|,
name|backslash
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|symbol
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|pattern
operator|,
name|s
operator|=
name|symbol
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
comment|/* It is a glob pattern only if there is no preceding 	 backslash.  */
if|if
condition|(
operator|!
name|backslash
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'?'
operator|||
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'['
operator|)
condition|)
block|{
name|free
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|backslash
condition|)
block|{
comment|/* Remove the preceding backslash.  */
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|=
operator|*
name|p
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|backslash
operator|=
operator|*
name|p
operator|==
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
name|symbol
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
return|return
name|pattern
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is called for each variable name or match expression.  NEW is    the name of the symbol to match, or, if LITERAL_P is FALSE, a glob    pattern to be matched against symbol names.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_new_vers_pattern
parameter_list|(
name|struct
name|bfd_elf_version_expr
modifier|*
name|orig
parameter_list|,
specifier|const
name|char
modifier|*
name|new
parameter_list|,
specifier|const
name|char
modifier|*
name|lang
parameter_list|,
name|bfd_boolean
name|literal_p
parameter_list|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|orig
expr_stmt|;
name|ret
operator|->
name|pattern
operator|=
name|literal_p
condition|?
name|NULL
else|:
name|new
expr_stmt|;
name|ret
operator|->
name|symver
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|script
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|symbol
operator|=
name|literal_p
condition|?
name|new
else|:
name|realsymbol
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|mask
operator|=
name|BFD_ELF_VERSION_C_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"C++"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|mask
operator|=
name|BFD_ELF_VERSION_CXX_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"Java"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|mask
operator|=
name|BFD_ELF_VERSION_JAVA_TYPE
expr_stmt|;
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unknown language `%s' in version information\n"
argument_list|)
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|ret
operator|->
name|mask
operator|=
name|BFD_ELF_VERSION_C_TYPE
expr_stmt|;
block|}
return|return
name|ldemul_new_vers_pattern
argument_list|(
name|ret
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is called for each set of variable names and match    expressions.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_new_vers_node
parameter_list|(
name|struct
name|bfd_elf_version_expr
modifier|*
name|globals
parameter_list|,
name|struct
name|bfd_elf_version_expr
modifier|*
name|locals
parameter_list|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|globals
operator|.
name|list
operator|=
name|globals
expr_stmt|;
name|ret
operator|->
name|locals
operator|.
name|list
operator|=
name|locals
expr_stmt|;
name|ret
operator|->
name|match
operator|=
name|lang_vers_match
expr_stmt|;
name|ret
operator|->
name|name_indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This static variable keeps track of version indices.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|version_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|hashval_t
name|version_expr_head_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_elf_version_expr
modifier|*
name|e
init|=
name|p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|e
operator|->
name|symbol
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|version_expr_head_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_elf_version_expr
modifier|*
name|e1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
init|=
name|p2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|e1
operator|->
name|symbol
argument_list|,
name|e2
operator|->
name|symbol
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_finalize_version_expr_head
parameter_list|(
name|struct
name|bfd_elf_version_expr_head
modifier|*
name|head
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|e
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
modifier|*
name|list_loc
decl_stmt|,
modifier|*
modifier|*
name|remaining_loc
decl_stmt|;
for|for
control|(
name|e
operator|=
name|head
operator|->
name|list
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|symbol
condition|)
name|count
operator|++
expr_stmt|;
name|head
operator|->
name|mask
operator||=
name|e
operator|->
name|mask
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|head
operator|->
name|htab
operator|=
name|htab_create
argument_list|(
name|count
operator|*
literal|2
argument_list|,
name|version_expr_head_hash
argument_list|,
name|version_expr_head_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_loc
operator|=
operator|&
name|head
operator|->
name|list
expr_stmt|;
name|remaining_loc
operator|=
operator|&
name|head
operator|->
name|remaining
expr_stmt|;
for|for
control|(
name|e
operator|=
name|head
operator|->
name|list
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|symbol
condition|)
block|{
operator|*
name|remaining_loc
operator|=
name|e
expr_stmt|;
name|remaining_loc
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
modifier|*
name|loc
init|=
name|htab_find_slot
argument_list|(
name|head
operator|->
name|htab
argument_list|,
name|e
argument_list|,
name|INSERT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e1
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|e1
operator|=
operator|*
name|loc
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
name|e1
operator|->
name|mask
operator|==
name|e
operator|->
name|mask
condition|)
block|{
name|last
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|e1
expr_stmt|;
name|e1
operator|=
name|e1
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|e1
operator|&&
name|strcmp
argument_list|(
name|e1
operator|->
name|symbol
argument_list|,
name|e
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
comment|/* This is a duplicate.  */
comment|/* FIXME: Memory leak.  Sometimes pattern is not 			 xmalloced alone, but in larger chunk of memory.  */
comment|/* free (e->symbol); */
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|e
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|loc
operator|=
name|e
expr_stmt|;
operator|*
name|list_loc
operator|=
name|e
expr_stmt|;
name|list_loc
operator|=
operator|&
name|e
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
operator|*
name|remaining_loc
operator|=
name|NULL
expr_stmt|;
operator|*
name|list_loc
operator|=
name|head
operator|->
name|remaining
expr_stmt|;
block|}
else|else
name|head
operator|->
name|remaining
operator|=
name|head
operator|->
name|list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when we know the name and dependencies of the    version.  */
end_comment

begin_function
name|void
name|lang_register_vers_node
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|bfd_elf_version_tree
modifier|*
name|version
parameter_list|,
name|struct
name|bfd_elf_version_deps
modifier|*
name|deps
parameter_list|)
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|e1
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|lang_elf_version_info
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|lang_elf_version_info
operator|&&
name|lang_elf_version_info
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: anonymous version tag cannot be combined"
literal|" with other version tags\n"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure this node has a unique name.  */
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate version tag `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lang_finalize_version_expr_head
argument_list|(
operator|&
name|version
operator|->
name|globals
argument_list|)
expr_stmt|;
name|lang_finalize_version_expr_head
argument_list|(
operator|&
name|version
operator|->
name|locals
argument_list|)
expr_stmt|;
comment|/* Check the global and local match names, and make sure there      aren't any duplicates.  */
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|globals
operator|.
name|list
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|locals
operator|.
name|htab
operator|&&
name|e1
operator|->
name|symbol
condition|)
block|{
name|e2
operator|=
name|htab_find
argument_list|(
name|t
operator|->
name|locals
operator|.
name|htab
argument_list|,
name|e1
argument_list|)
expr_stmt|;
while|while
condition|(
name|e2
operator|&&
name|strcmp
argument_list|(
name|e1
operator|->
name|symbol
argument_list|,
name|e2
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|mask
operator|==
name|e2
operator|->
name|mask
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s'"
literal|" in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|e2
operator|=
name|e2
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|e1
operator|->
name|symbol
condition|)
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|locals
operator|.
name|remaining
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|pattern
argument_list|,
name|e2
operator|->
name|pattern
argument_list|)
operator|==
literal|0
operator|&&
name|e1
operator|->
name|mask
operator|==
name|e2
operator|->
name|mask
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s'"
literal|" in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|locals
operator|.
name|list
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|globals
operator|.
name|htab
operator|&&
name|e1
operator|->
name|symbol
condition|)
block|{
name|e2
operator|=
name|htab_find
argument_list|(
name|t
operator|->
name|globals
operator|.
name|htab
argument_list|,
name|e1
argument_list|)
expr_stmt|;
while|while
condition|(
name|e2
operator|&&
name|strcmp
argument_list|(
name|e1
operator|->
name|symbol
argument_list|,
name|e2
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|mask
operator|==
name|e2
operator|->
name|mask
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s'"
literal|" in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|e2
operator|=
name|e2
operator|->
name|next
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|e1
operator|->
name|symbol
condition|)
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|globals
operator|.
name|remaining
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|pattern
argument_list|,
name|e2
operator|->
name|pattern
argument_list|)
operator|==
literal|0
operator|&&
name|e1
operator|->
name|mask
operator|==
name|e2
operator|->
name|mask
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s'"
literal|" in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
name|version
operator|->
name|deps
operator|=
name|deps
expr_stmt|;
name|version
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|version_index
expr_stmt|;
name|version
operator|->
name|vernum
operator|=
name|version_index
expr_stmt|;
block|}
else|else
name|version
operator|->
name|vernum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_elf_version_info
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when we see a version dependency.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_deps
modifier|*
name|lang_add_vers_depend
parameter_list|(
name|struct
name|bfd_elf_version_deps
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bfd_elf_version_deps
modifier|*
name|ret
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|list
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|->
name|version_needed
operator|=
name|t
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to find version dependency `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_do_version_exports_section
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|greg
init|=
name|NULL
decl_stmt|,
modifier|*
name|lreg
decl_stmt|;
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|is
argument_list|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
literal|".exports"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
continue|continue;
name|len
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|contents
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to read .exports section contents\n"
argument_list|)
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|p
operator|=
name|contents
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|contents
operator|+
name|len
condition|)
block|{
name|greg
operator|=
name|lang_new_vers_pattern
argument_list|(
name|greg
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Do not free the contents, as we used them creating the regex.  */
comment|/* Do not include this section in the link.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
name|lreg
operator|=
name|lang_new_vers_pattern
argument_list|(
name|NULL
argument_list|,
literal|"*"
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lang_register_vers_node
argument_list|(
name|command_line
operator|.
name|version_exports_section
argument_list|,
name|lang_new_vers_node
argument_list|(
name|greg
argument_list|,
name|lreg
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_unique
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|unique_sections
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|unique_section_list
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ent
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|unique_section_list
expr_stmt|;
name|unique_section_list
operator|=
name|ent
expr_stmt|;
block|}
end_function

end_unit

