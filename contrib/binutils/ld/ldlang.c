begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linker command language support.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002    Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"fnmatch.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* FORWARDS */
end_comment

begin_decl_stmt
specifier|static
name|lang_statement_union_type
modifier|*
name|new_statement
name|PARAMS
argument_list|(
operator|(
expr|enum
name|statement_enum
operator|,
name|size_t
operator|,
name|lang_statement_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LOCALS */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|stat_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|startup_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|input_file_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|placed_commons
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|default_common_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|map_option_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|print_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|first_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lang_phdr
modifier|*
name|lang_phdr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_for_each_statement_worker
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|lang_statement_union_type
operator|*
argument_list|)
operator|,
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|new_afile
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|lang_input_file_enum_type
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_default
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_map_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_os
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exp_init_os
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|section_already_linked
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|already_linked_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|already_linked_table_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|already_linked_table_free
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|wildcardp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_union_type
modifier|*
name|wild_sort
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
expr|struct
name|wildcard_list
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_section_callback
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
expr|struct
name|wildcard_list
operator|*
operator|,
name|asection
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|load_symbols
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|,
name|lang_statement_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wild
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|open_output
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ldlang_open_output
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|open_input_bfds
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_reasonable_defaults
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_undefined
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_place_undefineds
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_input_to_output_sections
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_output_section_statement
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_assignment
name|PARAMS
argument_list|(
operator|(
name|lang_assignment_statement_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_input_statement
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|print_one_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_input_section
name|PARAMS
argument_list|(
operator|(
name|lang_input_section_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_fill_statement
name|PARAMS
argument_list|(
operator|(
name|lang_fill_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_data_statement
name|PARAMS
argument_list|(
operator|(
name|lang_data_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_address_statement
name|PARAMS
argument_list|(
operator|(
name|lang_address_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_reloc_statement
name|PARAMS
argument_list|(
operator|(
name|lang_reloc_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_padding_statement
name|PARAMS
argument_list|(
operator|(
name|lang_padding_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_wild_statement
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_group
name|PARAMS
argument_list|(
operator|(
name|lang_group_statement_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statement
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statement_list
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statements
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_pad
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|*
operator|,
name|fill_type
operator|,
name|unsigned
name|int
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|size_input_section
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|,
name|fill_type
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_finish
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ignore_bfd_errors
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_check
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_common
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|lang_one_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_place_orphans
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|topower
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_set_startof
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gc_section_callback
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
expr|struct
name|wildcard_list
operator|*
operator|,
name|asection
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_record_phdrs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_gc_wild
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_gc_sections_1
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_gc_sections
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lang_vers_match_lang_c
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lang_vers_match_lang_cplusplus
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lang_vers_match_lang_java
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_do_version_exports_section
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_check_section_addresses
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|os_region_check
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
operator|,
expr|struct
name|memory_region_struct
operator|*
operator|,
name|etree_type
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*callback_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
expr|struct
name|wildcard_list
operator|*
operator|,
name|asection
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|walk_wild
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
name|callback_t
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|walk_wild_section
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|callback_t
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|walk_wild_file
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|callback_t
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_target
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_target
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stricpy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|strcut
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|name_compare
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|closest_target_match
name|PARAMS
argument_list|(
operator|(
specifier|const
name|bfd_target
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_first_input_target
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EXPORTS */
end_comment

begin_decl_stmt
name|lang_output_section_statement_type
modifier|*
name|abs_output_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
name|lang_output_section_statement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
modifier|*
name|stat_ptr
init|=
operator|&
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
name|file_chain
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|entry_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|entry_section
init|=
literal|".text"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|entry_from_cmdline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|lang_has_input_file
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|had_output_filename
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|lang_float_flag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|delete_output_file_on_failure
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lang_nocrossrefs
modifier|*
name|nocrossref_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|unique_sections
modifier|*
name|unique_section_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|etree_type
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocation base - or null */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
end_if

begin_define
define|#
directive|define
name|cat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##b
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
comment|/**/
value|b
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't beautify the line below with "innocent" whitespace, it breaks    the K&R C preprocessor!  */
end_comment

begin_define
define|#
directive|define
name|new_stat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
end_define

begin_define
define|#
directive|define
name|outside_section_address
parameter_list|(
name|q
parameter_list|)
define|\
value|((q)->output_offset + (q)->output_section->vma)
end_define

begin_define
define|#
directive|define
name|outside_symbol_address
parameter_list|(
name|q
parameter_list|)
define|\
value|((q)->value + outside_section_address (q->section))
end_define

begin_define
define|#
directive|define
name|SECTION_NAME_MAP_LENGTH
value|(16)
end_define

begin_function
name|PTR
name|stat_alloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|stat_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|boolean
name|unique_section_p
parameter_list|(
name|secnam
parameter_list|)
specifier|const
name|char
modifier|*
name|secnam
decl_stmt|;
block|{
name|struct
name|unique_sections
modifier|*
name|unam
decl_stmt|;
for|for
control|(
name|unam
operator|=
name|unique_section_list
init|;
name|unam
condition|;
name|unam
operator|=
name|unam
operator|->
name|next
control|)
if|if
condition|(
name|wildcardp
argument_list|(
name|unam
operator|->
name|name
argument_list|)
condition|?
name|fnmatch
argument_list|(
name|unam
operator|->
name|name
argument_list|,
name|secnam
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
else|:
name|strcmp
argument_list|(
name|unam
operator|->
name|name
argument_list|,
name|secnam
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Generic traversal routines for finding matching sections.  */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_section
parameter_list|(
name|ptr
parameter_list|,
name|file
parameter_list|,
name|callback
parameter_list|,
name|data
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|ptr
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
name|callback_t
name|callback
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|just_syms_flag
condition|)
return|return;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|ptr
operator|->
name|section_list
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|s
argument_list|,
name|file
argument_list|,
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|skip
init|=
name|false
decl_stmt|;
name|struct
name|name_list
modifier|*
name|list_tmp
decl_stmt|;
comment|/* Don't process sections from files which were 	     excluded.  */
for|for
control|(
name|list_tmp
operator|=
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
init|;
name|list_tmp
condition|;
name|list_tmp
operator|=
name|list_tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|wildcardp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|)
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|filename
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* If this file is part of an archive, and the archive is 		 excluded, exclude this file.  */
if|if
condition|(
operator|!
name|skip
operator|&&
name|file
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wildcardp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|)
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|list_tmp
operator|->
name|name
argument_list|,
name|file
operator|->
name|the_bfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|skip
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|skip
operator|&&
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|wildcardp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
condition|)
name|skip
operator|=
name|fnmatch
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
name|skip
operator|=
name|strcmp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
name|sname
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|s
argument_list|,
name|file
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle a wild statement for a single file F.  */
end_comment

begin_function
specifier|static
name|void
name|walk_wild_file
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|,
name|callback
parameter_list|,
name|data
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
name|callback_t
name|callback
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|the_bfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_check_format
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|walk_wild_section
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|member
decl_stmt|;
comment|/* This is an archive file.  We must map each member of the 	 archive separately.  */
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
comment|/* When lookup_name is called, it will call the add_symbols 	     entry point for the archive.  For each element of the 	     archive which is included, BFD will call ldlang_add_file, 	     which will set the usrdata field of the member to the 	     lang_input_statement.  */
if|if
condition|(
name|member
operator|->
name|usrdata
operator|!=
name|NULL
condition|)
block|{
name|walk_wild_section
argument_list|(
name|s
argument_list|,
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|member
operator|->
name|usrdata
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|walk_wild
parameter_list|(
name|s
parameter_list|,
name|callback
parameter_list|,
name|data
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
name|callback_t
name|callback
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|file_spec
init|=
name|s
operator|->
name|filename
decl_stmt|;
if|if
condition|(
name|file_spec
operator|==
name|NULL
condition|)
block|{
comment|/* Perform the iteration over all files in the list.  */
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wildcardp
argument_list|(
name|file_spec
argument_list|)
condition|)
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|file_spec
argument_list|,
name|f
operator|->
name|filename
argument_list|,
name|FNM_FILE_NAME
argument_list|)
operator|==
literal|0
condition|)
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
comment|/* Perform the iteration over a single file.  */
name|f
operator|=
name|lookup_name
argument_list|(
name|file_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|walk_wild_file
argument_list|(
name|s
argument_list|,
name|f
argument_list|,
name|callback
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* lang_for_each_statement walks the parse tree and calls the provided    function for each node.  */
end_comment

begin_function_decl
specifier|static
name|void
name|lang_for_each_statement_worker
parameter_list|(
name|func
parameter_list|,
name|s
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
name|func
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_input_statement_enum
case|:
case|case
name|lang_assignment_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_address_statement_enum
case|:
case|case
name|lang_fill_statement_enum
case|:
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function_decl
name|void
name|lang_for_each_statement
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lang_list_init
parameter_list|(
name|list
parameter_list|)
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|list
operator|->
name|head
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|->
name|tail
operator|=
operator|&
name|list
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a new statement node for the parse tree.  */
end_comment

begin_function
specifier|static
name|lang_statement_union_type
modifier|*
name|new_statement
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|enum
name|statement_enum
name|type
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|new
init|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|stat_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|new
operator|->
name|header
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lang_statement_append
argument_list|(
name|list
argument_list|,
name|new
argument_list|,
operator|&
name|new
operator|->
name|header
operator|.
name|next
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Build a new input file node for the language.  There are several    ways in which we treat an input file, eg, we only look at symbols,    or prefix it with a -l etc.     We can be supplied with requests for input files more than once;    they may, for example be split over serveral lines like foo.o(.text)    foo.o(.data) etc, so when asked for a file we check that we haven't    got it already so we don't duplicate the bfd.  */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|new_afile
parameter_list|(
name|name
parameter_list|,
name|file_type
parameter_list|,
name|target
parameter_list|,
name|add_to_list
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|lang_input_file_enum_type
name|file_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|boolean
name|add_to_list
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|add_to_list
condition|)
name|p
operator|=
name|new_stat
argument_list|(
name|lang_input_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
operator|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_input_statement_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|header
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|target
operator|=
name|target
expr_stmt|;
switch|switch
condition|(
name|file_type
condition|)
block|{
case|case
name|lang_input_file_is_symbols_only_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_fake_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_l_enum
case|:
name|p
operator|->
name|is_archive
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_marker_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_search_file_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_file_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|the_bfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|asymbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|next_real_file
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|symbol_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|dynamic
operator|=
name|config
operator|.
name|dynamic_link
expr_stmt|;
name|p
operator|->
name|whole_archive
operator|=
name|whole_archive
expr_stmt|;
name|p
operator|->
name|loaded
operator|=
name|false
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|input_file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|p
argument_list|,
operator|&
name|p
operator|->
name|next_real_file
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|lang_input_statement_type
modifier|*
name|lang_add_input_file
parameter_list|(
name|name
parameter_list|,
name|file_type
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|lang_input_file_enum_type
name|file_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
return|return
name|new_afile
argument_list|(
name|name
argument_list|,
name|file_type
argument_list|,
name|target
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build enough state so that the parser can build its tree.  */
end_comment

begin_function
name|void
name|lang_init
parameter_list|()
block|{
name|obstack_begin
argument_list|(
operator|&
name|stat_obstack
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|input_file_chain
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|file_chain
argument_list|)
expr_stmt|;
name|first_file
operator|=
name|lang_add_input_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|lang_input_file_is_marker_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|abs_output_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|BFD_ABS_SECTION_NAME
argument_list|)
expr_stmt|;
name|abs_output_section
operator|->
name|bfd_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   A region is an area of memory declared with the   MEMORY {  name:org=exp, len=exp ... }   syntax.    We maintain a list of all the regions here.    If no regions are specified in the script, then the default is used   which is created when looked up to be the entire data space.  */
end_comment

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
modifier|*
name|lang_memory_region_list_tail
init|=
operator|&
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_function
name|lang_memory_region_type
modifier|*
name|lang_memory_region_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
name|lang_memory_region_type
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This code used to always use the first region in the list as the      default region.  I changed it to instead use a region      encompassing all of memory as the default region.  This permits      NOLOAD sections to work reasonably without requiring a region.      People should specify what region they mean, if they really want      a region.  */
block|if (strcmp (name, "*default*") == 0)     {       if (lang_memory_region_list != (lang_memory_region_type *) NULL) 	{ 	  return lang_memory_region_list; 	}     }
endif|#
directive|endif
block|{
name|lang_memory_region_type
modifier|*
name|new
init|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_memory_region_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|lang_memory_region_list_tail
operator|=
name|new
expr_stmt|;
name|lang_memory_region_list_tail
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|not_flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|length
operator|=
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
expr_stmt|;
name|new
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|had_full_message
operator|=
name|false
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_default
parameter_list|(
name|section
parameter_list|)
name|asection
modifier|*
name|section
decl_stmt|;
block|{
name|lang_memory_region_type
modifier|*
name|p
decl_stmt|;
name|flagword
name|sec_flags
init|=
name|section
operator|->
name|flags
decl_stmt|;
comment|/* Override SEC_DATA to mean a writable section.  */
if|if
condition|(
operator|(
name|sec_flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
operator|)
operator|==
name|SEC_ALLOC
condition|)
name|sec_flags
operator||=
name|SEC_DATA
expr_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|sec_flags
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|not_flags
operator|&
name|sec_flags
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
return|return
name|lang_memory_region_lookup
argument_list|(
literal|"*default*"
argument_list|)
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|u
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|lookup
decl_stmt|;
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|u
operator|=
name|lookup
operator|->
name|next
control|)
block|{
name|lookup
operator|=
operator|&
name|u
operator|->
name|output_section_statement
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|lookup
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|lookup
return|;
block|}
block|}
return|return
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
name|lang_output_section_statement_type
modifier|*
name|lookup
decl_stmt|;
name|lookup
operator|=
name|lang_output_section_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|==
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|lookup
operator|=
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|new_stat
argument_list|(
name|lang_output_section_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|region
operator|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|lma_region
operator|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|fill
operator|=
literal|0
expr_stmt|;
name|lookup
operator|->
name|block_value
operator|=
literal|1
expr_stmt|;
name|lookup
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|lookup
operator|->
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|bfd_section
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|processed
operator|=
name|false
expr_stmt|;
name|lookup
operator|->
name|sectype
operator|=
name|normal_section
expr_stmt|;
name|lookup
operator|->
name|addr_tree
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|lookup
operator|->
name|children
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|memspec
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|lookup
operator|->
name|subsection_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|lookup
operator|->
name|section_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|lookup
operator|->
name|load_base
operator|=
operator|(
expr|union
name|etree_union
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|phdrs
operator|=
name|NULL
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|lookup
argument_list|,
operator|&
name|lookup
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_map_flags
parameter_list|(
name|flag
parameter_list|)
name|flagword
name|flag
decl_stmt|;
block|{
if|if
condition|(
name|flag
operator|&
name|SEC_ALLOC
condition|)
name|minfo
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_CODE
condition|)
name|minfo
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_READONLY
condition|)
name|minfo
argument_list|(
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_DATA
condition|)
name|minfo
argument_list|(
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|SEC_LOAD
condition|)
name|minfo
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_map
parameter_list|()
block|{
name|lang_memory_region_type
modifier|*
name|m
decl_stmt|;
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nMemory Configuration\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s %-18s %-18s %s\n"
argument_list|,
name|_
argument_list|(
literal|"Name"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Origin"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Length"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Attributes"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|lang_memory_region_list
init|;
name|m
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s "
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|origin
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V"
argument_list|,
name|m
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|||
name|m
operator|->
name|not_flags
condition|)
block|{
ifndef|#
directive|ifndef
name|BFD64
name|minfo
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|flags
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|lang_map_flags
argument_list|(
name|m
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|not_flags
condition|)
block|{
name|minfo
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
name|lang_map_flags
argument_list|(
name|m
operator|->
name|not_flags
argument_list|)
expr_stmt|;
block|}
block|}
name|print_nl
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|_
argument_list|(
literal|"\nLinker script and memory map\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|print_statements
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize an output section.  */
end_comment

begin_function
specifier|static
name|void
name|init_os
parameter_list|(
name|s
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|s
decl_stmt|;
block|{
name|section_userdata_type
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Illegal use of `%s' section\n"
argument_list|)
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
operator|(
name|section_userdata_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|section_userdata_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|s
operator|->
name|bfd_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|s
operator|->
name|bfd_section
operator|=
name|bfd_make_section
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: output format %s cannot represent section called %s\n"
argument_list|)
argument_list|,
name|output_bfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|bfd_section
operator|->
name|output_section
operator|=
name|s
operator|->
name|bfd_section
expr_stmt|;
comment|/* We initialize an output sections output offset to minus its own      vma to allow us to output a section through itself.  */
name|s
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
name|get_userdata
argument_list|(
name|s
operator|->
name|bfd_section
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|new
expr_stmt|;
comment|/* If there is a base address, make sure that any sections it might      mention are initialized.  */
if|if
condition|(
name|s
operator|->
name|addr_tree
operator|!=
name|NULL
condition|)
name|exp_init_os
argument_list|(
name|s
operator|->
name|addr_tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that all output sections mentioned in an expression are    initialized.  */
end_comment

begin_function
specifier|static
name|void
name|exp_init_os
parameter_list|(
name|exp
parameter_list|)
name|etree_type
modifier|*
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_assign
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ADDR
case|:
case|case
name|LOADADDR
case|:
case|case
name|SIZEOF
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|exp
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sections marked with the SEC_LINK_ONCE flag should only be linked    once into the output.  This routine checks each section, and    arrange to discard it if a section of the same name has already    been linked.  If the section has COMDAT information, then it uses    that to decide whether the section should be included.  This code    assumes that all relevant sections have the SEC_LINK_ONCE flag set;    that is, it does not depend solely upon the section name.    section_already_linked is called via bfd_map_over_sections.  */
end_comment

begin_comment
comment|/* This is the shape of the elements inside the already_linked hash    table. It maps a name onto a list of already_linked elements with    the same name.  It's possible to get more than one element in a    list if the COMDAT sections have different names.  */
end_comment

begin_struct
struct|struct
name|already_linked_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
name|struct
name|already_linked
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|already_linked
block|{
name|struct
name|already_linked
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_table
name|already_linked_table
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|section_already_linked
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|entry
init|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|data
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|already_linked
modifier|*
name|l
decl_stmt|;
name|struct
name|already_linked_hash_entry
modifier|*
name|already_linked_list
decl_stmt|;
comment|/* If we are only reading symbols from this object, then we want to      discard all sections.  */
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
block|{
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sec
operator|->
name|output_offset
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* FIXME: When doing a relocatable link, we may have trouble      copying relocations in other sections that refer to local symbols      in the section being discarded.  Those relocations will have to      be converted somehow; as of this writing I'm not sure that any of      the backends handle that correctly.       It is tempting to instead not discard link once sections when      doing a relocatable link (technically, they should be discarded      whenever we are building constructors).  However, that fails,      because the linker winds up combining all the link once sections      into a single large link once section, which defeats the purpose      of having link once sections in the first place.       Also, not merging link once sections in a relocatable link      causes trouble for MIPS ELF, which relies in link once semantics      to handle the .reginfo section correctly.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|already_linked_list
operator|=
operator|(
operator|(
expr|struct
name|already_linked_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|already_linked_table
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|already_linked_list
operator|->
name|entry
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|comdat
operator|==
name|NULL
operator|||
name|l
operator|->
name|sec
operator|->
name|comdat
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|comdat
operator|->
name|name
argument_list|,
name|l
operator|->
name|sec
operator|->
name|comdat
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The section has already been linked.  See if we should              issue a warning.  */
switch|switch
condition|(
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
if|if
condition|(
name|sec
operator|->
name|comdat
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: %B: warning: ignoring duplicate section `%s'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|sec
operator|->
name|comdat
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
comment|/* FIXME: We should really dig out the contents of both                  sections and memcmp them.  The COFF/PE spec says that                  the Microsoft linker does not implement this                  correctly, so I'm not going to bother doing it                  either.  */
comment|/* Fall through.  */
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
if|if
condition|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|bfd_section_size
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: %B: warning: duplicate section `%s' has different size\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Set the output_section field so that lang_add_section 	     does not create a lang_input_section structure for this 	     section.  */
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
return|return;
block|}
block|}
comment|/* This is the first section with this name.  Record it.  Allocate      the memory from the same obstack as the hash table is kept in.  */
name|l
operator|=
operator|(
operator|(
expr|struct
name|already_linked
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|already_linked_table
argument_list|,
sizeof|sizeof
expr|*
name|l
argument_list|)
operator|)
expr_stmt|;
name|l
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|already_linked_list
operator|->
name|entry
expr_stmt|;
name|already_linked_list
operator|->
name|entry
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support routines for the hash table used by section_already_linked,    initialize the table, fill in an entry and remove the table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|already_linked_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|already_linked_hash_entry
modifier|*
name|ret
init|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|already_linked_hash_entry
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|already_linked_table_init
parameter_list|()
block|{
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
operator|&
name|already_linked_table
argument_list|,
name|already_linked_newfunc
argument_list|,
literal|42
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Failed to create hash table\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|already_linked_table_free
parameter_list|()
block|{
name|bfd_hash_table_free
argument_list|(
operator|&
name|already_linked_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The wild routines.     These expand statements like *(.text) and foo.o to a list of    explicit actions, like foo.o(.text), bar.o(.text) and    foo.o(.text, .data).  */
end_comment

begin_comment
comment|/* Return true if the PATTERN argument is a wildcard pattern.    Although backslashes are treated specially if a pattern contains    wildcards, we do not consider the mere presence of a backslash to    be enough to cause the pattern to be treated as a wildcard.    That lets us handle DOS filenames more naturally.  */
end_comment

begin_function
specifier|static
name|boolean
name|wildcardp
parameter_list|(
name|pattern
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|pattern
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'?'
operator|||
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'['
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add SECTION to the output section OUTPUT.  Do this by creating a    lang_input_section statement which is placed at PTR.  FILE is the    input file which holds SECTION.  */
end_comment

begin_function
name|void
name|lang_add_section
parameter_list|(
name|ptr
parameter_list|,
name|section
parameter_list|,
name|output
parameter_list|,
name|file
parameter_list|)
name|lang_statement_list_type
modifier|*
name|ptr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|boolean
name|discard
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|discard
operator|=
name|false
expr_stmt|;
comment|/* If we are doing a final link, discard sections marked with      SEC_EXCLUDE.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|&&
operator|(
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
comment|/* Discard input sections which are assigned to a section named      DISCARD_SECTION_NAME.  */
if|if
condition|(
name|strcmp
argument_list|(
name|output
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
comment|/* Discard debugging sections if we are stripping debugging      information.  */
if|if
condition|(
operator|(
name|link_info
operator|.
name|strip
operator|==
name|strip_debugger
operator|||
name|link_info
operator|.
name|strip
operator|==
name|strip_all
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|discard
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
comment|/* This prevents future calls from assigning this section.  */
name|section
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|boolean
name|first
decl_stmt|;
name|lang_input_section_type
modifier|*
name|new
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|first
operator|=
operator|!
name|output
operator|->
name|bfd_section
operator|->
name|linker_has_input
expr_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|linker_has_input
operator|=
literal|1
expr_stmt|;
comment|/* Add a section reference to the list.  */
name|new
operator|=
name|new_stat
argument_list|(
name|lang_input_section
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|->
name|ifile
operator|=
name|file
expr_stmt|;
name|section
operator|->
name|output_section
operator|=
name|output
operator|->
name|bfd_section
expr_stmt|;
name|flags
operator|=
name|section
operator|->
name|flags
expr_stmt|;
comment|/* We don't copy the SEC_NEVER_LOAD flag from an input section 	 to an output section, because we want to be able to include a 	 SEC_NEVER_LOAD section in the middle of an otherwise loaded 	 section (I don't know why we want to do this, but we do). 	 build_link_order in ldwrite.c handles this case by turning 	 the embedded SEC_NEVER_LOAD section into a fill.  */
name|flags
operator|&=
operator|~
name|SEC_NEVER_LOAD
expr_stmt|;
comment|/* If final link, don't copy the SEC_LINK_ONCE flags, they've 	 already been processed.  One reason to do this is that on pe 	 format targets, .text$foo sections go into .text and it's odd 	 to see .text with SEC_LINK_ONCE set.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
condition|)
name|flags
operator|&=
operator|~
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES
operator|)
expr_stmt|;
comment|/* If this is not the first input section, and the SEC_READONLY          flag is not currently set, then don't set it just because the          input section has it set.  */
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
comment|/* Keep SEC_MERGE and SEC_STRINGS only if they are the same.  */
if|if
condition|(
operator|!
name|first
operator|&&
operator|(
operator|(
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
operator|)
operator|!=
operator|(
name|flags
operator|&
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|section
operator|->
name|output_section
operator|->
name|entsize
operator|!=
name|section
operator|->
name|entsize
operator|)
operator|)
condition|)
block|{
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|SEC_MERGE
operator||
name|SEC_STRINGS
operator|)
expr_stmt|;
block|}
name|section
operator|->
name|output_section
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_MERGE
condition|)
name|section
operator|->
name|output_section
operator|->
name|entsize
operator|=
name|section
operator|->
name|entsize
expr_stmt|;
comment|/* If SEC_READONLY is not set in the input section, then clear          it from the output section.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|section
operator|->
name|output_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
switch|switch
condition|(
name|output
operator|->
name|sectype
condition|)
block|{
case|case
name|normal_section
case|:
break|break;
case|case
name|dsect_section
case|:
case|case
name|copy_section
case|:
case|case
name|info_section
case|:
case|case
name|overlay_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
name|noload_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
block|}
comment|/* Copy over SEC_SMALL_DATA.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_SMALL_DATA
condition|)
name|section
operator|->
name|output_section
operator|->
name|flags
operator||=
name|SEC_SMALL_DATA
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|alignment_power
operator|>
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|section
operator|->
name|alignment_power
expr_stmt|;
comment|/* If supplied an aligment, then force it.  */
if|if
condition|(
name|output
operator|->
name|section_alignment
operator|!=
operator|-
literal|1
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|output
operator|->
name|section_alignment
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_BLOCK
condition|)
block|{
name|section
operator|->
name|output_section
operator|->
name|flags
operator||=
name|SEC_BLOCK
expr_stmt|;
comment|/* FIXME: This value should really be obtained from the bfd...  */
name|output
operator|->
name|block_value
operator|=
literal|128
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle wildcard sorting.  This returns the lang_input_section which    should follow the one we are going to create for SECTION and FILE,    based on the sorting requirements of WILD.  It returns NULL if the    new section should just go at the end of the current list.  */
end_comment

begin_function
specifier|static
name|lang_statement_union_type
modifier|*
name|wild_sort
parameter_list|(
name|wild
parameter_list|,
name|sec
parameter_list|,
name|file
parameter_list|,
name|section
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|wild
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|wild
operator|->
name|filenames_sorted
operator|&&
operator|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|sec
operator|->
name|spec
operator|.
name|sorted
operator|)
condition|)
return|return
name|NULL
return|;
name|section_name
operator|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|wild
operator|->
name|children
operator|.
name|head
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|header
operator|.
name|next
control|)
block|{
name|lang_input_section_type
modifier|*
name|ls
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|header
operator|.
name|type
operator|!=
name|lang_input_section_enum
condition|)
continue|continue;
name|ls
operator|=
operator|&
name|l
operator|->
name|input_section
expr_stmt|;
comment|/* Sorting by filename takes precedence over sorting by section          name.  */
if|if
condition|(
name|wild
operator|->
name|filenames_sorted
condition|)
block|{
specifier|const
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|ln
decl_stmt|;
name|boolean
name|fa
decl_stmt|,
name|la
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* The PE support for the .idata section as generated by              dlltool assumes that files will be sorted by the name of              the archive and then the name of the file within the              archive.  */
if|if
condition|(
name|file
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|bfd_my_archive
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fn
operator|=
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|fa
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|fn
operator|=
name|file
operator|->
name|filename
expr_stmt|;
name|fa
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ls
operator|->
name|ifile
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|bfd_my_archive
argument_list|(
name|ls
operator|->
name|ifile
operator|->
name|the_bfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ln
operator|=
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|ls
operator|->
name|ifile
operator|->
name|the_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|ln
operator|=
name|ls
operator|->
name|ifile
operator|->
name|filename
expr_stmt|;
name|la
operator|=
name|false
expr_stmt|;
block|}
name|i
operator|=
name|strcmp
argument_list|(
name|fn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|fa
operator|||
name|la
condition|)
block|{
if|if
condition|(
name|fa
condition|)
name|fn
operator|=
name|file
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|la
condition|)
name|ln
operator|=
name|ls
operator|->
name|ifile
operator|->
name|filename
expr_stmt|;
name|i
operator|=
name|strcmp
argument_list|(
name|fn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
block|}
block|}
comment|/* Here either the files are not sorted by name, or we are          looking at the sections for this file.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|section_name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|ls
operator|->
name|ifile
operator|->
name|the_bfd
argument_list|,
name|ls
operator|->
name|section
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Expand a wild statement for a particular FILE.  SECTION may be    NULL, in which case it is a wild card.  */
end_comment

begin_function
specifier|static
name|void
name|output_section_callback
parameter_list|(
name|ptr
parameter_list|,
name|sec
parameter_list|,
name|section
parameter_list|,
name|file
parameter_list|,
name|output
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|ptr
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
name|PTR
name|output
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|before
decl_stmt|;
comment|/* Exclude sections that match UNIQUE_SECTION_LIST.  */
if|if
condition|(
name|unique_section_p
argument_list|(
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|section
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If the wild pattern was marked KEEP, the member sections      should be as well.  */
if|if
condition|(
name|ptr
operator|->
name|keep_sections
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
name|before
operator|=
name|wild_sort
argument_list|(
name|ptr
argument_list|,
name|sec
argument_list|,
name|file
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* Here BEFORE points to the lang_input_section which      should follow the one we are about to add.  If BEFORE      is NULL, then the section should just go at the end      of the current list.  */
if|if
condition|(
name|before
operator|==
name|NULL
condition|)
name|lang_add_section
argument_list|(
operator|&
name|ptr
operator|->
name|children
argument_list|,
name|section
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|output
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_statement_list_type
name|list
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|pp
decl_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|lang_add_section
argument_list|(
operator|&
name|list
argument_list|,
name|section
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|output
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* If we are discarding the section, LIST.HEAD will 	 be NULL.  */
if|if
condition|(
name|list
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|list
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|ptr
operator|->
name|children
operator|.
name|head
init|;
operator|*
name|pp
operator|!=
name|before
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|header
operator|.
name|next
control|)
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|list
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|list
operator|.
name|head
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is passed a file name which must have been seen already and    added to the statement tree.  We will see if it has been opened    already and had its symbols read.  If not then we'll read it.  */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|search
decl_stmt|;
for|for
control|(
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|search
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|search
operator|->
name|next_real_file
control|)
block|{
if|if
condition|(
name|search
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|search
return|;
if|if
condition|(
name|search
operator|->
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|search
operator|->
name|filename
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|search
operator|==
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|)
name|search
operator|=
name|new_afile
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
name|default_target
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we have already added this file, or this file is not real      (FIXME: can that ever actually happen?) or the name is NULL      (FIXME: can that ever actually happen?) don't add this file.  */
if|if
condition|(
name|search
operator|->
name|loaded
operator|||
operator|!
name|search
operator|->
name|real
operator|||
name|search
operator|->
name|filename
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|search
return|;
if|if
condition|(
operator|!
name|load_symbols
argument_list|(
name|search
argument_list|,
operator|(
name|lang_statement_list_type
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Get the symbols for an input file.  */
end_comment

begin_function
specifier|static
name|boolean
name|load_symbols
parameter_list|(
name|entry
parameter_list|,
name|place
parameter_list|)
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|place
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|loaded
condition|)
return|return
name|true
return|;
name|ldfile_open_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
operator|&&
operator|!
name|bfd_check_format_matches
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_error_type
name|err
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|hold
decl_stmt|;
name|boolean
name|bad_load
init|=
name|true
decl_stmt|;
name|err
operator|=
name|bfd_get_error
argument_list|()
expr_stmt|;
comment|/* See if the emulation has some special knowledge.  */
if|if
condition|(
name|ldemul_unrecognized_file
argument_list|(
name|entry
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|err
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: file not recognized: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: matching formats:"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|matching
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|einfo
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%F\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|bfd_error_file_not_recognized
operator|||
name|place
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: file not recognized: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
else|else
name|bad_load
operator|=
name|false
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
comment|/* Try to interpret the file as a linker script.  */
name|ldfile_open_command_file
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|hold
operator|=
name|stat_ptr
expr_stmt|;
name|stat_ptr
operator|=
name|place
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|true
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|false
expr_stmt|;
name|stat_ptr
operator|=
name|hold
expr_stmt|;
return|return
operator|!
name|bad_load
return|;
block|}
if|if
condition|(
name|ldemul_recognized_file
argument_list|(
name|entry
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* We don't call ldlang_add_file for an archive.  Instead, the      add_symbols entry point will call ldlang_add_file, via the      add_archive_element callback, for each element of the archive      which is used.  */
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_object
case|:
name|ldlang_add_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
operator|||
name|trace_file_tries
condition|)
name|info_msg
argument_list|(
literal|"%I\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_archive
case|:
if|if
condition|(
name|entry
operator|->
name|whole_archive
condition|)
block|{
name|bfd
modifier|*
name|member
init|=
name|NULL
decl_stmt|;
name|boolean
name|loaded
init|=
name|true
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|member
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: member %B in archive is not an object\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|.
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
operator|&
name|link_info
argument_list|,
name|member
argument_list|,
literal|"--whole-archive"
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|member
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|loaded
operator|=
name|false
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|loaded
operator|=
name|loaded
expr_stmt|;
return|return
name|loaded
return|;
block|}
break|break;
block|}
if|if
condition|(
name|bfd_link_add_symbols
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
name|entry
operator|->
name|loaded
operator|=
name|true
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
return|return
name|entry
operator|->
name|loaded
return|;
block|}
end_function

begin_comment
comment|/* Handle a wild statement.  S->FILENAME or S->SECTION_LIST or both    may be NULL, indicating that it is a wildcard.  Separate    lang_input_section statements are created for each part of the    expansion; they are added after the wild statement S.  OUTPUT is    the output section.  */
end_comment

begin_function
specifier|static
name|void
name|wild
parameter_list|(
name|s
parameter_list|,
name|target
parameter_list|,
name|output
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|walk_wild
argument_list|(
name|s
argument_list|,
name|output_section_callback
argument_list|,
operator|(
name|PTR
operator|)
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|s
operator|->
name|section_list
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|default_common_section
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember the section that common is going to in case we 	     later get something which doesn't know where to put it.  */
name|default_common_section
operator|=
name|output
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true iff target is the sought target.  */
end_comment

begin_function
specifier|static
name|int
name|get_target
parameter_list|(
name|target
parameter_list|,
name|data
parameter_list|)
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|sought
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|target
operator|->
name|name
argument_list|,
name|sought
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like strcpy() but convert to lower case as well.  */
end_comment

begin_function
specifier|static
name|void
name|stricpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|0
condition|)
operator|*
name|dest
operator|++
operator|=
name|TOLOWER
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the first occurance of needle (if any) in haystack    from haystack.  */
end_comment

begin_function
specifier|static
name|void
name|strcut
parameter_list|(
name|haystack
parameter_list|,
name|needle
parameter_list|)
name|char
modifier|*
name|haystack
decl_stmt|;
name|char
modifier|*
name|needle
decl_stmt|;
block|{
name|haystack
operator|=
name|strstr
argument_list|(
name|haystack
argument_list|,
name|needle
argument_list|)
expr_stmt|;
if|if
condition|(
name|haystack
condition|)
block|{
name|char
modifier|*
name|src
decl_stmt|;
for|for
control|(
name|src
operator|=
name|haystack
operator|+
name|strlen
argument_list|(
name|needle
argument_list|)
init|;
operator|*
name|src
condition|;
control|)
operator|*
name|haystack
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|haystack
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two target format name strings.    Return a value indicating how "similar" they are.  */
end_comment

begin_function
specifier|static
name|int
name|name_compare
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|char
modifier|*
name|first
decl_stmt|;
name|char
modifier|*
name|second
decl_stmt|;
block|{
name|char
modifier|*
name|copy1
decl_stmt|;
name|char
modifier|*
name|copy2
decl_stmt|;
name|int
name|result
decl_stmt|;
name|copy1
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|first
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy2
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|second
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Convert the names to lower case.  */
name|stricpy
argument_list|(
name|copy1
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|stricpy
argument_list|(
name|copy2
argument_list|,
name|second
argument_list|)
expr_stmt|;
comment|/* Remove and endian strings from the name.  */
name|strcut
argument_list|(
name|copy1
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy1
argument_list|,
literal|"little"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy2
argument_list|,
literal|"big"
argument_list|)
expr_stmt|;
name|strcut
argument_list|(
name|copy2
argument_list|,
literal|"little"
argument_list|)
expr_stmt|;
comment|/* Return a value based on how many characters match,      starting from the beginning.   If both strings are      the same then return 10 * their length.  */
for|for
control|(
name|result
operator|=
literal|0
init|;
name|copy1
index|[
name|result
index|]
operator|==
name|copy2
index|[
name|result
index|]
condition|;
name|result
operator|++
control|)
if|if
condition|(
name|copy1
index|[
name|result
index|]
operator|==
literal|0
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|copy1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy2
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Set by closest_target_match() below.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|winner
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan all the valid bfd targets looking for one that has the endianness    requirement that was specified on the command line, and is the nearest    match to the original output target.  */
end_comment

begin_function
specifier|static
name|int
name|closest_target_match
parameter_list|(
name|target
parameter_list|,
name|data
parameter_list|)
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
specifier|const
name|bfd_target
modifier|*
name|original
init|=
operator|(
specifier|const
name|bfd_target
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
operator|&&
name|target
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_BIG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
operator|&&
name|target
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_LITTLE
condition|)
return|return
literal|0
return|;
comment|/* Must be the same flavour.  */
if|if
condition|(
name|target
operator|->
name|flavour
operator|!=
name|original
operator|->
name|flavour
condition|)
return|return
literal|0
return|;
comment|/* If we have not found a potential winner yet, then record this one.  */
if|if
condition|(
name|winner
operator|==
name|NULL
condition|)
block|{
name|winner
operator|=
name|target
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Oh dear, we now have two potential candidates for a successful match.      Compare their names and choose the better one.  */
if|if
condition|(
name|name_compare
argument_list|(
name|target
operator|->
name|name
argument_list|,
name|original
operator|->
name|name
argument_list|)
operator|>
name|name_compare
argument_list|(
name|winner
operator|->
name|name
argument_list|,
name|original
operator|->
name|name
argument_list|)
condition|)
name|winner
operator|=
name|target
expr_stmt|;
comment|/* Keep on searching until wqe have checked them all.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the BFD target format of the first input file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_first_input_target
parameter_list|()
block|{
name|char
modifier|*
name|target
init|=
name|NULL
decl_stmt|;
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|s
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|header
operator|.
name|type
operator|==
name|lang_input_statement_enum
operator|&&
name|s
operator|->
name|real
condition|)
block|{
name|ldfile_open_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
name|bfd_check_format
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|target
operator|=
name|bfd_get_target
argument_list|(
name|s
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Open the output file.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|open_output
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|bfd
modifier|*
name|output
decl_stmt|;
comment|/* Has the user told us which output format to use?  */
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No - has the current target been set to something other than          the default?  */
if|if
condition|(
name|current_target
operator|!=
name|default_target
condition|)
name|output_target
operator|=
name|current_target
expr_stmt|;
comment|/* No - can we determine the format of the first input file?  */
else|else
block|{
name|output_target
operator|=
name|get_first_input_target
argument_list|()
expr_stmt|;
comment|/* Failed - use the default output target.  */
if|if
condition|(
name|output_target
operator|==
name|NULL
condition|)
name|output_target
operator|=
name|default_target
expr_stmt|;
block|}
block|}
comment|/* Has the user requested a particular endianness on the command      line?  */
if|if
condition|(
name|command_line
operator|.
name|endian
operator|!=
name|ENDIAN_UNSET
condition|)
block|{
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
name|enum
name|bfd_endian
name|desired_endian
decl_stmt|;
comment|/* Get the chosen target.  */
name|target
operator|=
name|bfd_search_for_target
argument_list|(
name|get_target
argument_list|,
operator|(
name|PTR
operator|)
name|output_target
argument_list|)
expr_stmt|;
comment|/* If the target is not supported, we cannot do anything.  */
if|if
condition|(
name|target
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
condition|)
name|desired_endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
else|else
name|desired_endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
comment|/* See if the target has the wrong endianness.  This should 	     not happen if the linker script has provided big and 	     little endian alternatives, but some scrips don't do 	     this.  */
if|if
condition|(
name|target
operator|->
name|byteorder
operator|!=
name|desired_endian
condition|)
block|{
comment|/* If it does, then see if the target provides 		 an alternative with the correct endianness.  */
if|if
condition|(
name|target
operator|->
name|alternative_target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|alternative_target
operator|->
name|byteorder
operator|==
name|desired_endian
operator|)
condition|)
name|output_target
operator|=
name|target
operator|->
name|alternative_target
operator|->
name|name
expr_stmt|;
else|else
block|{
comment|/* Try to find a target as similar as possible to 		     the default target, but which has the desired 		     endian characteristic.  */
operator|(
name|void
operator|)
name|bfd_search_for_target
argument_list|(
name|closest_target_match
argument_list|,
operator|(
name|PTR
operator|)
name|target
argument_list|)
expr_stmt|;
comment|/* Oh dear - we could not find any targets that 		     satisfy our requirements.  */
if|if
condition|(
name|winner
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: could not find any targets that match endianness requirement\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_target
operator|=
name|winner
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
block|}
name|output
operator|=
name|bfd_openw
argument_list|(
name|name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_target
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: target %s not found\n"
argument_list|)
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open output file %s: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|delete_output_file_on_failure
operator|=
name|true
expr_stmt|;
if|#
directive|if
literal|0
block|output->flags |= D_PAGED;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|output
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can not make object file: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|output
argument_list|,
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can not set architecture: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|hash
operator|=
name|bfd_link_hash_table_create
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|hash
operator|==
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can not create link hash table: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|output
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ldlang_open_output
parameter_list|(
name|statement
parameter_list|)
name|lang_statement_union_type
modifier|*
name|statement
decl_stmt|;
block|{
switch|switch
condition|(
name|statement
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_statement_enum
case|:
name|ASSERT
argument_list|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|open_output
argument_list|(
name|statement
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
name|ldemul_set_output_arch
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|magic_demand_paged
operator|&&
operator|!
name|link_info
operator|.
name|relocateable
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|text_read_only
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|traditional_format
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|statement
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Open all the input files.  */
end_comment

begin_function
specifier|static
name|void
name|open_input_bfds
parameter_list|(
name|s
parameter_list|,
name|force
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|boolean
name|force
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
comment|/* Maybe we should load the file's symbols.  */
if|if
condition|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
operator|&&
operator|!
name|wildcardp
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_name
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs
decl_stmt|;
comment|/* We must continually search the entries in the group 	       until no new symbols are added to the list of undefined 	       symbols.  */
do|do
block|{
name|undefs
operator|=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|undefs
operator|!=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
condition|)
do|;
block|}
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|s
operator|->
name|input_statement
operator|.
name|real
condition|)
block|{
name|lang_statement_list_type
name|add
decl_stmt|;
name|s
operator|->
name|input_statement
operator|.
name|target
operator|=
name|current_target
expr_stmt|;
comment|/* If we are being called from within a group, and this                  is an archive which has already been searched, then                  force it to be researched unless the whole archive 		 has been loaded already.  */
if|if
condition|(
name|force
operator|&&
operator|!
name|s
operator|->
name|input_statement
operator|.
name|whole_archive
operator|&&
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|&&
name|bfd_check_format
argument_list|(
name|s
operator|->
name|input_statement
operator|.
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|=
name|false
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_symbols
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|,
operator|&
name|add
argument_list|)
condition|)
name|config
operator|.
name|make_executable
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|add
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
operator|*
name|add
operator|.
name|tail
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
name|s
operator|->
name|header
operator|.
name|next
operator|=
name|add
operator|.
name|head
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If there are [COMMONS] statements, put a wild one into the bss    section.  */
end_comment

begin_function
specifier|static
name|void
name|lang_reasonable_defaults
parameter_list|()
block|{
if|#
directive|if
literal|0
block|lang_output_section_statement_lookup (".text");   lang_output_section_statement_lookup (".data");    default_common_section = lang_output_section_statement_lookup (".bss");    if (placed_commons == false)     {       lang_wild_statement_type *new =       new_stat (lang_wild_statement,&default_common_section->children);        new->section_name = "COMMON";       new->filename = (char *) NULL;       lang_list_init (&new->children);     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Add the supplied name to the symbol table as an undefined reference.    This is a two step process as the symbol table doesn't even exist at    the time the ld command line is processed.  First we put the name    on a list, then, once the output file has been opened, transfer the    name to the symbol table.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ldlang_undef_chain_list
block|{
name|struct
name|ldlang_undef_chain_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|ldlang_undef_chain_list_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ldlang_undef_chain_list_type
modifier|*
name|ldlang_undef_chain_list_head
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ldlang_add_undef
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|new
init|=
operator|(
operator|(
name|ldlang_undef_chain_list_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ldlang_undef_chain_list_type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
name|ldlang_undef_chain_list_head
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|insert_undefined
argument_list|(
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert NAME as undefined in the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|insert_undefined
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Run through the list of undefineds created above and place them    into the linker hash table as undefined symbols belonging to the    script file.  */
end_comment

begin_function
specifier|static
name|void
name|lang_place_undefineds
parameter_list|()
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|ldlang_undef_chain_list_head
init|;
name|ptr
operator|!=
operator|(
name|ldlang_undef_chain_list_type
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|insert_undefined
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Open input files and attatch to output sections.  */
end_comment

begin_function
specifier|static
name|void
name|map_input_to_output_sections
parameter_list|(
name|s
parameter_list|,
name|target
parameter_list|,
name|output_section_statement
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
break|break;
case|case
name|lang_target_statement_enum
case|:
name|target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|output_section_statement
operator|!=
name|NULL
operator|&&
name|output_section_statement
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
if|if
condition|(
name|output_section_statement
operator|!=
name|NULL
operator|&&
name|output_section_statement
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output_section_statement
argument_list|)
expr_stmt|;
comment|/* Make sure that any sections mentioned in the assignment 	     are initialized.  */
name|exp_init_os
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
comment|/* Mark the specified section with the supplied address.  */
block|{
name|lang_output_section_statement_type
modifier|*
name|os
init|=
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|address_statement
operator|.
name|section_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|->
name|addr_tree
operator|=
name|s
operator|->
name|address_statement
operator|.
name|address
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_output_section_statement
parameter_list|(
name|output_section_statement
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
block|{
name|asection
modifier|*
name|section
init|=
name|output_section_statement
operator|->
name|bfd_section
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|output_section_statement
operator|!=
name|abs_output_section
condition|)
block|{
name|minfo
argument_list|(
literal|"\n%s"
argument_list|,
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
name|print_dot
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W"
argument_list|,
name|section
operator|->
name|vma
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_section_statement
operator|->
name|load_base
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|exp_get_abs_int
argument_list|(
name|output_section_statement
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
name|_
argument_list|(
literal|" load address 0x%V"
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|print_nl
argument_list|()
expr_stmt|;
block|}
name|print_statement_list
argument_list|(
name|output_section_statement
operator|->
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_assignment
parameter_list|(
name|assignment
parameter_list|,
name|output_section
parameter_list|)
name|lang_assignment_statement_type
modifier|*
name|assignment
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|etree_value_type
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|assignment
operator|->
name|exp
operator|->
name|assign
operator|.
name|src
argument_list|,
name|output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|print_dot
argument_list|,
operator|&
name|print_dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid_p
condition|)
name|minfo
argument_list|(
literal|"0x%V"
argument_list|,
name|result
operator|.
name|value
operator|+
name|result
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
else|else
block|{
name|minfo
argument_list|(
literal|"*undef*   "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|minfo
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|minfo
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|assignment
operator|->
name|exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_input_statement
parameter_list|(
name|statm
parameter_list|)
name|lang_input_statement_type
modifier|*
name|statm
decl_stmt|;
block|{
if|if
condition|(
name|statm
operator|->
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"LOAD %s\n"
argument_list|,
name|statm
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print all symbols defined in a particular section.  This is called    via bfd_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|print_one_symbol
parameter_list|(
name|hash_entry
parameter_list|,
name|ptr
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|hash_entry
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
operator|(
name|asection
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sec
operator|==
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V   "
argument_list|,
operator|(
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"             %T\n"
argument_list|,
name|hash_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print information about an input section to the map file.  */
end_comment

begin_function
specifier|static
name|void
name|print_input_section
parameter_list|(
name|in
parameter_list|)
name|lang_input_section_type
modifier|*
name|in
decl_stmt|;
block|{
name|asection
modifier|*
name|i
init|=
name|in
operator|->
name|section
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|i
operator|->
name|_cooked_size
else|:
name|i
operator|->
name|_raw_size
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %B\n"
argument_list|,
name|i
operator|->
name|output_section
operator|->
name|vma
operator|+
name|i
operator|->
name|output_offset
argument_list|,
name|size
operator|/
name|opb
argument_list|,
name|i
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
operator|&&
name|i
operator|->
name|_cooked_size
operator|!=
name|i
operator|->
name|_raw_size
condition|)
block|{
name|len
operator|=
name|SECTION_NAME_MAP_LENGTH
operator|+
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|len
operator|+=
literal|16
expr_stmt|;
else|#
directive|else
name|len
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
name|_
argument_list|(
literal|"%W (size before relaxing)\n"
argument_list|)
argument_list|,
name|i
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|print_one_symbol
argument_list|,
operator|(
name|PTR
operator|)
name|i
argument_list|)
expr_stmt|;
name|print_dot
operator|=
name|i
operator|->
name|output_section
operator|->
name|vma
operator|+
name|i
operator|->
name|output_offset
operator|+
name|size
operator|/
name|opb
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_fill_statement
parameter_list|(
name|fill
parameter_list|)
name|lang_fill_statement_type
modifier|*
name|fill
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" FILL mask 0x%x\n"
argument_list|,
name|fill
operator|->
name|fill
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_data_statement
parameter_list|(
name|data
parameter_list|)
name|lang_data_statement_type
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|data
operator|->
name|output_vma
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|data
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
name|name
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
name|name
operator|=
literal|"SHORT"
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
name|name
operator|=
literal|"LONG"
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
name|name
operator|=
literal|"QUAD"
expr_stmt|;
break|break;
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
name|name
operator|=
literal|"SQUAD"
expr_stmt|;
break|break;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %s 0x%v"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|name
argument_list|,
name|data
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|exp
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_value
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|exp_print_tree
argument_list|(
name|data
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|size
operator|/
name|opb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an address statement.  These are generated by options like    -Ttext.  */
end_comment

begin_function
specifier|static
name|void
name|print_address_statement
parameter_list|(
name|address
parameter_list|)
name|lang_address_statement_type
modifier|*
name|address
decl_stmt|;
block|{
name|minfo
argument_list|(
name|_
argument_list|(
literal|"Address of section %s set to "
argument_list|)
argument_list|,
name|address
operator|->
name|section_name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|address
operator|->
name|address
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a reloc statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_reloc_statement
parameter_list|(
name|reloc
parameter_list|)
name|lang_reloc_statement_type
modifier|*
name|reloc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|reloc
operator|->
name|output_vma
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|reloc
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc
operator|->
name|howto
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W RELOC %s "
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|reloc
operator|->
name|addend_exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|size
operator|/
name|opb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_padding_statement
parameter_list|(
name|s
parameter_list|)
name|lang_padding_statement_type
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
name|minfo
argument_list|(
literal|" *fill*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
expr|" *fill*"
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|addr
operator|=
name|s
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|s
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W"
argument_list|,
name|addr
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fill
operator|!=
literal|0
condition|)
name|minfo
argument_list|(
literal|" %u"
argument_list|,
name|s
operator|->
name|fill
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|s
operator|->
name|size
operator|/
name|opb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_wild_statement
parameter_list|(
name|w
parameter_list|,
name|os
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|w
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
name|struct
name|wildcard_list
modifier|*
name|sec
decl_stmt|;
name|print_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filenames_sorted
condition|)
name|minfo
argument_list|(
literal|"SORT("
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|w
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filenames_sorted
condition|)
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|w
operator|->
name|section_list
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
name|minfo
argument_list|(
literal|"SORT("
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|!=
name|NULL
condition|)
block|{
name|name_list
modifier|*
name|tmp
decl_stmt|;
name|minfo
argument_list|(
literal|"EXCLUDE_FILE ( %s"
argument_list|,
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|sec
operator|->
name|spec
operator|.
name|exclude_name_list
operator|->
name|next
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
name|minfo
argument_list|(
literal|", %s"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|sec
operator|->
name|spec
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|spec
operator|.
name|sorted
condition|)
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_statement_list
argument_list|(
name|w
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a group statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_group
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_group_statement_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"START GROUP\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|s
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"END GROUP\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the list of statements in S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement_list
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the first statement in statement list S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|_
argument_list|(
literal|"Fail with %d\n"
argument_list|)
argument_list|,
name|s
operator|->
name|header
operator|.
name|type
argument_list|)
expr_stmt|;
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
if|if
condition|(
name|constructor_list
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|constructors_sorted
condition|)
name|minfo
argument_list|(
literal|" SORT (CONSTRUCTORS)\n"
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|" CONSTRUCTORS\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|print_wild_statement
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
name|print_address_statement
argument_list|(
operator|&
name|s
operator|->
name|address_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|minfo
argument_list|(
literal|" CREATE_OBJECT_SYMBOLS\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|print_fill_statement
argument_list|(
operator|&
name|s
operator|->
name|fill_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
name|print_data_statement
argument_list|(
operator|&
name|s
operator|->
name|data_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_reloc_statement_enum
case|:
name|print_reloc_statement
argument_list|(
operator|&
name|s
operator|->
name|reloc_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
name|print_input_section
argument_list|(
operator|&
name|s
operator|->
name|input_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|print_padding_statement
argument_list|(
operator|&
name|s
operator|->
name|padding_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|print_output_section_statement
argument_list|(
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
name|print_assignment
argument_list|(
operator|&
name|s
operator|->
name|assignment_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"TARGET(%s)\n"
argument_list|,
name|s
operator|->
name|target_statement
operator|.
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
name|minfo
argument_list|(
literal|"OUTPUT(%s"
argument_list|,
name|s
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_target
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|" %s"
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
name|print_input_statement
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|print_group
argument_list|(
operator|&
name|s
operator|->
name|group_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_statements
parameter_list|()
block|{
name|print_statement_list
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the first N statements in statement list S to STDERR.    If N == 0, nothing is printed.    If N< 0, the entire list is printed.    Intended to be called from GDB.  */
end_comment

begin_function
name|void
name|dprint_statement
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|FILE
modifier|*
name|map_save
init|=
name|config
operator|.
name|map_file
decl_stmt|;
name|config
operator|.
name|map_file
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|print_statement_list
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|s
operator|&&
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
block|}
name|config
operator|.
name|map_file
operator|=
name|map_save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_pad
parameter_list|(
name|ptr
parameter_list|,
name|fill
parameter_list|,
name|alignment_needed
parameter_list|,
name|output_section
parameter_list|,
name|dot
parameter_list|)
name|lang_statement_union_type
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|unsigned
name|int
name|alignment_needed
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|pad
decl_stmt|;
name|pad
operator|=
operator|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|-
name|offsetof
argument_list|(
name|lang_statement_union_type
argument_list|,
name|header
operator|.
name|next
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|&
name|statement_list
operator|.
name|head
operator|&&
name|pad
operator|->
name|header
operator|.
name|type
operator|==
name|lang_padding_statement_enum
operator|&&
name|pad
operator|->
name|padding_statement
operator|.
name|output_section
operator|==
name|output_section
condition|)
block|{
comment|/* Use the existing pad statement.  The above test on output 	 section is probably redundant, but it doesn't hurt to check.  */
block|}
else|else
block|{
comment|/* Make a new padding statement, linked into existing chain.  */
name|pad
operator|=
operator|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_padding_statement_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|pad
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
name|pad
expr_stmt|;
name|pad
operator|->
name|header
operator|.
name|type
operator|=
name|lang_padding_statement_enum
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|output_section
operator|=
name|output_section
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|fill
operator|=
name|fill
expr_stmt|;
block|}
name|pad
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section
operator|->
name|vma
expr_stmt|;
name|pad
operator|->
name|padding_statement
operator|.
name|size
operator|=
name|alignment_needed
expr_stmt|;
name|output_section
operator|->
name|_raw_size
operator|+=
name|alignment_needed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work out how much this section will move the dot point.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|size_input_section
parameter_list|(
name|this_ptr
parameter_list|,
name|output_section_statement
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|)
name|lang_statement_union_type
modifier|*
modifier|*
name|this_ptr
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
name|lang_input_section_type
modifier|*
name|is
init|=
operator|&
operator|(
operator|(
operator|*
name|this_ptr
operator|)
operator|->
name|input_section
operator|)
decl_stmt|;
name|asection
modifier|*
name|i
init|=
name|is
operator|->
name|section
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|ifile
operator|->
name|just_syms_flag
operator|==
name|false
condition|)
block|{
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|alignment_needed
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* Align this section first to the input sections requirement, 	 then to the output section's requirement.  If this alignment 	 is greater than any seen before, then record it too.  Perform 	 the alignment by inserting a magic 'padding' statement.  */
if|if
condition|(
name|output_section_statement
operator|->
name|subsection_alignment
operator|!=
operator|-
literal|1
condition|)
name|i
operator|->
name|alignment_power
operator|=
name|output_section_statement
operator|->
name|subsection_alignment
expr_stmt|;
name|o
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|alignment_power
operator|<
name|i
operator|->
name|alignment_power
condition|)
name|o
operator|->
name|alignment_power
operator|=
name|i
operator|->
name|alignment_power
expr_stmt|;
name|alignment_needed
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|i
operator|->
name|alignment_power
argument_list|)
operator|-
name|dot
expr_stmt|;
if|if
condition|(
name|alignment_needed
operator|!=
literal|0
condition|)
block|{
name|insert_pad
argument_list|(
name|this_ptr
argument_list|,
name|fill
argument_list|,
name|alignment_needed
operator|*
name|opb
argument_list|,
name|o
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|alignment_needed
expr_stmt|;
block|}
comment|/* Remember where in the output section this input section goes.  */
name|i
operator|->
name|output_offset
operator|=
name|dot
operator|-
name|o
operator|->
name|vma
expr_stmt|;
comment|/* Mark how big the output section must be to contain this now.  */
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dot
operator|+=
name|i
operator|->
name|_cooked_size
operator|/
name|opb
expr_stmt|;
else|else
name|dot
operator|+=
name|i
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
name|o
operator|->
name|_raw_size
operator|=
operator|(
name|dot
operator|-
name|o
operator|->
name|vma
operator|)
operator|*
name|opb
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|output_offset
operator|=
name|i
operator|->
name|vma
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IGNORE_SECTION
parameter_list|(
name|bfd
parameter_list|,
name|s
parameter_list|)
define|\
value|(((bfd_get_section_flags (bfd, s)& (SEC_ALLOC | SEC_LOAD))	\     != (SEC_ALLOC | SEC_LOAD))					\    || bfd_section_size (bfd, s) == 0)
end_define

begin_comment
comment|/* Check to see if any allocated sections overlap with other allocated    sections.  This can happen when the linker script specifically specifies    the output section addresses of the two sections.  */
end_comment

begin_function
specifier|static
name|void
name|lang_check_section_addresses
parameter_list|()
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
decl_stmt|;
comment|/* Scan all sections in the output list.  */
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|os
decl_stmt|;
comment|/* Ignore sections which are not loaded or which have no contents.  */
if|if
condition|(
name|IGNORE_SECTION
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
condition|)
continue|continue;
comment|/* Once we reach section 's' stop our seach.  This prevents two 	 warning messages from being produced, one for 'section A overlaps 	 section B' and one for 'section B overlaps section A'.  */
for|for
control|(
name|os
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|os
operator|!=
name|s
condition|;
name|os
operator|=
name|os
operator|->
name|next
control|)
block|{
name|bfd_vma
name|s_start
decl_stmt|;
name|bfd_vma
name|s_end
decl_stmt|;
name|bfd_vma
name|os_start
decl_stmt|;
name|bfd_vma
name|os_end
decl_stmt|;
comment|/* Only consider loadable sections with real contents.  */
if|if
condition|(
name|IGNORE_SECTION
argument_list|(
name|output_bfd
argument_list|,
name|os
argument_list|)
condition|)
continue|continue;
comment|/* We must check the sections' LMA addresses not their 	     VMA addresses because overlay sections can have 	     overlapping VMAs but they must have distinct LMAs.  */
name|s_start
operator|=
name|bfd_section_lma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|os_start
operator|=
name|bfd_section_lma
argument_list|(
name|output_bfd
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|s_end
operator|=
name|s_start
operator|+
name|bfd_section_size
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
operator|/
name|opb
operator|-
literal|1
expr_stmt|;
name|os_end
operator|=
name|os_start
operator|+
name|bfd_section_size
argument_list|(
name|output_bfd
argument_list|,
name|os
argument_list|)
operator|/
name|opb
operator|-
literal|1
expr_stmt|;
comment|/* Look for an overlap.  */
if|if
condition|(
operator|(
name|s_end
operator|<
name|os_start
operator|)
operator|||
operator|(
name|s_start
operator|>
name|os_end
operator|)
condition|)
continue|continue;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"
argument_list|)
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s_start
argument_list|,
name|s_end
argument_list|,
name|os
operator|->
name|name
argument_list|,
name|os_start
argument_list|,
name|os_end
argument_list|)
expr_stmt|;
comment|/* Once we have found one overlap for this section, 	     stop looking for others.  */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make sure the new address is within the region.  We explicitly permit the    current address to be at the exact end of the region when the address is    non-zero, in case the region is at the end of addressable memory and the    calculation wraps around.  */
end_comment

begin_function
specifier|static
name|void
name|os_region_check
parameter_list|(
name|os
parameter_list|,
name|region
parameter_list|,
name|tree
parameter_list|,
name|base
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|struct
name|memory_region_struct
modifier|*
name|region
decl_stmt|;
name|etree_type
modifier|*
name|tree
decl_stmt|;
name|bfd_vma
name|base
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|region
operator|->
name|current
operator|<
name|region
operator|->
name|origin
operator|||
operator|(
name|region
operator|->
name|current
operator|-
name|region
operator|->
name|origin
operator|>
name|region
operator|->
name|length
operator|)
operator|)
operator|&&
operator|(
operator|(
name|region
operator|->
name|current
operator|!=
name|region
operator|->
name|origin
operator|+
name|region
operator|->
name|length
operator|)
operator|||
name|base
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|tree
operator|!=
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: address 0x%v of %B section %s is not within region %s\n"
argument_list|)
argument_list|,
name|region
operator|->
name|current
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|,
name|region
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: region %s is full (%B section %s)\n"
argument_list|)
argument_list|,
name|region
operator|->
name|name
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the region pointer.  */
name|region
operator|->
name|current
operator|=
name|region
operator|->
name|origin
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the sizes for all the output sections.  */
end_comment

begin_function
name|bfd_vma
name|lang_size_sections
parameter_list|(
name|s
parameter_list|,
name|output_section_statement
parameter_list|,
name|prev
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|,
name|relax
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|prev
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|boolean
modifier|*
name|relax
decl_stmt|;
block|{
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
comment|/* Size up the sections from their constituent parts.  */
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|bfd_vma
name|after
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|&
name|s
operator|->
name|output_section_statement
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
comment|/* This section was never actually created.  */
break|break;
comment|/* If this is a COFF shared library section, use the size and 	       address from the input section.  FIXME: This is COFF 	       specific; it would be cleaner if there were some other way 	       to do this, but nothing simple comes to mind.  */
if|if
condition|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|input
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|children
operator|.
name|head
operator|==
name|NULL
operator|||
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|header
operator|.
name|next
operator|!=
name|NULL
operator|||
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|header
operator|.
name|type
operator|!=
name|lang_input_section_enum
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: Internal error on COFF shared library section %s\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
name|input
operator|=
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|bfd_section_vma
argument_list|(
name|input
operator|->
name|owner
argument_list|,
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|=
name|input
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
condition|)
block|{
comment|/* No matter what happens, an abs section starts at zero.  */
name|ASSERT
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No address specified for this section, get one 		       from the region specification.  */
if|if
condition|(
name|os
operator|->
name|region
operator|==
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
operator|||
operator|(
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|os
operator|->
name|region
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|strcmp
argument_list|(
name|os
operator|->
name|region
operator|->
name|name
argument_list|,
literal|"*default*"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|os
operator|->
name|region
operator|=
name|lang_memory_default
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
block|}
comment|/* If a loadable section is using the default memory 		       region, and some non default memory regions were 		       defined, issue a warning.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|link_info
operator|.
name|relocateable
operator|&&
name|strcmp
argument_list|(
name|os
operator|->
name|region
operator|->
name|name
argument_list|,
literal|"*default*"
argument_list|)
operator|==
literal|0
operator|&&
name|lang_memory_region_list
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|lang_memory_region_list
operator|->
name|name
argument_list|,
literal|"*default*"
argument_list|)
operator|!=
literal|0
operator|||
name|lang_memory_region_list
operator|->
name|next
operator|!=
name|NULL
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: no memory region specified for section `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
argument_list|)
expr_stmt|;
name|dot
operator|=
name|os
operator|->
name|region
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|section_alignment
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|olddot
decl_stmt|;
name|olddot
operator|=
name|dot
expr_stmt|;
name|dot
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|olddot
operator|&&
name|config
operator|.
name|warn_section_align
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: changing start of section %s by %u bytes\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|dot
operator|-
name|olddot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|etree_value_type
name|r
decl_stmt|;
name|r
operator|=
name|exp_fold_tree
argument_list|(
name|os
operator|->
name|addr_tree
argument_list|,
name|abs_output_section
argument_list|,
name|lang_allocating_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid_p
operator|==
name|false
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%S: non constant address expression for section %s\n"
argument_list|)
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|r
operator|.
name|value
operator|+
name|r
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* The section starts here. 		   First, align to what the section needs.  */
if|if
condition|(
name|os
operator|->
name|section_alignment
operator|!=
operator|-
literal|1
condition|)
name|dot
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|os
operator|->
name|section_alignment
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
literal|0
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
name|lang_size_sections
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
operator|&
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
comment|/* Put the section within the requested block size, or 	       align at the block boundary.  */
name|after
operator|=
name|ALIGN_N
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|/
name|opb
argument_list|,
comment|/* The coercion here is important, see ld.h.  */
operator|(
name|bfd_vma
operator|)
name|os
operator|->
name|block_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|after
operator|==
name|os
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
else|else
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|=
operator|(
name|after
operator|-
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|)
operator|*
name|opb
expr_stmt|;
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
name|os
operator|->
name|processed
operator|=
name|true
expr_stmt|;
comment|/* Update dot in the region ? 	       We only do this if the section is going to be allocated, 	       since unallocated sections do not contribute to the region's 	       overall size in memory.  	       If the SEC_NEVER_LOAD bit is not set, it will affect the 	       addresses of sections after it. We have to update 	       dot.  */
if|if
condition|(
name|os
operator|->
name|region
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
operator|&&
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
operator|&
name|SEC_NEVER_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|)
condition|)
block|{
name|os
operator|->
name|region
operator|->
name|current
operator|=
name|dot
expr_stmt|;
comment|/* Make sure the new address is within the region.  */
name|os_region_check
argument_list|(
name|os
argument_list|,
name|os
operator|->
name|region
argument_list|,
name|os
operator|->
name|addr_tree
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
comment|/* If there's no load address specified, use the run 		   region as the load region.  */
if|if
condition|(
name|os
operator|->
name|lma_region
operator|==
name|NULL
operator|&&
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|os
operator|->
name|lma_region
operator|=
name|os
operator|->
name|region
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|lma_region
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|load_base
operator|!=
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: use an absolute load address or a load memory region, not both\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't allocate twice.  */
if|if
condition|(
name|os
operator|->
name|lma_region
operator|!=
name|os
operator|->
name|region
condition|)
block|{
comment|/* Set load_base, which will be handled later.  */
name|os
operator|->
name|load_base
operator|=
name|exp_intop
argument_list|(
name|os
operator|->
name|lma_region
operator|->
name|current
argument_list|)
expr_stmt|;
name|os
operator|->
name|lma_region
operator|->
name|current
operator|+=
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
name|os_region_check
argument_list|(
name|os
argument_list|,
name|os
operator|->
name|lma_region
argument_list|,
name|NULL
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|lma
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_vma
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|<
name|opb
condition|)
name|size
operator|=
name|opb
expr_stmt|;
name|dot
operator|+=
name|size
operator|/
name|opb
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
comment|/* The output section gets contents, and then we inspect for 	       any flags set in the input script which override any ALLOC.  */
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|output_section_statement
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
condition|)
block|{
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|int
name|size
decl_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_vma
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|size
operator|/
name|opb
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|link_info
operator|.
name|create_object_symbols_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|i
decl_stmt|;
name|i
operator|=
operator|(
operator|*
name|prev
operator|)
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|relax
condition|)
block|{
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|i
operator|->
name|_cooked_size
operator|=
name|i
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|again
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_relax_section
argument_list|(
name|i
operator|->
name|owner
argument_list|,
name|i
argument_list|,
operator|&
name|link_info
argument_list|,
operator|&
name|again
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't relax section: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
operator|*
name|relax
operator|=
name|true
expr_stmt|;
block|}
name|dot
operator|=
name|size_input_section
argument_list|(
name|prev
argument_list|,
name|output_section_statement
argument_list|,
name|output_section_statement
operator|->
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|s
operator|->
name|fill_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
block|{
name|bfd_vma
name|newdot
init|=
name|dot
decl_stmt|;
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
argument_list|,
name|lang_allocating_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|newdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdot
operator|!=
name|dot
condition|)
block|{
if|if
condition|(
name|output_section_statement
operator|==
name|abs_output_section
condition|)
block|{
comment|/* If we don't have an output section, then just adjust 		       the default memory address.  */
name|lang_memory_region_lookup
argument_list|(
literal|"*default*"
argument_list|)
operator|->
name|current
operator|=
name|newdot
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert a pad after this statement.  We can't 		       put the pad before when relaxing, in case the 		       assignment references dot.  */
name|insert_pad
argument_list|(
operator|&
name|s
operator|->
name|header
operator|.
name|next
argument_list|,
name|fill
argument_list|,
operator|(
name|newdot
operator|-
name|dot
operator|)
operator|*
name|opb
argument_list|,
name|output_section_statement
operator|->
name|bfd_section
argument_list|,
name|dot
argument_list|)
expr_stmt|;
comment|/* Don't neuter the pad below when relaxing.  */
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
name|dot
operator|=
name|newdot
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
comment|/* If this is the first time lang_size_sections is called, 	     we won't have any padding statements.  If this is the 	     second or later passes when relaxing, we should allow 	     padding to shrink.  If padding is needed on this pass, it 	     will be added back in.  */
name|s
operator|->
name|padding_statement
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Make sure output_offset is valid.  If relaxation shrinks 	     the section and this pad isn't needed, it's possible to 	     have output_offset larger than the final size of the 	     section.  bfd_set_section_contents will complain even for 	     a pad size of zero.  */
name|s
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
comment|/* We can only get here when relaxing is turned on.  */
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
name|prev
operator|=
operator|&
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_function
name|bfd_vma
name|lang_do_assignments
parameter_list|(
name|s
parameter_list|,
name|output_section_statement
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
operator|&
operator|(
name|s
operator|->
name|output_section_statement
operator|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
operator|(
name|void
operator|)
name|lang_do_assignments
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|load_base
condition|)
block|{
comment|/* If nothing has been placed into the output section then 		   it won't have a bfd_section.  */
if|if
condition|(
name|os
operator|->
name|bfd_section
condition|)
block|{
name|os
operator|->
name|bfd_section
operator|->
name|lma
operator|=
name|exp_get_abs_int
argument_list|(
name|os
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
if|#
directive|if
literal|0
block|case lang_common_statement_enum:
endif|#
directive|endif
break|break;
case|case
name|lang_data_statement_enum
case|:
block|{
name|etree_value_type
name|value
decl_stmt|;
name|value
operator|=
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|data_statement
operator|.
name|exp
argument_list|,
name|abs_output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|value
operator|=
name|value
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|valid_p
operator|==
name|false
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid data statement\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|unsigned
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|QUAD
case|:
case|case
name|SQUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|size
operator|<
name|opb
condition|)
name|size
operator|=
name|opb
expr_stmt|;
name|dot
operator|+=
name|size
operator|/
name|opb
expr_stmt|;
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|etree_value_type
name|value
decl_stmt|;
name|value
operator|=
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|addend_exp
argument_list|,
name|abs_output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|addend_value
operator|=
name|value
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|valid_p
operator|==
name|false
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid reloc statement\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dot
operator|+=
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
operator|/
name|opb
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|in
init|=
name|s
operator|->
name|input_section
operator|.
name|section
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dot
operator|+=
name|in
operator|->
name|_cooked_size
operator|/
name|opb
expr_stmt|;
else|else
name|dot
operator|+=
name|in
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
block|{
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|dot
operator|+=
name|s
operator|->
name|padding_statement
operator|.
name|size
operator|/
name|opb
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
block|}
return|return
name|dot
return|;
block|}
end_function

begin_comment
comment|/* Fix any .startof. or .sizeof. symbols.  When the assemblers see the    operator .startof. (section_name), it produces an undefined symbol    .startof.section_name.  Similarly, when it sees    .sizeof. (section_name), it produces an undefined symbol    .sizeof.section_name.  For all the output sections, we look for    such symbols, and set them to the correct value.  */
end_comment

begin_function
specifier|static
name|void
name|lang_set_startof
parameter_list|()
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
return|return;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|secname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|unsigned
name|opb
decl_stmt|;
name|opb
operator|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_cooked_size
operator|/
name|opb
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|opb
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lang_finish
parameter_list|()
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|warn
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
operator|||
name|link_info
operator|.
name|shared
condition|)
name|warn
operator|=
name|false
expr_stmt|;
else|else
name|warn
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|entry_symbol
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No entry has been specified.  Look for start, but don't warn 	 if we don't find it.  */
name|entry_symbol
operator|=
literal|"start"
expr_stmt|;
name|warn
operator|=
name|false
expr_stmt|;
block|}
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|entry_symbol
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F:%s: can't set start address\n"
argument_list|)
argument_list|,
name|entry_symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|send
decl_stmt|;
comment|/* We couldn't find the entry symbol.  Try parsing it as a          number.  */
name|val
operator|=
name|bfd_scan_vma
argument_list|(
name|entry_symbol
argument_list|,
operator|&
name|send
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|send
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't set start address\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|ts
decl_stmt|;
comment|/* Can't find the entry symbol, and it's not a number.  Use 	     the first address in the text section.  */
name|ts
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|entry_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: cannot find entry symbol %s; defaulting to %V\n"
argument_list|)
argument_list|,
name|entry_symbol
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: can't set start address\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: cannot find entry symbol %s; not setting start address\n"
argument_list|)
argument_list|,
name|entry_symbol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is a small function used when we want to ignore errors from    BFD.  */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|ignore_bfd_errors
parameter_list|(
specifier|const
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|ignore_bfd_errors
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* Don't do anything.  */
block|}
end_function

begin_comment
comment|/* Check that the architecture of all the input files is compatible    with the output file.  Also call the backend to let it do any    other checking that is needed.  */
end_comment

begin_function
specifier|static
name|void
name|lang_check
parameter_list|()
block|{
name|lang_statement_union_type
modifier|*
name|file
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|compatible
decl_stmt|;
for|for
control|(
name|file
operator|=
name|file_chain
operator|.
name|head
init|;
name|file
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|input_statement
operator|.
name|next
control|)
block|{
name|input_bfd
operator|=
name|file
operator|->
name|input_statement
operator|.
name|the_bfd
expr_stmt|;
name|compatible
operator|=
name|bfd_arch_get_compatible
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* In general it is not possible to perform a relocatable 	 link between differing object formats when the input 	 file has relocations, because the relocations in the 	 input format may not have equivalent representations in 	 the output format (and besides BFD does not translate 	 relocs for other link purposes than a final link).  */
if|if
condition|(
operator|(
name|link_info
operator|.
name|relocateable
operator|||
name|link_info
operator|.
name|emitrelocations
operator|)
operator|&&
operator|(
name|compatible
operator|==
name|NULL
operator|||
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|)
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|input_bfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* einfo with %F exits.  */
block|}
if|if
condition|(
name|compatible
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|warn_mismatch
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"
argument_list|)
argument_list|,
name|bfd_printable_name
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* If the input bfd has no contents, it shouldn't set the 	     private data of the output bfd. */
name|bfd_error_handler_type
name|pfn
init|=
name|NULL
decl_stmt|;
comment|/* If we aren't supposed to warn about mismatched input              files, temporarily set the BFD error handler to a              function which will do nothing.  We still want to call              bfd_merge_private_bfd_data, since it may set up              information which is needed in the output file.  */
if|if
condition|(
operator|!
name|command_line
operator|.
name|warn_mismatch
condition|)
name|pfn
operator|=
name|bfd_set_error_handler
argument_list|(
name|ignore_bfd_errors
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_merge_private_bfd_data
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|warn_mismatch
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%E%X: failed to merge target specific data of file %B\n"
argument_list|)
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|command_line
operator|.
name|warn_mismatch
condition|)
name|bfd_set_error_handler
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look through all the global common symbols and attach them to the    correct section.  The -sort-common command line switch may be used    to roughly sort the entries by size.  */
end_comment

begin_function
specifier|static
name|void
name|lang_common
parameter_list|()
block|{
if|if
condition|(
name|command_line
operator|.
name|inhibit_common_definition
condition|)
return|return;
if|if
condition|(
name|link_info
operator|.
name|relocateable
operator|&&
operator|!
name|command_line
operator|.
name|force_common_definition
condition|)
return|return;
if|if
condition|(
operator|!
name|config
operator|.
name|sort_common
condition|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|power
decl_stmt|;
for|for
control|(
name|power
operator|=
literal|4
init|;
name|power
operator|>=
literal|0
condition|;
name|power
operator|--
control|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|power
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Place one common symbol in the correct section.  */
end_comment

begin_function
specifier|static
name|boolean
name|lang_one_common
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|info
decl_stmt|;
block|{
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|opb
init|=
name|bfd_arch_mach_octets_per_byte
argument_list|(
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
return|return
name|true
return|;
name|size
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
name|power_of_two
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|sort_common
operator|&&
name|power_of_two
operator|<
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|info
condition|)
return|return
name|true
return|;
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
comment|/* Increase the size of the section.  */
name|section
operator|->
name|_cooked_size
operator|=
name|ALIGN_N
argument_list|(
operator|(
name|section
operator|->
name|_cooked_size
operator|+
name|opb
operator|-
literal|1
operator|)
operator|/
name|opb
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
operator|*
name|opb
expr_stmt|;
comment|/* Adjust the alignment if necessary.  */
if|if
condition|(
name|power_of_two
operator|>
name|section
operator|->
name|alignment_power
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|power_of_two
expr_stmt|;
comment|/* Change the symbol from common to defined.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|section
operator|->
name|_cooked_size
expr_stmt|;
comment|/* Increase the size of the section.  */
name|section
operator|->
name|_cooked_size
operator|+=
name|size
expr_stmt|;
comment|/* Make sure the section is allocated in memory, and make sure that      it is no longer a common section.  */
name|section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|boolean
name|header_printed
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nAllocating common symbols\n"
argument_list|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
name|_
argument_list|(
literal|"Common symbol       size              file\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|true
expr_stmt|;
block|}
name|name
operator|=
name|demangle
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|19
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|20
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0xffffffff
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%B\n"
argument_list|,
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Run through the input files and ensure that every input section has    somewhere to go.  If one is found without a destination then create    an input request and place it into the statement tree.  */
end_comment

begin_function
specifier|static
name|void
name|lang_place_orphans
parameter_list|()
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|file
argument_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This section of the file is not attatched, root 	         around for a sensible place for it to go.  */
if|if
condition|(
name|file
operator|->
name|just_syms_flag
condition|)
block|{
comment|/* We are only retrieving symbol values from this                      file.  We want the symbols to act as though the                      values in the file are absolute.  */
name|s
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|s
operator|->
name|output_offset
operator|=
name|s
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a lonely common section which must have 		     come from an archive.  We attach to the section 		     with the wildcard.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|||
name|command_line
operator|.
name|force_common_definition
condition|)
block|{
if|if
condition|(
name|default_common_section
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This message happens when using the                              svr3.ifile linker script, so I have                              disabled it.  */
block|info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
endif|#
directive|endif
name|default_common_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
literal|".bss"
argument_list|)
expr_stmt|;
block|}
name|lang_add_section
argument_list|(
operator|&
name|default_common_section
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|default_common_section
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ldemul_place_orphan
argument_list|(
name|file
argument_list|,
name|s
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|lang_add_section
argument_list|(
operator|&
name|os
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|os
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|lang_set_flags
parameter_list|(
name|ptr
parameter_list|,
name|flags
parameter_list|,
name|invert
parameter_list|)
name|lang_memory_region_type
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|flags
decl_stmt|;
name|int
name|invert
decl_stmt|;
block|{
name|flagword
modifier|*
name|ptr_flags
decl_stmt|;
name|ptr_flags
operator|=
name|invert
condition|?
operator|&
name|ptr
operator|->
name|not_flags
else|:
operator|&
name|ptr
operator|->
name|flags
expr_stmt|;
while|while
condition|(
operator|*
name|flags
condition|)
block|{
switch|switch
condition|(
operator|*
name|flags
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_READONLY
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
operator|*
name|ptr_flags
operator||=
name|SEC_LOAD
expr_stmt|;
break|break;
default|default:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid syntax in flags\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call a function on each input file.  This function will be called    on an archive, but not on the elements.  */
end_comment

begin_function_decl
name|void
name|lang_for_each_input_file
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next_real_file
control|)
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call a function on each file.  The function will be called on all    the elements of an archive which are included in the link, but will    not be called on the archive file itself.  */
end_comment

begin_function_decl
name|void
name|lang_for_each_file
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|f
argument_list|)
block|{
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used.  */
end_comment

begin_endif
unit|void lang_for_each_input_section (func)      void (*func) PARAMS ((bfd *ab, asection *as)); {   LANG_FOR_EACH_INPUT_STATEMENT (f)     {       asection *s;        for (s = f->the_bfd->sections; 	   s != (asection *) NULL; 	   s = s->next) 	{ 	  func (f->the_bfd, s); 	}     } }
endif|#
directive|endif
end_endif

begin_function
name|void
name|ldlang_add_file
parameter_list|(
name|entry
parameter_list|)
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
block|{
name|bfd
modifier|*
modifier|*
name|pp
decl_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* The BFD linker needs to have a list of all input BFDs involved in      a link.  */
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|->
name|link_next
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|!=
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|link_info
operator|.
name|input_bfds
init|;
operator|*
name|pp
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|link_next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|entry
operator|->
name|the_bfd
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|->
name|usrdata
operator|=
operator|(
name|PTR
operator|)
name|entry
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
comment|/* Look through the sections and check for any which should not be      included in the link.  We need to do this now, so that we can      notice when the backend linker tries to report multiple      definition errors for symbols which are in sections we aren't      going to link.  FIXME: It might be better to entirely ignore      symbols which are defined in sections which are going to be      discarded.  This would require modifying the backend linker for      each backend which might set the SEC_LINK_ONCE flag.  If we do      this, we should probably handle SEC_EXCLUDE in the same way.  */
name|bfd_map_over_sections
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|section_already_linked
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_output
parameter_list|(
name|name
parameter_list|,
name|from_script
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_script
decl_stmt|;
block|{
comment|/* Make -o on command line override OUTPUT in script.  */
if|if
condition|(
name|had_output_filename
operator|==
name|false
operator|||
operator|!
name|from_script
condition|)
block|{
name|output_filename
operator|=
name|name
expr_stmt|;
name|had_output_filename
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|topower
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
literal|32
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|x
condition|)
return|return
name|l
return|;
name|i
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_enter_output_section_statement
parameter_list|(
name|output_section_statement_name
parameter_list|,
name|address_exp
parameter_list|,
name|sectype
parameter_list|,
name|block_value
parameter_list|,
name|align
parameter_list|,
name|subalign
parameter_list|,
name|ebase
parameter_list|)
specifier|const
name|char
modifier|*
name|output_section_statement_name
decl_stmt|;
name|etree_type
modifier|*
name|address_exp
decl_stmt|;
name|enum
name|section_type
name|sectype
decl_stmt|;
name|bfd_vma
name|block_value
decl_stmt|;
name|etree_type
modifier|*
name|align
decl_stmt|;
name|etree_type
modifier|*
name|subalign
decl_stmt|;
name|etree_type
modifier|*
name|ebase
decl_stmt|;
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|current_section
operator|=
name|os
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|output_section_statement_name
argument_list|)
expr_stmt|;
comment|/* Add this statement to tree.  */
if|#
directive|if
literal|0
block|add_statement (lang_output_section_statement_enum, 		 output_section_statement);
endif|#
directive|endif
comment|/* Make next things chain into subchain of this.  */
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|os
operator|->
name|addr_tree
operator|=
name|address_exp
expr_stmt|;
block|}
name|os
operator|->
name|sectype
operator|=
name|sectype
expr_stmt|;
if|if
condition|(
name|sectype
operator|!=
name|noload_section
condition|)
name|os
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
else|else
name|os
operator|->
name|flags
operator|=
name|SEC_NEVER_LOAD
expr_stmt|;
name|os
operator|->
name|block_value
operator|=
name|block_value
condition|?
name|block_value
else|:
literal|1
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|os
operator|->
name|children
expr_stmt|;
name|os
operator|->
name|subsection_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|subalign
argument_list|,
operator|-
literal|1
argument_list|,
literal|"subsection alignment"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|section_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|align
argument_list|,
operator|-
literal|1
argument_list|,
literal|"section alignment"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|load_base
operator|=
name|ebase
expr_stmt|;
return|return
name|os
return|;
block|}
end_function

begin_function
name|void
name|lang_final
parameter_list|()
block|{
name|lang_output_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_output_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|output_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the current counters in the regions.  */
end_comment

begin_function
name|void
name|lang_reset_memory_regions
parameter_list|()
block|{
name|lang_memory_region_type
modifier|*
name|p
init|=
name|lang_memory_region_list
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|old_length
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|->
name|current
operator|-
name|p
operator|->
name|origin
argument_list|)
expr_stmt|;
name|p
operator|->
name|current
operator|=
name|p
operator|->
name|origin
expr_stmt|;
block|}
for|for
control|(
name|o
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
name|o
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the wild pattern was marked KEEP, the member sections    should be as well.  */
end_comment

begin_function
specifier|static
name|void
name|gc_section_callback
parameter_list|(
name|ptr
parameter_list|,
name|sec
parameter_list|,
name|section
parameter_list|,
name|file
parameter_list|,
name|data
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|ptr
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|->
name|keep_sections
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a wild statement, marking it against GC.  */
end_comment

begin_function
specifier|static
name|void
name|lang_gc_wild
parameter_list|(
name|s
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
block|{
name|walk_wild
argument_list|(
name|s
argument_list|,
name|gc_section_callback
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Iterate over sections marking them against GC.  */
end_comment

begin_function
specifier|static
name|void
name|lang_gc_sections_1
parameter_list|(
name|s
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|header
operator|.
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|lang_gc_wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|lang_gc_sections_1
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lang_gc_sections
parameter_list|()
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|ldlang_undef_chain_list_type
modifier|*
name|ulist
decl_stmt|,
name|fake_list_start
decl_stmt|;
comment|/* Keep all sections so marked in the link script.  */
name|lang_gc_sections_1
argument_list|(
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* Keep all sections containing symbols undefined on the command-line.      Handle the entry symbol at the same time.  */
if|if
condition|(
name|entry_symbol
operator|!=
name|NULL
condition|)
block|{
name|fake_list_start
operator|.
name|next
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
name|fake_list_start
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|entry_symbol
expr_stmt|;
name|ulist
operator|=
operator|&
name|fake_list_start
expr_stmt|;
block|}
else|else
name|ulist
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
for|for
control|(
init|;
name|ulist
condition|;
name|ulist
operator|=
name|ulist
operator|->
name|next
control|)
block|{
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|ulist
operator|->
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
block|}
block|}
name|bfd_gc_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_process
parameter_list|()
block|{
name|lang_reasonable_defaults
argument_list|()
expr_stmt|;
name|current_target
operator|=
name|default_target
expr_stmt|;
comment|/* Open the output file.  */
name|lang_for_each_statement
argument_list|(
name|ldlang_open_output
argument_list|)
expr_stmt|;
name|ldemul_create_output_section_statements
argument_list|()
expr_stmt|;
comment|/* Add to the hash table all undefineds on the command line.  */
name|lang_place_undefineds
argument_list|()
expr_stmt|;
name|already_linked_table_init
argument_list|()
expr_stmt|;
comment|/* Create a bfd for each input file.  */
name|current_target
operator|=
name|default_target
expr_stmt|;
name|open_input_bfds
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ldemul_after_open
argument_list|()
expr_stmt|;
name|already_linked_table_free
argument_list|()
expr_stmt|;
comment|/* Make sure that we're not mixing architectures.  We call this      after all the input files have been opened, but before we do any      other processing, so that any operations merge_private_bfd_data      does on the output file will be known during the rest of the      link.  */
name|lang_check
argument_list|()
expr_stmt|;
comment|/* Handle .exports instead of a version script if we're told to do so.  */
if|if
condition|(
name|command_line
operator|.
name|version_exports_section
condition|)
name|lang_do_version_exports_section
argument_list|()
expr_stmt|;
comment|/* Build all sets based on the information gathered from the input      files.  */
name|ldctor_build_sets
argument_list|()
expr_stmt|;
comment|/* Remove unreferenced sections if asked to.  */
if|if
condition|(
name|command_line
operator|.
name|gc_sections
condition|)
name|lang_gc_sections
argument_list|()
expr_stmt|;
comment|/* If there were any SEC_MERGE sections, finish their merging, so that      section sizes can be computed.  This has to be done after GC of sections,      so that GCed sections are not merged, but before assigning output      sections, since removing whole input sections is hard then.  */
name|bfd_merge_sections
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
comment|/* Size up the common data.  */
name|lang_common
argument_list|()
expr_stmt|;
comment|/* Run through the contours of the script and attach input sections      to the correct output sections.  */
name|map_input_to_output_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find any sections not attached explicitly and handle them.  */
name|lang_place_orphans
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
condition|)
block|{
comment|/* Look for a text section and set the readonly attribute in it.  */
name|asection
modifier|*
name|found
init|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".text"
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|config
operator|.
name|text_read_only
condition|)
name|found
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
else|else
name|found
operator|->
name|flags
operator|&=
operator|~
name|SEC_READONLY
expr_stmt|;
block|}
block|}
comment|/* Do anything special before sizing sections.  This is where ELF      and other back-ends size dynamic sections.  */
name|ldemul_before_allocation
argument_list|()
expr_stmt|;
comment|/* We must record the program headers before we try to fix the      section positions, since they will affect SIZEOF_HEADERS.  */
name|lang_record_phdrs
argument_list|()
expr_stmt|;
comment|/* Size up the sections.  */
name|lang_size_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
name|statement_list
operator|.
name|head
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now run around and relax if we can.  */
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
block|{
comment|/* Keep relaxing until bfd_relax_section gives up.  */
name|boolean
name|relax_again
decl_stmt|;
do|do
block|{
name|lang_reset_memory_regions
argument_list|()
expr_stmt|;
name|relax_again
operator|=
name|false
expr_stmt|;
comment|/* Note: pe-dll.c does something like this also.  If you find 	     you need to change this code, you probably need to change 	     pe-dll.c also.  DJ  */
comment|/* Do all the assignments with our current guesses as to 	     section sizes.  */
name|lang_do_assignments
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform another relax pass - this time we know where the 	     globals are, so can make better guess.  */
name|lang_size_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
operator|(
name|statement_list
operator|.
name|head
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|&
name|relax_again
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|relax_again
condition|)
do|;
block|}
comment|/* See if anything special should be done now we know how big      everything is.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Fix any .startof. or .sizeof. symbols.  */
name|lang_set_startof
argument_list|()
expr_stmt|;
comment|/* Do all the assignments, now that we know the final resting places      of all the symbols.  */
name|lang_do_assignments
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that the section addresses make sense.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|&&
name|command_line
operator|.
name|check_section_addresses
condition|)
name|lang_check_section_addresses
argument_list|()
expr_stmt|;
comment|/* Final stuffs.  */
name|ldemul_finish
argument_list|()
expr_stmt|;
name|lang_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXPORTED TO YACC */
end_comment

begin_function
name|void
name|lang_add_wild
parameter_list|(
name|filespec
parameter_list|,
name|section_list
parameter_list|,
name|keep_sections
parameter_list|)
name|struct
name|wildcard_spec
modifier|*
name|filespec
decl_stmt|;
name|struct
name|wildcard_list
modifier|*
name|section_list
decl_stmt|;
name|boolean
name|keep_sections
decl_stmt|;
block|{
name|struct
name|wildcard_list
modifier|*
name|curr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|lang_wild_statement_type
modifier|*
name|new
decl_stmt|;
comment|/* Reverse the list as the parser puts it back to front.  */
for|for
control|(
name|curr
operator|=
name|section_list
operator|,
name|section_list
operator|=
name|NULL
init|;
name|curr
operator|!=
name|NULL
condition|;
name|section_list
operator|=
name|curr
operator|,
name|curr
operator|=
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|spec
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|curr
operator|->
name|spec
operator|.
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
name|placed_commons
operator|=
name|true
expr_stmt|;
name|next
operator|=
name|curr
operator|->
name|next
expr_stmt|;
name|curr
operator|->
name|next
operator|=
name|section_list
expr_stmt|;
block|}
if|if
condition|(
name|filespec
operator|!=
name|NULL
operator|&&
name|filespec
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|filespec
operator|->
name|name
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|filespec
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wildcardp
argument_list|(
name|filespec
operator|->
name|name
argument_list|)
condition|)
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
block|}
name|new
operator|=
name|new_stat
argument_list|(
name|lang_wild_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|filenames_sorted
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|filespec
operator|!=
name|NULL
condition|)
block|{
name|new
operator|->
name|filename
operator|=
name|filespec
operator|->
name|name
expr_stmt|;
name|new
operator|->
name|filenames_sorted
operator|=
name|filespec
operator|->
name|sorted
expr_stmt|;
block|}
name|new
operator|->
name|section_list
operator|=
name|section_list
expr_stmt|;
name|new
operator|->
name|keep_sections
operator|=
name|keep_sections
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|new
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_section_start
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|etree_type
modifier|*
name|address
decl_stmt|;
block|{
name|lang_address_statement_type
modifier|*
name|ad
decl_stmt|;
name|ad
operator|=
name|new_stat
argument_list|(
name|lang_address_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|ad
operator|->
name|section_name
operator|=
name|name
expr_stmt|;
name|ad
operator|->
name|address
operator|=
name|address
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the start symbol to NAME.  CMDLINE is nonzero if this is called    because of a -e argument on the command line, or zero if this is    called by ENTRY in a linker script.  Command line arguments take    precedence.  */
end_comment

begin_function
name|void
name|lang_add_entry
parameter_list|(
name|name
parameter_list|,
name|cmdline
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|cmdline
decl_stmt|;
block|{
if|if
condition|(
name|entry_symbol
operator|==
name|NULL
operator|||
name|cmdline
operator|||
operator|!
name|entry_from_cmdline
condition|)
block|{
name|entry_symbol
operator|=
name|name
expr_stmt|;
name|entry_from_cmdline
operator|=
name|cmdline
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_add_target
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|lang_target_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_target_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|target
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_map
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|name
condition|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'F'
case|:
name|map_option_f
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|name
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_add_fill
parameter_list|(
name|exp
parameter_list|)
name|int
name|exp
decl_stmt|;
block|{
name|lang_fill_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_fill_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|fill
operator|=
name|exp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_data
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|)
name|int
name|type
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
block|{
name|lang_data_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_data_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new reloc statement.  RELOC is the BFD relocation type to    generate.  HOWTO is the corresponding howto structure (we could    look this up, but the caller has already done so).  SECTION is the    section to generate a reloc against, or NAME is the name of the    symbol to generate a reloc against.  Exactly one of SECTION and    NAME must be NULL.  ADDEND is an expression for the addend.  */
end_comment

begin_function
name|void
name|lang_add_reloc
parameter_list|(
name|reloc
parameter_list|,
name|howto
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|addend
parameter_list|)
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|union
name|etree_union
modifier|*
name|addend
decl_stmt|;
block|{
name|lang_reloc_statement_type
modifier|*
name|p
init|=
name|new_stat
argument_list|(
name|lang_reloc_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|addend_exp
operator|=
name|addend
expr_stmt|;
name|p
operator|->
name|addend_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|output_vma
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|lang_assignment_statement_type
modifier|*
name|lang_add_assignment
parameter_list|(
name|exp
parameter_list|)
name|etree_type
modifier|*
name|exp
decl_stmt|;
block|{
name|lang_assignment_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_assignment_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|void
name|lang_add_attribute
parameter_list|(
name|attribute
parameter_list|)
name|enum
name|statement_enum
name|attribute
decl_stmt|;
block|{
name|new_statement
argument_list|(
name|attribute
argument_list|,
sizeof|sizeof
argument_list|(
name|lang_statement_union_type
argument_list|)
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_startup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|startup_file
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%Fmultiple STARTUP files\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first_file
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|startup_file
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_float
parameter_list|(
name|maybe
parameter_list|)
name|boolean
name|maybe
decl_stmt|;
block|{
name|lang_float_flag
operator|=
name|maybe
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_leave_output_section_statement
parameter_list|(
name|fill
parameter_list|,
name|memspec
parameter_list|,
name|phdrs
parameter_list|,
name|lma_memspec
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
specifier|const
name|char
modifier|*
name|memspec
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|lma_memspec
decl_stmt|;
block|{
name|current_section
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
name|current_section
operator|->
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|memspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lma_memspec
argument_list|,
literal|"*default*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|current_section
operator|->
name|lma_region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|lma_memspec
argument_list|)
expr_stmt|;
comment|/* If no runtime region has been given, but the load region has          been, use the load region.  */
if|if
condition|(
name|strcmp
argument_list|(
name|memspec
argument_list|,
literal|"*default*"
argument_list|)
operator|==
literal|0
condition|)
name|current_section
operator|->
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|lma_memspec
argument_list|)
expr_stmt|;
block|}
name|current_section
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an absolute symbol with the given name with the value of the    address of first byte of the section named.     If the symbol already exists, then do nothing.  */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_beginning_of
parameter_list|(
name|secname
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create an absolute symbol with the given name with the value of the    address of the first byte after the end of the section named.     If the symbol already exists, then do nothing.  */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_end_of
parameter_list|(
name|secname
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
operator|/
name|bfd_octets_per_byte
argument_list|(
name|output_bfd
argument_list|)
operator|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_statement_append
parameter_list|(
name|list
parameter_list|,
name|element
parameter_list|,
name|field
parameter_list|)
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|element
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|field
decl_stmt|;
block|{
operator|*
operator|(
name|list
operator|->
name|tail
operator|)
operator|=
name|element
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output format type.  -oformat overrides scripts.  */
end_comment

begin_function
name|void
name|lang_add_output_format
parameter_list|(
name|format
parameter_list|,
name|big
parameter_list|,
name|little
parameter_list|,
name|from_script
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
name|big
decl_stmt|;
specifier|const
name|char
modifier|*
name|little
decl_stmt|;
name|int
name|from_script
decl_stmt|;
block|{
if|if
condition|(
name|output_target
operator|==
name|NULL
operator|||
operator|!
name|from_script
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
operator|&&
name|big
operator|!=
name|NULL
condition|)
name|format
operator|=
name|big
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
operator|&&
name|little
operator|!=
name|NULL
condition|)
name|format
operator|=
name|little
expr_stmt|;
name|output_target
operator|=
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter a group.  This creates a new lang_group_statement, and sets    stat_ptr to build new statements within the group.  */
end_comment

begin_function
name|void
name|lang_enter_group
parameter_list|()
block|{
name|lang_group_statement_type
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|new_stat
argument_list|(
name|lang_group_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|g
operator|->
name|children
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|g
operator|->
name|children
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leave a group.  This just resets stat_ptr to start writing to the    regular list of statements again.  Note that this will not work if    groups can occur inside anything else which can adjust stat_ptr,    but currently they can't.  */
end_comment

begin_function
name|void
name|lang_leave_group
parameter_list|()
block|{
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new program header.  This is called for each entry in a PHDRS    command in a linker script.  */
end_comment

begin_function
name|void
name|lang_new_phdr
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|filehdr
parameter_list|,
name|phdrs
parameter_list|,
name|at
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|etree_type
modifier|*
name|type
decl_stmt|;
name|boolean
name|filehdr
decl_stmt|;
name|boolean
name|phdrs
decl_stmt|;
name|etree_type
modifier|*
name|at
decl_stmt|;
name|etree_type
modifier|*
name|flags
decl_stmt|;
block|{
name|struct
name|lang_phdr
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|lang_phdr
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_phdr
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|exp_get_value_int
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|"program header type"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
name|n
operator|->
name|filehdr
operator|=
name|filehdr
expr_stmt|;
name|n
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|n
operator|->
name|at
operator|=
name|at
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_phdr_list
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the program header information in the output BFD.  FIXME: We    should not be calling an ELF specific function here.  */
end_comment

begin_function
specifier|static
name|void
name|lang_record_phdrs
parameter_list|()
block|{
name|unsigned
name|int
name|alc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|last
decl_stmt|;
name|struct
name|lang_phdr
modifier|*
name|l
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|u
decl_stmt|;
name|alc
operator|=
literal|10
expr_stmt|;
name|secs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
name|lang_phdr_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_vma
name|at
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|next
control|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
name|os
operator|=
operator|&
name|u
operator|->
name|output_section_statement
expr_stmt|;
name|pl
operator|=
name|os
operator|->
name|phdrs
expr_stmt|;
if|if
condition|(
name|pl
operator|!=
name|NULL
condition|)
name|last
operator|=
name|pl
expr_stmt|;
else|else
block|{
if|if
condition|(
name|os
operator|->
name|sectype
operator|==
name|noload_section
operator|||
name|os
operator|->
name|bfd_section
operator|==
name|NULL
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pl
operator|=
name|last
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
name|l
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|alc
condition|)
block|{
name|alc
operator|*=
literal|2
expr_stmt|;
name|secs
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|secs
argument_list|,
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|secs
index|[
name|c
index|]
operator|=
name|os
operator|->
name|bfd_section
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|pl
operator|->
name|used
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|l
operator|->
name|flags
operator|==
name|NULL
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|flags
argument_list|,
literal|0
argument_list|,
literal|"phdr flags"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|at
operator|==
name|NULL
condition|)
name|at
operator|=
literal|0
expr_stmt|;
else|else
name|at
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|at
argument_list|,
literal|0
argument_list|,
literal|"phdr load address"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_record_phdr
argument_list|(
name|output_bfd
argument_list|,
name|l
operator|->
name|type
argument_list|,
name|l
operator|->
name|flags
operator|!=
name|NULL
argument_list|,
name|flags
argument_list|,
name|l
operator|->
name|at
operator|!=
name|NULL
argument_list|,
name|at
argument_list|,
name|l
operator|->
name|filehdr
argument_list|,
name|l
operator|->
name|phdrs
argument_list|,
name|c
argument_list|,
name|secs
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_record_phdr failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|secs
argument_list|)
expr_stmt|;
comment|/* Make sure all the phdr assignments succeeded.  */
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|next
control|)
block|{
name|struct
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|output_section_statement
operator|.
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|pl
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|phdrs
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|pl
operator|->
name|used
operator|&&
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
literal|"NONE"
argument_list|)
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: section `%s' assigned to non-existent phdr `%s'\n"
argument_list|)
argument_list|,
name|u
operator|->
name|output_section_statement
operator|.
name|name
argument_list|,
name|pl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a list of sections which may not be cross referenced.  */
end_comment

begin_function
name|void
name|lang_add_nocrossref
parameter_list|(
name|l
parameter_list|)
name|struct
name|lang_nocrossref
modifier|*
name|l
decl_stmt|;
block|{
name|struct
name|lang_nocrossrefs
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|lang_nocrossrefs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|nocrossref_list
expr_stmt|;
name|n
operator|->
name|list
operator|=
name|l
expr_stmt|;
name|nocrossref_list
operator|=
name|n
expr_stmt|;
comment|/* Set notice_all so that we get informed about all symbols.  */
name|link_info
operator|.
name|notice_all
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Overlay handling.  We handle overlays with some static variables.  */
end_comment

begin_comment
comment|/* The overlay virtual address.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_vma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The overlay load address.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_lma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether nocrossrefs is set for this overlay.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overlay_nocrossrefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An expression for the maximum section size seen so far.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all the sections in this overlay.  */
end_comment

begin_struct
struct|struct
name|overlay_list
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|overlay_list
modifier|*
name|overlay_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start handling an overlay.  */
end_comment

begin_function
name|void
name|lang_enter_overlay
parameter_list|(
name|vma_expr
parameter_list|,
name|lma_expr
parameter_list|,
name|nocrossrefs
parameter_list|)
name|etree_type
modifier|*
name|vma_expr
decl_stmt|;
name|etree_type
modifier|*
name|lma_expr
decl_stmt|;
name|int
name|nocrossrefs
decl_stmt|;
block|{
comment|/* The grammar should prevent nested overlays from occurring.  */
name|ASSERT
argument_list|(
name|overlay_vma
operator|==
name|NULL
operator|&&
name|overlay_lma
operator|==
name|NULL
operator|&&
name|overlay_list
operator|==
name|NULL
operator|&&
name|overlay_max
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|vma_expr
expr_stmt|;
name|overlay_lma
operator|=
name|lma_expr
expr_stmt|;
name|overlay_nocrossrefs
operator|=
name|nocrossrefs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a section in an overlay.  We handle this by calling    lang_enter_output_section_statement with the correct VMA and LMA.  */
end_comment

begin_function
name|void
name|lang_enter_overlay_section
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|overlay_list
modifier|*
name|n
decl_stmt|;
name|etree_type
modifier|*
name|size
decl_stmt|;
name|lang_enter_output_section_statement
argument_list|(
name|name
argument_list|,
name|overlay_vma
argument_list|,
name|normal_section
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|overlay_lma
argument_list|)
expr_stmt|;
comment|/* If this is the first section, then base the VMA and LMA of future      sections on this one.  This will work correctly even if `.' is      used in the addresses.  */
if|if
condition|(
name|overlay_list
operator|==
name|NULL
condition|)
block|{
name|overlay_vma
operator|=
name|exp_nameop
argument_list|(
name|ADDR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|overlay_lma
operator|=
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the section.  */
name|n
operator|=
operator|(
expr|struct
name|overlay_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|os
operator|=
name|current_section
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|overlay_list
expr_stmt|;
name|overlay_list
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Adjust the LMA for the next section.  */
name|overlay_lma
operator|=
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|overlay_lma
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Arrange to work out the maximum section end address.  */
if|if
condition|(
name|overlay_max
operator|==
name|NULL
condition|)
name|overlay_max
operator|=
name|size
expr_stmt|;
else|else
name|overlay_max
operator|=
name|exp_binop
argument_list|(
name|MAX_K
argument_list|,
name|overlay_max
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a section in an overlay.  There isn't any special to do    here.  */
end_comment

begin_function
name|void
name|lang_leave_overlay_section
parameter_list|(
name|fill
parameter_list|,
name|phdrs
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|clean
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|name
operator|=
name|current_section
operator|->
name|name
expr_stmt|;
name|lang_leave_output_section_statement
argument_list|(
name|fill
argument_list|,
literal|"*default*"
argument_list|,
name|phdrs
argument_list|,
literal|"*default*"
argument_list|)
expr_stmt|;
comment|/* Define the magic symbols.  */
name|clean
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|clean
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|name
init|;
operator|*
name|s1
operator|!=
literal|'\0'
condition|;
name|s1
operator|++
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
operator|*
name|s1
argument_list|)
operator|||
operator|*
name|s1
operator|==
literal|'_'
condition|)
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_start_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_start_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_stop_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_stop_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|,
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an overlay.  If there are any overlay wide settings, this    looks through all the sections in the overlay and sets them.  */
end_comment

begin_function
name|void
name|lang_leave_overlay
parameter_list|(
name|fill
parameter_list|,
name|memspec
parameter_list|,
name|phdrs
parameter_list|,
name|lma_memspec
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
specifier|const
name|char
modifier|*
name|memspec
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
specifier|const
name|char
modifier|*
name|lma_memspec
decl_stmt|;
block|{
name|lang_memory_region_type
modifier|*
name|region
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|default_region
decl_stmt|;
name|lang_memory_region_type
modifier|*
name|lma_region
decl_stmt|;
name|struct
name|overlay_list
modifier|*
name|l
decl_stmt|;
name|struct
name|lang_nocrossref
modifier|*
name|nocrossref
decl_stmt|;
name|default_region
operator|=
name|lang_memory_region_lookup
argument_list|(
literal|"*default*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memspec
operator|==
name|NULL
condition|)
name|region
operator|=
name|NULL
expr_stmt|;
else|else
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|memspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|lma_memspec
operator|==
name|NULL
condition|)
name|lma_region
operator|=
name|NULL
expr_stmt|;
else|else
name|lma_region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|lma_memspec
argument_list|)
expr_stmt|;
name|nocrossref
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|overlay_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|fill
operator|!=
literal|0
operator|&&
name|l
operator|->
name|os
operator|->
name|fill
operator|==
literal|0
condition|)
name|l
operator|->
name|os
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
comment|/* Assign a region to the sections, if one has been specified. 	 Override the assignment of the default section, but not 	 other sections.  */
if|if
condition|(
name|region
operator|!=
name|NULL
operator|&&
operator|(
name|l
operator|->
name|os
operator|->
name|region
operator|==
name|NULL
operator|||
name|l
operator|->
name|os
operator|->
name|region
operator|==
name|default_region
operator|)
condition|)
name|l
operator|->
name|os
operator|->
name|region
operator|=
name|region
expr_stmt|;
comment|/* We only set lma_region for the first overlay section, as 	 subsequent overlay sections will have load_base set relative 	 to the first section.  Also, don't set lma_region if 	 load_base is specified.  FIXME:  There should really be a test 	 that `AT ( LDADDR )' doesn't conflict with `AT>LMA_REGION' 	 rather than letting LDADDR simply override LMA_REGION.  */
if|if
condition|(
name|lma_region
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|lma_region
operator|==
name|NULL
operator|&&
name|l
operator|->
name|next
operator|==
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|load_base
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|lma_region
operator|=
name|lma_region
expr_stmt|;
if|if
condition|(
name|phdrs
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|phdrs
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
if|if
condition|(
name|overlay_nocrossrefs
condition|)
block|{
name|struct
name|lang_nocrossref
modifier|*
name|nc
decl_stmt|;
name|nc
operator|=
operator|(
expr|struct
name|lang_nocrossref
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nc
argument_list|)
expr_stmt|;
name|nc
operator|->
name|name
operator|=
name|l
operator|->
name|os
operator|->
name|name
expr_stmt|;
name|nc
operator|->
name|next
operator|=
name|nocrossref
expr_stmt|;
name|nocrossref
operator|=
name|nc
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|nocrossref
operator|!=
name|NULL
condition|)
name|lang_add_nocrossref
argument_list|(
name|nocrossref
argument_list|)
expr_stmt|;
comment|/* Update . for the end of the overlay.  */
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
literal|"."
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|overlay_vma
argument_list|,
name|overlay_max
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|NULL
expr_stmt|;
name|overlay_lma
operator|=
name|NULL
expr_stmt|;
name|overlay_nocrossrefs
operator|=
literal|0
expr_stmt|;
name|overlay_list
operator|=
name|NULL
expr_stmt|;
name|overlay_max
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Version handling.  This is only useful for ELF.  */
end_comment

begin_comment
comment|/* This global variable holds the version tree that we build.  */
end_comment

begin_decl_stmt
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_elf_version_info
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|lang_vers_match_lang_c
parameter_list|(
name|expr
parameter_list|,
name|sym
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|expr
operator|->
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|expr
operator|->
name|pattern
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
return|return
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lang_vers_match_lang_cplusplus
parameter_list|(
name|expr
parameter_list|,
name|sym
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|char
modifier|*
name|alt_sym
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|expr
operator|->
name|pattern
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
name|alt_sym
operator|=
name|cplus_demangle
argument_list|(
name|sym
argument_list|,
comment|/* DMGL_NO_TPARAMS */
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt_sym
condition|)
block|{
comment|/* cplus_demangle (also) returns NULL when it is not a C++ symbol. 	 Should we early out false in this case?  */
name|result
operator|=
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|alt_sym
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
name|free
argument_list|(
name|alt_sym
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lang_vers_match_lang_java
parameter_list|(
name|expr
parameter_list|,
name|sym
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|char
modifier|*
name|alt_sym
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|pattern
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|expr
operator|->
name|pattern
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
name|alt_sym
operator|=
name|cplus_demangle
argument_list|(
name|sym
argument_list|,
name|DMGL_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|alt_sym
condition|)
block|{
comment|/* cplus_demangle (also) returns NULL when it is not a Java symbol. 	 Should we early out false in this case?  */
name|result
operator|=
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|sym
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|fnmatch
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|alt_sym
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
expr_stmt|;
name|free
argument_list|(
name|alt_sym
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This is called for each variable name or match expression.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_new_vers_pattern
parameter_list|(
name|orig
parameter_list|,
name|new
parameter_list|,
name|lang
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|new
decl_stmt|;
specifier|const
name|char
modifier|*
name|lang
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|orig
expr_stmt|;
name|ret
operator|->
name|pattern
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|lang
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|match
operator|=
name|lang_vers_match_lang_c
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"C++"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|match
operator|=
name|lang_vers_match_lang_cplusplus
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|lang
argument_list|,
literal|"Java"
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|->
name|match
operator|=
name|lang_vers_match_lang_java
expr_stmt|;
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unknown language `%s' in version information\n"
argument_list|)
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|ret
operator|->
name|match
operator|=
name|lang_vers_match_lang_c
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This is called for each set of variable names and match    expressions.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_new_vers_node
parameter_list|(
name|globals
parameter_list|,
name|locals
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|globals
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|locals
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_tree
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|vernum
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|globals
operator|=
name|globals
expr_stmt|;
name|ret
operator|->
name|locals
operator|=
name|locals
expr_stmt|;
name|ret
operator|->
name|deps
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|name_indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This static variable keeps track of version indices.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|version_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called when we know the name and dependencies of the    version.  */
end_comment

begin_function
name|void
name|lang_register_vers_node
parameter_list|(
name|name
parameter_list|,
name|version
parameter_list|,
name|deps
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|version
decl_stmt|;
name|struct
name|bfd_elf_version_deps
modifier|*
name|deps
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|e1
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|lang_elf_version_info
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|lang_elf_version_info
operator|&&
name|lang_elf_version_info
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: anonymous version tag cannot be combined with other version tags\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure this node has a unique name.  */
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate version tag `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Check the global and local match names, and make sure there      aren't any duplicates.  */
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|globals
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|locals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|pattern
argument_list|,
name|e2
operator|->
name|pattern
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|locals
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|globals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|pattern
argument_list|,
name|e2
operator|->
name|pattern
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|)
argument_list|,
name|e1
operator|->
name|pattern
argument_list|)
expr_stmt|;
block|}
block|}
name|version
operator|->
name|deps
operator|=
name|deps
expr_stmt|;
name|version
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|++
name|version_index
expr_stmt|;
name|version
operator|->
name|vernum
operator|=
name|version_index
expr_stmt|;
block|}
else|else
name|version
operator|->
name|vernum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_elf_version_info
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when we see a version dependency.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_deps
modifier|*
name|lang_add_vers_depend
parameter_list|(
name|list
parameter_list|,
name|name
parameter_list|)
name|struct
name|bfd_elf_version_deps
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_deps
modifier|*
name|ret
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_deps
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|list
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|->
name|version_needed
operator|=
name|t
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to find version dependency `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lang_do_version_exports_section
parameter_list|()
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|greg
init|=
name|NULL
decl_stmt|,
modifier|*
name|lreg
decl_stmt|;
name|LANG_FOR_EACH_INPUT_STATEMENT
argument_list|(
argument|is
argument_list|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
literal|".exports"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
continue|continue;
name|len
operator|=
name|bfd_section_size
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to read .exports section contents\n"
argument_list|)
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|p
operator|=
name|contents
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|contents
operator|+
name|len
condition|)
block|{
name|greg
operator|=
name|lang_new_vers_pattern
argument_list|(
name|greg
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Do not free the contents, as we used them creating the regex.  */
comment|/* Do not include this section in the link.  */
name|bfd_set_section_flags
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|is
operator|->
name|the_bfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_EXCLUDE
argument_list|)
expr_stmt|;
block|}
name|lreg
operator|=
name|lang_new_vers_pattern
argument_list|(
name|NULL
argument_list|,
literal|"*"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lang_register_vers_node
argument_list|(
name|command_line
operator|.
name|version_exports_section
argument_list|,
name|lang_new_vers_node
argument_list|(
name|greg
argument_list|,
name|lreg
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_unique
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|unique_sections
modifier|*
name|ent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|unique_section_list
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ent
operator|=
operator|(
expr|struct
name|unique_sections
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|unique_section_list
expr_stmt|;
name|unique_section_list
operator|=
name|ent
expr_stmt|;
block|}
end_function

end_unit

