begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linker command language support.    Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"fnmatch.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* FORWARDS */
end_comment

begin_decl_stmt
specifier|static
name|lang_statement_union_type
modifier|*
name|new_statement
name|PARAMS
argument_list|(
operator|(
expr|enum
name|statement_enum
operator|,
name|size_t
operator|,
name|lang_statement_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LOCALS */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|stat_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|startup_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|input_file_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|placed_commons
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|default_common_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|map_option_f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|print_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|first_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|lang_output_section_statement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|current_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONST
name|char
modifier|*
name|output_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_statement_list_type
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lang_phdr
modifier|*
name|lang_phdr_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_for_each_statement_worker
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|lang_statement_union_type
operator|*
argument_list|)
operator|,
name|lang_statement_union_type
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|new_afile
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|lang_input_file_enum_type
name|file_type
operator|,
specifier|const
name|char
operator|*
name|target
operator|,
name|boolean
name|add_to_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_os
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exp_init_os
name|PARAMS
argument_list|(
operator|(
name|etree_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|section_already_linked
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|wildcardp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wild_section
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
name|ptr
operator|,
specifier|const
name|char
operator|*
name|section
operator|,
name|lang_input_statement_type
operator|*
name|file
operator|,
name|lang_output_section_statement_type
operator|*
name|output
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_symbols
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
name|entry
operator|,
name|lang_statement_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wild_file
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|lang_input_statement_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wild
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
name|s
operator|,
specifier|const
name|char
operator|*
name|section
operator|,
specifier|const
name|char
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|target
operator|,
name|lang_output_section_statement_type
operator|*
name|output
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|open_output
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ldlang_open_output
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|statement
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|open_input_bfds
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|statement
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_reasonable_defaults
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_place_undefineds
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|map_input_to_output_sections
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|s
operator|,
specifier|const
name|char
operator|*
name|target
operator|,
name|lang_output_section_statement_type
operator|*
name|output_section_statement
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_output_section_statement
name|PARAMS
argument_list|(
operator|(
name|lang_output_section_statement_type
operator|*
name|output_section_statement
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_assignment
name|PARAMS
argument_list|(
operator|(
name|lang_assignment_statement_type
operator|*
name|assignment
operator|,
name|lang_output_section_statement_type
operator|*
name|output_section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_input_statement
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
name|statm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|print_one_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_input_section
name|PARAMS
argument_list|(
operator|(
name|lang_input_section_type
operator|*
name|in
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_fill_statement
name|PARAMS
argument_list|(
operator|(
name|lang_fill_statement_type
operator|*
name|fill
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_data_statement
name|PARAMS
argument_list|(
operator|(
name|lang_data_statement_type
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_address_statement
name|PARAMS
argument_list|(
operator|(
name|lang_address_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_reloc_statement
name|PARAMS
argument_list|(
operator|(
name|lang_reloc_statement_type
operator|*
name|reloc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_padding_statement
name|PARAMS
argument_list|(
operator|(
name|lang_padding_statement_type
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_wild_statement
name|PARAMS
argument_list|(
operator|(
name|lang_wild_statement_type
operator|*
name|w
operator|,
name|lang_output_section_statement_type
operator|*
name|os
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_group
name|PARAMS
argument_list|(
operator|(
name|lang_group_statement_type
operator|*
operator|,
name|lang_output_section_statement_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statement
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|s
operator|,
name|lang_output_section_statement_type
operator|*
name|os
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statement_list
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
name|s
operator|,
name|lang_output_section_statement_type
operator|*
name|os
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_statements
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|insert_pad
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|*
name|this_ptr
operator|,
name|fill_type
name|fill
operator|,
name|unsigned
name|int
name|power
operator|,
name|asection
operator|*
name|output_section_statement
operator|,
name|bfd_vma
name|dot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|size_input_section
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|*
name|this_ptr
operator|,
name|lang_output_section_statement_type
operator|*
name|output_section_statement
operator|,
name|fill_type
name|fill
operator|,
name|bfd_vma
name|dot
operator|,
name|boolean
name|relax
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_finish
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_check
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_common
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|lang_one_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_place_orphans
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|topower
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_set_startof
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_memory_regions
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lang_record_phdrs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EXPORTS */
end_comment

begin_decl_stmt
name|lang_output_section_statement_type
modifier|*
name|abs_output_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
modifier|*
name|stat_ptr
init|=
operator|&
name|statement_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lang_statement_list_type
name|file_chain
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|entry_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|entry_from_cmdline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|lang_has_input_file
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|had_output_filename
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|lang_float_flag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|delete_output_file_on_failure
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lang_nocrossrefs
modifier|*
name|nocrossref_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|etree_type
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relocation base - or null */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
end_if

begin_define
define|#
directive|define
name|cat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a##b
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|cat
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a
comment|/**/
value|b
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|new_stat
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(cat(x,_type)*) new_statement(cat(x,_enum), sizeof(cat(x,_type)),y)
end_define

begin_define
define|#
directive|define
name|outside_section_address
parameter_list|(
name|q
parameter_list|)
value|( (q)->output_offset + (q)->output_section->vma)
end_define

begin_define
define|#
directive|define
name|outside_symbol_address
parameter_list|(
name|q
parameter_list|)
value|((q)->value +   outside_section_address(q->section))
end_define

begin_define
define|#
directive|define
name|SECTION_NAME_MAP_LENGTH
value|(16)
end_define

begin_function
name|PTR
name|stat_alloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
name|obstack_alloc
argument_list|(
operator|&
name|stat_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   lang_for_each_statement walks the parse tree and calls the provided   function for each node */
end_comment

begin_function_decl
specifier|static
name|void
name|lang_for_each_statement_worker
parameter_list|(
name|func
parameter_list|,
name|s
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|func
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|constructor_list
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_input_statement_enum
case|:
case|case
name|lang_assignment_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_address_statement_enum
case|:
case|case
name|lang_fill_statement_enum
case|:
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function_decl
name|void
name|lang_for_each_statement
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lang_for_each_statement_worker
argument_list|(
name|func
argument_list|,
name|statement_list
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lang_list_init
parameter_list|(
name|list
parameter_list|)
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|list
operator|->
name|head
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|->
name|tail
operator|=
operator|&
name|list
operator|->
name|head
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------    build a new statement node for the parse tree   */
end_comment

begin_function
specifier|static
name|lang_statement_union_type
modifier|*
name|new_statement
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|,
name|list
parameter_list|)
name|enum
name|statement_enum
name|type
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|new
init|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|stat_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|new
operator|->
name|header
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lang_statement_append
argument_list|(
name|list
argument_list|,
name|new
argument_list|,
operator|&
name|new
operator|->
name|header
operator|.
name|next
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*   Build a new input file node for the language. There are several ways   in which we treat an input file, eg, we only look at symbols, or   prefix it with a -l etc.    We can be supplied with requests for input files more than once;   they may, for example be split over serveral lines like foo.o(.text)   foo.o(.data) etc, so when asked for a file we check that we havn't   got it already so we don't duplicate the bfd.   */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|new_afile
parameter_list|(
name|name
parameter_list|,
name|file_type
parameter_list|,
name|target
parameter_list|,
name|add_to_list
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|lang_input_file_enum_type
name|file_type
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
name|boolean
name|add_to_list
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|add_to_list
condition|)
name|p
operator|=
name|new_stat
argument_list|(
name|lang_input_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
operator|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_input_statement_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|header
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|target
operator|=
name|target
expr_stmt|;
switch|switch
condition|(
name|file_type
condition|)
block|{
case|case
name|lang_input_file_is_symbols_only_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_fake_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_l_enum
case|:
name|p
operator|->
name|is_archive
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|concat
argument_list|(
literal|"-l"
argument_list|,
name|name
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_marker_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_search_file_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|lang_input_file_is_file_enum
case|:
name|p
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_archive
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|p
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|p
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|the_bfd
operator|=
operator|(
name|bfd
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|asymbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|next_real_file
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|p
operator|->
name|symbol_count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|dynamic
operator|=
name|config
operator|.
name|dynamic_link
expr_stmt|;
name|p
operator|->
name|whole_archive
operator|=
name|whole_archive
expr_stmt|;
name|p
operator|->
name|loaded
operator|=
name|false
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|input_file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|p
argument_list|,
operator|&
name|p
operator|->
name|next_real_file
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|lang_input_statement_type
modifier|*
name|lang_add_input_file
parameter_list|(
name|name
parameter_list|,
name|file_type
parameter_list|,
name|target
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|lang_input_file_enum_type
name|file_type
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
block|{
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
return|return
name|new_afile
argument_list|(
name|name
argument_list|,
name|file_type
argument_list|,
name|target
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build enough state so that the parser can build its tree */
end_comment

begin_function
name|void
name|lang_init
parameter_list|()
block|{
name|obstack_begin
argument_list|(
operator|&
name|stat_obstack
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|input_file_chain
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|file_chain
argument_list|)
expr_stmt|;
name|first_file
operator|=
name|lang_add_input_file
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|lang_input_file_is_marker_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|abs_output_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|BFD_ABS_SECTION_NAME
argument_list|)
expr_stmt|;
name|abs_output_section
operator|->
name|bfd_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  A region is an area of memory declared with the  MEMORY {  name:org=exp, len=exp ... }  syntax.   We maintain a list of all the regions here   If no regions are specified in the script, then the default is used  which is created when looked up to be the entire data space */
end_comment

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lang_memory_region_type
modifier|*
modifier|*
name|lang_memory_region_list_tail
init|=
operator|&
name|lang_memory_region_list
decl_stmt|;
end_decl_stmt

begin_function
name|lang_memory_region_type
modifier|*
name|lang_memory_region_lookup
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|name
decl_stmt|;
block|{
name|lang_memory_region_type
modifier|*
name|p
init|=
name|lang_memory_region_list
decl_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This code used to always use the first region in the list as the      default region.  I changed it to instead use a region      encompassing all of memory as the default region.  This permits      NOLOAD sections to work reasonably without requiring a region.      People should specify what region they mean, if they really want      a region.  */
block|if (strcmp (name, "*default*") == 0)     {       if (lang_memory_region_list != (lang_memory_region_type *) NULL) 	{ 	  return lang_memory_region_list; 	}     }
endif|#
directive|endif
block|{
name|lang_memory_region_type
modifier|*
name|new
init|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_memory_region_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|buystring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|lang_memory_region_list_tail
operator|=
name|new
expr_stmt|;
name|lang_memory_region_list_tail
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
name|new
operator|->
name|origin
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|length
operator|=
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0
expr_stmt|;
name|new
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|had_full_message
operator|=
name|false
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_find
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|name
decl_stmt|;
block|{
name|lang_statement_union_type
modifier|*
name|u
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|lookup
decl_stmt|;
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|u
operator|=
name|lookup
operator|->
name|next
control|)
block|{
name|lookup
operator|=
operator|&
name|u
operator|->
name|output_section_statement
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|lookup
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|lookup
return|;
block|}
block|}
return|return
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|lang_output_section_statement_type
modifier|*
name|lang_output_section_statement_lookup
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|name
decl_stmt|;
block|{
name|lang_output_section_statement_type
modifier|*
name|lookup
decl_stmt|;
name|lookup
operator|=
name|lang_output_section_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|==
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|lookup
operator|=
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|new_stat
argument_list|(
name|lang_output_section_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|region
operator|=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|fill
operator|=
literal|0
expr_stmt|;
name|lookup
operator|->
name|block_value
operator|=
literal|1
expr_stmt|;
name|lookup
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|lookup
operator|->
name|next
operator|=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|bfd_section
operator|=
operator|(
name|asection
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|processed
operator|=
name|false
expr_stmt|;
name|lookup
operator|->
name|sectype
operator|=
name|normal_section
expr_stmt|;
name|lookup
operator|->
name|addr_tree
operator|=
operator|(
name|etree_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|lookup
operator|->
name|children
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|memspec
operator|=
operator|(
name|CONST
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|lookup
operator|->
name|subsection_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|lookup
operator|->
name|section_alignment
operator|=
operator|-
literal|1
expr_stmt|;
name|lookup
operator|->
name|load_base
operator|=
operator|(
expr|union
name|etree_union
operator|*
operator|)
name|NULL
expr_stmt|;
name|lookup
operator|->
name|phdrs
operator|=
name|NULL
expr_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|lang_output_section_statement
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|lookup
argument_list|,
operator|&
name|lookup
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|lookup
return|;
block|}
end_function

begin_function
name|void
name|lang_map
parameter_list|()
block|{
name|lang_memory_region_type
modifier|*
name|m
decl_stmt|;
name|minfo
argument_list|(
literal|"\nMemory Configuration\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s %-18s %-18s\n"
argument_list|,
literal|"Name"
argument_list|,
literal|"Origin"
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|lang_memory_region_list
init|;
name|m
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"%-16s "
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|origin
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%s "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V\n"
argument_list|,
name|m
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"\nLinker script and memory map\n\n"
argument_list|)
expr_stmt|;
name|print_statements
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize an output section.  */
end_comment

begin_function
specifier|static
name|void
name|init_os
parameter_list|(
name|s
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|s
decl_stmt|;
block|{
name|section_userdata_type
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%P%F: Illegal use of `%s' section"
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
operator|(
name|section_userdata_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|section_userdata_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|s
operator|->
name|bfd_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|s
operator|->
name|bfd_section
operator|=
name|bfd_make_section
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|bfd_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%F: output format %s cannot represent section called %s\n"
argument_list|,
name|output_bfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|bfd_section
operator|->
name|output_section
operator|=
name|s
operator|->
name|bfd_section
expr_stmt|;
comment|/* We initialize an output sections output offset to minus its own */
comment|/* vma to allow us to output a section through itself */
name|s
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
name|get_userdata
argument_list|(
name|s
operator|->
name|bfd_section
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|new
expr_stmt|;
comment|/* If there is a base address, make sure that any sections it might      mention are initialized.  */
if|if
condition|(
name|s
operator|->
name|addr_tree
operator|!=
name|NULL
condition|)
name|exp_init_os
argument_list|(
name|s
operator|->
name|addr_tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that all output sections mentioned in an expression are    initialized.  */
end_comment

begin_function
specifier|static
name|void
name|exp_init_os
parameter_list|(
name|exp
parameter_list|)
name|etree_type
modifier|*
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_class
condition|)
block|{
case|case
name|etree_assign
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|assign
operator|.
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_binary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|binary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_trinary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|cond
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|lhs
argument_list|)
expr_stmt|;
name|exp_init_os
argument_list|(
name|exp
operator|->
name|trinary
operator|.
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_unary
case|:
name|exp_init_os
argument_list|(
name|exp
operator|->
name|unary
operator|.
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|etree_name
case|:
switch|switch
condition|(
name|exp
operator|->
name|type
operator|.
name|node_code
condition|)
block|{
case|case
name|ADDR
case|:
case|case
name|LOADADDR
case|:
case|case
name|SIZEOF
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|os
operator|=
name|lang_output_section_find
argument_list|(
name|exp
operator|->
name|name
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
operator|&&
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Sections marked with the SEC_LINK_ONCE flag should only be linked    once into the output.  This routine checks each sections, and    arranges to discard it if a section of the same name has already    been linked.  This code assumes that all relevant sections have the    SEC_LINK_ONCE flag set; that is, it does not depend solely upon the    section name.  This is called via bfd_map_over_sections.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|section_already_linked
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|entry
init|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|data
decl_stmt|;
struct|struct
name|sec_link_once
block|{
name|struct
name|sec_link_once
modifier|*
name|next
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|sec_link_once
modifier|*
name|sec_link_once_list
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|sec_link_once
modifier|*
name|l
decl_stmt|;
comment|/* If we are only reading symbols from this object, then we want to      discard all sections.  */
if|if
condition|(
name|entry
operator|->
name|just_syms_flag
condition|)
block|{
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|sec
operator|->
name|output_offset
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LINK_ONCE
operator|)
operator|==
literal|0
condition|)
return|return;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|sec_link_once_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The section has already been linked.  See if we should              issue a warning.  */
switch|switch
condition|(
name|flags
operator|&
name|SEC_LINK_DUPLICATES
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SEC_LINK_DUPLICATES_DISCARD
case|:
break|break;
case|case
name|SEC_LINK_DUPLICATES_ONE_ONLY
case|:
name|einfo
argument_list|(
literal|"%P: %B: warning: ignoring duplicate section `%s'\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEC_LINK_DUPLICATES_SAME_CONTENTS
case|:
comment|/* FIXME: We should really dig out the contents of both                  sections and memcmp them.  The COFF/PE spec says that                  the Microsoft linker does not implement this                  correctly, so I'm not going to bother doing it                  either.  */
comment|/* Fall through.  */
case|case
name|SEC_LINK_DUPLICATES_SAME_SIZE
case|:
if|if
condition|(
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|bfd_section_size
argument_list|(
name|l
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|l
operator|->
name|sec
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P: %B: warning: duplicate section `%s' has different size\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Set the output_section field so that wild_doit does not 	     create a lang_input_section structure for this section.  */
name|sec
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
return|return;
block|}
block|}
comment|/* This is the first section with this name.  Record it.  */
name|l
operator|=
operator|(
expr|struct
name|sec_link_once
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|sec_link_once_list
expr_stmt|;
name|sec_link_once_list
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The wild routines.     These expand statements like *(.text) and foo.o to a list of    explicit actions, like foo.o(.text), bar.o(.text) and    foo.o(.text, .data).  */
end_comment

begin_comment
comment|/* Return true if the PATTERN argument is a wildcard pattern.  */
end_comment

begin_function
specifier|static
name|boolean
name|wildcardp
parameter_list|(
name|pattern
parameter_list|)
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|pattern
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'?'
operator|||
operator|*
name|s
operator|==
literal|'\\'
operator|||
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'['
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Add SECTION to the output section OUTPUT.  Do this by creating a    lang_input_section statement which is placed at PTR.  FILE is the    input file which holds SECTION.  */
end_comment

begin_function
name|void
name|wild_doit
parameter_list|(
name|ptr
parameter_list|,
name|section
parameter_list|,
name|output
parameter_list|,
name|file
parameter_list|)
name|lang_statement_list_type
modifier|*
name|ptr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|boolean
name|discard
decl_stmt|;
name|flags
operator|=
name|bfd_get_section_flags
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|discard
operator|=
name|false
expr_stmt|;
comment|/* If we are doing a final link, discard sections marked with      SEC_EXCLUDE.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|&&
operator|(
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
comment|/* Discard input sections which are assigned to a section named      DISCARD_SECTION_NAME.  */
if|if
condition|(
name|strcmp
argument_list|(
name|output
operator|->
name|name
argument_list|,
name|DISCARD_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
comment|/* Discard debugging sections if we are stripping debugging      information.  */
if|if
condition|(
operator|(
name|link_info
operator|.
name|strip
operator|==
name|strip_debugger
operator|||
name|link_info
operator|.
name|strip
operator|==
name|strip_all
operator|)
operator|&&
operator|(
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|discard
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|discard
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
comment|/* This prevents future calls from assigning this section.  */
name|section
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
name|lang_input_section_type
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|output
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output
argument_list|)
expr_stmt|;
comment|/* Add a section reference to the list */
name|new
operator|=
name|new_stat
argument_list|(
name|lang_input_section
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|new
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|new
operator|->
name|ifile
operator|=
name|file
expr_stmt|;
name|section
operator|->
name|output_section
operator|=
name|output
operator|->
name|bfd_section
expr_stmt|;
comment|/* We don't copy the SEC_NEVER_LOAD flag from an input section 	 to an output section, because we want to be able to include a 	 SEC_NEVER_LOAD section in the middle of an otherwise loaded 	 section (I don't know why we want to do this, but we do). 	 build_link_order in ldwrite.c handles this case by turning 	 the embedded SEC_NEVER_LOAD section into a fill.  	 If final link, don't copy the SEC_LINK_ONCE flags, they've already 	 been processed.  One reason to do this is that on pe format targets, 	 .text$foo sections go into .text and it's odd to see .text with 	 SEC_LINK_ONCE set.  */
name|section
operator|->
name|output_section
operator|->
name|flags
operator||=
name|section
operator|->
name|flags
operator|&
call|(
name|flagword
call|)
argument_list|(
operator|~
operator|(
name|SEC_NEVER_LOAD
operator||
operator|(
operator|!
name|link_info
operator|.
name|relocateable
condition|?
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|output
operator|->
name|sectype
condition|)
block|{
case|case
name|normal_section
case|:
break|break;
case|case
name|dsect_section
case|:
case|case
name|copy_section
case|:
case|case
name|info_section
case|:
case|case
name|overlay_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_ALLOC
expr_stmt|;
break|break;
case|case
name|noload_section
case|:
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_LOAD
expr_stmt|;
name|output
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|section
operator|->
name|alignment_power
operator|>
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|section
operator|->
name|alignment_power
expr_stmt|;
comment|/* If supplied an aligment, then force it.  */
if|if
condition|(
name|output
operator|->
name|section_alignment
operator|!=
operator|-
literal|1
condition|)
name|output
operator|->
name|bfd_section
operator|->
name|alignment_power
operator|=
name|output
operator|->
name|section_alignment
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a wild statement for a particular FILE.  SECTION may be    NULL, in which case it is a wild card.  */
end_comment

begin_function
specifier|static
name|void
name|wild_section
parameter_list|(
name|ptr
parameter_list|,
name|section
parameter_list|,
name|file
parameter_list|,
name|output
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
block|{
if|if
condition|(
name|file
operator|->
name|just_syms_flag
operator|==
name|false
condition|)
block|{
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|wildcard
decl_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
name|wildcard
operator|=
name|false
expr_stmt|;
else|else
name|wildcard
operator|=
name|wildcardp
argument_list|(
name|section
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|boolean
name|match
decl_stmt|;
comment|/* Attach all sections named SECTION.  If SECTION is NULL, 	     then attach all sections.  	     Previously, if SECTION was NULL, this code did not call 	     wild_doit if the SEC_IS_COMMON flag was set for the 	     section.  I did not understand that, and I took it out. 	     --ian@cygnus.com.  */
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
name|match
operator|=
name|true
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|file
operator|->
name|the_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcard
condition|)
name|match
operator|=
name|fnmatch
argument_list|(
name|section
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|?
name|true
else|:
name|false
expr_stmt|;
else|else
name|match
operator|=
name|strcmp
argument_list|(
name|section
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|?
name|true
else|:
name|false
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
name|wild_doit
argument_list|(
operator|&
name|ptr
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|output
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is passed a file name which must have been seen already and    added to the statement tree.  We will see if it has been opened    already and had its symbols read.  If not then we'll read it.  */
end_comment

begin_function
specifier|static
name|lang_input_statement_type
modifier|*
name|lookup_name
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|search
decl_stmt|;
for|for
control|(
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|search
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|search
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|search
operator|->
name|next_real_file
control|)
block|{
if|if
condition|(
name|search
operator|->
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|search
return|;
if|if
condition|(
name|search
operator|->
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|search
operator|->
name|filename
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|search
operator|==
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|)
name|search
operator|=
name|new_afile
argument_list|(
name|name
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
name|default_target
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we have already added this file, or this file is not real      (FIXME: can that ever actually happen?) or the name is NULL      (FIXME: can that ever actually happen?) don't add this file.  */
if|if
condition|(
name|search
operator|->
name|loaded
operator|||
operator|!
name|search
operator|->
name|real
operator|||
name|search
operator|->
name|filename
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|search
return|;
name|load_symbols
argument_list|(
name|search
argument_list|,
operator|(
name|lang_statement_list_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Get the symbols for an input file.  */
end_comment

begin_function
specifier|static
name|void
name|load_symbols
parameter_list|(
name|entry
parameter_list|,
name|place
parameter_list|)
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|place
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matching
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|loaded
condition|)
return|return;
name|ldfile_open_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
operator|&&
operator|!
name|bfd_check_format_matches
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_object
argument_list|,
operator|&
name|matching
argument_list|)
condition|)
block|{
name|bfd_error_type
name|err
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|hold
decl_stmt|;
name|err
operator|=
name|bfd_get_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|bfd_error_file_ambiguously_recognized
condition|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|einfo
argument_list|(
literal|"%B: file not recognized: %E\n"
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%B: matching formats:"
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|matching
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
name|einfo
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%F\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|bfd_error_file_not_recognized
operator|||
name|place
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%F%B: file not recognized: %E\n"
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
comment|/* See if the emulation has some special knowledge.  */
if|if
condition|(
name|ldemul_unrecognized_file
argument_list|(
name|entry
argument_list|)
condition|)
return|return;
comment|/* Try to interpret the file as a linker script.  */
name|ldfile_open_command_file
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|hold
operator|=
name|stat_ptr
expr_stmt|;
name|stat_ptr
operator|=
name|place
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|true
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|false
expr_stmt|;
name|stat_ptr
operator|=
name|hold
expr_stmt|;
return|return;
block|}
comment|/* We don't call ldlang_add_file for an archive.  Instead, the      add_symbols entry point will call ldlang_add_file, via the      add_archive_element callback, for each element of the archive      which is used.  */
switch|switch
condition|(
name|bfd_get_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_object
case|:
name|ldlang_add_file
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_files
operator|||
name|trace_file_tries
condition|)
name|info_msg
argument_list|(
literal|"%I\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_archive
case|:
if|if
condition|(
name|entry
operator|->
name|whole_archive
condition|)
block|{
name|bfd
modifier|*
name|member
init|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|member
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%F%B: object %B in archive is not object\n"
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|.
name|callbacks
operator|->
name|add_archive_element
call|)
argument_list|(
operator|&
name|link_info
argument_list|,
name|member
argument_list|,
literal|"--whole-archive"
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|member
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|loaded
operator|=
name|true
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_link_add_symbols
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%F%B: could not read symbols: %E\n"
argument_list|,
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|loaded
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a wild statement for a single file F.  */
end_comment

begin_function
specifier|static
name|void
name|wild_file
parameter_list|(
name|s
parameter_list|,
name|section
parameter_list|,
name|f
parameter_list|,
name|output
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|the_bfd
operator|==
name|NULL
operator|||
operator|!
name|bfd_check_format
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|wild_section
argument_list|(
name|s
argument_list|,
name|section
argument_list|,
name|f
argument_list|,
name|output
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd
modifier|*
name|member
decl_stmt|;
comment|/* This is an archive file.  We must map each member of the 	 archive separately.  */
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|member
operator|!=
name|NULL
condition|)
block|{
comment|/* When lookup_name is called, it will call the add_symbols 	     entry point for the archive.  For each element of the 	     archive which is included, BFD will call ldlang_add_file, 	     which will set the usrdata field of the member to the 	     lang_input_statement.  */
if|if
condition|(
name|member
operator|->
name|usrdata
operator|!=
name|NULL
condition|)
block|{
name|wild_section
argument_list|(
name|s
argument_list|,
name|section
argument_list|,
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|member
operator|->
name|usrdata
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|member
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|f
operator|->
name|the_bfd
argument_list|,
name|member
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle a wild statement.  SECTION or FILE or both may be NULL,    indicating that it is a wildcard.  Separate lang_input_section    statements are created for each part of the expansion; they are    added after the wild statement S.  OUTPUT is the output section.  */
end_comment

begin_function
specifier|static
name|void
name|wild
parameter_list|(
name|s
parameter_list|,
name|section
parameter_list|,
name|file
parameter_list|,
name|target
parameter_list|,
name|output
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Perform the iteration over all files in the list */
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|file_chain
operator|.
name|head
init|;
name|f
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next
control|)
block|{
name|wild_file
argument_list|(
name|s
argument_list|,
name|section
argument_list|,
name|f
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wildcardp
argument_list|(
name|file
argument_list|)
condition|)
block|{
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|file_chain
operator|.
name|head
init|;
name|f
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|file
argument_list|,
name|f
operator|->
name|filename
argument_list|,
name|FNM_FILE_NAME
argument_list|)
operator|==
literal|0
condition|)
name|wild_file
argument_list|(
name|s
argument_list|,
name|section
argument_list|,
name|f
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Perform the iteration over a single file */
name|f
operator|=
name|lookup_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|wild_file
argument_list|(
name|s
argument_list|,
name|section
argument_list|,
name|f
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|section
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
operator|&&
name|default_common_section
operator|==
name|NULL
condition|)
block|{
comment|/* Remember the section that common is going to in case we later          get something which doesn't know where to put it.  */
name|default_common_section
operator|=
name|output
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Open the output file.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|open_output
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|bfd
modifier|*
name|output
decl_stmt|;
if|if
condition|(
name|output_target
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|current_target
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|output_target
operator|=
name|current_target
expr_stmt|;
else|else
name|output_target
operator|=
name|default_target
expr_stmt|;
block|}
name|output
operator|=
name|bfd_openw
argument_list|(
name|name
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_target
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%F: target %s not found\n"
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
block|}
name|einfo
argument_list|(
literal|"%P%F: cannot open output file %s: %E\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|delete_output_file_on_failure
operator|=
name|true
expr_stmt|;
comment|/*  output->flags |= D_PAGED;*/
if|if
condition|(
operator|!
name|bfd_set_format
argument_list|(
name|output
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P%F:%s: can not make object file: %E\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|output
argument_list|,
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P%F:%s: can not set architecture: %E\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|hash
operator|=
name|bfd_link_hash_table_create
argument_list|(
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|hash
operator|==
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: can not create link hash table: %E\n"
argument_list|)
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|output
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ldlang_open_output
parameter_list|(
name|statement
parameter_list|)
name|lang_statement_union_type
modifier|*
name|statement
decl_stmt|;
block|{
switch|switch
condition|(
name|statement
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_statement_enum
case|:
name|ASSERT
argument_list|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|output_bfd
operator|=
name|open_output
argument_list|(
name|statement
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
name|ldemul_set_output_arch
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|magic_demand_paged
operator|&&
operator|!
name|link_info
operator|.
name|relocateable
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|text_read_only
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|WP_TEXT
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|traditional_format
condition|)
name|output_bfd
operator|->
name|flags
operator||=
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|BFD_TRADITIONAL_FORMAT
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|statement
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Open all the input files.  */
end_comment

begin_function
specifier|static
name|void
name|open_input_bfds
parameter_list|(
name|s
parameter_list|,
name|force
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|boolean
name|force
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|open_input_bfds
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_wild_statement_enum
case|:
comment|/* Maybe we should load the file's symbols */
if|if
condition|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
operator|&&
operator|!
name|wildcardp
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lookup_name
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|)
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|undefs
decl_stmt|;
comment|/* We must continually search the entries in the group                until no new symbols are added to the list of undefined                symbols.  */
do|do
block|{
name|undefs
operator|=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
expr_stmt|;
name|open_input_bfds
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|undefs
operator|!=
name|link_info
operator|.
name|hash
operator|->
name|undefs_tail
condition|)
do|;
block|}
break|break;
case|case
name|lang_target_statement_enum
case|:
name|current_target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|s
operator|->
name|input_statement
operator|.
name|real
operator|==
name|true
condition|)
block|{
name|lang_statement_list_type
name|add
decl_stmt|;
name|s
operator|->
name|input_statement
operator|.
name|target
operator|=
name|current_target
expr_stmt|;
comment|/* If we are being called from within a group, and this                  is an archive which has already been searched, then                  force it to be researched.  */
if|if
condition|(
name|force
operator|&&
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|&&
name|bfd_check_format
argument_list|(
name|s
operator|->
name|input_statement
operator|.
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|s
operator|->
name|input_statement
operator|.
name|loaded
operator|=
name|false
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|add
argument_list|)
expr_stmt|;
name|load_symbols
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|,
operator|&
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
operator|*
name|add
operator|.
name|tail
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|add
operator|.
name|head
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If there are [COMMONS] statements, put a wild one into the bss section */
end_comment

begin_function
specifier|static
name|void
name|lang_reasonable_defaults
parameter_list|()
block|{
if|#
directive|if
literal|0
block|lang_output_section_statement_lookup (".text");   lang_output_section_statement_lookup (".data");    default_common_section =     lang_output_section_statement_lookup (".bss");     if (placed_commons == false)     {       lang_wild_statement_type *new =       new_stat (lang_wild_statement,&default_common_section->children);        new->section_name = "COMMON";       new->filename = (char *) NULL;       lang_list_init (&new->children);     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  Add the supplied name to the symbol table as an undefined reference.  Remove items from the chain as we open input bfds  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ldlang_undef_chain_list
block|{
name|struct
name|ldlang_undef_chain_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|ldlang_undef_chain_list_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ldlang_undef_chain_list_type
modifier|*
name|ldlang_undef_chain_list_head
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ldlang_add_undef
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|name
decl_stmt|;
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|new
init|=
operator|(
operator|(
name|ldlang_undef_chain_list_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ldlang_undef_chain_list_type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|ldlang_undef_chain_list_head
expr_stmt|;
name|ldlang_undef_chain_list_head
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|buystring
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run through the list of undefineds created above and place them    into the linker hash table as undefined symbols belonging to the    script file. */
end_comment

begin_function
specifier|static
name|void
name|lang_place_undefineds
parameter_list|()
block|{
name|ldlang_undef_chain_list_type
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|ldlang_undef_chain_list_head
init|;
name|ptr
operator|!=
operator|(
name|ldlang_undef_chain_list_type
operator|*
operator|)
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|bfd_link_add_undef
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Open input files and attatch to output sections */
end_comment

begin_function
specifier|static
name|void
name|map_input_to_output_sections
parameter_list|(
name|s
parameter_list|,
name|target
parameter_list|,
name|output_section_statement
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|CONST
name|char
modifier|*
name|target
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_wild_statement_enum
case|:
name|wild
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|s
operator|->
name|wild_statement
operator|.
name|section_name
argument_list|,
name|s
operator|->
name|wild_statement
operator|.
name|filename
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|output_section_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
break|break;
case|case
name|lang_target_statement_enum
case|:
name|target
operator|=
name|s
operator|->
name|target_statement
operator|.
name|target
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|map_input_to_output_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|target
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
case|case
name|lang_input_section_enum
case|:
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_data_statement_enum
case|:
case|case
name|lang_reloc_statement_enum
case|:
case|case
name|lang_padding_statement_enum
case|:
case|case
name|lang_input_statement_enum
case|:
if|if
condition|(
name|output_section_statement
operator|!=
name|NULL
operator|&&
name|output_section_statement
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
if|if
condition|(
name|output_section_statement
operator|!=
name|NULL
operator|&&
name|output_section_statement
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|output_section_statement
argument_list|)
expr_stmt|;
comment|/* Make sure that any sections mentioned in the assignment              are initialized.  */
name|exp_init_os
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
comment|/* Mark the specified section with the supplied address */
block|{
name|lang_output_section_statement_type
modifier|*
name|os
init|=
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|address_statement
operator|.
name|section_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
name|init_os
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|os
operator|->
name|addr_tree
operator|=
name|s
operator|->
name|address_statement
operator|.
name|address
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_output_section_statement
parameter_list|(
name|output_section_statement
parameter_list|)
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
block|{
name|asection
modifier|*
name|section
init|=
name|output_section_statement
operator|->
name|bfd_section
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|output_section_statement
operator|!=
name|abs_output_section
condition|)
block|{
name|minfo
argument_list|(
literal|"\n%s"
argument_list|,
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
name|print_dot
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|output_section_statement
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W"
argument_list|,
name|section
operator|->
name|vma
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_section_statement
operator|->
name|load_base
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|addr
operator|=
name|exp_get_abs_int
argument_list|(
name|output_section_statement
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|" load address 0x%V"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
name|print_nl
argument_list|()
expr_stmt|;
block|}
name|print_statement_list
argument_list|(
name|output_section_statement
operator|->
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_assignment
parameter_list|(
name|assignment
parameter_list|,
name|output_section
parameter_list|)
name|lang_assignment_statement_type
modifier|*
name|assignment
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|etree_value_type
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|result
operator|=
name|exp_fold_tree
argument_list|(
name|assignment
operator|->
name|exp
operator|->
name|assign
operator|.
name|src
argument_list|,
name|output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|print_dot
argument_list|,
operator|&
name|print_dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|valid
condition|)
name|minfo
argument_list|(
literal|"0x%V"
argument_list|,
name|result
operator|.
name|value
operator|+
name|result
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
else|else
block|{
name|minfo
argument_list|(
literal|"*undef*   "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|minfo
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|minfo
argument_list|(
literal|"                "
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|assignment
operator|->
name|exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_input_statement
parameter_list|(
name|statm
parameter_list|)
name|lang_input_statement_type
modifier|*
name|statm
decl_stmt|;
block|{
if|if
condition|(
name|statm
operator|->
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"LOAD %s\n"
argument_list|,
name|statm
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print all symbols defined in a particular section.  This is called    via bfd_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|print_one_symbol
parameter_list|(
name|hash_entry
parameter_list|,
name|ptr
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|hash_entry
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
operator|(
name|asection
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash_entry
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sec
operator|==
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V   "
argument_list|,
operator|(
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|hash_entry
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"             %T\n"
argument_list|,
name|hash_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Print information about an input section to the map file.  */
end_comment

begin_function
specifier|static
name|void
name|print_input_section
parameter_list|(
name|in
parameter_list|)
name|lang_input_section_type
modifier|*
name|in
decl_stmt|;
block|{
name|asection
modifier|*
name|i
init|=
name|in
operator|->
name|section
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|i
operator|->
name|_cooked_size
else|:
name|i
operator|->
name|_raw_size
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|i
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|SECTION_NAME_MAP_LENGTH
operator|-
literal|1
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %B\n"
argument_list|,
name|i
operator|->
name|output_section
operator|->
name|vma
operator|+
name|i
operator|->
name|output_offset
argument_list|,
name|size
argument_list|,
name|i
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
operator|&&
name|i
operator|->
name|_cooked_size
operator|!=
name|i
operator|->
name|_raw_size
condition|)
block|{
name|len
operator|=
name|SECTION_NAME_MAP_LENGTH
operator|+
literal|3
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD64
name|len
operator|+=
literal|16
expr_stmt|;
else|#
directive|else
name|len
operator|+=
literal|8
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%W (size before relaxing)\n"
argument_list|,
name|i
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|print_one_symbol
argument_list|,
operator|(
name|PTR
operator|)
name|i
argument_list|)
expr_stmt|;
name|print_dot
operator|=
name|i
operator|->
name|output_section
operator|->
name|vma
operator|+
name|i
operator|->
name|output_offset
operator|+
name|size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_fill_statement
parameter_list|(
name|fill
parameter_list|)
name|lang_fill_statement_type
modifier|*
name|fill
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" FILL mask 0x%x\n"
argument_list|,
name|fill
operator|->
name|fill
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_data_statement
parameter_list|(
name|data
parameter_list|)
name|lang_data_statement_type
modifier|*
name|data
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|data
operator|->
name|output_vma
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|data
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
name|name
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
name|name
operator|=
literal|"SHORT"
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
name|name
operator|=
literal|"LONG"
expr_stmt|;
break|break;
case|case
name|QUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
name|name
operator|=
literal|"QUAD"
expr_stmt|;
break|break;
block|}
name|minfo
argument_list|(
literal|"0x%V %W %s 0x%v"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|name
argument_list|,
name|data
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|exp
operator|->
name|type
operator|.
name|node_class
operator|!=
name|etree_value
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
name|exp_print_tree
argument_list|(
name|data
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an address statement.  These are generated by options like    -Ttext.  */
end_comment

begin_function
specifier|static
name|void
name|print_address_statement
parameter_list|(
name|address
parameter_list|)
name|lang_address_statement_type
modifier|*
name|address
decl_stmt|;
block|{
name|minfo
argument_list|(
literal|"Address of section %s set to "
argument_list|,
name|address
operator|->
name|section_name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|address
operator|->
name|address
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a reloc statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_reloc_statement
parameter_list|(
name|reloc
parameter_list|)
name|lang_reloc_statement_type
modifier|*
name|reloc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|;
name|i
operator|++
control|)
name|print_space
argument_list|()
expr_stmt|;
name|addr
operator|=
name|reloc
operator|->
name|output_vma
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|reloc
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|reloc
operator|->
name|howto
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W RELOC %s "
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|->
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"%s+"
argument_list|,
name|reloc
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|exp_print_tree
argument_list|(
name|reloc
operator|->
name|addend_exp
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_padding_statement
parameter_list|(
name|s
parameter_list|)
name|lang_padding_statement_type
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|minfo
argument_list|(
literal|" *fill*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
expr|" *fill*"
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|SECTION_NAME_MAP_LENGTH
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|addr
operator|=
name|s
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|addr
operator|+=
name|s
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|minfo
argument_list|(
literal|"0x%V %W"
argument_list|,
name|addr
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fill
operator|!=
literal|0
condition|)
name|minfo
argument_list|(
literal|" %u"
argument_list|,
name|s
operator|->
name|fill
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_dot
operator|=
name|addr
operator|+
name|s
operator|->
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_wild_statement
parameter_list|(
name|w
parameter_list|,
name|os
parameter_list|)
name|lang_wild_statement_type
modifier|*
name|w
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
name|print_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|w
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|section_name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"(%s)"
argument_list|,
name|w
operator|->
name|section_name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"(*)"
argument_list|)
expr_stmt|;
name|print_nl
argument_list|()
expr_stmt|;
name|print_statement_list
argument_list|(
name|w
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a group statement.  */
end_comment

begin_function
specifier|static
name|void
name|print_group
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_group_statement_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"START GROUP\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|s
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"END GROUP\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the list of statements in S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement_list
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the first statement in statement list S.    This can be called for any statement type.  */
end_comment

begin_function
specifier|static
name|void
name|print_statement
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"Fail with %d\n"
argument_list|,
name|s
operator|->
name|header
operator|.
name|type
argument_list|)
expr_stmt|;
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_constructors_statement_enum
case|:
if|if
condition|(
name|constructor_list
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|minfo
argument_list|(
literal|" CONSTRUCTORS\n"
argument_list|)
expr_stmt|;
name|print_statement_list
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|print_wild_statement
argument_list|(
operator|&
name|s
operator|->
name|wild_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
name|print_address_statement
argument_list|(
operator|&
name|s
operator|->
name|address_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|minfo
argument_list|(
literal|" CREATE_OBJECT_SYMBOLS\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|print_fill_statement
argument_list|(
operator|&
name|s
operator|->
name|fill_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
name|print_data_statement
argument_list|(
operator|&
name|s
operator|->
name|data_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_reloc_statement_enum
case|:
name|print_reloc_statement
argument_list|(
operator|&
name|s
operator|->
name|reloc_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
name|print_input_section
argument_list|(
operator|&
name|s
operator|->
name|input_section
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|print_padding_statement
argument_list|(
operator|&
name|s
operator|->
name|padding_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
name|print_output_section_statement
argument_list|(
operator|&
name|s
operator|->
name|output_section_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
name|print_assignment
argument_list|(
operator|&
name|s
operator|->
name|assignment_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_target_statement_enum
case|:
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"TARGET(%s)\n"
argument_list|,
name|s
operator|->
name|target_statement
operator|.
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
name|minfo
argument_list|(
literal|"OUTPUT(%s"
argument_list|,
name|s
operator|->
name|output_statement
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_target
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|" %s"
argument_list|,
name|output_target
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_statement_enum
case|:
name|print_input_statement
argument_list|(
operator|&
name|s
operator|->
name|input_statement
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|print_group
argument_list|(
operator|&
name|s
operator|->
name|group_statement
argument_list|,
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_afile_asection_pair_statement_enum
case|:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_statements
parameter_list|()
block|{
name|print_statement_list
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the first N statements in statement list S to STDERR.    If N == 0, nothing is printed.    If N< 0, the entire list is printed.    Intended to be called from GDB.  */
end_comment

begin_function
name|void
name|dprint_statement
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|FILE
modifier|*
name|map_save
init|=
name|config
operator|.
name|map_file
decl_stmt|;
name|config
operator|.
name|map_file
operator|=
name|stderr
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|print_statement_list
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|s
operator|&&
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|print_statement
argument_list|(
name|s
argument_list|,
name|abs_output_section
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
name|config
operator|.
name|map_file
operator|=
name|map_save
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|insert_pad
parameter_list|(
name|this_ptr
parameter_list|,
name|fill
parameter_list|,
name|power
parameter_list|,
name|output_section_statement
parameter_list|,
name|dot
parameter_list|)
name|lang_statement_union_type
modifier|*
modifier|*
name|this_ptr
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|unsigned
name|int
name|power
decl_stmt|;
name|asection
modifier|*
name|output_section_statement
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
comment|/* Align this section first to the      input sections requirement, then      to the output section's requirement.      If this alignment is> than any seen before,      then record it too. Perform the alignment by      inserting a magic 'padding' statement.      */
name|unsigned
name|int
name|alignment_needed
init|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|power
argument_list|)
operator|-
name|dot
decl_stmt|;
if|if
condition|(
name|alignment_needed
operator|!=
literal|0
condition|)
block|{
name|lang_statement_union_type
modifier|*
name|new
init|=
operator|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_padding_statement_type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Link into existing chain */
name|new
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|this_ptr
expr_stmt|;
operator|*
name|this_ptr
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|type
operator|=
name|lang_padding_statement_enum
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|output_section
operator|=
name|output_section_statement
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|vma
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|fill
operator|=
name|fill
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|size
operator|=
name|alignment_needed
expr_stmt|;
block|}
comment|/* Remember the most restrictive alignment */
if|if
condition|(
name|power
operator|>
name|output_section_statement
operator|->
name|alignment_power
condition|)
block|{
name|output_section_statement
operator|->
name|alignment_power
operator|=
name|power
expr_stmt|;
block|}
name|output_section_statement
operator|->
name|_raw_size
operator|+=
name|alignment_needed
expr_stmt|;
return|return
name|alignment_needed
operator|+
name|dot
return|;
block|}
end_function

begin_comment
comment|/* Work out how much this section will move the dot point */
end_comment

begin_function
specifier|static
name|bfd_vma
name|size_input_section
parameter_list|(
name|this_ptr
parameter_list|,
name|output_section_statement
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|,
name|relax
parameter_list|)
name|lang_statement_union_type
modifier|*
modifier|*
name|this_ptr
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|boolean
name|relax
decl_stmt|;
block|{
name|lang_input_section_type
modifier|*
name|is
init|=
operator|&
operator|(
operator|(
operator|*
name|this_ptr
operator|)
operator|->
name|input_section
operator|)
decl_stmt|;
name|asection
modifier|*
name|i
init|=
name|is
operator|->
name|section
decl_stmt|;
if|if
condition|(
name|is
operator|->
name|ifile
operator|->
name|just_syms_flag
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|output_section_statement
operator|->
name|subsection_alignment
operator|!=
operator|-
literal|1
condition|)
name|i
operator|->
name|alignment_power
operator|=
name|output_section_statement
operator|->
name|subsection_alignment
expr_stmt|;
name|dot
operator|=
name|insert_pad
argument_list|(
name|this_ptr
argument_list|,
name|fill
argument_list|,
name|i
operator|->
name|alignment_power
argument_list|,
name|output_section_statement
operator|->
name|bfd_section
argument_list|,
name|dot
argument_list|)
expr_stmt|;
comment|/* Remember where in the output section this input section goes */
name|i
operator|->
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
comment|/* Mark how big the output section must be to contain this now 	 */
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dot
operator|+=
name|i
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dot
operator|+=
name|i
operator|->
name|_raw_size
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
else|else
block|{
name|i
operator|->
name|output_offset
operator|=
name|i
operator|->
name|vma
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_comment
comment|/* This variable indicates whether bfd_relax_section should be called    again.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|relax_again
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the sizes for all the output sections.  */
end_comment

begin_function
name|bfd_vma
name|lang_size_sections
parameter_list|(
name|s
parameter_list|,
name|output_section_statement
parameter_list|,
name|prev
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|,
name|relax
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|prev
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|boolean
name|relax
decl_stmt|;
block|{
comment|/* Size up the sections from their constituent parts */
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|bfd_vma
name|after
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
init|=
operator|&
name|s
operator|->
name|output_section_statement
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
block|{
comment|/* This section was never actually created.  */
break|break;
block|}
comment|/* If this is a COFF shared library section, use the size and 	  address from the input section.  FIXME: This is COFF 	  specific; it would be cleaner if there were some other way 	  to do this, but nothing simple comes to mind.  */
if|if
condition|(
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|input
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|children
operator|.
name|head
operator|==
name|NULL
operator|||
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|next
operator|!=
name|NULL
operator|||
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|header
operator|.
name|type
operator|!=
name|lang_input_section_enum
condition|)
name|einfo
argument_list|(
literal|"%P%X: Internal error on COFF shared library section %s"
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
name|input
operator|=
name|os
operator|->
name|children
operator|.
name|head
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|bfd_section_vma
argument_list|(
name|input
operator|->
name|owner
argument_list|,
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|=
name|input
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
condition|)
block|{
comment|/* No matter what happens, an abs section starts at zero */
name|ASSERT
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No address specified for this section, get one 	      from the region specification 	      */
if|if
condition|(
name|os
operator|->
name|region
operator|==
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|os
operator|->
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
literal|"*default*"
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|os
operator|->
name|region
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|section_alignment
operator|==
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|olddot
decl_stmt|;
name|olddot
operator|=
name|dot
expr_stmt|;
name|dot
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|alignment_power
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|olddot
operator|&&
name|config
operator|.
name|warn_section_align
condition|)
name|einfo
argument_list|(
literal|"%P: warning: changing start of section %s by %u bytes\n"
argument_list|,
name|os
operator|->
name|name
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|dot
operator|-
name|olddot
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|etree_value_type
name|r
decl_stmt|;
name|r
operator|=
name|exp_fold_tree
argument_list|(
name|os
operator|->
name|addr_tree
argument_list|,
name|abs_output_section
argument_list|,
name|lang_allocating_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|valid
operator|==
name|false
condition|)
block|{
name|einfo
argument_list|(
literal|"%F%S: non constant address expression for section %s\n"
argument_list|,
name|os
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|r
operator|.
name|value
operator|+
name|r
operator|.
name|section
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* The section starts here */
comment|/* First, align to what the section needs */
if|if
condition|(
name|os
operator|->
name|section_alignment
operator|!=
operator|-
literal|1
condition|)
name|dot
operator|=
name|align_power
argument_list|(
name|dot
argument_list|,
name|os
operator|->
name|section_alignment
argument_list|)
expr_stmt|;
name|bfd_set_section_vma
argument_list|(
literal|0
argument_list|,
name|os
operator|->
name|bfd_section
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|os
operator|->
name|bfd_section
operator|->
name|output_offset
operator|=
literal|0
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lang_size_sections
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
operator|&
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
comment|/* Ignore the size of the input sections, use the vma and size to */
comment|/* align against */
name|after
operator|=
name|ALIGN_N
argument_list|(
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
argument_list|,
comment|/* The coercion here is important, see ld.h.  */
operator|(
name|bfd_vma
operator|)
name|os
operator|->
name|block_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|os
operator|->
name|bfd_section
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|after
operator|==
name|os
operator|->
name|bfd_section
operator|->
name|vma
argument_list|)
expr_stmt|;
else|else
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|=
name|after
operator|-
name|os
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
expr_stmt|;
name|os
operator|->
name|processed
operator|=
name|true
expr_stmt|;
comment|/* Replace into region ? */
if|if
condition|(
name|os
operator|->
name|region
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|os
operator|->
name|region
operator|->
name|current
operator|=
name|dot
expr_stmt|;
comment|/* Make sure this isn't silly.  */
if|if
condition|(
name|os
operator|->
name|region
operator|->
name|current
operator|<
name|os
operator|->
name|region
operator|->
name|origin
operator|||
operator|(
name|os
operator|->
name|region
operator|->
name|current
operator|-
name|os
operator|->
name|region
operator|->
name|origin
operator|>
name|os
operator|->
name|region
operator|->
name|length
operator|)
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|!=
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
literal|"%X%P: address 0x%v of %B section %s is not within region %s\n"
argument_list|,
name|os
operator|->
name|region
operator|->
name|current
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|,
name|os
operator|->
name|region
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
literal|"%X%P: region %s is full (%B section %s)\n"
argument_list|,
name|os
operator|->
name|region
operator|->
name|name
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|owner
argument_list|,
name|os
operator|->
name|bfd_section
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the region pointer.  */
name|os
operator|->
name|region
operator|->
name|current
operator|=
name|os
operator|->
name|region
operator|->
name|origin
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_data_statement_enum
case|:
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_vma
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
name|size
operator|=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|size
operator|=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|size
operator|=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|size
operator|=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
name|dot
operator|+=
name|size
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
comment|/* The output section gets contents, and then we inspect for 	  any flags set in the input script which override any ALLOC */
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|output_section_statement
operator|->
name|flags
operator|&
name|SEC_NEVER_LOAD
operator|)
condition|)
block|{
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|int
name|size
decl_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_vma
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
expr_stmt|;
name|dot
operator|+=
name|size
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
name|link_info
operator|.
name|create_object_symbols_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
break|break;
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|i
decl_stmt|;
name|i
operator|=
operator|(
operator|*
name|prev
operator|)
operator|->
name|input_section
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|relax
condition|)
block|{
if|if
condition|(
name|i
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|i
operator|->
name|_cooked_size
operator|=
name|i
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|again
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_relax_section
argument_list|(
name|i
operator|->
name|owner
argument_list|,
name|i
argument_list|,
operator|&
name|link_info
argument_list|,
operator|&
name|again
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P%F: can't relax section: %E\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
name|relax_again
operator|=
name|true
expr_stmt|;
block|}
name|dot
operator|=
name|size_input_section
argument_list|(
name|prev
argument_list|,
name|output_section_statement
argument_list|,
name|output_section_statement
operator|->
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|s
operator|->
name|fill_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
block|{
name|bfd_vma
name|newdot
init|=
name|dot
decl_stmt|;
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
argument_list|,
name|lang_allocating_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|newdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdot
operator|!=
name|dot
operator|&&
operator|!
name|relax
condition|)
block|{
comment|/* The assignment changed dot.  Insert a pad.  */
if|if
condition|(
name|output_section_statement
operator|==
name|abs_output_section
condition|)
block|{
comment|/* If we don't have an output section, then just adjust 		  the default memory address.  */
name|lang_memory_region_lookup
argument_list|(
literal|"*default*"
argument_list|)
operator|->
name|current
operator|=
name|newdot
expr_stmt|;
block|}
else|else
block|{
name|lang_statement_union_type
modifier|*
name|new
init|=
operator|(
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_padding_statement_type
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Link into existing chain */
name|new
operator|->
name|header
operator|.
name|next
operator|=
operator|*
name|prev
expr_stmt|;
operator|*
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|header
operator|.
name|type
operator|=
name|lang_padding_statement_enum
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|output_section
operator|=
name|output_section_statement
operator|->
name|bfd_section
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|fill
operator|=
name|fill
expr_stmt|;
name|new
operator|->
name|padding_statement
operator|.
name|size
operator|=
name|newdot
operator|-
name|dot
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|new
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
block|}
name|dot
operator|=
name|newdot
expr_stmt|;
block|}
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
comment|/* If we are relaxing, and this is not the first pass, some 	padding statements may have been inserted during previous 	passes.  We may have to move the padding statement to a new 	location if dot has a different value at this point in this 	pass than it did at this point in the previous pass.  */
name|s
operator|->
name|padding_statement
operator|.
name|output_offset
operator|=
name|dot
operator|-
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
name|dot
operator|+=
name|s
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
name|output_section_statement
operator|->
name|bfd_section
operator|->
name|_raw_size
operator|+=
name|s
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_size_sections
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
operator|&
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|,
name|relax
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
comment|/* This can only get here when relaxing is turned on */
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
name|prev
operator|=
operator|&
name|s
operator|->
name|header
operator|.
name|next
expr_stmt|;
block|}
return|return
name|dot
return|;
block|}
end_function

begin_function
name|bfd_vma
name|lang_do_assignments
parameter_list|(
name|s
parameter_list|,
name|output_section_statement
parameter_list|,
name|fill
parameter_list|,
name|dot
parameter_list|)
name|lang_statement_union_type
modifier|*
name|s
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|output_section_statement
decl_stmt|;
name|fill_type
name|fill
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
block|{
for|for
control|(
init|;
name|s
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|s
operator|->
name|header
operator|.
name|type
condition|)
block|{
case|case
name|lang_constructors_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|constructor_list
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_output_section_statement_enum
case|:
block|{
name|lang_output_section_statement_type
modifier|*
name|os
init|=
operator|&
operator|(
name|s
operator|->
name|output_section_statement
operator|)
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
expr_stmt|;
operator|(
name|void
operator|)
name|lang_do_assignments
argument_list|(
name|os
operator|->
name|children
operator|.
name|head
argument_list|,
name|os
argument_list|,
name|os
operator|->
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
name|dot
operator|=
name|os
operator|->
name|bfd_section
operator|->
name|vma
operator|+
name|os
operator|->
name|bfd_section
operator|->
name|_raw_size
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|load_base
condition|)
block|{
comment|/* If nothing has been placed into the output section then 		   it won't have a bfd_section. */
if|if
condition|(
name|os
operator|->
name|bfd_section
condition|)
block|{
name|os
operator|->
name|bfd_section
operator|->
name|lma
operator|=
name|exp_get_abs_int
argument_list|(
name|os
operator|->
name|load_base
argument_list|,
literal|0
argument_list|,
literal|"load base"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|lang_wild_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|s
operator|->
name|wild_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_object_symbols_statement_enum
case|:
case|case
name|lang_output_statement_enum
case|:
case|case
name|lang_target_statement_enum
case|:
if|#
directive|if
literal|0
block|case lang_common_statement_enum:
endif|#
directive|endif
break|break;
case|case
name|lang_data_statement_enum
case|:
block|{
name|etree_value_type
name|value
decl_stmt|;
name|value
operator|=
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|data_statement
operator|.
name|exp
argument_list|,
name|abs_output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
name|s
operator|->
name|data_statement
operator|.
name|value
operator|=
name|value
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|valid
operator|==
name|false
condition|)
name|einfo
argument_list|(
literal|"%F%P: invalid data statement\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|s
operator|->
name|data_statement
operator|.
name|type
condition|)
block|{
case|case
name|QUAD
case|:
name|dot
operator|+=
name|QUAD_SIZE
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|dot
operator|+=
name|LONG_SIZE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|dot
operator|+=
name|SHORT_SIZE
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|dot
operator|+=
name|BYTE_SIZE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|lang_reloc_statement_enum
case|:
block|{
name|etree_value_type
name|value
decl_stmt|;
name|value
operator|=
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|addend_exp
argument_list|,
name|abs_output_section
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
name|s
operator|->
name|reloc_statement
operator|.
name|addend_value
operator|=
name|value
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|valid
operator|==
name|false
condition|)
name|einfo
argument_list|(
literal|"%F%P: invalid reloc statement\n"
argument_list|)
expr_stmt|;
block|}
name|dot
operator|+=
name|bfd_get_reloc_size
argument_list|(
name|s
operator|->
name|reloc_statement
operator|.
name|howto
argument_list|)
expr_stmt|;
break|break;
case|case
name|lang_input_section_enum
case|:
block|{
name|asection
modifier|*
name|in
init|=
name|s
operator|->
name|input_section
operator|.
name|section
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dot
operator|+=
name|in
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dot
operator|+=
name|in
operator|->
name|_raw_size
expr_stmt|;
block|}
break|break;
case|case
name|lang_input_statement_enum
case|:
break|break;
case|case
name|lang_fill_statement_enum
case|:
name|fill
operator|=
name|s
operator|->
name|fill_statement
operator|.
name|fill
expr_stmt|;
break|break;
case|case
name|lang_assignment_statement_enum
case|:
block|{
name|exp_fold_tree
argument_list|(
name|s
operator|->
name|assignment_statement
operator|.
name|exp
argument_list|,
name|output_section_statement
argument_list|,
name|lang_final_phase_enum
argument_list|,
name|dot
argument_list|,
operator|&
name|dot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lang_padding_statement_enum
case|:
name|dot
operator|+=
name|s
operator|->
name|padding_statement
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|lang_group_statement_enum
case|:
name|dot
operator|=
name|lang_do_assignments
argument_list|(
name|s
operator|->
name|group_statement
operator|.
name|children
operator|.
name|head
argument_list|,
name|output_section_statement
argument_list|,
name|fill
argument_list|,
name|dot
argument_list|)
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|()
expr_stmt|;
break|break;
case|case
name|lang_address_statement_enum
case|:
break|break;
block|}
block|}
return|return
name|dot
return|;
block|}
end_function

begin_comment
comment|/* Fix any .startof. or .sizeof. symbols.  When the assemblers see the    operator .startof. (section_name), it produces an undefined symbol    .startof.section_name.  Similarly, when it sees    .sizeof. (section_name), it produces an undefined symbol    .sizeof.section_name.  For all the output sections, we look for    such symbols, and set them to the correct value.  */
end_comment

begin_function
specifier|static
name|void
name|lang_set_startof
parameter_list|()
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
return|return;
for|for
control|(
name|s
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|secname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".startof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".sizeof.%s"
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|buf
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lang_finish
parameter_list|()
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|warn
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
operator|||
name|link_info
operator|.
name|shared
condition|)
name|warn
operator|=
name|false
expr_stmt|;
else|else
name|warn
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|entry_symbol
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No entry has been specified.  Look for start, but don't warn 	 if we don't find it.  */
name|entry_symbol
operator|=
literal|"start"
expr_stmt|;
name|warn
operator|=
name|false
expr_stmt|;
block|}
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|entry_symbol
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|val
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P%F:%s: can't set start address\n"
argument_list|,
name|entry_symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|ts
decl_stmt|;
comment|/* Can't find the entry symbol.  Use the first address in the 	 text section.  */
name|ts
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
literal|"%P: warning: cannot find entry symbol %s; defaulting to %V\n"
argument_list|,
name|entry_symbol
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|ts
argument_list|)
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%P%F: can't set start address\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warn
condition|)
name|einfo
argument_list|(
literal|"%P: warning: cannot find entry symbol %s; not setting start address\n"
argument_list|,
name|entry_symbol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check that the architecture of all the input files is compatible    with the output file.  Also call the backend to let it do any    other checking that is needed.  */
end_comment

begin_function
specifier|static
name|void
name|lang_check
parameter_list|()
block|{
name|lang_statement_union_type
modifier|*
name|file
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|CONST
name|bfd_arch_info_type
modifier|*
name|compatible
decl_stmt|;
for|for
control|(
name|file
operator|=
name|file_chain
operator|.
name|head
init|;
name|file
operator|!=
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|NULL
condition|;
name|file
operator|=
name|file
operator|->
name|input_statement
operator|.
name|next
control|)
block|{
name|input_bfd
operator|=
name|file
operator|->
name|input_statement
operator|.
name|the_bfd
expr_stmt|;
name|compatible
operator|=
name|bfd_arch_get_compatible
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|compatible
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"
argument_list|,
name|bfd_printable_name
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bfd_merge_private_bfd_data
argument_list|(
name|input_bfd
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look through all the global common symbols and attach them to the    correct section.  The -sort-common command line switch may be used    to roughly sort the entries by size.  */
end_comment

begin_function
specifier|static
name|void
name|lang_common
parameter_list|()
block|{
if|if
condition|(
name|link_info
operator|.
name|relocateable
operator|&&
operator|!
name|command_line
operator|.
name|force_common_definition
condition|)
return|return;
if|if
condition|(
operator|!
name|config
operator|.
name|sort_common
condition|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|power
decl_stmt|;
for|for
control|(
name|power
operator|=
literal|4
init|;
name|power
operator|>=
literal|0
condition|;
name|power
operator|--
control|)
name|bfd_link_hash_traverse
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|lang_one_common
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|power
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Place one common symbol in the correct section.  */
end_comment

begin_function
specifier|static
name|boolean
name|lang_one_common
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|info
decl_stmt|;
block|{
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_vma
name|size
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_common
condition|)
return|return
name|true
return|;
name|size
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
name|power_of_two
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|alignment_power
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|sort_common
operator|&&
name|power_of_two
operator|<
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
name|info
condition|)
return|return
name|true
return|;
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
expr_stmt|;
comment|/* Increase the size of the section.  */
name|section
operator|->
name|_raw_size
operator|=
name|ALIGN_N
argument_list|(
name|section
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust the alignment if necessary.  */
if|if
condition|(
name|power_of_two
operator|>
name|section
operator|->
name|alignment_power
condition|)
name|section
operator|->
name|alignment_power
operator|=
name|power_of_two
expr_stmt|;
comment|/* Change the symbol from common to defined.  */
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|section
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increase the size of the section.  */
name|section
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
comment|/* Make sure the section is allocated in memory, and make sure that      it is no longer a common section.  */
name|section
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|section
operator|->
name|flags
operator|&=
operator|~
name|SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|boolean
name|header_printed
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|minfo
argument_list|(
literal|"\nAllocating common symbols\n"
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"Common symbol       size              file\n\n"
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|true
expr_stmt|;
block|}
name|name
operator|=
name|demangle
argument_list|(
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|19
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|20
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0xffffffff
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|else
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|16
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%B\n"
argument_list|,
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* run through the input files and ensure that every input section has somewhere to go. If one is found without a destination then create an input request and place it into the statement tree. */
end_comment

begin_function
specifier|static
name|void
name|lang_place_orphans
parameter_list|()
block|{
name|lang_input_statement_type
modifier|*
name|file
decl_stmt|;
for|for
control|(
name|file
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|file_chain
operator|.
name|head
init|;
name|file
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|file
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|file
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|file
operator|->
name|the_bfd
operator|->
name|sections
init|;
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This section of the file is not attatched, root 	         around for a sensible place for it to go */
if|if
condition|(
name|file
operator|->
name|just_syms_flag
condition|)
block|{
comment|/* We are only retrieving symbol values from this                      file.  We want the symbols to act as though the                      values in the file are absolute.  */
name|s
operator|->
name|output_section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|s
operator|->
name|output_offset
operator|=
name|s
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a lonely common section which must have 		     come from an archive.  We attach to the section 		     with the wildcard.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|||
name|command_line
operator|.
name|force_common_definition
condition|)
block|{
if|if
condition|(
name|default_common_section
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This message happens when using the                              svr3.ifile linker script, so I have                              disabled it.  */
block|info_msg ("%P: no [COMMON] command, defaulting to .bss\n");
endif|#
directive|endif
name|default_common_section
operator|=
name|lang_output_section_statement_lookup
argument_list|(
literal|".bss"
argument_list|)
expr_stmt|;
block|}
name|wild_doit
argument_list|(
operator|&
name|default_common_section
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|default_common_section
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ldemul_place_orphan
argument_list|(
name|file
argument_list|,
name|s
argument_list|)
condition|)
empty_stmt|;
else|else
block|{
name|lang_output_section_statement_type
modifier|*
name|os
init|=
name|lang_output_section_statement_lookup
argument_list|(
name|s
operator|->
name|name
argument_list|)
decl_stmt|;
name|wild_doit
argument_list|(
operator|&
name|os
operator|->
name|children
argument_list|,
name|s
argument_list|,
name|os
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|lang_set_flags
parameter_list|(
name|ptr
parameter_list|,
name|flags
parameter_list|)
name|int
modifier|*
name|ptr
decl_stmt|;
name|CONST
name|char
modifier|*
name|flags
decl_stmt|;
block|{
name|boolean
name|state
init|=
name|false
decl_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|flags
condition|)
block|{
if|if
condition|(
operator|*
name|flags
operator|==
literal|'!'
condition|)
block|{
name|state
operator|=
name|false
expr_stmt|;
name|flags
operator|++
expr_stmt|;
block|}
else|else
name|state
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
operator|*
name|flags
condition|)
block|{
case|case
literal|'R'
case|:
comment|/*	  ptr->flag_read = state; */
break|break;
case|case
literal|'W'
case|:
comment|/*	  ptr->flag_write = state; */
break|break;
case|case
literal|'X'
case|:
comment|/*	  ptr->flag_executable= state;*/
break|break;
case|case
literal|'L'
case|:
case|case
literal|'I'
case|:
comment|/*	  ptr->flag_loadable= state;*/
break|break;
default|default:
name|einfo
argument_list|(
literal|"%P%F: invalid syntax in flags\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|flags
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Call a function on each input file.  This function will be called    on an archive, but not on the elements.  */
end_comment

begin_function_decl
name|void
name|lang_for_each_input_file
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|input_file_chain
operator|.
name|head
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next_real_file
control|)
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Call a function on each file.  The function will be called on all    the elements of an archive which are included in the link, but will    not be called on the archive file itself.  */
end_comment

begin_function_decl
name|void
name|lang_for_each_file
parameter_list|(
name|func
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lang_input_statement_type
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|file_chain
operator|.
name|head
init|;
name|f
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|;
name|f
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|f
operator|->
name|next
control|)
block|{
name|func
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not used.  */
end_comment

begin_endif
unit|void lang_for_each_input_section (func)      void (*func) PARAMS ((bfd * ab, asection * as)); {   lang_input_statement_type *f;    for (f = (lang_input_statement_type *) file_chain.head;        f != (lang_input_statement_type *) NULL;        f = (lang_input_statement_type *) f->next)     {       asection *s;        for (s = f->the_bfd->sections; 	   s != (asection *) NULL; 	   s = s->next) 	{ 	  func (f->the_bfd, s); 	}     } }
endif|#
directive|endif
end_endif

begin_function
name|void
name|ldlang_add_file
parameter_list|(
name|entry
parameter_list|)
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
block|{
name|bfd
modifier|*
modifier|*
name|pp
decl_stmt|;
name|lang_statement_append
argument_list|(
operator|&
name|file_chain
argument_list|,
operator|(
name|lang_statement_union_type
operator|*
operator|)
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/* The BFD linker needs to have a list of all input BFDs involved in      a link.  */
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|->
name|link_next
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|entry
operator|->
name|the_bfd
operator|!=
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|link_info
operator|.
name|input_bfds
init|;
operator|*
name|pp
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|link_next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|entry
operator|->
name|the_bfd
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|->
name|usrdata
operator|=
operator|(
name|PTR
operator|)
name|entry
expr_stmt|;
name|bfd_set_gp_size
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|g_switch_value
argument_list|)
expr_stmt|;
comment|/* Look through the sections and check for any which should not be      included in the link.  We need to do this now, so that we can      notice when the backend linker tries to report multiple      definition errors for symbols which are in sections we aren't      going to link.  FIXME: It might be better to entirely ignore      symbols which are defined in sections which are going to be      discarded.  This would require modifying the backend linker for      each backend which might set the SEC_LINK_ONCE flag.  If we do      this, we should probably handle SEC_EXCLUDE in the same way.  */
name|bfd_map_over_sections
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|section_already_linked
argument_list|,
operator|(
name|PTR
operator|)
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_output
parameter_list|(
name|name
parameter_list|,
name|from_script
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_script
decl_stmt|;
block|{
comment|/* Make -o on command line override OUTPUT in script.  */
if|if
condition|(
name|had_output_filename
operator|==
name|false
operator|||
operator|!
name|from_script
condition|)
block|{
name|output_filename
operator|=
name|name
expr_stmt|;
name|had_output_filename
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|lang_output_section_statement_type
modifier|*
name|current_section
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|topower
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|unsigned
name|int
name|i
init|=
literal|1
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
literal|32
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|x
condition|)
return|return
name|l
return|;
name|i
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|lang_enter_output_section_statement
parameter_list|(
name|output_section_statement_name
parameter_list|,
name|address_exp
parameter_list|,
name|sectype
parameter_list|,
name|block_value
parameter_list|,
name|align
parameter_list|,
name|subalign
parameter_list|,
name|ebase
parameter_list|)
specifier|const
name|char
modifier|*
name|output_section_statement_name
decl_stmt|;
name|etree_type
modifier|*
name|address_exp
decl_stmt|;
name|enum
name|section_type
name|sectype
decl_stmt|;
name|bfd_vma
name|block_value
decl_stmt|;
name|etree_type
modifier|*
name|align
decl_stmt|;
name|etree_type
modifier|*
name|subalign
decl_stmt|;
name|etree_type
modifier|*
name|ebase
decl_stmt|;
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|current_section
operator|=
name|os
operator|=
name|lang_output_section_statement_lookup
argument_list|(
name|output_section_statement_name
argument_list|)
expr_stmt|;
comment|/* Add this statement to tree */
comment|/*  add_statement(lang_output_section_statement_enum,       output_section_statement);*/
comment|/* Make next things chain into subchain of this */
if|if
condition|(
name|os
operator|->
name|addr_tree
operator|==
operator|(
name|etree_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|os
operator|->
name|addr_tree
operator|=
name|address_exp
expr_stmt|;
block|}
name|os
operator|->
name|sectype
operator|=
name|sectype
expr_stmt|;
if|if
condition|(
name|sectype
operator|!=
name|noload_section
condition|)
name|os
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
else|else
name|os
operator|->
name|flags
operator|=
name|SEC_NEVER_LOAD
expr_stmt|;
name|os
operator|->
name|block_value
operator|=
name|block_value
condition|?
name|block_value
else|:
literal|1
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|os
operator|->
name|children
expr_stmt|;
name|os
operator|->
name|subsection_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|subalign
argument_list|,
operator|-
literal|1
argument_list|,
literal|"subsection alignment"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|section_alignment
operator|=
name|topower
argument_list|(
name|exp_get_value_int
argument_list|(
name|align
argument_list|,
operator|-
literal|1
argument_list|,
literal|"section alignment"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|load_base
operator|=
name|ebase
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_final
parameter_list|()
block|{
name|lang_output_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_output_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|output_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the current counters in the regions */
end_comment

begin_function
specifier|static
name|void
name|reset_memory_regions
parameter_list|()
block|{
name|lang_memory_region_type
modifier|*
name|p
init|=
name|lang_memory_region_list
decl_stmt|;
for|for
control|(
name|p
operator|=
name|lang_memory_region_list
init|;
name|p
operator|!=
operator|(
name|lang_memory_region_type
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|old_length
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|->
name|current
operator|-
name|p
operator|->
name|origin
argument_list|)
expr_stmt|;
name|p
operator|->
name|current
operator|=
name|p
operator|->
name|origin
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_process
parameter_list|()
block|{
name|lang_reasonable_defaults
argument_list|()
expr_stmt|;
name|current_target
operator|=
name|default_target
expr_stmt|;
name|lang_for_each_statement
argument_list|(
name|ldlang_open_output
argument_list|)
expr_stmt|;
comment|/* Open the output file */
name|ldemul_create_output_section_statements
argument_list|()
expr_stmt|;
comment|/* Add to the hash table all undefineds on the command line */
name|lang_place_undefineds
argument_list|()
expr_stmt|;
comment|/* Create a bfd for each input file */
name|current_target
operator|=
name|default_target
expr_stmt|;
name|open_input_bfds
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|ldemul_after_open
argument_list|()
expr_stmt|;
comment|/* Make sure that we're not mixing architectures.  We call this      after all the input files have been opened, but before we do any      other processing, so that any operations merge_private_bfd_data      does on the output file will be known during the rest of the      link.  */
name|lang_check
argument_list|()
expr_stmt|;
comment|/* Build all sets based on the information gathered from the input      files.  */
name|ldctor_build_sets
argument_list|()
expr_stmt|;
comment|/* Size up the common data */
name|lang_common
argument_list|()
expr_stmt|;
comment|/* Run through the contours of the script and attach input sections      to the correct output sections      */
name|map_input_to_output_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|lang_output_section_statement_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find any sections not attached explicitly and handle them */
name|lang_place_orphans
argument_list|()
expr_stmt|;
name|ldemul_before_allocation
argument_list|()
expr_stmt|;
comment|/* We must record the program headers before we try to fix the      section positions, since they will affect SIZEOF_HEADERS.  */
name|lang_record_phdrs
argument_list|()
expr_stmt|;
comment|/* Now run around and relax if we can */
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
block|{
comment|/* First time round is a trial run to get the 'worst case' 	 addresses of the objects if there was no relaxing.  */
name|lang_size_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
operator|(
name|statement_list
operator|.
name|head
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* Keep relaxing until bfd_relax_section gives up.  */
do|do
block|{
name|reset_memory_regions
argument_list|()
expr_stmt|;
name|relax_again
operator|=
name|false
expr_stmt|;
comment|/* Do all the assignments with our current guesses as to 	     section sizes.  */
name|lang_do_assignments
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Perform another relax pass - this time we know where the 	     globals are, so can make better guess.  */
name|lang_size_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
operator|(
name|statement_list
operator|.
name|head
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|relax_again
condition|)
do|;
block|}
else|else
block|{
comment|/* Size up the sections.  */
name|lang_size_sections
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|&
operator|(
name|statement_list
operator|.
name|head
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* See if anything special should be done now we know how big      everything is.  */
name|ldemul_after_allocation
argument_list|()
expr_stmt|;
comment|/* Fix any .startof. or .sizeof. symbols.  */
name|lang_set_startof
argument_list|()
expr_stmt|;
comment|/* Do all the assignments, now that we know the final restingplaces      of all the symbols */
name|lang_do_assignments
argument_list|(
name|statement_list
operator|.
name|head
argument_list|,
name|abs_output_section
argument_list|,
operator|(
name|fill_type
operator|)
literal|0
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Final stuffs */
name|ldemul_finish
argument_list|()
expr_stmt|;
name|lang_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXPORTED TO YACC */
end_comment

begin_function
name|void
name|lang_add_wild
parameter_list|(
name|section_name
parameter_list|,
name|filename
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|section_name
decl_stmt|;
name|CONST
name|char
modifier|*
name|CONST
name|filename
decl_stmt|;
block|{
name|lang_wild_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_wild_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|section_name
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|placed_commons
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|lang_has_input_file
operator|=
name|true
expr_stmt|;
block|}
name|new
operator|->
name|section_name
operator|=
name|section_name
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|new
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_section_start
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|etree_type
modifier|*
name|address
decl_stmt|;
block|{
name|lang_address_statement_type
modifier|*
name|ad
init|=
name|new_stat
argument_list|(
name|lang_address_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|ad
operator|->
name|section_name
operator|=
name|name
expr_stmt|;
name|ad
operator|->
name|address
operator|=
name|address
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the start symbol to NAME.  CMDLINE is nonzero if this is called    because of a -e argument on the command line, or zero if this is    called by ENTRY in a linker script.  Command line arguments take    precedence.  */
end_comment

begin_comment
comment|/* WINDOWS_NT.  When an entry point has been specified, we will also force    this symbol to be defined by calling ldlang_add_undef (equivalent to     having switch -u entry_name on the command line).  The reason we do    this is so that the user doesn't have to because they would have to use    the -u switch if they were specifying an entry point other than     _mainCRTStartup.  Specifically, if creating a windows application, entry    point _WinMainCRTStartup must be specified.      What I have found for non console applications (entry not _mainCRTStartup)    is that the .obj that contains mainCRTStartup is brought in since it is    the first encountered in libc.lib and it has other symbols in it which will    be pulled in by the link process.  To avoid this, adding -u with the entry    point name specified forces the correct .obj to be used.  We can avoid    making the user do this by always adding the entry point name as an    undefined symbol.  */
end_comment

begin_function
name|void
name|lang_add_entry
parameter_list|(
name|name
parameter_list|,
name|cmdline
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|cmdline
decl_stmt|;
block|{
if|if
condition|(
name|entry_symbol
operator|==
name|NULL
operator|||
name|cmdline
operator|||
operator|!
name|entry_from_cmdline
condition|)
block|{
name|entry_symbol
operator|=
name|name
expr_stmt|;
name|entry_from_cmdline
operator|=
name|cmdline
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* don't do this yet.  It seems to work (the executables run), but the       image created is very different from what I was getting before indicating      that something else is being pulled in.  When everything else is working,      then try to put this back in to see if it will do the right thing for      other more complicated applications */
block|ldlang_add_undef (name);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|lang_add_target
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|lang_target_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_target_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|target
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_map
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|name
condition|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'F'
case|:
name|map_option_f
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|name
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_add_fill
parameter_list|(
name|exp
parameter_list|)
name|int
name|exp
decl_stmt|;
block|{
name|lang_fill_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_fill_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|fill
operator|=
name|exp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_data
parameter_list|(
name|type
parameter_list|,
name|exp
parameter_list|)
name|int
name|type
decl_stmt|;
name|union
name|etree_union
modifier|*
name|exp
decl_stmt|;
block|{
name|lang_data_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_data_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a new reloc statement.  RELOC is the BFD relocation type to    generate.  HOWTO is the corresponding howto structure (we could    look this up, but the caller has already done so).  SECTION is the    section to generate a reloc against, or NAME is the name of the    symbol to generate a reloc against.  Exactly one of SECTION and    NAME must be NULL.  ADDEND is an expression for the addend.  */
end_comment

begin_function
name|void
name|lang_add_reloc
parameter_list|(
name|reloc
parameter_list|,
name|howto
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|addend
parameter_list|)
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|union
name|etree_union
modifier|*
name|addend
decl_stmt|;
block|{
name|lang_reloc_statement_type
modifier|*
name|p
init|=
name|new_stat
argument_list|(
name|lang_reloc_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|addend_exp
operator|=
name|addend
expr_stmt|;
name|p
operator|->
name|addend_value
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|output_vma
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_assignment
parameter_list|(
name|exp
parameter_list|)
name|etree_type
modifier|*
name|exp
decl_stmt|;
block|{
name|lang_assignment_statement_type
modifier|*
name|new
init|=
name|new_stat
argument_list|(
name|lang_assignment_statement
argument_list|,
name|stat_ptr
argument_list|)
decl_stmt|;
name|new
operator|->
name|exp
operator|=
name|exp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_add_attribute
parameter_list|(
name|attribute
parameter_list|)
name|enum
name|statement_enum
name|attribute
decl_stmt|;
block|{
name|new_statement
argument_list|(
name|attribute
argument_list|,
sizeof|sizeof
argument_list|(
name|lang_statement_union_type
argument_list|)
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_startup
parameter_list|(
name|name
parameter_list|)
name|CONST
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|startup_file
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%Fmultiple STARTUP files\n"
argument_list|)
expr_stmt|;
block|}
name|first_file
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|local_sym_name
operator|=
name|name
expr_stmt|;
name|first_file
operator|->
name|real
operator|=
name|true
expr_stmt|;
name|startup_file
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_float
parameter_list|(
name|maybe
parameter_list|)
name|boolean
name|maybe
decl_stmt|;
block|{
name|lang_float_flag
operator|=
name|maybe
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lang_leave_output_section_statement
parameter_list|(
name|fill
parameter_list|,
name|memspec
parameter_list|,
name|phdrs
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
specifier|const
name|char
modifier|*
name|memspec
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
block|{
name|current_section
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
name|current_section
operator|->
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|memspec
argument_list|)
expr_stmt|;
name|current_section
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Create an absolute symbol with the given name with the value of the  address of first byte of the section named.   If the symbol already exists, then do nothing. */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_beginning_of
parameter_list|(
name|secname
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Create an absolute symbol with the given name with the value of the  address of the first byte after the end of the section named.   If the symbol already exists, then do nothing. */
end_comment

begin_function
name|void
name|lang_abs_symbol_at_end_of
parameter_list|(
name|secname
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
operator|(
name|bfd_get_section_vma
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
operator|+
name|bfd_section_size
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|)
operator|)
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lang_statement_append
parameter_list|(
name|list
parameter_list|,
name|element
parameter_list|,
name|field
parameter_list|)
name|lang_statement_list_type
modifier|*
name|list
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|element
decl_stmt|;
name|lang_statement_union_type
modifier|*
modifier|*
name|field
decl_stmt|;
block|{
operator|*
operator|(
name|list
operator|->
name|tail
operator|)
operator|=
name|element
expr_stmt|;
name|list
operator|->
name|tail
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output format type.  -oformat overrides scripts.  */
end_comment

begin_function
name|void
name|lang_add_output_format
parameter_list|(
name|format
parameter_list|,
name|big
parameter_list|,
name|little
parameter_list|,
name|from_script
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
name|big
decl_stmt|;
specifier|const
name|char
modifier|*
name|little
decl_stmt|;
name|int
name|from_script
decl_stmt|;
block|{
if|if
condition|(
name|output_target
operator|==
name|NULL
operator|||
operator|!
name|from_script
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_BIG
operator|&&
name|big
operator|!=
name|NULL
condition|)
name|format
operator|=
name|big
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|endian
operator|==
name|ENDIAN_LITTLE
operator|&&
name|little
operator|!=
name|NULL
condition|)
name|format
operator|=
name|little
expr_stmt|;
name|output_target
operator|=
name|format
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enter a group.  This creates a new lang_group_statement, and sets    stat_ptr to build new statements within the group.  */
end_comment

begin_function
name|void
name|lang_enter_group
parameter_list|()
block|{
name|lang_group_statement_type
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|new_stat
argument_list|(
name|lang_group_statement
argument_list|,
name|stat_ptr
argument_list|)
expr_stmt|;
name|lang_list_init
argument_list|(
operator|&
name|g
operator|->
name|children
argument_list|)
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|g
operator|->
name|children
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Leave a group.  This just resets stat_ptr to start writing to the    regular list of statements again.  Note that this will not work if    groups can occur inside anything else which can adjust stat_ptr,    but currently they can't.  */
end_comment

begin_function
name|void
name|lang_leave_group
parameter_list|()
block|{
name|stat_ptr
operator|=
operator|&
name|statement_list
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new program header.  This is called for each entry in a PHDRS    command in a linker script.  */
end_comment

begin_function
name|void
name|lang_new_phdr
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|filehdr
parameter_list|,
name|phdrs
parameter_list|,
name|at
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|etree_type
modifier|*
name|type
decl_stmt|;
name|boolean
name|filehdr
decl_stmt|;
name|boolean
name|phdrs
decl_stmt|;
name|etree_type
modifier|*
name|at
decl_stmt|;
name|etree_type
modifier|*
name|flags
decl_stmt|;
block|{
name|struct
name|lang_phdr
modifier|*
name|n
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|lang_phdr
operator|*
operator|)
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_phdr
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|exp_get_value_int
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|"program header type"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
name|n
operator|->
name|filehdr
operator|=
name|filehdr
expr_stmt|;
name|n
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
name|n
operator|->
name|at
operator|=
name|at
expr_stmt|;
name|n
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_phdr_list
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the program header information in the output BFD.  FIXME: We    should not be calling an ELF specific function here.  */
end_comment

begin_function
specifier|static
name|void
name|lang_record_phdrs
parameter_list|()
block|{
name|unsigned
name|int
name|alc
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secs
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|last
decl_stmt|;
name|struct
name|lang_phdr
modifier|*
name|l
decl_stmt|;
name|lang_statement_union_type
modifier|*
name|u
decl_stmt|;
name|alc
operator|=
literal|10
expr_stmt|;
name|secs
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
name|lang_phdr_list
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_vma
name|at
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|next
control|)
block|{
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
name|os
operator|=
operator|&
name|u
operator|->
name|output_section_statement
expr_stmt|;
name|pl
operator|=
name|os
operator|->
name|phdrs
expr_stmt|;
if|if
condition|(
name|pl
operator|!=
name|NULL
condition|)
name|last
operator|=
name|pl
expr_stmt|;
else|else
block|{
if|if
condition|(
name|os
operator|->
name|sectype
operator|==
name|noload_section
operator|||
name|os
operator|->
name|bfd_section
operator|==
name|NULL
operator|||
operator|(
name|os
operator|->
name|bfd_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pl
operator|=
name|last
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
name|l
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|alc
condition|)
block|{
name|alc
operator|*=
literal|2
expr_stmt|;
name|secs
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|secs
argument_list|,
name|alc
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|secs
index|[
name|c
index|]
operator|=
name|os
operator|->
name|bfd_section
expr_stmt|;
operator|++
name|c
expr_stmt|;
name|pl
operator|->
name|used
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|l
operator|->
name|flags
operator|==
name|NULL
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|flags
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|flags
argument_list|,
literal|0
argument_list|,
literal|"phdr flags"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|at
operator|==
name|NULL
condition|)
name|at
operator|=
literal|0
expr_stmt|;
else|else
name|at
operator|=
name|exp_get_vma
argument_list|(
name|l
operator|->
name|at
argument_list|,
literal|0
argument_list|,
literal|"phdr load address"
argument_list|,
name|lang_final_phase_enum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_record_phdr
argument_list|(
name|output_bfd
argument_list|,
name|l
operator|->
name|type
argument_list|,
name|l
operator|->
name|flags
operator|==
name|NULL
condition|?
name|false
else|:
name|true
argument_list|,
name|flags
argument_list|,
name|l
operator|->
name|at
operator|==
name|NULL
condition|?
name|false
else|:
name|true
argument_list|,
name|at
argument_list|,
name|l
operator|->
name|filehdr
argument_list|,
name|l
operator|->
name|phdrs
argument_list|,
name|c
argument_list|,
name|secs
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%F%P: bfd_record_phdr failed: %E\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|secs
argument_list|)
expr_stmt|;
comment|/* Make sure all the phdr assignments succeeded.  */
for|for
control|(
name|u
operator|=
name|lang_output_section_statement
operator|.
name|head
init|;
name|u
operator|!=
name|NULL
condition|;
name|u
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|next
control|)
block|{
name|struct
name|lang_output_section_phdr_list
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|u
operator|->
name|output_section_statement
operator|.
name|bfd_section
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|pl
operator|=
name|u
operator|->
name|output_section_statement
operator|.
name|phdrs
init|;
name|pl
operator|!=
name|NULL
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|pl
operator|->
name|used
operator|&&
name|strcmp
argument_list|(
name|pl
operator|->
name|name
argument_list|,
literal|"NONE"
argument_list|)
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: section `%s' assigned to non-existent phdr `%s'\n"
argument_list|,
name|u
operator|->
name|output_section_statement
operator|.
name|name
argument_list|,
name|pl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a list of sections which may not be cross referenced.  */
end_comment

begin_function
name|void
name|lang_add_nocrossref
parameter_list|(
name|l
parameter_list|)
name|struct
name|lang_nocrossref
modifier|*
name|l
decl_stmt|;
block|{
name|struct
name|lang_nocrossrefs
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|lang_nocrossrefs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|nocrossref_list
expr_stmt|;
name|n
operator|->
name|list
operator|=
name|l
expr_stmt|;
name|nocrossref_list
operator|=
name|n
expr_stmt|;
comment|/* Set notice_all so that we get informed about all symbols.  */
name|link_info
operator|.
name|notice_all
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Overlay handling.  We handle overlays with some static variables.  */
end_comment

begin_comment
comment|/* The overlay virtual address.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_vma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The overlay load address.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_lma
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether nocrossrefs is set for this overlay.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overlay_nocrossrefs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An expression for the maximum section size seen so far.  */
end_comment

begin_decl_stmt
specifier|static
name|etree_type
modifier|*
name|overlay_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of all the sections in this overlay.  */
end_comment

begin_struct
struct|struct
name|overlay_list
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
name|lang_output_section_statement_type
modifier|*
name|os
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|overlay_list
modifier|*
name|overlay_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start handling an overlay.  */
end_comment

begin_function
name|void
name|lang_enter_overlay
parameter_list|(
name|vma_expr
parameter_list|,
name|lma_expr
parameter_list|,
name|nocrossrefs
parameter_list|)
name|etree_type
modifier|*
name|vma_expr
decl_stmt|;
name|etree_type
modifier|*
name|lma_expr
decl_stmt|;
name|int
name|nocrossrefs
decl_stmt|;
block|{
comment|/* The grammar should prevent nested overlays from occurring.  */
name|ASSERT
argument_list|(
name|overlay_vma
operator|==
name|NULL
operator|&&
name|overlay_lma
operator|==
name|NULL
operator|&&
name|overlay_list
operator|==
name|NULL
operator|&&
name|overlay_max
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|vma_expr
expr_stmt|;
name|overlay_lma
operator|=
name|lma_expr
expr_stmt|;
name|overlay_nocrossrefs
operator|=
name|nocrossrefs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a section in an overlay.  We handle this by calling    lang_enter_output_section_statement with the correct VMA and LMA.  */
end_comment

begin_function
name|void
name|lang_enter_overlay_section
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|overlay_list
modifier|*
name|n
decl_stmt|;
name|etree_type
modifier|*
name|size
decl_stmt|;
name|lang_enter_output_section_statement
argument_list|(
name|name
argument_list|,
name|overlay_vma
argument_list|,
name|normal_section
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|overlay_lma
argument_list|)
expr_stmt|;
comment|/* If this is the first section, then base the VMA and LMA of future      sections on this one.  This will work correctly even if `.' is      used in the addresses.  */
if|if
condition|(
name|overlay_list
operator|==
name|NULL
condition|)
block|{
name|overlay_vma
operator|=
name|exp_nameop
argument_list|(
name|ADDR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|overlay_lma
operator|=
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the section.  */
name|n
operator|=
operator|(
expr|struct
name|overlay_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|os
operator|=
name|current_section
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|overlay_list
expr_stmt|;
name|overlay_list
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Adjust the LMA for the next section.  */
name|overlay_lma
operator|=
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|overlay_lma
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Arrange to work out the maximum section end address.  */
if|if
condition|(
name|overlay_max
operator|==
name|NULL
condition|)
name|overlay_max
operator|=
name|size
expr_stmt|;
else|else
name|overlay_max
operator|=
name|exp_binop
argument_list|(
name|MAX
argument_list|,
name|overlay_max
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish a section in an overlay.  There isn't any special to do    here.  */
end_comment

begin_function
name|void
name|lang_leave_overlay_section
parameter_list|(
name|fill
parameter_list|,
name|phdrs
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|clean
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|name
operator|=
name|current_section
operator|->
name|name
expr_stmt|;
name|lang_leave_output_section_statement
argument_list|(
name|fill
argument_list|,
literal|"*default*"
argument_list|,
name|phdrs
argument_list|)
expr_stmt|;
comment|/* Define the magic symbols.  */
name|clean
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s2
operator|=
name|clean
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|name
init|;
operator|*
name|s1
operator|!=
literal|'\0'
condition|;
name|s1
operator|++
control|)
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|s1
argument_list|)
operator|||
operator|*
name|s1
operator|==
literal|'_'
condition|)
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_start_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_start_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|clean
argument_list|)
operator|+
sizeof|sizeof
expr|"__load_stop_"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__load_stop_%s"
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|buf
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|exp_nameop
argument_list|(
name|LOADADDR
argument_list|,
name|name
argument_list|)
argument_list|,
name|exp_nameop
argument_list|(
name|SIZEOF
argument_list|,
name|name
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an overlay.  If there are any overlay wide settings, this    looks through all the sections in the overlay and sets them.  */
end_comment

begin_function
name|void
name|lang_leave_overlay
parameter_list|(
name|fill
parameter_list|,
name|memspec
parameter_list|,
name|phdrs
parameter_list|)
name|bfd_vma
name|fill
decl_stmt|;
specifier|const
name|char
modifier|*
name|memspec
decl_stmt|;
name|struct
name|lang_output_section_phdr_list
modifier|*
name|phdrs
decl_stmt|;
block|{
name|lang_memory_region_type
modifier|*
name|region
decl_stmt|;
name|struct
name|overlay_list
modifier|*
name|l
decl_stmt|;
name|struct
name|lang_nocrossref
modifier|*
name|nocrossref
decl_stmt|;
if|if
condition|(
name|memspec
operator|==
name|NULL
condition|)
name|region
operator|=
name|NULL
expr_stmt|;
else|else
name|region
operator|=
name|lang_memory_region_lookup
argument_list|(
name|memspec
argument_list|)
expr_stmt|;
name|nocrossref
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|overlay_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|struct
name|overlay_list
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|fill
operator|!=
literal|0
operator|&&
name|l
operator|->
name|os
operator|->
name|fill
operator|==
literal|0
condition|)
name|l
operator|->
name|os
operator|->
name|fill
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|region
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|region
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|region
operator|=
name|region
expr_stmt|;
if|if
condition|(
name|phdrs
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|os
operator|->
name|phdrs
operator|==
name|NULL
condition|)
name|l
operator|->
name|os
operator|->
name|phdrs
operator|=
name|phdrs
expr_stmt|;
if|if
condition|(
name|overlay_nocrossrefs
condition|)
block|{
name|struct
name|lang_nocrossref
modifier|*
name|nc
decl_stmt|;
name|nc
operator|=
operator|(
expr|struct
name|lang_nocrossref
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nc
argument_list|)
expr_stmt|;
name|nc
operator|->
name|name
operator|=
name|l
operator|->
name|os
operator|->
name|name
expr_stmt|;
name|nc
operator|->
name|next
operator|=
name|nocrossref
expr_stmt|;
name|nocrossref
operator|=
name|nc
expr_stmt|;
block|}
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|nocrossref
operator|!=
name|NULL
condition|)
name|lang_add_nocrossref
argument_list|(
name|nocrossref
argument_list|)
expr_stmt|;
comment|/* Update . for the end of the overlay.  */
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
literal|"."
argument_list|,
name|exp_binop
argument_list|(
literal|'+'
argument_list|,
name|overlay_vma
argument_list|,
name|overlay_max
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|overlay_vma
operator|=
name|NULL
expr_stmt|;
name|overlay_lma
operator|=
name|NULL
expr_stmt|;
name|overlay_nocrossrefs
operator|=
literal|0
expr_stmt|;
name|overlay_list
operator|=
name|NULL
expr_stmt|;
name|overlay_max
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Version handling.  This is only useful for ELF.  */
end_comment

begin_comment
comment|/* This global variable holds the version tree that we build.  */
end_comment

begin_decl_stmt
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_elf_version_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called for each variable name or match expression.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_expr
modifier|*
name|lang_new_vers_regex
parameter_list|(
name|orig
parameter_list|,
name|new
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|orig
decl_stmt|;
specifier|const
name|char
modifier|*
name|new
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_expr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|orig
expr_stmt|;
name|ret
operator|->
name|match
operator|=
name|new
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This is called for each set of variable names and match    expressions.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_tree
modifier|*
name|lang_new_vers_node
parameter_list|(
name|globals
parameter_list|,
name|locals
parameter_list|)
name|struct
name|bfd_elf_version_expr
modifier|*
name|globals
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|locals
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_tree
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|vernum
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|globals
operator|=
name|globals
expr_stmt|;
name|ret
operator|->
name|locals
operator|=
name|locals
expr_stmt|;
name|ret
operator|->
name|deps
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|name_indx
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* This static variable keeps track of version indices.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|version_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is called when we know the name and dependencies of the    version.  */
end_comment

begin_function
name|void
name|lang_register_vers_node
parameter_list|(
name|name
parameter_list|,
name|version
parameter_list|,
name|deps
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|version
decl_stmt|;
name|struct
name|bfd_elf_version_deps
modifier|*
name|deps
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|bfd_elf_version_expr
modifier|*
name|e1
decl_stmt|;
comment|/* Make sure this node has a unique name.  */
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: duplicate version tag `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Check the global and local match names, and make sure there      aren't any duplicates.  */
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|globals
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|globals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|match
argument_list|,
name|e2
operator|->
name|match
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|,
name|e1
operator|->
name|match
argument_list|)
expr_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|locals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|match
argument_list|,
name|e2
operator|->
name|match
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|,
name|e1
operator|->
name|match
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|e1
operator|=
name|version
operator|->
name|locals
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|e1
operator|->
name|next
control|)
block|{
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_version_expr
modifier|*
name|e2
decl_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|globals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|match
argument_list|,
name|e2
operator|->
name|match
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|,
name|e1
operator|->
name|match
argument_list|)
expr_stmt|;
for|for
control|(
name|e2
operator|=
name|t
operator|->
name|locals
init|;
name|e2
operator|!=
name|NULL
condition|;
name|e2
operator|=
name|e2
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|e1
operator|->
name|match
argument_list|,
name|e2
operator|->
name|match
argument_list|)
operator|==
literal|0
condition|)
name|einfo
argument_list|(
literal|"%X%P: duplicate expression `%s' in version information\n"
argument_list|,
name|e1
operator|->
name|match
argument_list|)
expr_stmt|;
block|}
block|}
name|version
operator|->
name|deps
operator|=
name|deps
expr_stmt|;
name|version
operator|->
name|name
operator|=
name|name
expr_stmt|;
operator|++
name|version_index
expr_stmt|;
name|version
operator|->
name|vernum
operator|=
name|version_index
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|lang_elf_version_info
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|pp
operator|=
name|version
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when we see a version dependency.  */
end_comment

begin_function
name|struct
name|bfd_elf_version_deps
modifier|*
name|lang_add_vers_depend
parameter_list|(
name|list
parameter_list|,
name|name
parameter_list|)
name|struct
name|bfd_elf_version_deps
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|bfd_elf_version_deps
modifier|*
name|ret
decl_stmt|;
name|struct
name|bfd_elf_version_tree
modifier|*
name|t
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|bfd_elf_version_deps
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|list
expr_stmt|;
for|for
control|(
name|t
operator|=
name|lang_elf_version_info
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|->
name|version_needed
operator|=
name|t
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|einfo
argument_list|(
literal|"%X%P: unable to find version dependency `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

