begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ld-emul.h - Linker emulation header file    Copyright 1991, 92, 93, 94, 95, 96, 97, 1998, 2000 Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LDEMUL_H
end_ifndef

begin_define
define|#
directive|define
name|LDEMUL_H
end_define

begin_if
if|#
directive|if
name|ANSI_PROTOTYPES
end_if

begin_struct_decl
struct_decl|struct
name|lang_input_statement_struct
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|search_dirs
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|ldemul_hll
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_syslib
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_after_parse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_before_parse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_after_open
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_after_allocation
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_before_allocation
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_set_output_arch
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ldemul_choose_target
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_choose_mode
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_list_emulations
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_list_emulation_options
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ldemul_get_script
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
name|isfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_finish
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_set_symbols
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|ldemul_create_output_section_statements
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|ldemul_place_orphan
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ldemul_parse_args
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|ldemul_unrecognized_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|ldemul_recognized_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|ldemul_open_dynamic_archive
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|search_dirs
operator|*
operator|,
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ldemul_default_target
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|after_parse_default
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|after_open_default
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|after_allocation_default
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|before_allocation_default
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|set_output_arch_default
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|syslib_default
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|hll_default
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ldemul_find_potential_libraries
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ld_emulation_xfer_struct
block|{
comment|/* Run before parsing the command line and script file.      Set the architecture, maybe other things.  */
name|void
argument_list|(
argument|*before_parse
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Handle the SYSLIB (low level library) script command.  */
name|void
argument_list|(
argument|*syslib
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Handle the HLL (high level library) script command.  */
name|void
argument_list|(
argument|*hll
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Run after parsing the command line and script file.  */
name|void
argument_list|(
argument|*after_parse
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Run after opening all input files, and loading the symbols.  */
name|void
argument_list|(
argument|*after_open
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Run after allocating output sections.  */
name|void
argument_list|(
argument|*after_allocation
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the output architecture and machine if possible.  */
name|void
argument_list|(
argument|*set_output_arch
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Decide which target name to use.  */
name|char
operator|*
operator|(
operator|*
name|choose_target
operator|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Run before allocating output sections.  */
name|void
argument_list|(
argument|*before_allocation
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Return the appropriate linker script.  */
name|char
operator|*
operator|(
operator|*
name|get_script
operator|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
name|isfile
operator|)
argument_list|)
expr_stmt|;
comment|/* The name of this emulation.  */
name|char
modifier|*
name|emulation_name
decl_stmt|;
comment|/* The output format.  */
name|char
modifier|*
name|target_name
decl_stmt|;
comment|/* Run after assigning values from the script.  */
name|void
argument_list|(
argument|*finish
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Create any output sections needed by the target.  */
name|void
argument_list|(
argument|*create_output_section_statements
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Try to open a dynamic library.  ARCH is an architecture name, and      is normally the empty string.  ENTRY is the lang_input_statement      that should be opened.  */
name|boolean
argument_list|(
argument|*open_dynamic_archive
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|arch
operator|,
expr|struct
name|search_dirs
operator|*
operator|,
expr|struct
name|lang_input_statement_struct
operator|*
name|entry
operator|)
argument_list|)
expr_stmt|;
comment|/* Place an orphan section.  Return true if it was placed, false if      the default action should be taken.  This field may be NULL, in      which case the default action will always be taken.  */
name|boolean
argument_list|(
argument|*place_orphan
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Run after assigning parsing with the args, but before       reading the script.  Used to initialize symbols used in the script. */
name|void
argument_list|(
argument|*set_symbols
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
comment|/* Run to parse args which the base linker doesn't      understand. Return non zero on sucess. */
name|int
argument_list|(
argument|*parse_args
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Run to handle files which are not recognized as object files or      archives.  Return true if the file was handled.  */
name|boolean
argument_list|(
argument|*unrecognized_file
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Run to list the command line options which parse_args handles.  */
name|void
argument_list|(
argument|* list_options
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Run to specially handle files which *are* recognized as object      files or archives.  Return true if the file was handled.  */
name|boolean
argument_list|(
argument|*recognized_file
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Called when looking for libraries in a directory specified      via a linker command line option or linker script option.      Files that match the pattern "lib*.a" have already been scanned.      (For VMS files matching ":lib*.a" have also been scanned).  */
name|int
argument_list|(
argument|* find_potential_libraries
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|lang_input_statement_struct
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
name|ld_emulation_xfer_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|intel_ic960_ld_mode_enum
block|,
name|default_mode_enum
block|,
name|intel_gld960_ld_mode_enum
block|}
name|lang_emulation_mode_enum_type
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|ld_emulation_xfer_type
modifier|*
name|ld_emulations
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

