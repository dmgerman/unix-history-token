begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Main program of GNU linker.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002    Free Software Foundation, Inc.    Written by Steve Chamberlain steve@cygnus.com  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"progress.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldwrite.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_comment
comment|/* Somewhere above, sys/stat.h got included . . . .  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SBRK
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_DECLARATION_SBRK
end_ifdef

begin_function_decl
specifier|extern
name|PTR
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_emulation
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_scripts_dir
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EXPORTS */
end_comment

begin_decl_stmt
name|char
modifier|*
name|default_target
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|output_filename
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name this program was invoked by.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file that we're creating.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|output_bfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by -G argument, for MIPS ECOFF target.  */
end_comment

begin_decl_stmt
name|int
name|g_switch_value
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print names of input files as processed.  */
end_comment

begin_decl_stmt
name|boolean
name|trace_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means same, but note open failures, too.  */
end_comment

begin_decl_stmt
name|boolean
name|trace_file_tries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means version number was printed, so exit successfully    instead of complaining if no input files are given.  */
end_comment

begin_decl_stmt
name|boolean
name|version_printed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means link in every member of an archive.  */
end_comment

begin_decl_stmt
name|boolean
name|whole_archive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we should demangle symbol names.  */
end_comment

begin_decl_stmt
name|boolean
name|demangling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|args_type
name|command_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ld_config_type
name|config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|check_for_scripts_dir
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|add_archive_element
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|multiple_definition
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|multiple_common
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
expr|enum
name|bfd_link_hash_type
operator|,
name|bfd_vma
operator|,
name|bfd
operator|*
operator|,
expr|enum
name|bfd_link_hash_type
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|add_to_set
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|constructor_callback
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
name|constructor
operator|,
specifier|const
name|char
operator|*
name|name
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|warning_callback
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warning_find_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|undefined_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|reloc_overflow
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|reloc_dangerous
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|unattached_reloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|notice
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_callbacks
name|link_callbacks
init|=
block|{
name|add_archive_element
block|,
name|multiple_definition
block|,
name|multiple_common
block|,
name|add_to_set
block|,
name|constructor_callback
block|,
name|warning_callback
block|,
name|undefined_symbol
block|,
name|reloc_overflow
block|,
name|reloc_dangerous
block|,
name|unattached_reloc
block|,
name|notice
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_link_info
name|link_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remove_output
parameter_list|()
block|{
if|if
condition|(
name|output_filename
condition|)
block|{
if|if
condition|(
name|output_bfd
operator|&&
name|output_bfd
operator|->
name|iostream
condition|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|output_bfd
operator|->
name|iostream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_output_file_on_failure
condition|)
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|emulation
decl_stmt|;
name|long
name|start_time
init|=
name|get_run_time
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|xmalloc_set_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|START_PROGRESS
argument_list|(
name|program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_init
argument_list|()
expr_stmt|;
name|bfd_set_error_program_name
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
name|xatexit
argument_list|(
name|remove_output
argument_list|)
expr_stmt|;
comment|/* Set the default BFD target based on the configured target.  Doing      this permits the linker to be configured for a particular target,      and linked against a shared BFD library which was configured for      a different target.  The macro TARGET is defined by Makefile.  */
if|if
condition|(
operator|!
name|bfd_set_default_target
argument_list|(
name|TARGET
argument_list|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: can't set BFD default target to `%s': %E\n"
argument_list|)
argument_list|,
name|TARGET
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|YYDEBUG
block|{
specifier|extern
name|int
name|yydebug
decl_stmt|;
name|yydebug
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initialize the data about options.  */
name|trace_files
operator|=
name|trace_file_tries
operator|=
name|version_printed
operator|=
name|false
expr_stmt|;
name|whole_archive
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|has_shared
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|split_by_reloc
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|config
operator|.
name|split_by_file
operator|=
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
expr_stmt|;
name|command_line
operator|.
name|force_common_definition
operator|=
name|false
expr_stmt|;
name|command_line
operator|.
name|inhibit_common_definition
operator|=
name|false
expr_stmt|;
name|command_line
operator|.
name|interpreter
operator|=
name|NULL
expr_stmt|;
name|command_line
operator|.
name|rpath
operator|=
name|NULL
expr_stmt|;
name|command_line
operator|.
name|warn_mismatch
operator|=
name|true
expr_stmt|;
name|command_line
operator|.
name|check_section_addresses
operator|=
name|true
expr_stmt|;
comment|/* We initialize DEMANGLING based on the environment variable      COLLECT_NO_DEMANGLE.  The gcc collect2 program will demangle the      output of the linker, unless COLLECT_NO_DEMANGLE is set in the      environment.  Acting the same way here lets us provide the same      interface by default.  */
name|demangling
operator|=
name|getenv
argument_list|(
literal|"COLLECT_NO_DEMANGLE"
argument_list|)
operator|==
name|NULL
expr_stmt|;
name|link_info
operator|.
name|callbacks
operator|=
operator|&
name|link_callbacks
expr_stmt|;
name|link_info
operator|.
name|relocateable
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|emitrelocations
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|shared
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|symbolic
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|export_dynamic
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|static_link
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|traditional_format
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|optimize
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|no_undefined
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|allow_shlib_undefined
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|strip
operator|=
name|strip_none
expr_stmt|;
name|link_info
operator|.
name|discard
operator|=
name|discard_sec_merge
expr_stmt|;
name|link_info
operator|.
name|keep_memory
operator|=
name|true
expr_stmt|;
name|link_info
operator|.
name|input_bfds
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|create_object_symbols_section
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|keep_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|notice_all
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|notice_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|wrap_hash
operator|=
name|NULL
expr_stmt|;
name|link_info
operator|.
name|mpc860c0
operator|=
literal|0
expr_stmt|;
comment|/* SVR4 linkers seem to set DT_INIT and DT_FINI based on magic _init      and _fini symbols.  We are compatible.  */
name|link_info
operator|.
name|init_function
operator|=
literal|"_init"
expr_stmt|;
name|link_info
operator|.
name|fini_function
operator|=
literal|"_fini"
expr_stmt|;
name|link_info
operator|.
name|new_dtags
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|eh_frame_hdr
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|flags
operator|=
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|link_info
operator|.
name|flags_1
operator|=
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|link_info
operator|.
name|pei386_auto_import
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|combreloc
operator|=
name|false
expr_stmt|;
name|link_info
operator|.
name|spare_dynamic_tags
operator|=
literal|5
expr_stmt|;
name|ldfile_add_arch
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|config
operator|.
name|make_executable
operator|=
name|true
expr_stmt|;
name|force_make_executable
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|true
expr_stmt|;
name|emulation
operator|=
name|get_emulation
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|ldemul_choose_mode
argument_list|(
name|emulation
argument_list|)
expr_stmt|;
name|default_target
operator|=
name|ldemul_choose_target
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|lang_init
argument_list|()
expr_stmt|;
name|ldemul_before_parse
argument_list|()
expr_stmt|;
name|lang_has_input_file
operator|=
name|false
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|ldemul_set_symbols
argument_list|()
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|gc_sections
condition|)
name|einfo
argument_list|(
literal|"%P%F: --gc-sections and -r may not be used together\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|mpc860c0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -r and --mpc860c0 may not be used together\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: --relax and -r may not be used together\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|shared
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -r and -shared may not be used together\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link_info
operator|.
name|shared
condition|)
block|{
if|if
condition|(
name|command_line
operator|.
name|filter_shlib
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -F may not be used without -shared\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|auxiliary_filters
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -f may not be used without -shared\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I      don't see how else this can be handled, since in this case we      must preserve all externally visible symbols.  */
if|if
condition|(
name|link_info
operator|.
name|relocateable
operator|&&
name|link_info
operator|.
name|strip
operator|==
name|strip_all
condition|)
block|{
name|link_info
operator|.
name|strip
operator|=
name|strip_debugger
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|discard
operator|==
name|discard_sec_merge
condition|)
name|link_info
operator|.
name|discard
operator|=
name|discard_all
expr_stmt|;
block|}
comment|/* This essentially adds another -L directory so this must be done after      the -L's in argv have been processed.  */
name|set_scripts_dir
argument_list|()
expr_stmt|;
comment|/* If we have not already opened and parsed a linker script      read the emulation's appropriate default script.  */
if|if
condition|(
name|saved_script_handle
operator|==
name|NULL
condition|)
block|{
name|int
name|isfile
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|ldemul_get_script
argument_list|(
operator|&
name|isfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|isfile
condition|)
name|ldfile_open_command_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|lex_string
operator|=
name|s
expr_stmt|;
name|lex_redirect
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|lex_string
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|saved_script_handle
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"using external linker script:"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"using internal linker script:"
argument_list|)
argument_list|)
expr_stmt|;
name|info_msg
argument_list|(
literal|"\n==================================================\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_script_handle
condition|)
block|{
specifier|static
specifier|const
name|int
name|ld_bufsz
init|=
literal|8193
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|ld_bufsz
argument_list|)
decl_stmt|;
name|rewind
argument_list|(
name|saved_script_handle
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|ld_bufsz
operator|-
literal|1
argument_list|,
name|saved_script_handle
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|buf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|info_msg
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|rewind
argument_list|(
name|saved_script_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|isfile
decl_stmt|;
name|info_msg
argument_list|(
name|ldemul_get_script
argument_list|(
operator|&
name|isfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|info_msg
argument_list|(
literal|"\n==================================================\n"
argument_list|)
expr_stmt|;
block|}
name|lang_final
argument_list|()
expr_stmt|;
if|if
condition|(
name|lang_has_input_file
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|version_printed
condition|)
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: no input files\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
condition|)
block|{
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"%P: mode %s\n"
argument_list|)
argument_list|,
name|emulation
argument_list|)
expr_stmt|;
block|}
name|ldemul_after_parse
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_filename
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|config
operator|.
name|map_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|config
operator|.
name|map_file
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|config
operator|.
name|map_file
operator|=
name|fopen
argument_list|(
name|config
operator|.
name|map_filename
argument_list|,
name|FOPEN_WT
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open map file %s: %E\n"
argument_list|)
argument_list|,
name|config
operator|.
name|map_filename
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lang_process
argument_list|()
expr_stmt|;
comment|/* Print error messages for any missing symbols, for any warning      symbols, and possibly multiple definitions.  */
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
name|output_bfd
operator|->
name|flags
operator|&=
operator|~
name|EXEC_P
expr_stmt|;
else|else
name|output_bfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
name|ldwrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
name|lang_map
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|cref
condition|)
name|output_cref
argument_list|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|?
name|config
operator|.
name|map_file
else|:
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nocrossref_list
operator|!=
name|NULL
condition|)
name|check_nocrossrefs
argument_list|()
expr_stmt|;
comment|/* Even if we're producing relocateable output, some non-fatal errors should      be reported in the exit status.  (What non-fatal errors, if any, do we      want to ignore for relocateable output?)  */
if|if
condition|(
name|config
operator|.
name|make_executable
operator|==
name|false
operator|&&
name|force_make_executable
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|trace_files
operator|==
name|true
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: link errors found, deleting executable `%s'\n"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
block|}
comment|/* The file will be removed by remove_output.  */
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%B: final close failed: %E\n"
argument_list|)
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* If the --force-exe-suffix is enabled, and we're making an 	 executable file and it doesn't end in .exe, copy it to one 	 which does.  */
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocateable
operator|&&
name|command_line
operator|.
name|force_exe_suffix
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|output_filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
operator|||
operator|(
name|strcasecmp
argument_list|(
name|output_filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|output_filename
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".dll"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|FILE
modifier|*
name|src
decl_stmt|;
name|FILE
modifier|*
name|dst
decl_stmt|;
specifier|const
name|int
name|bsize
init|=
literal|4096
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|bsize
argument_list|)
decl_stmt|;
name|int
name|l
decl_stmt|;
name|char
modifier|*
name|dst_name
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|dst_name
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dst_name
argument_list|,
literal|".exe"
argument_list|)
expr_stmt|;
name|src
operator|=
name|fopen
argument_list|(
name|output_filename
argument_list|,
name|FOPEN_RB
argument_list|)
expr_stmt|;
name|dst
operator|=
name|fopen
argument_list|(
name|dst_name
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to open for source of copy `%s'\n"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: unable to open for destination of copy `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|bsize
argument_list|,
name|src
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|done
init|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|l
argument_list|,
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|done
operator|!=
name|l
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error writing file `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|dst
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Error closing file `%s'\n"
argument_list|)
argument_list|,
name|dst_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dst_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|END_PROGRESS
argument_list|(
name|program_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|stats
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|long
name|run_time
init|=
name|get_run_time
argument_list|()
operator|-
name|start_time
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: total time in link: %ld.%06ld\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|run_time
operator|/
literal|1000000
argument_list|,
name|run_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: data size %ld\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Prevent remove_output from doing anything, after a successful link.  */
name|output_filename
operator|=
name|NULL
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We need to find any explicitly given emulation in order to initialize the    state that's needed by the lex&yacc argument parser (parse_args).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_emulation
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|emulation
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emulation
operator|=
name|getenv
argument_list|(
name|EMULATION_ENVIRON
argument_list|)
expr_stmt|;
if|if
condition|(
name|emulation
operator|==
name|NULL
condition|)
name|emulation
operator|=
name|DEFAULT_EMULATION
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-m"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* -m EMUL */
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|emulation
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: missing argument to -m\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips2"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips3"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips32"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips64"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-mips5"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: The arguments -mips1, -mips2, -mips3, etc. are 		 passed to the linker by some MIPS compilers.  They 		 generally tell the linker to use a slightly different 		 library path.  Perhaps someday these should be 		 implemented as emulations; until then, we just ignore 		 the arguments and hope that nobody ever creates 		 emulations named ips1, ips2 or ips3.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-m486"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* FIXME: The argument -m486 is passed to the linker on 		 some Linux systems.  Hope that nobody creates an 		 emulation named 486.  */
block|}
else|else
block|{
comment|/* -mEMUL */
name|emulation
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|emulation
return|;
block|}
end_function

begin_comment
comment|/* If directory DIR contains an "ldscripts" subdirectory,    add DIR to the library search path and return true,    else return false.  */
end_comment

begin_function
specifier|static
name|boolean
name|check_for_scripts_dir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|size_t
name|dirlen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|boolean
name|res
decl_stmt|;
name|dirlen
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* sizeof counts the terminating NUL.  */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirlen
operator|+
sizeof|sizeof
argument_list|(
literal|"/ldscripts"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/ldscripts"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|ldfile_add_library_path
argument_list|(
name|dir
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Set the default directory for finding script files.    Libraries will be searched for here too, but that's ok.    We look for the "ldscripts" directory in:     SCRIPTDIR (passed from Makefile)    the dir where this program is (for using it from the build tree)    the dir where this program is/../lib (for installing the tool suite elsewhere) */
end_comment

begin_function
specifier|static
name|void
name|set_scripts_dir
parameter_list|()
block|{
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|size_t
name|dirlen
decl_stmt|;
if|if
condition|(
name|check_for_scripts_dir
argument_list|(
name|SCRIPTDIR
argument_list|)
condition|)
comment|/* We've been installed normally.  */
return|return;
comment|/* Look for "ldscripts" in the dir where our binary is.  */
name|end
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
block|{
comment|/* We could have \foo\bar, or /foo\bar.  */
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
operator|||
operator|(
name|bslash
operator|!=
name|NULL
operator|&&
name|bslash
operator|>
name|end
operator|)
condition|)
name|end
operator|=
name|bslash
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
comment|/* Don't look for ldscripts in the current directory.  There is          too much potential for confusion.  */
return|return;
block|}
name|dirlen
operator|=
name|end
operator|-
name|program_name
expr_stmt|;
comment|/* Make a copy of program_name in dir.      Leave room for later "/../lib".  */
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirlen
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dir
argument_list|,
name|program_name
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|dir
index|[
name|dirlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
condition|)
comment|/* Don't free dir.  */
return|return;
comment|/* Look for "ldscripts" in<the dir where our binary is>/../lib.  */
name|strcpy
argument_list|(
name|dir
operator|+
name|dirlen
argument_list|,
literal|"/../lib"
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_for_scripts_dir
argument_list|(
name|dir
argument_list|)
condition|)
return|return;
comment|/* Well, we tried.  */
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_ysym
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|link_info
operator|.
name|notice_hash
operator|==
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|NULL
condition|)
block|{
name|link_info
operator|.
name|notice_hash
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
name|link_info
operator|.
name|notice_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
literal|61
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|notice_hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a symbol to be wrapped, from the --wrap option.  */
end_comment

begin_function
name|void
name|add_wrap
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|link_info
operator|.
name|wrap_hash
operator|==
name|NULL
condition|)
block|{
name|link_info
operator|.
name|wrap_hash
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init_n
argument_list|(
name|link_info
operator|.
name|wrap_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|,
literal|61
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|wrap_hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the -retain-symbols-file option.  */
end_comment

begin_function
name|void
name|add_keepsyms_file
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|link_info
operator|.
name|strip
operator|==
name|strip_some
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%P: error: duplicate retain-symbols-file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%X%P: %s: %E\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|link_info
operator|.
name|keep_hash
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|link_info
operator|.
name|keep_hash
argument_list|,
name|bfd_hash_newfunc
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|100
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|buf
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|bufsize
condition|)
block|{
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|link_info
operator|.
name|keep_hash
argument_list|,
name|buf
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|==
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_hash_lookup for insertion failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_info
operator|.
name|strip
operator|!=
name|strip_none
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: `-retain-symbols-file' overrides `-s' and `-S'\n"
argument_list|)
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|strip
operator|=
name|strip_some
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Callbacks from the BFD linker routines.  */
end_comment

begin_comment
comment|/* This is called when BFD has decided to include an archive member in    a link.  */
end_comment

begin_function
specifier|static
name|boolean
name|add_archive_element
parameter_list|(
name|info
parameter_list|,
name|abfd
parameter_list|,
name|name
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|lang_input_statement_type
modifier|*
name|input
decl_stmt|;
name|input
operator|=
operator|(
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lang_input_statement_type
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|input
operator|->
name|filename
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
name|input
operator|->
name|local_sym_name
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
name|input
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|input
operator|->
name|asymbols
operator|=
name|NULL
expr_stmt|;
name|input
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|input
operator|->
name|just_syms_flag
operator|=
name|false
expr_stmt|;
name|input
operator|->
name|loaded
operator|=
name|false
expr_stmt|;
name|input
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
comment|/* FIXME: The following fields are not set: header.next,      header.type, closed, passive_position, symbol_count,      next_real_file, is_archive, target, real.  This bit of code is      from the old decode_library_subfile function.  I don't know      whether any of those fields matters.  */
name|ldlang_add_file
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|static
name|boolean
name|header_printed
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd
modifier|*
name|from
decl_stmt|;
name|int
name|len
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|link_info
operator|.
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
name|from
operator|=
name|NULL
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|h
operator|->
name|type
condition|)
block|{
default|default:
name|from
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|from
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
operator|->
name|owner
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"Archive member included because of file (symbol)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|minfo
argument_list|(
literal|"%s(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|+
literal|2
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|29
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|30
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%B "
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"(%T)\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"(%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace_files
operator|||
name|trace_file_tries
condition|)
name|info_msg
argument_list|(
literal|"%I\n"
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a symbol which is defined    multiple times.  */
end_comment

begin_function
specifier|static
name|boolean
name|multiple_definition
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|obfd
parameter_list|,
name|osec
parameter_list|,
name|oval
parameter_list|,
name|nbfd
parameter_list|,
name|nsec
parameter_list|,
name|nval
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|bfd_vma
name|oval
decl_stmt|;
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|asection
modifier|*
name|nsec
decl_stmt|;
name|bfd_vma
name|nval
decl_stmt|;
block|{
comment|/* If either section has the output_section field set to      bfd_abs_section_ptr, it means that the section is being      discarded, and this is not really a multiple definition at all.      FIXME: It would be cleaner to somehow ignore symbols defined in      sections which are being discarded.  */
if|if
condition|(
operator|(
name|osec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|osec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|)
operator|||
operator|(
name|nsec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|nsec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|nsec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
return|return
name|true
return|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%X%C: multiple definition of `%T'\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|nsec
argument_list|,
name|nval
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%D: first defined here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|osec
argument_list|,
name|oval
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|relax
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: Disabling relaxation: it will not work with multiple definitions\n"
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|relax
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when there is a definition of a common symbol, or    when a common symbol is found for a symbol that is already defined,    or when two common symbols are found.  We only do something if    -warn-common was used.  */
end_comment

begin_function
specifier|static
name|boolean
name|multiple_common
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|obfd
parameter_list|,
name|otype
parameter_list|,
name|osize
parameter_list|,
name|nbfd
parameter_list|,
name|ntype
parameter_list|,
name|nsize
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|enum
name|bfd_link_hash_type
name|otype
decl_stmt|;
name|bfd_vma
name|osize
decl_stmt|;
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|enum
name|bfd_link_hash_type
name|ntype
decl_stmt|;
name|bfd_vma
name|nsize
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|config
operator|.
name|warn_common
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ntype
operator|==
name|bfd_link_hash_defined
operator|||
name|ntype
operator|==
name|bfd_link_hash_defweak
operator|||
name|ntype
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|ASSERT
argument_list|(
name|otype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: definition of `%T' overriding common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|otype
operator|==
name|bfd_link_hash_defined
operator|||
name|otype
operator|==
name|bfd_link_hash_defweak
operator|||
name|otype
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|ASSERT
argument_list|(
name|ntype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overridden by definition\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: defined here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|otype
operator|==
name|bfd_link_hash_common
operator|&&
name|ntype
operator|==
name|bfd_link_hash_common
argument_list|)
expr_stmt|;
if|if
condition|(
name|osize
operator|>
name|nsize
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overridden by larger common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: larger common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsize
operator|>
name|osize
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: common of `%T' overriding smaller common\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: smaller common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: multiple common of `%T'\n"
argument_list|)
argument_list|,
name|nbfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|obfd
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: warning: previous common is here\n"
argument_list|)
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a set element.  H is the    entry in the linker hash table for the set.  SECTION and VALUE    represent a value which should be added to the set.  */
end_comment

begin_function
specifier|static
name|boolean
name|add_to_set
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|reloc
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
name|config
operator|.
name|warn_constructors
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: global constructor %s used\n"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|build_constructors
condition|)
return|return
name|true
return|;
name|ldctor_add_set_entry
argument_list|(
name|h
argument_list|,
name|reloc
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We don't call bfd_link_add_undef to add this to the list of 	 undefined symbols because we are going to define it 	 ourselves.  */
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when BFD has discovered a constructor.  This is only    called for some object file formats--those which do not handle    constructors in some more clever fashion.  This is similar to    adding an element to a set, but less general.  */
end_comment

begin_function
specifier|static
name|boolean
name|constructor_callback
parameter_list|(
name|info
parameter_list|,
name|constructor
parameter_list|,
name|name
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|constructor
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|char
name|set_name
index|[
literal|1
operator|+
sizeof|sizeof
expr|"__CTOR_LIST__"]
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|warn_constructors
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: warning: global constructor %s used\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
operator|.
name|build_constructors
condition|)
return|return
name|true
return|;
comment|/* Ensure that BFD_RELOC_CTOR exists now, so that we can give a      useful error message.  */
if|if
condition|(
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|link_info
operator|.
name|relocateable
operator|||
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|BFD_RELOC_CTOR
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|set_name
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructor
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"__CTOR_LIST__"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"__DTOR_LIST__"
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|set_name
argument_list|,
name|true
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bfd_link_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_new
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|undef
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
comment|/* We don't call bfd_link_add_undef to add this to the list of 	 undefined symbols because we are going to define it 	 ourselves.  */
block|}
name|ldctor_add_set_entry
argument_list|(
name|h
argument_list|,
name|BFD_RELOC_CTOR
argument_list|,
name|name
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A structure used by warning_callback to pass information through    bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|warning_callback_info
block|{
name|boolean
name|found
decl_stmt|;
specifier|const
name|char
modifier|*
name|warning
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is called when there is a reference to a warning symbol.  */
end_comment

begin_function
specifier|static
name|boolean
name|warning_callback
parameter_list|(
name|info
parameter_list|,
name|warning
parameter_list|,
name|symbol
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|warning
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
comment|/* This is a hack to support warn_multiple_gp.  FIXME: This should      have a cleaner interface, but what?  */
if|if
condition|(
operator|!
name|config
operator|.
name|warn_multiple_gp
operator|&&
name|strcmp
argument_list|(
name|warning
argument_list|,
literal|"using multiple gp values"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%C: %s\n"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%P: %s\n"
argument_list|,
name|warning
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
literal|"%B: %s\n"
argument_list|,
name|abfd
argument_list|,
name|warning
argument_list|)
expr_stmt|;
else|else
block|{
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
name|struct
name|warning_callback_info
name|info
decl_stmt|;
comment|/* Look through the relocs to see if we can find a plausible 	 address.  */
name|entry
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|abfd
operator|->
name|usrdata
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|asymbols
operator|!=
name|NULL
condition|)
name|asymbols
operator|=
name|entry
operator|->
name|asymbols
expr_stmt|;
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symbol_count
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|asymbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symbol_count
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|entry
operator|->
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|entry
operator|->
name|symbol_count
operator|=
name|symbol_count
expr_stmt|;
block|}
block|}
name|info
operator|.
name|found
operator|=
name|false
expr_stmt|;
name|info
operator|.
name|warning
operator|=
name|warning
expr_stmt|;
name|info
operator|.
name|symbol
operator|=
name|symbol
expr_stmt|;
name|info
operator|.
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|warning_find_reloc
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|found
condition|)
name|einfo
argument_list|(
literal|"%B: %s\n"
argument_list|,
name|abfd
argument_list|,
name|warning
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|asymbols
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called by warning_callback for each section.  It checks the    relocs of the section to see if it can find a reference to the    symbol which triggered the warning.  If it can, it uses the reloc    to give an error message with a file and line number.  */
end_comment

begin_function
specifier|static
name|void
name|warning_find_reloc
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|iarg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|iarg
decl_stmt|;
block|{
name|struct
name|warning_callback_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|warning_callback_info
operator|*
operator|)
name|iarg
decl_stmt|;
name|long
name|relsize
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|long
name|relcount
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|found
condition|)
return|return;
name|relsize
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsize
operator|==
literal|0
condition|)
return|return;
name|relpp
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|relsize
argument_list|)
expr_stmt|;
name|relcount
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relpp
argument_list|,
name|info
operator|->
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|relcount
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read relocs: %E\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|relpp
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|relcount
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|pend
operator|&&
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|arelent
modifier|*
name|q
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
operator|*
name|q
operator|->
name|sym_ptr_ptr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_asymbol_name
argument_list|(
operator|*
name|q
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|info
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found a reloc for the symbol we are looking for.  */
name|einfo
argument_list|(
literal|"%C: %s\n"
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|q
operator|->
name|address
argument_list|,
name|info
operator|->
name|warning
argument_list|)
expr_stmt|;
name|info
operator|->
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|relpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called when an undefined symbol is found.  */
end_comment

begin_function
specifier|static
name|boolean
name|undefined_symbol
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|,
name|fatal
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|boolean
name|fatal
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|error_name
decl_stmt|;
specifier|static
name|unsigned
name|int
name|error_count
decl_stmt|;
define|#
directive|define
name|MAX_ERRORS_IN_A_ROW
value|5
if|if
condition|(
name|config
operator|.
name|warn_once
condition|)
block|{
specifier|static
name|struct
name|bfd_hash_table
modifier|*
name|hash
decl_stmt|;
comment|/* Only warn once about a particular undefined symbol.  */
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|hash
operator|=
operator|(
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|hash
argument_list|,
name|bfd_hash_newfunc
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We never print more than a reasonable number of errors in a row      for a single symbol.  */
if|if
condition|(
name|error_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|error_name
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|error_count
expr_stmt|;
else|else
block|{
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|free
argument_list|(
name|error_name
argument_list|)
expr_stmt|;
name|error_name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error_count
operator|<
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%C: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|einfo
argument_list|(
literal|"%X"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error_count
operator|==
name|MAX_ERRORS_IN_A_ROW
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%D: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error_count
operator|<
name|MAX_ERRORS_IN_A_ROW
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: undefined reference to `%T'\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|einfo
argument_list|(
literal|"%X"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error_count
operator|==
name|MAX_ERRORS_IN_A_ROW
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B: more undefined references to `%T' follow\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when a reloc overflows.  */
end_comment

begin_function
specifier|static
name|boolean
name|reloc_overflow
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|reloc_name
parameter_list|,
name|addend
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|reloc_name
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: generated"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%X%C:"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|" relocation truncated to fit: %s %T"
argument_list|)
argument_list|,
name|reloc_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addend
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
literal|"+%v"
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when a dangerous relocation is made.  */
end_comment

begin_function
specifier|static
name|boolean
name|reloc_dangerous
parameter_list|(
name|info
parameter_list|,
name|message
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: generated"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%X%C:"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"dangerous relocation: %s\n"
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called when a reloc is being generated attached to a symbol    that is not being output.  */
end_comment

begin_function
specifier|static
name|boolean
name|unattached_reloc
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|address
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: generated"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%X%C:"
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|" reloc refers to symbol `%T' which is not being output\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called if link_info.notice_all is set, or when a symbol in    link_info.notice_hash is found.  Symbols are put in notice_hash    using the -y option.  */
end_comment

begin_function
specifier|static
name|boolean
name|notice
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|notice_all
operator|||
operator|(
name|info
operator|->
name|notice_hash
operator|!=
name|NULL
operator|&&
name|bfd_hash_lookup
argument_list|(
name|info
operator|->
name|notice_hash
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|section
argument_list|)
condition|)
name|einfo
argument_list|(
literal|"%B: reference to %s\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%B: definition of %s\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|command_line
operator|.
name|cref
operator|||
name|nocrossref_list
operator|!=
name|NULL
condition|)
name|add_cref
argument_list|(
name|name
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

end_unit

