begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse options for the GNU linker.    Copyright (C) 1991, 92, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldver.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_comment
comment|/* Somewhere above, sys/stat.h got included . . . . */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Omit args to avoid the possibility of clashing with a system header    that might disagree about consts.  */
end_comment

begin_function_decl
name|unsigned
name|long
name|strtoul
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|set_default_dirlist
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dirlist_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_section_start
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|sect
operator|,
name|char
operator|*
name|valstr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we are processing a --defsym from the command line.  */
end_comment

begin_decl_stmt
name|int
name|parsing_defsym
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes used for the long options with no short synonyms.  150 isn't    special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_ASSERT
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_CALL_SHARED
value|(OPTION_ASSERT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CREF
value|(OPTION_CALL_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DEFSYM
value|(OPTION_CREF + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DYNAMIC_LINKER
value|(OPTION_DEFSYM + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_DYNAMIC_LINKER + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_EB + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EMBEDDED_RELOCS
value|(OPTION_EL + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EXPORT_DYNAMIC
value|(OPTION_EMBEDDED_RELOCS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_HELP
value|(OPTION_EXPORT_DYNAMIC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_IGNORE
value|(OPTION_HELP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_MAP
value|(OPTION_IGNORE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_KEEP_MEMORY
value|(OPTION_MAP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NOINHIBIT_EXEC
value|(OPTION_NO_KEEP_MEMORY + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NON_SHARED
value|(OPTION_NOINHIBIT_EXEC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_WHOLE_ARCHIVE
value|(OPTION_NON_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_OFORMAT
value|(OPTION_NO_WHOLE_ARCHIVE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_OFORMAT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RETAIN_SYMBOLS_FILE
value|(OPTION_RELAX + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RPATH
value|(OPTION_RETAIN_SYMBOLS_FILE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RPATH_LINK
value|(OPTION_RPATH + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SHARED
value|(OPTION_RPATH_LINK + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SONAME
value|(OPTION_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SORT_COMMON
value|(OPTION_SONAME + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STATS
value|(OPTION_SORT_COMMON + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SYMBOLIC
value|(OPTION_STATS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TBSS
value|(OPTION_SYMBOLIC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TDATA
value|(OPTION_TBSS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TTEXT
value|(OPTION_TDATA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TRADITIONAL_FORMAT
value|(OPTION_TTEXT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_UR
value|(OPTION_TRADITIONAL_FORMAT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERBOSE
value|(OPTION_UR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERSION
value|(OPTION_VERBOSE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERSION_SCRIPT
value|(OPTION_VERSION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_COMMON
value|(OPTION_VERSION_SCRIPT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_CONSTRUCTORS
value|(OPTION_WARN_COMMON + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_MULTIPLE_GP
value|(OPTION_WARN_CONSTRUCTORS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_ONCE
value|(OPTION_WARN_MULTIPLE_GP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_SECTION_ALIGN
value|(OPTION_WARN_ONCE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SPLIT_BY_RELOC
value|(OPTION_WARN_SECTION_ALIGN + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SPLIT_BY_FILE
value|(OPTION_SPLIT_BY_RELOC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WHOLE_ARCHIVE
value|(OPTION_SPLIT_BY_FILE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WRAP
value|(OPTION_WHOLE_ARCHIVE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_FORCE_EXE_SUFFIX
value|(OPTION_WRAP + 1)
end_define

begin_comment
comment|/* The long options.  This structure is used for both the option    parsing and the help text.  */
end_comment

begin_struct
struct|struct
name|ld_option
block|{
comment|/* The long option information.  */
name|struct
name|option
name|opt
decl_stmt|;
comment|/* The short option with the same meaning ('\0' if none).  */
name|char
name|shortopt
decl_stmt|;
comment|/* The name of the argument (NULL if none).  */
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* The documentation string.  If this is NULL, this is a synonym for      the previous option.  */
specifier|const
name|char
modifier|*
name|doc
decl_stmt|;
enum|enum
block|{
comment|/* Use one dash before long option name.  */
name|ONE_DASH
block|,
comment|/* Use two dashes before long option name.  */
name|TWO_DASHES
block|,
comment|/* Don't mention this option in --help output.  */
name|NO_HELP
block|}
name|control
enum|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ld_option
name|ld_options
index|[]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'a'
block|,
literal|"KEYWORD"
block|,
literal|"Shared library control for HP/UX compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
literal|'A'
block|,
literal|"ARCH"
block|,
literal|"Set architecture"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
literal|'b'
block|,
literal|"TARGET"
block|,
literal|"Specify target for following input files"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"mri-script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
literal|'c'
block|,
literal|"FILE"
block|,
literal|"Read MRI format linker script"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'d'
block|,
name|NULL
block|,
literal|"Force common symbols to be defined"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"entry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
literal|'e'
block|,
literal|"ADDRESS"
block|,
literal|"Set start address"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"export-dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EXPORT_DYNAMIC
block|}
block|,
literal|'E'
block|,
name|NULL
block|,
literal|"Export all dynamic symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"auxiliary"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
literal|'f'
block|,
literal|"SHLIB"
block|,
literal|"Auxiliary filter for shared object symbol table"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"filter"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
literal|'F'
block|,
literal|"SHLIB"
block|,
literal|"Filter for shared object symbol table"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'g'
block|,
name|NULL
block|,
literal|"Ignored"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"gpsize"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
literal|'G'
block|,
literal|"SIZE"
block|,
literal|"Small data size (if no size, same as --shared)"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"soname"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SONAME
block|}
block|,
literal|'h'
block|,
literal|"FILENAME"
block|,
literal|"Set internal name of shared library"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"library"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
literal|'l'
block|,
literal|"LIBNAME"
block|,
literal|"Search for library LIBNAME"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"library-path"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
literal|'L'
block|,
literal|"DIRECTORY"
block|,
literal|"Add DIRECTORY to library search path"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'m'
block|,
literal|"EMULATION"
block|,
literal|"Set emulation"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"print-map"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
literal|'M'
block|,
name|NULL
block|,
literal|"Print map file on standard output"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"nmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
literal|'n'
block|,
name|NULL
block|,
literal|"Do not page align data"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"omagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
literal|'N'
block|,
name|NULL
block|,
literal|"Do not page align data, do not make text readonly"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
literal|'o'
block|,
literal|"FILE"
block|,
literal|"Set output file name"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'O'
block|,
name|NULL
block|,
literal|"Ignored"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"relocateable"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
literal|'r'
block|,
name|NULL
block|,
literal|"Generate relocateable output"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'i'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"just-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
literal|'R'
block|,
literal|"FILE"
block|,
literal|"Just link symbols (if directory, same as --rpath)"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
literal|'s'
block|,
name|NULL
block|,
literal|"Strip all symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
literal|'S'
block|,
name|NULL
block|,
literal|"Strip debugging symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
literal|'t'
block|,
name|NULL
block|,
literal|"Trace file opens"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
literal|'T'
block|,
literal|"FILE"
block|,
literal|"Read linker script"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"undefined"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
literal|'u'
block|,
literal|"SYMBOL"
block|,
literal|"Start with undefined reference to SYMBOL"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERSION
block|}
block|,
literal|'v'
block|,
name|NULL
block|,
literal|"Print version information"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'V'
block|,
name|NULL
block|,
literal|"Print version and emulation information"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
literal|'x'
block|,
name|NULL
block|,
literal|"Discard all local symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
literal|'X'
block|,
name|NULL
block|,
literal|"Discard temporary local symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'y'
block|}
block|,
literal|'y'
block|,
literal|"SYMBOL"
block|,
literal|"Trace mentions of SYMBOL"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'Y'
block|,
literal|"PATH"
block|,
literal|"Default search path for Solaris compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'z'
block|,
literal|"KEYWORD"
block|,
literal|"Ignored for Solaris compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"start-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'('
block|}
block|,
literal|'('
block|,
name|NULL
block|,
literal|"Start a group"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"end-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|')'
block|}
block|,
literal|')'
block|,
name|NULL
block|,
literal|"End a group"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"assert"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ASSERT
block|}
block|,
literal|'\0'
block|,
literal|"KEYWORD"
block|,
literal|"Ignored for SunOS compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bdynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Link against shared libraries"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"call_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bstatic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Do not link against shared libraries"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dn"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"non_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"static"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bsymbolic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SYMBOLIC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Bind global references locally"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"cref"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CREF
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Output cross reference table"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"defsym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFSYM
block|}
block|,
literal|'\0'
block|,
literal|"SYMBOL=EXPRESSION"
block|,
literal|"Define a symbol"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dynamic-linker"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LINKER
block|}
block|,
literal|'\0'
block|,
literal|"PROGRAM"
block|,
literal|"Set the dynamic linker to use"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Link big-endian objects"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Link little-endian objects"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"embedded-relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EMBEDDED_RELOCS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Generate embedded relocs"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"force-exe-suffix"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FORCE_EXE_SUFFIX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Force generation of file with .exe suffix"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_HELP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Print option help"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Map"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MAP
block|}
block|,
literal|'\0'
block|,
literal|"FILE"
block|,
literal|"Write a map file"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"no-keep-memory"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_KEEP_MEMORY
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Use less memory and more disk I/O"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Turn off --whole-archive"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit-exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Create an output file even if errors occur"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit_exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"oformat"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_OFORMAT
block|}
block|,
literal|'\0'
block|,
literal|"TARGET"
block|,
literal|"Specify target of output file"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"qmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Ignored for Linux compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Qy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Ignored for SVR4 compatibility"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Relax branches on certain targets"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"retain-symbols-file"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RETAIN_SYMBOLS_FILE
block|}
block|,
literal|'\0'
block|,
literal|"FILE"
block|,
literal|"Keep only symbols listed in FILE"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"rpath"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH
block|}
block|,
literal|'\0'
block|,
literal|"PATH"
block|,
literal|"Set runtime shared library search path"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"rpath-link"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH_LINK
block|}
block|,
literal|'\0'
block|,
literal|"PATH"
block|,
literal|"Set link time shared library search path"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Create a shared library"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bshareable"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
comment|/* FreeBSD.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"sort-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Sort common symbols by size"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"sort_common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"split-by-file"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_FILE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Split output sections for each file"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"split-by-reloc"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_RELOC
block|}
block|,
literal|'\0'
block|,
literal|"COUNT"
block|,
literal|"Split output sections every COUNT relocs"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"stats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STATS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Print memory usage statistics"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"traditional-format"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRADITIONAL_FORMAT
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Use same format as native linker"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Tbss"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TBSS
block|}
block|,
literal|'\0'
block|,
literal|"ADDRESS"
block|,
literal|"Set address of .bss section"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Tdata"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TDATA
block|}
block|,
literal|'\0'
block|,
literal|"ADDRESS"
block|,
literal|"Set address of .data section"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Ttext"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TTEXT
block|}
block|,
literal|'\0'
block|,
literal|"ADDRESS"
block|,
literal|"Set address of .text section"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Ur"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_UR
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Build global constructor/destructor tables"
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Output lots of information during link"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dll-verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
comment|/* Linux.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"version-script"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_VERSION_SCRIPT
block|}
block|,
literal|'\0'
block|,
literal|"FILE"
block|,
literal|"Read version information script"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Warn about duplicate common symbols"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-constructors"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_CONSTRUCTORS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Warn if global constructors/destructors are seen"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-multiple-gp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_MULTIPLE_GP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Warn if the multiple GP values are used"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-once"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_ONCE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Warn only once per undefined symbol"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-section-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_SECTION_ALIGN
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Warn if start of section changes due to alignment"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
literal|"Include all objects from following archives"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"wrap"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_WRAP
block|}
block|,
literal|'\0'
block|,
literal|"SYMBOL"
block|,
literal|"Use wrapper functions for SYMBOL"
block|,
name|TWO_DASHES
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_COUNT
value|(sizeof ld_options / sizeof ld_options[0])
end_define

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|is
decl_stmt|,
name|il
decl_stmt|;
name|int
name|ingroup
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|default_dirlist
init|=
name|NULL
decl_stmt|;
name|char
name|shortopts
index|[
name|OPTION_COUNT
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|option
name|longopts
index|[
name|OPTION_COUNT
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Starting the short option string with '-' is for programs that      expect options and other ARGV-elements in any order and that care about      the ordering of the two.  We describe each non-option ARGV-element      as if it were the argument of an option with character code 1.  */
name|shortopts
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|is
operator|=
literal|1
expr_stmt|;
name|il
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|required_argument
operator|||
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|longopts
index|[
name|il
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
expr_stmt|;
operator|++
name|il
expr_stmt|;
block|}
block|}
name|shortopts
index|[
name|is
index|]
operator|=
literal|'\0'
expr_stmt|;
name|longopts
index|[
name|il
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* The -G option is ambiguous on different platforms.  Sometimes it      specifies the largest data size to put into the small data      section.  Sometimes it is equivalent to --shared.  Unfortunately,      the first form takes an argument, while the second does not.       We need to permit the --shared form because on some platforms,      such as Solaris, gcc -shared will pass -G to the linker.       To permit either usage, we look through the argument list.  If we      find -G not followed by a number, we change it into --shared.      This will work for most normal cases.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-G"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|+
literal|1
operator|>=
name|argc
operator|||
operator|!
name|isdigit
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"--shared"
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* getopt_long_only is like getopt_long, but '-' as well as '--' can 	 indicate a long option.  */
name|int
name|longind
decl_stmt|;
name|int
name|optc
decl_stmt|;
if|if
condition|(
name|ldemul_parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
continue|continue;
name|optc
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
expr_stmt|;
if|if
condition|(
name|optc
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|optc
condition|)
block|{
default|default:
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* File name.  */
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_IGNORE
case|:
break|break;
case|case
literal|'a'
case|:
comment|/* For HP/UX compatibility.  Actually -a shared should mean              ``use only shared libraries'' but, then, we don't              currently support shared libraries on HP/UX anyhow.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"archive"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"shared"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|true
expr_stmt|;
else|else
name|einfo
argument_list|(
literal|"%P%F: unrecognized -a option `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ASSERT
case|:
comment|/* FIXME: We just ignore these, but we should handle them.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"definitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nodefinitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nosymbolic"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"pure-text"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|einfo
argument_list|(
literal|"%P%F: unrecognized -assert option `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|ldfile_add_arch
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|lang_add_target
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_mri_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_CALL_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NON_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_CREF
case|:
name|command_line
operator|.
name|cref
operator|=
name|true
expr_stmt|;
name|link_info
operator|.
name|notice_all
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|command_line
operator|.
name|force_common_definition
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_DEFSYM
case|:
name|lex_string
operator|=
name|optarg
expr_stmt|;
name|lex_redirect
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_defsym
expr_stmt|;
name|parsing_defsym
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|parsing_defsym
operator|=
literal|0
expr_stmt|;
name|lex_string
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPTION_DYNAMIC_LINKER
case|:
name|command_line
operator|.
name|interpreter
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_BIG
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_LITTLE
expr_stmt|;
break|break;
case|case
name|OPTION_EMBEDDED_RELOCS
case|:
name|command_line
operator|.
name|embedded_relocs
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_EXPORT_DYNAMIC
case|:
case|case
literal|'E'
case|:
comment|/* HP/UX compatibility.  */
name|command_line
operator|.
name|export_dynamic
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|lang_add_entry
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|command_line
operator|.
name|auxiliary_filters
operator|==
name|NULL
condition|)
block|{
name|command_line
operator|.
name|auxiliary_filters
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|command_line
operator|.
name|auxiliary_filters
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
operator|++
name|c
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|command_line
operator|.
name|auxiliary_filters
argument_list|,
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
name|command_line
operator|.
name|filter_shlib
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_FORCE_EXE_SUFFIX
case|:
name|command_line
operator|.
name|force_exe_suffix
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|g_switch_value
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
literal|"%P%F: invalid number `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
comment|/* Ignore.  */
break|break;
case|case
name|OPTION_HELP
case|:
name|help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|ldfile_add_library_path
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_l_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|config
operator|.
name|map_filename
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Ignore.  Was handled in a pre-parse.   */
break|break;
case|case
name|OPTION_MAP
case|:
name|config
operator|.
name|map_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NO_KEEP_MEMORY
case|:
name|link_info
operator|.
name|keep_memory
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NOINHIBIT_EXEC
case|:
name|force_make_executable
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* FIXME "-O<non-digits><value>" used to set the address of 	     section<non-digits>.  Was this for compatibility with 	     something, or can we create a new option to do that 	     (with a syntax similar to -defsym)? 	     getopt can't handle two args to an option without kludges.  */
break|break;
case|case
literal|'o'
case|:
name|lang_add_output
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_OFORMAT
case|:
name|lang_add_output_format
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'r'
case|:
name|link_info
operator|.
name|relocateable
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* The GNU linker traditionally uses -R to mean to include 	     only the symbols from a file.  The Solaris linker uses -R 	     to set the path used by the runtime linker to find 	     libraries.  This is the GNU linker -rpath argument.  We 	     try to support both simultaneously by checking the file 	     named.  If it is a directory, rather than a regular file, 	     we assume -rpath was meant.  */
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|optarg
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_symbols_only_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
case|case
name|OPTION_RPATH
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath
operator|=
name|buystring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|command_line
operator|.
name|rpath
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_RPATH_LINK
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath_link
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath_link
operator|=
name|buystring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|command_line
operator|.
name|rpath_link
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath_link
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_RELAX
case|:
name|command_line
operator|.
name|relax
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_RETAIN_SYMBOLS_FILE
case|:
name|add_keepsyms_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_debugger
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_all
expr_stmt|;
break|break;
case|case
name|OPTION_SHARED
case|:
name|link_info
operator|.
name|shared
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Used on Solaris.  */
case|case
name|OPTION_SONAME
case|:
name|command_line
operator|.
name|soname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_SORT_COMMON
case|:
name|config
operator|.
name|sort_common
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_STATS
case|:
name|config
operator|.
name|stats
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_SYMBOLIC
case|:
name|link_info
operator|.
name|symbolic
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace_files
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_TBSS
case|:
name|set_section_start
argument_list|(
literal|".bss"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TDATA
case|:
name|set_section_start
argument_list|(
literal|".data"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TTEXT
case|:
name|set_section_start
argument_list|(
literal|".text"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TRADITIONAL_FORMAT
case|:
name|link_info
operator|.
name|traditional_format
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_UR
case|:
name|link_info
operator|.
name|relocateable
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ldlang_add_undef
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_VERBOSE
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
name|trace_file_tries
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ldversion
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
comment|/* This output is intended to follow the GNU standards document.  */
name|printf
argument_list|(
literal|"GNU ld %s\n"
argument_list|,
name|ld_program_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Copyright 1997 Free Software Foundation, Inc.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ This program is free software; you may redistribute it under the terms of\n\ the GNU General Public License.  This program has absolutely no warranty.\n"
argument_list|)
expr_stmt|;
block|{
name|ld_emulation_xfer_type
modifier|*
modifier|*
name|ptr
init|=
name|ld_emulations
decl_stmt|;
name|printf
argument_list|(
literal|"  Supported emulations:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"   %s\n"
argument_list|,
operator|(
operator|*
name|ptr
operator|)
operator|->
name|emulation_name
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
block|}
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION_SCRIPT
case|:
comment|/* This option indicates a small script that only specifies              version information.  Read it, but don't assume that              we've seen a linker script.  */
block|{
name|boolean
name|hold_had_script
decl_stmt|;
name|hold_had_script
operator|=
name|had_script
expr_stmt|;
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|had_script
operator|=
name|hold_had_script
expr_stmt|;
name|parser_input
operator|=
name|input_version_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_WARN_COMMON
case|:
name|config
operator|.
name|warn_common
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_CONSTRUCTORS
case|:
name|config
operator|.
name|warn_constructors
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_MULTIPLE_GP
case|:
name|config
operator|.
name|warn_multiple_gp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_ONCE
case|:
name|config
operator|.
name|warn_once
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_SECTION_ALIGN
case|:
name|config
operator|.
name|warn_section_align
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WRAP
case|:
name|add_wrap
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_l
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_all
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"P,"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|optarg
operator|+=
literal|2
expr_stmt|;
name|default_dirlist
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|add_ysym
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* We accept and ignore this option for Solaris              compatibility.  Actually, on Solaris, optarg is not              ignored.  Someday we should handle it correctly.  FIXME.  */
break|break;
case|case
name|OPTION_SPLIT_BY_RELOC
case|:
name|config
operator|.
name|split_by_reloc
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SPLIT_BY_FILE
case|:
name|config
operator|.
name|split_by_file
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|ingroup
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: may not nest groups (--help for usage)\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lang_enter_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
name|ingroup
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: group ended before it began (--help for usage)\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lang_leave_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ingroup
condition|)
name|lang_leave_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|default_dirlist
operator|!=
name|NULL
condition|)
name|set_default_dirlist
argument_list|(
name|default_dirlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the (colon-separated) elements of DIRLIST_PTR to the    library search path.  */
end_comment

begin_function
specifier|static
name|void
name|set_default_dirlist
parameter_list|(
name|dirlist_ptr
parameter_list|)
name|char
modifier|*
name|dirlist_ptr
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|dirlist_ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|dirlist_ptr
operator|!=
literal|'\0'
condition|)
name|ldfile_add_library_path
argument_list|(
name|dirlist_ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|dirlist_ptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_start
parameter_list|(
name|sect
parameter_list|,
name|valstr
parameter_list|)
name|char
modifier|*
name|sect
decl_stmt|,
decl|*
name|valstr
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|val
init|=
name|strtoul
argument_list|(
name|valstr
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
literal|"%P%F: invalid hex number `%s'\n"
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
name|lang_section_start
argument_list|(
name|sect
argument_list|,
name|exp_intop
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Print help messages for the options.  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|targets
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|printf
argument_list|(
literal|"Usage: %s [options] file...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|comma
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|comma
operator|=
name|false
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|printf
argument_list|(
literal|"%s-%c"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|!=
name|optional_argument
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|printf
argument_list|(
literal|"%s-%s%s"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|TWO_DASHES
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
operator|(
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|TWO_DASHES
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
if|if
condition|(
name|len
operator|>=
literal|30
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
operator|<
literal|30
condition|;
name|len
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s: supported targets:"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|targets
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|targets
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: supported emulations: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|ldemul_list_emulations
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nReport bugs to bug-gnu-utils@prep.ai.mit.edu\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

