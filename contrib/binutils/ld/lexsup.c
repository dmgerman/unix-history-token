begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse options for the GNU linker.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002    Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldver.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|';'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Somewhere above, sys/stat.h got included . . . .  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|is_num
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_default_dirlist
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dirlist_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_section_start
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|sect
operator|,
name|char
operator|*
name|valstr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|help
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we are processing a --defsym from the command line.  */
end_comment

begin_decl_stmt
name|int
name|parsing_defsym
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes used for the long options with no short synonyms.  150 isn't    special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_define
define|#
directive|define
name|OPTION_ASSERT
value|150
end_define

begin_define
define|#
directive|define
name|OPTION_CALL_SHARED
value|(OPTION_ASSERT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CREF
value|(OPTION_CALL_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DEFSYM
value|(OPTION_CREF + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DEMANGLE
value|(OPTION_DEFSYM + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DYNAMIC_LINKER
value|(OPTION_DEMANGLE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EB
value|(OPTION_DYNAMIC_LINKER + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EL
value|(OPTION_EB + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EMBEDDED_RELOCS
value|(OPTION_EL + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_EXPORT_DYNAMIC
value|(OPTION_EMBEDDED_RELOCS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_HELP
value|(OPTION_EXPORT_DYNAMIC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_IGNORE
value|(OPTION_HELP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_MAP
value|(OPTION_IGNORE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_DEMANGLE
value|(OPTION_MAP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_KEEP_MEMORY
value|(OPTION_NO_DEMANGLE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_WARN_MISMATCH
value|(OPTION_NO_KEEP_MEMORY + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NOINHIBIT_EXEC
value|(OPTION_NO_WARN_MISMATCH + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NON_SHARED
value|(OPTION_NOINHIBIT_EXEC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_WHOLE_ARCHIVE
value|(OPTION_NON_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_OFORMAT
value|(OPTION_NO_WHOLE_ARCHIVE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RELAX
value|(OPTION_OFORMAT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RETAIN_SYMBOLS_FILE
value|(OPTION_RELAX + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RPATH
value|(OPTION_RETAIN_SYMBOLS_FILE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_RPATH_LINK
value|(OPTION_RPATH + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SHARED
value|(OPTION_RPATH_LINK + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SONAME
value|(OPTION_SHARED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SORT_COMMON
value|(OPTION_SONAME + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_STATS
value|(OPTION_SORT_COMMON + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SYMBOLIC
value|(OPTION_STATS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TASK_LINK
value|(OPTION_SYMBOLIC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TBSS
value|(OPTION_TASK_LINK + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TDATA
value|(OPTION_TBSS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TTEXT
value|(OPTION_TDATA + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TRADITIONAL_FORMAT
value|(OPTION_TTEXT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_UR
value|(OPTION_TRADITIONAL_FORMAT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERBOSE
value|(OPTION_UR + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERSION
value|(OPTION_VERBOSE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERSION_SCRIPT
value|(OPTION_VERSION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_VERSION_EXPORTS_SECTION
value|(OPTION_VERSION_SCRIPT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_COMMON
value|(OPTION_VERSION_EXPORTS_SECTION + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_CONSTRUCTORS
value|(OPTION_WARN_COMMON + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_FATAL
value|(OPTION_WARN_CONSTRUCTORS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_MULTIPLE_GP
value|(OPTION_WARN_FATAL + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_ONCE
value|(OPTION_WARN_MULTIPLE_GP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WARN_SECTION_ALIGN
value|(OPTION_WARN_ONCE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SPLIT_BY_RELOC
value|(OPTION_WARN_SECTION_ALIGN + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SPLIT_BY_FILE
value|(OPTION_SPLIT_BY_RELOC + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WHOLE_ARCHIVE
value|(OPTION_SPLIT_BY_FILE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_WRAP
value|(OPTION_WHOLE_ARCHIVE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_FORCE_EXE_SUFFIX
value|(OPTION_WRAP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_GC_SECTIONS
value|(OPTION_FORCE_EXE_SUFFIX + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_GC_SECTIONS
value|(OPTION_GC_SECTIONS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_CHECK_SECTIONS
value|(OPTION_NO_GC_SECTIONS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_CHECK_SECTIONS
value|(OPTION_CHECK_SECTIONS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_MPC860C0
value|(OPTION_NO_CHECK_SECTIONS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_UNDEFINED
value|(OPTION_MPC860C0 + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_INIT
value|(OPTION_NO_UNDEFINED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_FINI
value|(OPTION_INIT + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SECTION_START
value|(OPTION_FINI + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_UNIQUE
value|(OPTION_SECTION_START + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_TARGET_HELP
value|(OPTION_UNIQUE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_ALLOW_SHLIB_UNDEFINED
value|(OPTION_TARGET_HELP + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_DISCARD_NONE
value|(OPTION_ALLOW_SHLIB_UNDEFINED + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_SPARE_DYNAMIC_TAGS
value|(OPTION_DISCARD_NONE + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NO_DEFINE_COMMON
value|(OPTION_SPARE_DYNAMIC_TAGS + 1)
end_define

begin_define
define|#
directive|define
name|OPTION_NOSTDLIB
value|(OPTION_NO_DEFINE_COMMON + 1)
end_define

begin_comment
comment|/* The long options.  This structure is used for both the option    parsing and the help text.  */
end_comment

begin_struct
struct|struct
name|ld_option
block|{
comment|/* The long option information.  */
name|struct
name|option
name|opt
decl_stmt|;
comment|/* The short option with the same meaning ('\0' if none).  */
name|char
name|shortopt
decl_stmt|;
comment|/* The name of the argument (NULL if none).  */
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* The documentation string.  If this is NULL, this is a synonym for      the previous option.  */
specifier|const
name|char
modifier|*
name|doc
decl_stmt|;
enum|enum
block|{
comment|/* Use one dash before long option name.  */
name|ONE_DASH
block|,
comment|/* Use two dashes before long option name.  */
name|TWO_DASHES
block|,
comment|/* Only accept two dashes before the long option name.        This is an overloading of the use of this enum, since originally it        was only intended to tell the --help display function how to display        the long option name.  This feature was added in order to resolve        the confusion about the -omagic command line switch.  Is it setting        the output file name to "magic" or is it setting the NMAGIC flag on        the output ?  It has been decided that it is setting the output file        name, and that if you want to set the NMAGIC flag you should use -N        or --omagic.  */
name|EXACTLY_TWO_DASHES
block|,
comment|/* Don't mention this option in --help output.  */
name|NO_HELP
block|}
name|control
enum|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ld_option
name|ld_options
index|[]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'a'
block|,
name|N_
argument_list|(
literal|"KEYWORD"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Shared library control for HP/UX compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
literal|'A'
block|,
name|N_
argument_list|(
literal|"ARCH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set architecture"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
literal|'b'
block|,
name|N_
argument_list|(
literal|"TARGET"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Specify target for following input files"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"mri-script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
literal|'c'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read MRI format linker script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'d'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Force common symbols to be defined"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"entry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
literal|'e'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set start address"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"export-dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EXPORT_DYNAMIC
block|}
block|,
literal|'E'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Export all dynamic symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link big-endian objects"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link little-endian objects"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"auxiliary"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
literal|'f'
block|,
name|N_
argument_list|(
literal|"SHLIB"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Auxiliary filter for shared object symbol table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"filter"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
literal|'F'
block|,
name|N_
argument_list|(
literal|"SHLIB"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Filter for shared object symbol table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'g'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"gpsize"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
literal|'G'
block|,
name|N_
argument_list|(
literal|"SIZE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Small data size (if no size, same as --shared)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"soname"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SONAME
block|}
block|,
literal|'h'
block|,
name|N_
argument_list|(
literal|"FILENAME"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set internal name of shared library"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dynamic-linker"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LINKER
block|}
block|,
literal|'I'
block|,
name|N_
argument_list|(
literal|"PROGRAM"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set PROGRAM as the dynamic linker to use"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"library"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
literal|'l'
block|,
name|N_
argument_list|(
literal|"LIBNAME"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Search for library LIBNAME"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"library-path"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
literal|'L'
block|,
name|N_
argument_list|(
literal|"DIRECTORY"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Add DIRECTORY to library search path"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'m'
block|,
name|N_
argument_list|(
literal|"EMULATION"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set emulation"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"print-map"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
literal|'M'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print map file on standard output"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"nmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
literal|'n'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not page align data"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"omagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
literal|'N'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not page align data, do not make text readonly"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
literal|'o'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set output file name"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'O'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Optimize output file"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Qy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored for SVR4 compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"emit-relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
literal|'q'
block|,
name|NULL
block|,
literal|"Generate relocations in final output"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"relocateable"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
literal|'r'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Generate relocateable output"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'i'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"just-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
literal|'R'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Just link symbols (if directory, same as --rpath)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
literal|'s'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Strip all symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
literal|'S'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Strip debugging symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
literal|'t'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Trace file opens"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
literal|'T'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read linker script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"undefined"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
literal|'u'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Start with undefined reference to SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"unique"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_UNIQUE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=SECTION]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Don't merge input [SECTION | orphan] sections"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Ur"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_UR
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Build global constructor/destructor tables"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERSION
block|}
block|,
literal|'v'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print version information"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'V'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print version and emulation information"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
literal|'x'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Discard all local symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
literal|'X'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Discard temporary local symbols (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"discard-none"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DISCARD_NONE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't discard any local symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'y'
block|}
block|,
literal|'y'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Trace mentions of SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'Y'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Default search path for Solaris compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"start-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'('
block|}
block|,
literal|'('
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Start a group"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"end-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|')'
block|}
block|,
literal|')'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"End a group"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"assert"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ASSERT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"KEYWORD"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Ignored for SunOS compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bdynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link against shared libraries"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"call_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bstatic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not link against shared libraries"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dn"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"non_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"static"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bsymbolic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SYMBOLIC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Bind global references locally"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"check-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CHECK_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Check section addresses for overlaps (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-check-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_CHECK_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not check section addresses for overlaps"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"cref"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CREF
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Output cross reference table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"defsym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFSYM
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL=EXPRESSION"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Define a symbol"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_DEMANGLE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=STYLE]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Demangle symbol names [using STYLE]"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"embedded-relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EMBEDDED_RELOCS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Generate embedded relocs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"fini"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_FINI
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Call SYMBOL at unload-time"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"force-exe-suffix"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FORCE_EXE_SUFFIX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Force generation of file with .exe suffix"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Remove unused sections (on some targets)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't remove unused sections (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_HELP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print option help"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"init"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_INIT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Call SYMBOL at load-time"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Map"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MAP
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Write a map file"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"no-define-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DEFINE_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not define Common storage"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-demangle"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DEMANGLE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not demangle symbol names"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-keep-memory"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_KEEP_MEMORY
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use less memory and more disk I/O"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-undefined"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_UNDEFINED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Allow no undefined symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"allow-shlib-undefined"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ALLOW_SHLIB_UNDEFINED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Allow undefined symbols in shared objects"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-warn-mismatch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_MISMATCH
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't warn about mismatched input files"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Turn off --whole-archive"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit-exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create an output file even if errors occur"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit_exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"nostdlib"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOSTDLIB
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Only use library directories specified on\n\t\t\t\tthe command line"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"oformat"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_OFORMAT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"TARGET"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Specify target of output file"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
literal|"qmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored for Linux compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Relax branches on certain targets"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"retain-symbols-file"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RETAIN_SYMBOLS_FILE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Keep only symbols listed in FILE"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"rpath"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set runtime shared library search path"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"rpath-link"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH_LINK
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set link time shared library search path"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create a shared library"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bshareable"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
comment|/* FreeBSD.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"sort-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Sort common symbols by size"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"sort_common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"spare-dynamic-tags"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SPARE_DYNAMIC_TAGS
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"COUNT"
argument_list|)
block|,
name|N_
argument_list|(
literal|"How many tags to reserve in .dynamic section"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"split-by-file"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_FILE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=SIZE]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Split output sections every SIZE octets"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"split-by-reloc"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_RELOC
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=COUNT]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Split output sections every COUNT relocs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"stats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STATS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print memory usage statistics"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"target-help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TARGET_HELP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Display target specific options"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"task-link"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TASK_LINK
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Do task level linking"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"traditional-format"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRADITIONAL_FORMAT
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use same format as native linker"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"section-start"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SECTION_START
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SECTION=ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of named section"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Tbss"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TBSS
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .bss section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Tdata"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TDATA
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .data section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Ttext"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TTEXT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .text section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Output lots of information during link"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dll-verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
comment|/* Linux.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"version-script"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_VERSION_SCRIPT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read version information script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"version-exports-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_VERSION_EXPORTS_SECTION
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Take export symbols list from .exports, using\n\t\t\t\tSYMBOL as the version."
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn about duplicate common symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-constructors"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_CONSTRUCTORS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if global constructors/destructors are seen"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-multiple-gp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_MULTIPLE_GP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if the multiple GP values are used"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-once"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_ONCE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn only once per undefined symbol"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-section-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_SECTION_ALIGN
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if start of section changes due to alignment"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"fatal-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_FATAL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Treat warnings as errors"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Include all objects from following archives"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"wrap"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_WRAP
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Use wrapper functions for SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"mpc860c0"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_MPC860C0
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=WORDS]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Modify problematic branches in last WORDS (1-10,\n\t\t\t\tdefault 5) words of a page"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_COUNT
value|ARRAY_SIZE (ld_options)
end_define

begin_comment
comment|/* Test STRING for containing a string of digits that form a number    between MIN and MAX.  The return value is the number or ERR.  */
end_comment

begin_function
specifier|static
name|int
name|is_num
parameter_list|(
name|string
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|err
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|err
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|string
condition|;
operator|++
name|string
control|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|string
argument_list|)
condition|)
block|{
name|result
operator|=
name|err
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|result
operator|*
literal|10
operator|+
operator|(
operator|*
name|string
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
name|min
operator|||
name|result
operator|>
name|max
condition|)
name|result
operator|=
name|err
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|unsigned
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|is
decl_stmt|,
name|il
decl_stmt|,
name|irl
decl_stmt|;
name|int
name|ingroup
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|default_dirlist
init|=
name|NULL
decl_stmt|;
name|char
name|shortopts
index|[
name|OPTION_COUNT
operator|*
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|option
name|longopts
index|[
name|OPTION_COUNT
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|option
name|really_longopts
index|[
name|OPTION_COUNT
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|last_optind
decl_stmt|;
comment|/* Starting the short option string with '-' is for programs that      expect options and other ARGV-elements in any order and that care about      the ordering of the two.  We describe each non-option ARGV-element      as if it were the argument of an option with character code 1.  */
name|shortopts
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|is
operator|=
literal|1
expr_stmt|;
name|il
operator|=
literal|0
expr_stmt|;
name|irl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|required_argument
operator|||
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|control
operator|==
name|EXACTLY_TWO_DASHES
condition|)
block|{
name|really_longopts
index|[
name|irl
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
expr_stmt|;
operator|++
name|irl
expr_stmt|;
block|}
else|else
block|{
name|longopts
index|[
name|il
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
expr_stmt|;
operator|++
name|il
expr_stmt|;
block|}
block|}
block|}
name|shortopts
index|[
name|is
index|]
operator|=
literal|'\0'
expr_stmt|;
name|longopts
index|[
name|il
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|really_longopts
index|[
name|irl
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* The -G option is ambiguous on different platforms.  Sometimes it      specifies the largest data size to put into the small data      section.  Sometimes it is equivalent to --shared.  Unfortunately,      the first form takes an argument, while the second does not.       We need to permit the --shared form because on some platforms,      such as Solaris, gcc -shared will pass -G to the linker.       To permit either usage, we look through the argument list.  If we      find -G not followed by a number, we change it into --shared.      This will work for most normal cases.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-G"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|+
literal|1
operator|>=
name|argc
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"--shared"
expr_stmt|;
comment|/* Because we permit long options to start with a single dash, and      we have a --library option, and the -l option is conventionally      used with an immediately following argument, we can have bad      results if somebody tries to use -l with a library whose name      happens to start with "ibrary", as in -li.  We avoid problems by      simply turning -l into --library.  This means that users will      have to use two dashes in order to use --library, which is OK      since that's how it is documented.       FIXME: It's possible that this problem can arise for other short      options as well, although the user does always have the recourse      of adding a space between the option and the argument.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"--library=%s"
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
name|last_optind
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|longind
decl_stmt|;
name|int
name|optc
decl_stmt|;
comment|/* Using last_optind lets us avoid calling ldemul_parse_args 	 multiple times on a single option, which would lead to 	 confusion in the internal static variables maintained by 	 getopt.  This could otherwise happen for an argument like 	 -nx, in which the -n is parsed as a single option, and we 	 loop around to pick up the -x.  */
if|if
condition|(
name|optind
operator|!=
name|last_optind
condition|)
if|if
condition|(
name|ldemul_parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
continue|continue;
comment|/* getopt_long_only is like getopt_long, but '-' as well as '--' 	 can indicate a long option.  */
name|opterr
operator|=
literal|0
expr_stmt|;
name|last_optind
operator|=
name|optind
expr_stmt|;
name|optc
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
expr_stmt|;
if|if
condition|(
name|optc
operator|==
literal|'?'
condition|)
block|{
name|optind
operator|=
name|last_optind
expr_stmt|;
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-"
argument_list|,
name|really_longopts
argument_list|,
operator|&
name|longind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optc
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'?'
case|:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: unrecognized option '%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
name|last_optind
index|]
argument_list|)
expr_stmt|;
default|default:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: use the --help option for usage information\n"
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* File name.  */
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_IGNORE
case|:
break|break;
case|case
literal|'a'
case|:
comment|/* For HP/UX compatibility.  Actually -a shared should mean              ``use only shared libraries'' but, then, we don't              currently support shared libraries on HP/UX anyhow.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"archive"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"shared"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|true
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unrecognized -a option `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ASSERT
case|:
comment|/* FIXME: We just ignore these, but we should handle them.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"definitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nodefinitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nosymbolic"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"pure-text"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unrecognized -assert option `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|ldfile_add_arch
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|lang_add_target
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_mri_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_CALL_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NON_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_CREF
case|:
name|command_line
operator|.
name|cref
operator|=
name|true
expr_stmt|;
name|link_info
operator|.
name|notice_all
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|command_line
operator|.
name|force_common_definition
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_DEFSYM
case|:
name|lex_string
operator|=
name|optarg
expr_stmt|;
name|lex_redirect
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_defsym
expr_stmt|;
name|parsing_defsym
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|parsing_defsym
operator|=
literal|0
expr_stmt|;
name|lex_string
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPTION_DEMANGLE
case|:
name|demangling
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: unknown demangling style `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* Used on Solaris.  */
case|case
name|OPTION_DYNAMIC_LINKER
case|:
name|command_line
operator|.
name|interpreter
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_EB
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_BIG
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_LITTLE
expr_stmt|;
break|break;
case|case
name|OPTION_EMBEDDED_RELOCS
case|:
name|command_line
operator|.
name|embedded_relocs
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_EXPORT_DYNAMIC
case|:
case|case
literal|'E'
case|:
comment|/* HP/UX compatibility.  */
name|link_info
operator|.
name|export_dynamic
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|lang_add_entry
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|command_line
operator|.
name|auxiliary_filters
operator|==
name|NULL
condition|)
block|{
name|command_line
operator|.
name|auxiliary_filters
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|command_line
operator|.
name|auxiliary_filters
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
operator|++
name|c
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|command_line
operator|.
name|auxiliary_filters
argument_list|,
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
name|command_line
operator|.
name|filter_shlib
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_FORCE_EXE_SUFFIX
case|:
name|command_line
operator|.
name|force_exe_suffix
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|g_switch_value
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid number `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
comment|/* Ignore.  */
break|break;
case|case
name|OPTION_GC_SECTIONS
case|:
name|command_line
operator|.
name|gc_sections
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_HELP
case|:
name|help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|ldfile_add_library_path
argument_list|(
name|optarg
argument_list|,
name|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_l_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|config
operator|.
name|map_filename
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Ignore.  Was handled in a pre-parse.   */
break|break;
case|case
name|OPTION_MAP
case|:
name|config
operator|.
name|map_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DEFINE_COMMON
case|:
name|command_line
operator|.
name|inhibit_common_definition
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DEMANGLE
case|:
name|demangling
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NO_GC_SECTIONS
case|:
name|command_line
operator|.
name|gc_sections
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NO_KEEP_MEMORY
case|:
name|link_info
operator|.
name|keep_memory
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NO_UNDEFINED
case|:
name|link_info
operator|.
name|no_undefined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_ALLOW_SHLIB_UNDEFINED
case|:
name|link_info
operator|.
name|allow_shlib_undefined
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WARN_MISMATCH
case|:
name|command_line
operator|.
name|warn_mismatch
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|OPTION_NOINHIBIT_EXEC
case|:
name|force_make_executable
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NOSTDLIB
case|:
name|config
operator|.
name|only_cmd_line_lib_dirs
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* FIXME "-O<non-digits><value>" used to set the address of 	     section<non-digits>.  Was this for compatibility with 	     something, or can we create a new option to do that 	     (with a syntax similar to -defsym)? 	     getopt can't handle two args to an option without kludges.  */
comment|/* Enable optimizations of output files.  */
name|link_info
operator|.
name|optimize
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|?
name|true
else|:
name|false
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|lang_add_output
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_OFORMAT
case|:
name|lang_add_output_format
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|link_info
operator|.
name|emitrelocations
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|optind
operator|==
name|last_optind
condition|)
comment|/* This can happen if the user put "-rpath,a" on the command 	       line.  (Or something similar.  The comma is important). 	       Getopt becomes confused and thinks that this is a -r option 	       but it cannot parse the text after the -r so it refuses to 	       increment the optind counter.  Detect this case and issue 	       an error message here.  We cannot just make this a warning, 	       increment optind, and continue because getopt is too confused 	       and will seg-fault the next time around.  */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bad -rpath option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|relocateable
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* The GNU linker traditionally uses -R to mean to include 	     only the symbols from a file.  The Solaris linker uses -R 	     to set the path used by the runtime linker to find 	     libraries.  This is the GNU linker -rpath argument.  We 	     try to support both simultaneously by checking the file 	     named.  If it is a directory, rather than a regular file, 	     we assume -rpath was meant.  */
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|optarg
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_symbols_only_enum
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
case|case
name|OPTION_RPATH
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|rpath_len
init|=
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
decl_stmt|;
name|size_t
name|optarg_len
init|=
name|strlen
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|command_line
operator|.
name|rpath
decl_stmt|;
comment|/* First see whether OPTARG is already in the path.  */
do|do
block|{
name|size_t
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|optarg
index|[
name|idx
index|]
operator|!=
literal|'\0'
operator|&&
name|optarg
index|[
name|idx
index|]
operator|==
name|cp
index|[
name|idx
index|]
condition|)
operator|++
name|idx
expr_stmt|;
if|if
condition|(
name|optarg
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|cp
index|[
name|idx
index|]
operator|==
literal|'\0'
operator|||
name|cp
index|[
name|idx
index|]
operator|==
literal|':'
operator|)
condition|)
comment|/* We found it.  */
break|break;
comment|/* Not yet found.  */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|++
name|cp
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|xmalloc
argument_list|(
name|rpath_len
operator|+
name|optarg_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|command_line
operator|.
name|rpath
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath
operator|=
name|buf
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPTION_RPATH_LINK
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath_link
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath_link
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%s"
argument_list|,
name|command_line
operator|.
name|rpath_link
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath_link
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_RELAX
case|:
name|command_line
operator|.
name|relax
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_RETAIN_SYMBOLS_FILE
case|:
name|add_keepsyms_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_debugger
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_all
expr_stmt|;
break|break;
case|case
name|OPTION_SHARED
case|:
if|if
condition|(
name|config
operator|.
name|has_shared
condition|)
name|link_info
operator|.
name|shared
operator|=
name|true
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -shared not supported\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Used on Solaris.  */
case|case
name|OPTION_SONAME
case|:
name|command_line
operator|.
name|soname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_SORT_COMMON
case|:
name|config
operator|.
name|sort_common
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_STATS
case|:
name|config
operator|.
name|stats
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_SYMBOLIC
case|:
name|link_info
operator|.
name|symbolic
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace_files
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_SECTION_START
case|:
block|{
name|char
modifier|*
name|optarg2
decl_stmt|;
name|char
modifier|*
name|sec_name
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Check for<something>=<somthing>...  */
name|optarg2
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|optarg2
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid argument to option \"--section-start\"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|optarg2
operator|++
expr_stmt|;
comment|/* So far so good.  Are all the args present?  */
if|if
condition|(
operator|(
operator|*
name|optarg
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|optarg2
operator|==
literal|'\0'
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: missing argument(s) to option \"--section-start\"\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must copy the section name as set_section_start 	       doesn't do it for us.  */
name|len
operator|=
name|optarg2
operator|-
name|optarg
expr_stmt|;
name|sec_name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
argument_list|,
name|optarg
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sec_name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Then set it...  */
name|set_section_start
argument_list|(
name|sec_name
argument_list|,
name|optarg2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_TARGET_HELP
case|:
comment|/* Mention any target specific options.  */
name|ldemul_list_emulation_options
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|OPTION_TBSS
case|:
name|set_section_start
argument_list|(
literal|".bss"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TDATA
case|:
name|set_section_start
argument_list|(
literal|".data"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TTEXT
case|:
name|set_section_start
argument_list|(
literal|".text"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TRADITIONAL_FORMAT
case|:
name|link_info
operator|.
name|traditional_format
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_TASK_LINK
case|:
name|link_info
operator|.
name|task_link
operator|=
name|true
expr_stmt|;
comment|/* Fall through - do an implied -r option.  */
case|case
name|OPTION_UR
case|:
name|link_info
operator|.
name|relocateable
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|true
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|false
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ldlang_add_undef
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_UNIQUE
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|lang_add_unique
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|unique_orphan_sections
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_VERBOSE
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
name|trace_file_tries
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ldversion
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
name|ldversion
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION_SCRIPT
case|:
comment|/* This option indicates a small script that only specifies              version information.  Read it, but don't assume that              we've seen a linker script.  */
block|{
name|FILE
modifier|*
name|hold_script_handle
decl_stmt|;
name|hold_script_handle
operator|=
name|saved_script_handle
expr_stmt|;
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|saved_script_handle
operator|=
name|hold_script_handle
expr_stmt|;
name|parser_input
operator|=
name|input_version_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_VERSION_EXPORTS_SECTION
case|:
comment|/* This option records a version symbol to be applied to the 	     symbols listed for export to be found in the object files 	     .exports sections.  */
name|command_line
operator|.
name|version_exports_section
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_COMMON
case|:
name|config
operator|.
name|warn_common
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_CONSTRUCTORS
case|:
name|config
operator|.
name|warn_constructors
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_FATAL
case|:
name|config
operator|.
name|fatal_warnings
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_MULTIPLE_GP
case|:
name|config
operator|.
name|warn_multiple_gp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_ONCE
case|:
name|config
operator|.
name|warn_once
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_SECTION_ALIGN
case|:
name|config
operator|.
name|warn_section_align
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_WRAP
case|:
name|add_wrap
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_DISCARD_NONE
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_none
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_l
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_all
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"P,"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|optarg
operator|+=
literal|2
expr_stmt|;
name|default_dirlist
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|add_ysym
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SPARE_DYNAMIC_TAGS
case|:
name|link_info
operator|.
name|spare_dynamic_tags
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SPLIT_BY_RELOC
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|config
operator|.
name|split_by_reloc
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|split_by_reloc
operator|=
literal|32768
expr_stmt|;
break|break;
case|case
name|OPTION_SPLIT_BY_FILE
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|config
operator|.
name|split_by_file
operator|=
name|bfd_scan_vma
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|split_by_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_CHECK_SECTIONS
case|:
name|command_line
operator|.
name|check_section_addresses
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_NO_CHECK_SECTIONS
case|:
name|command_line
operator|.
name|check_section_addresses
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|ingroup
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: may not nest groups (--help for usage)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lang_enter_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
name|ingroup
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: group ended before it began (--help for usage)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lang_leave_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_MPC860C0
case|:
comment|/* Default value (in bytes).  */
name|link_info
operator|.
name|mpc860c0
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|optarg
condition|)
block|{
name|unsigned
name|words
decl_stmt|;
name|words
operator|=
name|is_num
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|==
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid argument to option \"mpc860c0\"\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert words to bytes.  */
name|link_info
operator|.
name|mpc860c0
operator|=
name|words
operator|*
literal|4
expr_stmt|;
block|}
name|command_line
operator|.
name|relax
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OPTION_INIT
case|:
name|link_info
operator|.
name|init_function
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_FINI
case|:
name|link_info
operator|.
name|fini_function
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ingroup
condition|)
name|lang_leave_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|default_dirlist
operator|!=
name|NULL
condition|)
name|set_default_dirlist
argument_list|(
name|default_dirlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the (colon-separated) elements of DIRLIST_PTR to the    library search path.  */
end_comment

begin_function
specifier|static
name|void
name|set_default_dirlist
parameter_list|(
name|dirlist_ptr
parameter_list|)
name|char
modifier|*
name|dirlist_ptr
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|dirlist_ptr
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|dirlist_ptr
operator|!=
literal|'\0'
condition|)
name|ldfile_add_library_path
argument_list|(
name|dirlist_ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|dirlist_ptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_start
parameter_list|(
name|sect
parameter_list|,
name|valstr
parameter_list|)
name|char
modifier|*
name|sect
decl_stmt|,
decl|*
name|valstr
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|bfd_vma
name|val
init|=
name|bfd_scan_vma
argument_list|(
name|valstr
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid hex number `%s'\n"
argument_list|)
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
name|lang_section_start
argument_list|(
name|sect
argument_list|,
name|exp_intop
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Print help messages for the options.  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|targets
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [options] file...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|comma
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|comma
operator|=
name|false
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|printf
argument_list|(
literal|"%s-%c"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|!=
name|optional_argument
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|int
name|two_dashes
init|=
operator|(
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|TWO_DASHES
operator|||
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|EXACTLY_TWO_DASHES
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s-%s%s"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|two_dashes
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
operator|(
name|two_dashes
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
if|if
condition|(
name|len
operator|>=
literal|30
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
operator|<
literal|30
condition|;
name|len
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Note: Various tools (such as libtool) depend upon the      format of the listings below - do not change them.  */
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: supported targets:"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|targets
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|targets
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: supported emulations: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|ldemul_list_emulations
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: emulation specific options:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|ldemul_list_emulation_options
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

