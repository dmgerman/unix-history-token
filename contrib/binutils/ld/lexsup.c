begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse options for the GNU linker.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdver.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldver.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|';'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Somewhere above, sys/stat.h got included . . . .  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_default_dirlist
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_section_start
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_segment_start
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero if we are processing a --defsym from the command line.  */
end_comment

begin_decl_stmt
name|int
name|parsing_defsym
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes used for the long options with no short synonyms.  150 isn't    special; it's just an arbitrary non-ASCII char value.  */
end_comment

begin_enum
enum|enum
name|option_values
block|{
name|OPTION_ASSERT
init|=
literal|150
block|,
name|OPTION_CALL_SHARED
block|,
name|OPTION_CREF
block|,
name|OPTION_DEFSYM
block|,
name|OPTION_DEMANGLE
block|,
name|OPTION_DYNAMIC_LINKER
block|,
name|OPTION_SYSROOT
block|,
name|OPTION_EB
block|,
name|OPTION_EL
block|,
name|OPTION_EMBEDDED_RELOCS
block|,
name|OPTION_EXPORT_DYNAMIC
block|,
name|OPTION_HELP
block|,
name|OPTION_IGNORE
block|,
name|OPTION_MAP
block|,
name|OPTION_NO_DEMANGLE
block|,
name|OPTION_NO_KEEP_MEMORY
block|,
name|OPTION_NO_WARN_MISMATCH
block|,
name|OPTION_NO_WARN_SEARCH_MISMATCH
block|,
name|OPTION_NOINHIBIT_EXEC
block|,
name|OPTION_NON_SHARED
block|,
name|OPTION_NO_WHOLE_ARCHIVE
block|,
name|OPTION_OFORMAT
block|,
name|OPTION_RELAX
block|,
name|OPTION_RETAIN_SYMBOLS_FILE
block|,
name|OPTION_RPATH
block|,
name|OPTION_RPATH_LINK
block|,
name|OPTION_SHARED
block|,
name|OPTION_SONAME
block|,
name|OPTION_SORT_COMMON
block|,
name|OPTION_SORT_SECTION
block|,
name|OPTION_STATS
block|,
name|OPTION_SYMBOLIC
block|,
name|OPTION_SYMBOLIC_FUNCTIONS
block|,
name|OPTION_TASK_LINK
block|,
name|OPTION_TBSS
block|,
name|OPTION_TDATA
block|,
name|OPTION_TTEXT
block|,
name|OPTION_TRADITIONAL_FORMAT
block|,
name|OPTION_UR
block|,
name|OPTION_VERBOSE
block|,
name|OPTION_VERSION
block|,
name|OPTION_VERSION_SCRIPT
block|,
name|OPTION_VERSION_EXPORTS_SECTION
block|,
name|OPTION_DYNAMIC_LIST
block|,
name|OPTION_DYNAMIC_LIST_CPP_NEW
block|,
name|OPTION_DYNAMIC_LIST_CPP_TYPEINFO
block|,
name|OPTION_DYNAMIC_LIST_DATA
block|,
name|OPTION_WARN_COMMON
block|,
name|OPTION_WARN_CONSTRUCTORS
block|,
name|OPTION_WARN_FATAL
block|,
name|OPTION_WARN_MULTIPLE_GP
block|,
name|OPTION_WARN_ONCE
block|,
name|OPTION_WARN_SECTION_ALIGN
block|,
name|OPTION_SPLIT_BY_RELOC
block|,
name|OPTION_SPLIT_BY_FILE
block|,
name|OPTION_WHOLE_ARCHIVE
block|,
name|OPTION_ADD_NEEDED
block|,
name|OPTION_NO_ADD_NEEDED
block|,
name|OPTION_AS_NEEDED
block|,
name|OPTION_NO_AS_NEEDED
block|,
name|OPTION_WRAP
block|,
name|OPTION_FORCE_EXE_SUFFIX
block|,
name|OPTION_GC_SECTIONS
block|,
name|OPTION_NO_GC_SECTIONS
block|,
name|OPTION_PRINT_GC_SECTIONS
block|,
name|OPTION_NO_PRINT_GC_SECTIONS
block|,
name|OPTION_HASH_SIZE
block|,
name|OPTION_CHECK_SECTIONS
block|,
name|OPTION_NO_CHECK_SECTIONS
block|,
name|OPTION_NO_UNDEFINED
block|,
name|OPTION_INIT
block|,
name|OPTION_FINI
block|,
name|OPTION_SECTION_START
block|,
name|OPTION_UNIQUE
block|,
name|OPTION_TARGET_HELP
block|,
name|OPTION_ALLOW_SHLIB_UNDEFINED
block|,
name|OPTION_NO_ALLOW_SHLIB_UNDEFINED
block|,
name|OPTION_ALLOW_MULTIPLE_DEFINITION
block|,
name|OPTION_NO_UNDEFINED_VERSION
block|,
name|OPTION_DEFAULT_SYMVER
block|,
name|OPTION_DEFAULT_IMPORTED_SYMVER
block|,
name|OPTION_DISCARD_NONE
block|,
name|OPTION_SPARE_DYNAMIC_TAGS
block|,
name|OPTION_NO_DEFINE_COMMON
block|,
name|OPTION_NOSTDLIB
block|,
name|OPTION_NO_OMAGIC
block|,
name|OPTION_STRIP_DISCARDED
block|,
name|OPTION_NO_STRIP_DISCARDED
block|,
name|OPTION_ACCEPT_UNKNOWN_INPUT_ARCH
block|,
name|OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH
block|,
name|OPTION_PIE
block|,
name|OPTION_UNRESOLVED_SYMBOLS
block|,
name|OPTION_WARN_UNRESOLVED_SYMBOLS
block|,
name|OPTION_ERROR_UNRESOLVED_SYMBOLS
block|,
name|OPTION_WARN_SHARED_TEXTREL
block|,
name|OPTION_REDUCE_MEMORY_OVERHEADS
block|,
name|OPTION_DEFAULT_SCRIPT
block|}
enum|;
end_enum

begin_comment
comment|/* The long options.  This structure is used for both the option    parsing and the help text.  */
end_comment

begin_struct
struct|struct
name|ld_option
block|{
comment|/* The long option information.  */
name|struct
name|option
name|opt
decl_stmt|;
comment|/* The short option with the same meaning ('\0' if none).  */
name|char
name|shortopt
decl_stmt|;
comment|/* The name of the argument (NULL if none).  */
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* The documentation string.  If this is NULL, this is a synonym for      the previous option.  */
specifier|const
name|char
modifier|*
name|doc
decl_stmt|;
enum|enum
block|{
comment|/* Use one dash before long option name.  */
name|ONE_DASH
block|,
comment|/* Use two dashes before long option name.  */
name|TWO_DASHES
block|,
comment|/* Only accept two dashes before the long option name.        This is an overloading of the use of this enum, since originally it        was only intended to tell the --help display function how to display        the long option name.  This feature was added in order to resolve        the confusion about the -omagic command line switch.  Is it setting        the output file name to "magic" or is it setting the NMAGIC flag on        the output ?  It has been decided that it is setting the output file        name, and that if you want to set the NMAGIC flag you should use -N        or --omagic.  */
name|EXACTLY_TWO_DASHES
block|,
comment|/* Don't mention this option in --help output.  */
name|NO_HELP
block|}
name|control
enum|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ld_option
name|ld_options
index|[]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'a'
block|,
name|N_
argument_list|(
literal|"KEYWORD"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Shared library control for HP/UX compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"architecture"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
literal|'A'
block|,
name|N_
argument_list|(
literal|"ARCH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set architecture"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
literal|'b'
block|,
name|N_
argument_list|(
literal|"TARGET"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Specify target for following input files"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"mri-script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
literal|'c'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read MRI format linker script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dc"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'d'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Force common symbols to be defined"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"entry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
literal|'e'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set start address"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"export-dynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EXPORT_DYNAMIC
block|}
block|,
literal|'E'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Export all dynamic symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"EB"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EB
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link big-endian objects"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"EL"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link little-endian objects"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"auxiliary"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
literal|'f'
block|,
name|N_
argument_list|(
literal|"SHLIB"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Auxiliary filter for shared object symbol table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"filter"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
literal|'F'
block|,
name|N_
argument_list|(
literal|"SHLIB"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Filter for shared object symbol table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'g'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"gpsize"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
literal|'G'
block|,
name|N_
argument_list|(
literal|"SIZE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Small data size (if no size, same as --shared)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"soname"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SONAME
block|}
block|,
literal|'h'
block|,
name|N_
argument_list|(
literal|"FILENAME"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set internal name of shared library"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dynamic-linker"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LINKER
block|}
block|,
literal|'I'
block|,
name|N_
argument_list|(
literal|"PROGRAM"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set PROGRAM as the dynamic linker to use"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"library"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
literal|'l'
block|,
name|N_
argument_list|(
literal|"LIBNAME"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Search for library LIBNAME"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"library-path"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
literal|'L'
block|,
name|N_
argument_list|(
literal|"DIRECTORY"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Add DIRECTORY to library search path"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"sysroot=<DIRECTORY>"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SYSROOT
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Override the default sysroot location"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'m'
block|,
name|N_
argument_list|(
literal|"EMULATION"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set emulation"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"print-map"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
literal|'M'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print map file on standard output"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"nmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
literal|'n'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not page align data"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"omagic"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
literal|'N'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not page align data, do not make text readonly"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-omagic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_OMAGIC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Page align data, make text readonly"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
literal|"output"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
literal|'o'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set output file name"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'O'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Optimize output file"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Qy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored for SVR4 compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"emit-relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
literal|'q'
block|,
name|NULL
block|,
literal|"Generate relocations in final output"
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"relocatable"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
literal|'r'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Generate relocatable output"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'i'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"just-symbols"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
literal|'R'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Just link symbols (if directory, same as --rpath)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
literal|'s'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Strip all symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-debug"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
literal|'S'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Strip debugging symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"strip-discarded"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STRIP_DISCARDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Strip symbols in discarded sections"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-strip-discarded"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_STRIP_DISCARDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not strip symbols in discarded sections"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
literal|'t'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Trace file opens"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"script"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'T'
block|}
block|,
literal|'T'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read linker script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"default-script"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFAULT_SCRIPT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read default linker script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dT"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFAULT_SCRIPT
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"undefined"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
literal|'u'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Start with undefined reference to SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"unique"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_UNIQUE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=SECTION]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Don't merge input [SECTION | orphan] sections"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Ur"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_UR
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Build global constructor/destructor tables"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERSION
block|}
block|,
literal|'v'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print version information"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'V'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print version and emulation information"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"discard-all"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
literal|'x'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Discard all local symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"discard-locals"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
literal|'X'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Discard temporary local symbols (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"discard-none"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DISCARD_NONE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't discard any local symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"trace-symbol"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'y'
block|}
block|,
literal|'y'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Trace mentions of SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
name|NULL
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'\0'
block|}
block|,
literal|'Y'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Default search path for Solaris compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"start-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'('
block|}
block|,
literal|'('
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Start a group"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"end-group"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|')'
block|}
block|,
literal|')'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"End a group"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"accept-unknown-input-arch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ACCEPT_UNKNOWN_INPUT_ARCH
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Accept input files whose architecture cannot be determined"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-accept-unknown-input-arch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Reject input files whose architecture is unknown"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"add-needed"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ADD_NEEDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Set DT_NEEDED tags for DT_NEEDED entries in\n"
literal|"\t\t\t\tfollowing dynamic libs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-add-needed"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_ADD_NEEDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not set DT_NEEDED tags for DT_NEEDED entries\n"
literal|"\t\t\t\tin following dynamic libs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"as-needed"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_AS_NEEDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Only set DT_NEEDED for following dynamic libs if used"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-as-needed"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_AS_NEEDED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Always set DT_NEEDED for following dynamic libs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"assert"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_ASSERT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"KEYWORD"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Ignored for SunOS compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bdynamic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Link against shared libraries"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dy"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"call_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CALL_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bstatic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not link against shared libraries"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"dn"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"non_shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"static"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NON_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bsymbolic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SYMBOLIC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Bind global references locally"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bsymbolic-functions"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SYMBOLIC_FUNCTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Bind global function references locally"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"check-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CHECK_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Check section addresses for overlaps (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-check-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_CHECK_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not check section addresses for overlaps"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"cref"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_CREF
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Output cross reference table"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"defsym"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DEFSYM
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL=EXPRESSION"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Define a symbol"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"demangle"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_DEMANGLE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=STYLE]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Demangle symbol names [using STYLE]"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"embedded-relocs"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_EMBEDDED_RELOCS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Generate embedded relocs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"fatal-warnings"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_FATAL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Treat warnings as errors"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"fini"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_FINI
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Call SYMBOL at unload-time"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"force-exe-suffix"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_FORCE_EXE_SUFFIX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Force generation of file with .exe suffix"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Remove unused sections (on some targets)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't remove unused sections (default)"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"print-gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PRINT_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"List removed unused sections on stderr"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-print-gc-sections"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_PRINT_GC_SECTIONS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not list removed unused sections"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"hash-size=<NUMBER>"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_HASH_SIZE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Set default hash table size close to<NUMBER>"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_HELP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print option help"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"init"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_INIT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Call SYMBOL at load-time"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Map"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_MAP
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Write a map file"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"no-define-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DEFINE_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not define Common storage"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-demangle"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_DEMANGLE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not demangle symbol names"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-keep-memory"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_KEEP_MEMORY
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use less memory and more disk I/O"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-undefined"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_UNDEFINED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not allow unresolved references in object files"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"allow-shlib-undefined"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ALLOW_SHLIB_UNDEFINED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Allow unresolved references in shared libaries"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-allow-shlib-undefined"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_ALLOW_SHLIB_UNDEFINED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Do not allow unresolved references in shared libs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"allow-multiple-definition"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ALLOW_MULTIPLE_DEFINITION
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Allow multiple definitions"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-undefined-version"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_UNDEFINED_VERSION
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Disallow undefined version"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"default-symver"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DEFAULT_SYMVER
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create default symbol version"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"default-imported-symver"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DEFAULT_IMPORTED_SYMVER
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create default symbol version for imported symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-warn-mismatch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_MISMATCH
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't warn about mismatched input files"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-warn-search-mismatch"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WARN_SEARCH_MISMATCH
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Don't warn on finding an incompatible library"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"no-whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NO_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Turn off --whole-archive"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit-exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create an output file even if errors occur"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"noinhibit_exec"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOINHIBIT_EXEC
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"nostdlib"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_NOSTDLIB
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Only use library directories specified on\n"
literal|"\t\t\t\tthe command line"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"oformat"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_OFORMAT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"TARGET"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Specify target of output file"
argument_list|)
block|,
name|EXACTLY_TWO_DASHES
block|}
block|,
block|{
block|{
literal|"qmagic"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_IGNORE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Ignored for Linux compatibility"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"reduce-memory-overheads"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_REDUCE_MEMORY_OVERHEADS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Reduce memory overheads, possibly taking much longer"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"relax"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_RELAX
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Relax branches on certain targets"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"retain-symbols-file"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RETAIN_SYMBOLS_FILE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Keep only symbols listed in FILE"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"rpath"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set runtime shared library search path"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"rpath-link"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_RPATH_LINK
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"PATH"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set link time shared library search path"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"shared"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create a shared library"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Bshareable"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SHARED
block|}
block|,
comment|/* FreeBSD.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"pie"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Create a position independent executable"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"pic-executable"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_PIE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"sort-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Sort common symbols by size"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"sort_common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_SORT_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"sort-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SORT_SECTION
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"name|alignment"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Sort sections by name or maximum alignment"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"spare-dynamic-tags"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SPARE_DYNAMIC_TAGS
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"COUNT"
argument_list|)
block|,
name|N_
argument_list|(
literal|"How many tags to reserve in .dynamic section"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"split-by-file"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_FILE
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=SIZE]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Split output sections every SIZE octets"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"split-by-reloc"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|OPTION_SPLIT_BY_RELOC
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"[=COUNT]"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Split output sections every COUNT relocs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"stats"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_STATS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Print memory usage statistics"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"target-help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TARGET_HELP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Display target specific options"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"task-link"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TASK_LINK
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Do task level linking"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"traditional-format"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_TRADITIONAL_FORMAT
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use same format as native linker"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"section-start"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_SECTION_START
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SECTION=ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of named section"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"Tbss"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TBSS
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .bss section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Tdata"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TDATA
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .data section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"Ttext"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_TTEXT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"ADDRESS"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Set address of .text section"
argument_list|)
block|,
name|ONE_DASH
block|}
block|,
block|{
block|{
literal|"unresolved-symbols=<method>"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_UNRESOLVED_SYMBOLS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"How to handle unresolved symbols.<method> is:\n"
literal|"\t\t\t\tignore-all, report-all, ignore-in-object-files,\n"
literal|"\t\t\t\tignore-in-shared-libs"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Output lots of information during link"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dll-verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_VERBOSE
block|}
block|,
comment|/* Linux.  */
literal|'\0'
block|,
name|NULL
block|,
name|NULL
block|,
name|NO_HELP
block|}
block|,
block|{
block|{
literal|"version-script"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_VERSION_SCRIPT
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read version information script"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"version-exports-section"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_VERSION_EXPORTS_SECTION
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Take export symbols list from .exports, using\n"
literal|"\t\t\t\tSYMBOL as the version."
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dynamic-list-data"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LIST_DATA
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Add data symbols to dynamic list"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dynamic-list-cpp-new"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LIST_CPP_NEW
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use C++ operator new/delete dynamic list"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dynamic-list-cpp-typeinfo"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LIST_CPP_TYPEINFO
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Use C++ typeinfo dynamic list"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"dynamic-list"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_DYNAMIC_LIST
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"FILE"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Read dynamic list"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-common"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_COMMON
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn about duplicate common symbols"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-constructors"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_CONSTRUCTORS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if global constructors/destructors are seen"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-multiple-gp"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_MULTIPLE_GP
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if the multiple GP values are used"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-once"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_ONCE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn only once per undefined symbol"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-section-align"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_SECTION_ALIGN
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if start of section changes due to alignment"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-shared-textrel"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_SHARED_TEXTREL
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Warn if shared object has DT_TEXTREL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"warn-unresolved-symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WARN_UNRESOLVED_SYMBOLS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Report unresolved symbols as warnings"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"error-unresolved-symbols"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_ERROR_UNRESOLVED_SYMBOLS
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Report unresolved symbols as errors"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"whole-archive"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPTION_WHOLE_ARCHIVE
block|}
block|,
literal|'\0'
block|,
name|NULL
block|,
name|N_
argument_list|(
literal|"Include all objects from following archives"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|,
block|{
block|{
literal|"wrap"
block|,
name|required_argument
block|,
name|NULL
block|,
name|OPTION_WRAP
block|}
block|,
literal|'\0'
block|,
name|N_
argument_list|(
literal|"SYMBOL"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Use wrapper functions for SYMBOL"
argument_list|)
block|,
name|TWO_DASHES
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OPTION_COUNT
value|ARRAY_SIZE (ld_options)
end_define

begin_function
name|void
name|parse_args
parameter_list|(
name|unsigned
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|is
decl_stmt|,
name|il
decl_stmt|,
name|irl
decl_stmt|;
name|int
name|ingroup
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|default_dirlist
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|shortopts
decl_stmt|;
name|struct
name|option
modifier|*
name|longopts
decl_stmt|;
name|struct
name|option
modifier|*
name|really_longopts
decl_stmt|;
name|int
name|last_optind
decl_stmt|;
name|enum
name|report_method
name|how_to_report_unresolved_symbols
init|=
name|RM_GENERATE_ERROR
decl_stmt|;
name|shortopts
operator|=
name|xmalloc
argument_list|(
name|OPTION_COUNT
operator|*
literal|3
operator|+
literal|2
argument_list|)
expr_stmt|;
name|longopts
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|longopts
argument_list|)
operator|*
operator|(
name|OPTION_COUNT
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|really_longopts
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|really_longopts
argument_list|)
operator|*
operator|(
name|OPTION_COUNT
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Starting the short option string with '-' is for programs that      expect options and other ARGV-elements in any order and that care about      the ordering of the two.  We describe each non-option ARGV-element      as if it were the argument of an option with character code 1.  */
name|shortopts
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|is
operator|=
literal|1
expr_stmt|;
name|il
operator|=
literal|0
expr_stmt|;
name|irl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|shortopt
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|required_argument
operator|||
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|==
name|optional_argument
condition|)
block|{
name|shortopts
index|[
name|is
index|]
operator|=
literal|':'
expr_stmt|;
operator|++
name|is
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|control
operator|==
name|EXACTLY_TWO_DASHES
condition|)
block|{
name|really_longopts
index|[
name|irl
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
expr_stmt|;
operator|++
name|irl
expr_stmt|;
block|}
else|else
block|{
name|longopts
index|[
name|il
index|]
operator|=
name|ld_options
index|[
name|i
index|]
operator|.
name|opt
expr_stmt|;
operator|++
name|il
expr_stmt|;
block|}
block|}
block|}
name|shortopts
index|[
name|is
index|]
operator|=
literal|'\0'
expr_stmt|;
name|longopts
index|[
name|il
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|really_longopts
index|[
name|irl
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|ldemul_add_options
argument_list|(
name|is
argument_list|,
operator|&
name|shortopts
argument_list|,
name|il
argument_list|,
operator|&
name|longopts
argument_list|,
name|irl
argument_list|,
operator|&
name|really_longopts
argument_list|)
expr_stmt|;
comment|/* The -G option is ambiguous on different platforms.  Sometimes it      specifies the largest data size to put into the small data      section.  Sometimes it is equivalent to --shared.  Unfortunately,      the first form takes an argument, while the second does not.       We need to permit the --shared form because on some platforms,      such as Solaris, gcc -shared will pass -G to the linker.       To permit either usage, we look through the argument list.  If we      find -G not followed by a number, we change it into --shared.      This will work for most normal cases.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-G"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|+
literal|1
operator|>=
name|argc
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|argv
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|"--shared"
expr_stmt|;
comment|/* Because we permit long options to start with a single dash, and      we have a --library option, and the -l option is conventionally      used with an immediately following argument, we can have bad      results if somebody tries to use -l with a library whose name      happens to start with "ibrary", as in -li.  We avoid problems by      simply turning -l into --library.  This means that users will      have to use two dashes in order to use --library, which is OK      since that's how it is documented.       FIXME: It's possible that this problem can arise for other short      options as well, although the user does always have the recourse      of adding a space between the option and the argument.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"--library=%s"
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
name|last_optind
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|longind
decl_stmt|;
name|int
name|optc
decl_stmt|;
comment|/* Using last_optind lets us avoid calling ldemul_parse_args 	 multiple times on a single option, which would lead to 	 confusion in the internal static variables maintained by 	 getopt.  This could otherwise happen for an argument like 	 -nx, in which the -n is parsed as a single option, and we 	 loop around to pick up the -x.  */
if|if
condition|(
name|optind
operator|!=
name|last_optind
condition|)
if|if
condition|(
name|ldemul_parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
continue|continue;
comment|/* getopt_long_only is like getopt_long, but '-' as well as '--' 	 can indicate a long option.  */
name|opterr
operator|=
literal|0
expr_stmt|;
name|last_optind
operator|=
name|optind
expr_stmt|;
name|optc
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
operator|&
name|longind
argument_list|)
expr_stmt|;
if|if
condition|(
name|optc
operator|==
literal|'?'
condition|)
block|{
name|optind
operator|=
name|last_optind
expr_stmt|;
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-"
argument_list|,
name|really_longopts
argument_list|,
operator|&
name|longind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ldemul_handle_option
argument_list|(
name|optc
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|optc
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'?'
case|:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: unrecognized option '%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
name|last_optind
index|]
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: use the --help option for usage information\n"
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
comment|/* File name.  */
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_file_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_IGNORE
case|:
break|break;
case|case
literal|'a'
case|:
comment|/* For HP/UX compatibility.  Actually -a shared should mean 	     ``use only shared libraries'' but, then, we don't 	     currently support shared libraries on HP/UX anyhow.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"archive"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"shared"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|config
operator|.
name|dynamic_link
operator|=
name|TRUE
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unrecognized -a option `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_ASSERT
case|:
comment|/* FIXME: We just ignore these, but we should handle them.  */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"definitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nodefinitions"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"nosymbolic"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"pure-text"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unrecognized -assert option `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|ldfile_add_arch
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|lang_add_target
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_mri_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_CALL_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NON_SHARED
case|:
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_CREF
case|:
name|command_line
operator|.
name|cref
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|notice_all
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|command_line
operator|.
name|force_common_definition
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_DEFSYM
case|:
name|lex_string
operator|=
name|optarg
expr_stmt|;
name|lex_redirect
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_defsym
expr_stmt|;
name|parsing_defsym
operator|=
literal|1
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
name|parsing_defsym
operator|=
literal|0
expr_stmt|;
name|lex_string
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPTION_DEMANGLE
case|:
name|demangling
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: unknown demangling style `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* Used on Solaris.  */
case|case
name|OPTION_DYNAMIC_LINKER
case|:
name|command_line
operator|.
name|interpreter
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_SYSROOT
case|:
comment|/* Already handled in ldmain.c.  */
break|break;
case|case
name|OPTION_EB
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_BIG
expr_stmt|;
break|break;
case|case
name|OPTION_EL
case|:
name|command_line
operator|.
name|endian
operator|=
name|ENDIAN_LITTLE
expr_stmt|;
break|break;
case|case
name|OPTION_EMBEDDED_RELOCS
case|:
name|command_line
operator|.
name|embedded_relocs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_EXPORT_DYNAMIC
case|:
case|case
literal|'E'
case|:
comment|/* HP/UX compatibility.  */
name|link_info
operator|.
name|export_dynamic
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|lang_add_entry
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|command_line
operator|.
name|auxiliary_filters
operator|==
name|NULL
condition|)
block|{
name|command_line
operator|.
name|auxiliary_filters
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|command_line
operator|.
name|auxiliary_filters
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
operator|++
name|c
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
operator|=
name|xrealloc
argument_list|(
name|command_line
operator|.
name|auxiliary_filters
argument_list|,
operator|(
name|c
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
index|]
operator|=
name|optarg
expr_stmt|;
name|command_line
operator|.
name|auxiliary_filters
index|[
name|c
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
name|command_line
operator|.
name|filter_shlib
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_FORCE_EXE_SUFFIX
case|:
name|command_line
operator|.
name|force_exe_suffix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|g_switch_value
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid number `%s'\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
comment|/* Ignore.  */
break|break;
case|case
name|OPTION_GC_SECTIONS
case|:
name|link_info
operator|.
name|gc_sections
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_PRINT_GC_SECTIONS
case|:
name|link_info
operator|.
name|print_gc_sections
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_HELP
case|:
name|help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|ldfile_add_library_path
argument_list|(
name|optarg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_l_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|config
operator|.
name|map_filename
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Ignore.  Was handled in a pre-parse.   */
break|break;
case|case
name|OPTION_MAP
case|:
name|config
operator|.
name|map_filename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|config
operator|.
name|text_read_only
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_OMAGIC
case|:
name|config
operator|.
name|text_read_only
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|TRUE
expr_stmt|;
comment|/* NB/ Does not set dynamic_link to TRUE. 	     Use --call-shared or -Bdynamic for this.  */
break|break;
case|case
literal|'n'
case|:
name|config
operator|.
name|magic_demand_paged
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DEFINE_COMMON
case|:
name|command_line
operator|.
name|inhibit_common_definition
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_DEMANGLE
case|:
name|demangling
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_GC_SECTIONS
case|:
name|link_info
operator|.
name|gc_sections
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_PRINT_GC_SECTIONS
case|:
name|link_info
operator|.
name|print_gc_sections
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_KEEP_MEMORY
case|:
name|link_info
operator|.
name|keep_memory
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_UNDEFINED
case|:
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
break|break;
case|case
name|OPTION_ALLOW_SHLIB_UNDEFINED
case|:
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_IGNORE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_ALLOW_SHLIB_UNDEFINED
case|:
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
break|break;
case|case
name|OPTION_UNRESOLVED_SYMBOLS
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ignore-all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_IGNORE
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_IGNORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"report-all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ignore-in-object-files"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_IGNORE
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"ignore-in-shared-libs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_IGNORE
expr_stmt|;
block|}
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bad --unresolved-symbols option: %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_UNRESOLVED_SYMBOLS
case|:
name|how_to_report_unresolved_symbols
operator|=
name|RM_GENERATE_WARNING
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
condition|)
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_GENERATE_WARNING
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|==
name|RM_GENERATE_ERROR
condition|)
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_GENERATE_WARNING
expr_stmt|;
break|break;
case|case
name|OPTION_ERROR_UNRESOLVED_SYMBOLS
case|:
name|how_to_report_unresolved_symbols
operator|=
name|RM_GENERATE_ERROR
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_WARNING
condition|)
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_GENERATE_ERROR
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|==
name|RM_GENERATE_WARNING
condition|)
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_GENERATE_ERROR
expr_stmt|;
break|break;
case|case
name|OPTION_ALLOW_MULTIPLE_DEFINITION
case|:
name|link_info
operator|.
name|allow_multiple_definition
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_UNDEFINED_VERSION
case|:
name|link_info
operator|.
name|allow_undefined_version
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_DEFAULT_SYMVER
case|:
name|link_info
operator|.
name|create_default_symver
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_DEFAULT_IMPORTED_SYMVER
case|:
name|link_info
operator|.
name|default_imported_symver
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WARN_MISMATCH
case|:
name|command_line
operator|.
name|warn_mismatch
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WARN_SEARCH_MISMATCH
case|:
name|command_line
operator|.
name|warn_search_mismatch
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_NOINHIBIT_EXEC
case|:
name|force_make_executable
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NOSTDLIB
case|:
name|config
operator|.
name|only_cmd_line_lib_dirs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* FIXME "-O<non-digits><value>" used to set the address of 	     section<non-digits>.  Was this for compatibility with 	     something, or can we create a new option to do that 	     (with a syntax similar to -defsym)? 	     getopt can't handle two args to an option without kludges.  */
comment|/* Enable optimizations of output files.  */
name|link_info
operator|.
name|optimize
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|lang_add_output
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_OFORMAT
case|:
name|lang_add_output_format
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|link_info
operator|.
name|emitrelocations
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|optind
operator|==
name|last_optind
condition|)
comment|/* This can happen if the user put "-rpath,a" on the command 	       line.  (Or something similar.  The comma is important). 	       Getopt becomes confused and thinks that this is a -r option 	       but it cannot parse the text after the -r so it refuses to 	       increment the optind counter.  Detect this case and issue 	       an error message here.  We cannot just make this a warning, 	       increment optind, and continue because getopt is too confused 	       and will seg-fault the next time around.  */
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: bad -rpath option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|link_info
operator|.
name|relocatable
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* The GNU linker traditionally uses -R to mean to include 	     only the symbols from a file.  The Solaris linker uses -R 	     to set the path used by the runtime linker to find 	     libraries.  This is the GNU linker -rpath argument.  We 	     try to support both simultaneously by checking the file 	     named.  If it is a directory, rather than a regular file, 	     we assume -rpath was meant.  */
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|optarg
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|lang_add_input_file
argument_list|(
name|optarg
argument_list|,
name|lang_input_file_is_symbols_only_enum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
case|case
name|OPTION_RPATH
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|rpath_len
init|=
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
decl_stmt|;
name|size_t
name|optarg_len
init|=
name|strlen
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|command_line
operator|.
name|rpath
decl_stmt|;
comment|/* First see whether OPTARG is already in the path.  */
do|do
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
name|cp
argument_list|,
name|optarg_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
index|[
name|optarg_len
index|]
operator|==
literal|0
operator|||
name|cp
index|[
name|optarg_len
index|]
operator|==
name|config
operator|.
name|rpath_separator
operator|)
condition|)
comment|/* We found it.  */
break|break;
comment|/* Not yet found.  */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
name|config
operator|.
name|rpath_separator
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|++
name|cp
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|xmalloc
argument_list|(
name|rpath_len
operator|+
name|optarg_len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%c%s"
argument_list|,
name|command_line
operator|.
name|rpath
argument_list|,
name|config
operator|.
name|rpath_separator
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath
operator|=
name|buf
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPTION_RPATH_LINK
case|:
if|if
condition|(
name|command_line
operator|.
name|rpath_link
operator|==
name|NULL
condition|)
name|command_line
operator|.
name|rpath_link
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%c%s"
argument_list|,
name|command_line
operator|.
name|rpath_link
argument_list|,
name|config
operator|.
name|rpath_separator
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command_line
operator|.
name|rpath_link
argument_list|)
expr_stmt|;
name|command_line
operator|.
name|rpath_link
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_RELAX
case|:
name|command_line
operator|.
name|relax
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_RETAIN_SYMBOLS_FILE
case|:
name|add_keepsyms_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_debugger
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|link_info
operator|.
name|strip
operator|=
name|strip_all
expr_stmt|;
break|break;
case|case
name|OPTION_STRIP_DISCARDED
case|:
name|link_info
operator|.
name|strip_discarded
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_STRIP_DISCARDED
case|:
name|link_info
operator|.
name|strip_discarded
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_SHARED
case|:
if|if
condition|(
name|config
operator|.
name|has_shared
condition|)
block|{
name|link_info
operator|.
name|shared
operator|=
name|TRUE
expr_stmt|;
comment|/* When creating a shared library, the default 		 behaviour is to ignore any unresolved references.  */
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|==
name|RM_NOT_YET_SET
condition|)
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|RM_IGNORE
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|==
name|RM_NOT_YET_SET
condition|)
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|RM_IGNORE
expr_stmt|;
block|}
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -shared not supported\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_PIE
case|:
if|if
condition|(
name|config
operator|.
name|has_shared
condition|)
block|{
name|link_info
operator|.
name|shared
operator|=
name|TRUE
expr_stmt|;
name|link_info
operator|.
name|pie
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: -pie not supported\n"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Used on Solaris.  */
case|case
name|OPTION_SONAME
case|:
name|command_line
operator|.
name|soname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_SORT_COMMON
case|:
name|config
operator|.
name|sort_common
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_SORT_SECTION
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"name"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|sort_section
operator|=
name|by_name
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|N_
argument_list|(
literal|"alignment"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|sort_section
operator|=
name|by_alignment
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid section sorting option: %s\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_STATS
case|:
name|config
operator|.
name|stats
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_SYMBOLIC
case|:
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic
expr_stmt|;
break|break;
case|case
name|OPTION_SYMBOLIC_FUNCTIONS
case|:
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic_functions
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace_files
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|parser_input
operator|=
name|input_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
break|break;
case|case
name|OPTION_DEFAULT_SCRIPT
case|:
name|command_line
operator|.
name|default_script
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_SECTION_START
case|:
block|{
name|char
modifier|*
name|optarg2
decl_stmt|;
name|char
modifier|*
name|sec_name
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Check for<something>=<somthing>...  */
name|optarg2
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|optarg2
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid argument to option"
literal|" \"--section-start\"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|optarg2
operator|++
expr_stmt|;
comment|/* So far so good.  Are all the args present?  */
if|if
condition|(
operator|(
operator|*
name|optarg
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|optarg2
operator|==
literal|'\0'
operator|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: missing argument(s) to option"
literal|" \"--section-start\"\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must copy the section name as set_section_start 	       doesn't do it for us.  */
name|len
operator|=
name|optarg2
operator|-
name|optarg
expr_stmt|;
name|sec_name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sec_name
argument_list|,
name|optarg
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sec_name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Then set it...  */
name|set_section_start
argument_list|(
name|sec_name
argument_list|,
name|optarg2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_TARGET_HELP
case|:
comment|/* Mention any target specific options.  */
name|ldemul_list_emulation_options
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|OPTION_TBSS
case|:
name|set_segment_start
argument_list|(
literal|".bss"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TDATA
case|:
name|set_segment_start
argument_list|(
literal|".data"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TTEXT
case|:
name|set_segment_start
argument_list|(
literal|".text"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_TRADITIONAL_FORMAT
case|:
name|link_info
operator|.
name|traditional_format
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_TASK_LINK
case|:
name|link_info
operator|.
name|task_link
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through - do an implied -r option.  */
case|case
name|OPTION_UR
case|:
name|link_info
operator|.
name|relocatable
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|build_constructors
operator|=
name|TRUE
expr_stmt|;
name|config
operator|.
name|magic_demand_paged
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|text_read_only
operator|=
name|FALSE
expr_stmt|;
name|config
operator|.
name|dynamic_link
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|ldlang_add_undef
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_UNIQUE
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|lang_add_unique
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|unique_orphan_sections
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_VERBOSE
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|TRUE
expr_stmt|;
name|trace_file_tries
operator|=
name|TRUE
expr_stmt|;
name|overflow_cutoff_limit
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ldversion
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|ldversion
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|version_printed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION
case|:
name|ldversion
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_VERSION_SCRIPT
case|:
comment|/* This option indicates a small script that only specifies 	     version information.  Read it, but don't assume that 	     we've seen a linker script.  */
block|{
name|FILE
modifier|*
name|hold_script_handle
decl_stmt|;
name|hold_script_handle
operator|=
name|saved_script_handle
expr_stmt|;
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|saved_script_handle
operator|=
name|hold_script_handle
expr_stmt|;
name|parser_input
operator|=
name|input_version_script
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|OPTION_VERSION_EXPORTS_SECTION
case|:
comment|/* This option records a version symbol to be applied to the 	     symbols listed for export to be found in the object files 	     .exports sections.  */
name|command_line
operator|.
name|version_exports_section
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_DYNAMIC_LIST_DATA
case|:
name|command_line
operator|.
name|dynamic_list
operator|=
name|dynamic_list_data
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|symbolic
operator|==
name|symbolic
condition|)
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic_unset
expr_stmt|;
break|break;
case|case
name|OPTION_DYNAMIC_LIST_CPP_TYPEINFO
case|:
name|lang_append_dynamic_list_cpp_typeinfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|dynamic_list
operator|!=
name|dynamic_list_data
condition|)
name|command_line
operator|.
name|dynamic_list
operator|=
name|dynamic_list
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|symbolic
operator|==
name|symbolic
condition|)
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic_unset
expr_stmt|;
break|break;
case|case
name|OPTION_DYNAMIC_LIST_CPP_NEW
case|:
name|lang_append_dynamic_list_cpp_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|dynamic_list
operator|!=
name|dynamic_list_data
condition|)
name|command_line
operator|.
name|dynamic_list
operator|=
name|dynamic_list
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|symbolic
operator|==
name|symbolic
condition|)
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic_unset
expr_stmt|;
break|break;
case|case
name|OPTION_DYNAMIC_LIST
case|:
comment|/* This option indicates a small script that only specifies 	     a dynamic list.  Read it, but don't assume that we've 	     seen a linker script.  */
block|{
name|FILE
modifier|*
name|hold_script_handle
decl_stmt|;
name|hold_script_handle
operator|=
name|saved_script_handle
expr_stmt|;
name|ldfile_open_command_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|saved_script_handle
operator|=
name|hold_script_handle
expr_stmt|;
name|parser_input
operator|=
name|input_dynamic_list
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|command_line
operator|.
name|dynamic_list
operator|!=
name|dynamic_list_data
condition|)
name|command_line
operator|.
name|dynamic_list
operator|=
name|dynamic_list
expr_stmt|;
if|if
condition|(
name|command_line
operator|.
name|symbolic
operator|==
name|symbolic
condition|)
name|command_line
operator|.
name|symbolic
operator|=
name|symbolic_unset
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_COMMON
case|:
name|config
operator|.
name|warn_common
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_CONSTRUCTORS
case|:
name|config
operator|.
name|warn_constructors
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_FATAL
case|:
name|config
operator|.
name|fatal_warnings
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_MULTIPLE_GP
case|:
name|config
operator|.
name|warn_multiple_gp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_ONCE
case|:
name|config
operator|.
name|warn_once
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_SECTION_ALIGN
case|:
name|config
operator|.
name|warn_section_align
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WARN_SHARED_TEXTREL
case|:
name|link_info
operator|.
name|warn_shared_textrel
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_WHOLE_ARCHIVE
case|:
name|whole_archive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_ADD_NEEDED
case|:
name|add_needed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_ADD_NEEDED
case|:
name|add_needed
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_AS_NEEDED
case|:
comment|/* XXX: --as-needed is broken on powerpc64 */
ifndef|#
directive|ifndef
name|__powerpc64__
name|as_needed
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OPTION_NO_AS_NEEDED
case|:
name|as_needed
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_WRAP
case|:
name|add_wrap
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_DISCARD_NONE
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_none
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_l
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|link_info
operator|.
name|discard
operator|=
name|discard_all
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|optarg
argument_list|,
literal|"P,"
argument_list|)
condition|)
name|optarg
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|default_dirlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|default_dirlist
argument_list|)
expr_stmt|;
name|default_dirlist
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|add_ysym
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SPARE_DYNAMIC_TAGS
case|:
name|link_info
operator|.
name|spare_dynamic_tags
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTION_SPLIT_BY_RELOC
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|config
operator|.
name|split_by_reloc
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|split_by_reloc
operator|=
literal|32768
expr_stmt|;
break|break;
case|case
name|OPTION_SPLIT_BY_FILE
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|config
operator|.
name|split_by_file
operator|=
name|bfd_scan_vma
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|config
operator|.
name|split_by_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPTION_CHECK_SECTIONS
case|:
name|command_line
operator|.
name|check_section_addresses
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_CHECK_SECTIONS
case|:
name|command_line
operator|.
name|check_section_addresses
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|OPTION_ACCEPT_UNKNOWN_INPUT_ARCH
case|:
name|command_line
operator|.
name|accept_unknown_input_arch
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH
case|:
name|command_line
operator|.
name|accept_unknown_input_arch
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|ingroup
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: may not nest groups (--help for usage)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lang_enter_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
name|ingroup
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: group ended before it began (--help for usage)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lang_leave_group
argument_list|()
expr_stmt|;
name|ingroup
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OPTION_INIT
case|:
name|link_info
operator|.
name|init_function
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_FINI
case|:
name|link_info
operator|.
name|fini_function
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPTION_REDUCE_MEMORY_OVERHEADS
case|:
name|link_info
operator|.
name|reduce_memory_overheads
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|config
operator|.
name|hash_table_size
operator|==
literal|0
condition|)
name|config
operator|.
name|hash_table_size
operator|=
literal|1021
expr_stmt|;
break|break;
case|case
name|OPTION_HASH_SIZE
case|:
block|{
name|bfd_size_type
name|new_size
decl_stmt|;
name|new_size
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_size
condition|)
name|config
operator|.
name|hash_table_size
operator|=
name|new_size
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: --hash-size needs a numeric argument\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ingroup
condition|)
name|lang_leave_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|default_dirlist
operator|!=
name|NULL
condition|)
block|{
name|set_default_dirlist
argument_list|(
name|default_dirlist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|default_dirlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|==
name|RM_NOT_YET_SET
condition|)
comment|/* FIXME: Should we allow emulations a chance to set this ?  */
name|link_info
operator|.
name|unresolved_syms_in_objects
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|==
name|RM_NOT_YET_SET
condition|)
comment|/* FIXME: Should we allow emulations a chance to set this ?  */
name|link_info
operator|.
name|unresolved_syms_in_shared_libs
operator|=
name|how_to_report_unresolved_symbols
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the (colon-separated) elements of DIRLIST_PTR to the    library search path.  */
end_comment

begin_function
specifier|static
name|void
name|set_default_dirlist
parameter_list|(
name|char
modifier|*
name|dirlist_ptr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|dirlist_ptr
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|dirlist_ptr
operator|!=
literal|'\0'
condition|)
name|ldfile_add_library_path
argument_list|(
name|dirlist_ptr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|dirlist_ptr
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_section_start
parameter_list|(
name|char
modifier|*
name|sect
parameter_list|,
name|char
modifier|*
name|valstr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|bfd_vma
name|val
init|=
name|bfd_scan_vma
argument_list|(
name|valstr
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid hex number `%s'\n"
argument_list|)
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
name|lang_section_start
argument_list|(
name|sect
argument_list|,
name|exp_intop
argument_list|(
name|val
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_segment_start
parameter_list|(
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|char
modifier|*
name|valstr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|segment_type
modifier|*
name|seg
decl_stmt|;
name|bfd_vma
name|val
init|=
name|bfd_scan_vma
argument_list|(
name|valstr
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: invalid hex number `%s'\n"
argument_list|)
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
comment|/* If we already have an entry for this segment, update the existing      value.  */
name|name
operator|=
name|section
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|seg
operator|=
name|segments
init|;
name|seg
condition|;
name|seg
operator|=
name|seg
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|seg
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|seg
operator|->
name|value
operator|=
name|val
expr_stmt|;
return|return;
block|}
comment|/* There was no existing value so we must create a new segment      entry.  */
name|seg
operator|=
name|stat_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|)
expr_stmt|;
name|seg
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|seg
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|seg
operator|->
name|used
operator|=
name|FALSE
expr_stmt|;
comment|/* Add it to the linked list of segments.  */
name|seg
operator|->
name|next
operator|=
name|segments
expr_stmt|;
name|segments
operator|=
name|seg
expr_stmt|;
comment|/* Historically, -Ttext and friends set the base address of a      particular section.  For backwards compatibility, we still do      that.  If a SEGMENT_START directive is seen, the section address      assignment will be disabled.  */
name|lang_section_start
argument_list|(
name|section
argument_list|,
name|exp_intop
argument_list|(
name|val
argument_list|)
argument_list|,
name|seg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print help messages for the options.  */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|targets
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [options] file...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Options:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPTION_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|comma
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|comma
operator|=
name|FALSE
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
operator|!=
literal|'\0'
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|printf
argument_list|(
literal|"%s-%c"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|shortopt
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|has_arg
operator|!=
name|optional_argument
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|TRUE
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
name|j
operator|=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|!=
name|NO_HELP
condition|)
block|{
name|int
name|two_dashes
init|=
operator|(
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|TWO_DASHES
operator|||
name|ld_options
index|[
name|j
index|]
operator|.
name|control
operator|==
name|EXACTLY_TWO_DASHES
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s-%s%s"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|two_dashes
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
operator|(
name|comma
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
operator|(
name|two_dashes
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|opt
operator|.
name|name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|_
argument_list|(
name|ld_options
index|[
name|j
index|]
operator|.
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|comma
operator|=
name|TRUE
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|OPTION_COUNT
operator|&&
name|ld_options
index|[
name|j
index|]
operator|.
name|doc
operator|==
name|NULL
condition|)
do|;
if|if
condition|(
name|len
operator|>=
literal|30
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
operator|<
literal|30
condition|;
name|len
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|_
argument_list|(
name|ld_options
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|_
argument_list|(
literal|"  @FILE"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|strlen
argument_list|(
literal|"  @FILE"
argument_list|)
init|;
name|len
operator|<
literal|30
condition|;
name|len
operator|++
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Read options from FILE\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: Various tools (such as libtool) depend upon the      format of the listings below - do not change them.  */
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: supported targets:"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|targets
operator|=
name|bfd_target_list
argument_list|()
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|targets
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|targets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: supported emulations: "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|ldemul_list_emulations
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s: emulation specific options:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|ldemul_list_emulation_options
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REPORT_BUGS_TO
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Report bugs to %s\n"
argument_list|)
argument_list|,
name|REPORT_BUGS_TO
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

