begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldemul.c -- clearing house for ld emulation states    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2005, 2007    Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldemul-list.h"
end_include

begin_decl_stmt
specifier|static
name|ld_emulation_xfer_type
modifier|*
name|ld_emulation
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ldemul_hll
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ld_emulation
operator|->
name|hll
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_syslib
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ld_emulation
operator|->
name|syslib
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_after_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|after_parse
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_before_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|before_parse
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_after_open
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|after_open
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_after_allocation
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|after_allocation
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_before_allocation
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|before_allocation
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_set_output_arch
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|set_output_arch
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|ld_emulation
operator|->
name|finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_set_symbols
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|set_symbols
condition|)
name|ld_emulation
operator|->
name|set_symbols
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_create_output_section_statements
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|create_output_section_statements
condition|)
name|ld_emulation
operator|->
name|create_output_section_statements
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|ldemul_get_script
parameter_list|(
name|int
modifier|*
name|isfile
parameter_list|)
block|{
return|return
name|ld_emulation
operator|->
name|get_script
argument_list|(
name|isfile
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|ldemul_open_dynamic_archive
parameter_list|(
specifier|const
name|char
modifier|*
name|arch
parameter_list|,
name|search_dirs_type
modifier|*
name|search
parameter_list|,
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|open_dynamic_archive
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|open_dynamic_archive
call|)
argument_list|(
name|arch
argument_list|,
name|search
argument_list|,
name|entry
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|ldemul_place_orphan
parameter_list|(
name|asection
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|place_orphan
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|place_orphan
call|)
argument_list|(
name|s
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|ldemul_add_options
parameter_list|(
name|int
name|ns
parameter_list|,
name|char
modifier|*
modifier|*
name|shortopts
parameter_list|,
name|int
name|nl
parameter_list|,
name|struct
name|option
modifier|*
modifier|*
name|longopts
parameter_list|,
name|int
name|nrl
parameter_list|,
name|struct
name|option
modifier|*
modifier|*
name|really_longopts
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|add_options
condition|)
call|(
modifier|*
name|ld_emulation
operator|->
name|add_options
call|)
argument_list|(
name|ns
argument_list|,
name|shortopts
argument_list|,
name|nl
argument_list|,
name|longopts
argument_list|,
name|nrl
argument_list|,
name|really_longopts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|ldemul_handle_option
parameter_list|(
name|int
name|optc
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|handle_option
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|handle_option
call|)
argument_list|(
name|optc
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|ldemul_parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
comment|/* Try and use the emulation parser if there is one.  */
if|if
condition|(
name|ld_emulation
operator|->
name|parse_args
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|parse_args
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Let the emulation code handle an unrecognized file.  */
end_comment

begin_function
name|bfd_boolean
name|ldemul_unrecognized_file
parameter_list|(
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|unrecognized_file
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|unrecognized_file
call|)
argument_list|(
name|entry
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Let the emulation code handle a recognized file.  */
end_comment

begin_function
name|bfd_boolean
name|ldemul_recognized_file
parameter_list|(
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|recognized_file
condition|)
return|return
call|(
modifier|*
name|ld_emulation
operator|->
name|recognized_file
call|)
argument_list|(
name|entry
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ldemul_choose_target
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
name|ld_emulation
operator|->
name|choose_target
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The default choose_target function.  */
end_comment

begin_function
name|char
modifier|*
name|ldemul_default_target
parameter_list|(
name|int
name|argc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|from_outside
init|=
name|getenv
argument_list|(
name|TARGET_ENVIRON
argument_list|)
decl_stmt|;
if|if
condition|(
name|from_outside
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
name|from_outside
return|;
return|return
name|ld_emulation
operator|->
name|target_name
return|;
block|}
end_function

begin_function
name|void
name|after_parse_default
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|after_open_default
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|after_allocation_default
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|before_allocation_default
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
condition|)
name|strip_excluded_output_sections
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finish_default
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|.
name|relocatable
condition|)
name|_bfd_fix_excluded_sec_syms
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|link_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_output_arch_default
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Set the output architecture and machine if possible.  */
name|bfd_set_arch_mach
argument_list|(
name|output_bfd
argument_list|,
name|ldfile_output_architecture
argument_list|,
name|ldfile_output_machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|syslib_default
parameter_list|(
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"%S SYSLIB ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hll_default
parameter_list|(
name|char
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"%S HLL ignored\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|ld_emulation_xfer_type
modifier|*
name|ld_emulations
index|[]
init|=
block|{
name|EMULATION_LIST
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ldemul_choose_mode
parameter_list|(
name|char
modifier|*
name|target
parameter_list|)
block|{
name|ld_emulation_xfer_type
modifier|*
modifier|*
name|eptr
init|=
name|ld_emulations
decl_stmt|;
comment|/* Ignore "gld" prefix.  */
if|if
condition|(
name|target
index|[
literal|0
index|]
operator|==
literal|'g'
operator|&&
name|target
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|target
index|[
literal|2
index|]
operator|==
literal|'d'
condition|)
name|target
operator|+=
literal|3
expr_stmt|;
for|for
control|(
init|;
operator|*
name|eptr
condition|;
name|eptr
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target
argument_list|,
operator|(
operator|*
name|eptr
operator|)
operator|->
name|emulation_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ld_emulation
operator|=
operator|*
name|eptr
expr_stmt|;
return|return;
block|}
block|}
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: unrecognised emulation mode: %s\n"
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"Supported emulations: "
argument_list|)
argument_list|)
expr_stmt|;
name|ldemul_list_emulations
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
literal|"%F\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldemul_list_emulations
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|ld_emulation_xfer_type
modifier|*
modifier|*
name|eptr
init|=
name|ld_emulations
decl_stmt|;
name|bfd_boolean
name|first
init|=
name|TRUE
decl_stmt|;
for|for
control|(
init|;
operator|*
name|eptr
condition|;
name|eptr
operator|++
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|FALSE
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
operator|(
operator|*
name|eptr
operator|)
operator|->
name|emulation_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ldemul_list_emulation_options
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|ld_emulation_xfer_type
modifier|*
modifier|*
name|eptr
decl_stmt|;
name|int
name|options_found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|eptr
operator|=
name|ld_emulations
init|;
operator|*
name|eptr
condition|;
name|eptr
operator|++
control|)
block|{
name|ld_emulation_xfer_type
modifier|*
name|emul
init|=
operator|*
name|eptr
decl_stmt|;
if|if
condition|(
name|emul
operator|->
name|list_options
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s: \n"
argument_list|,
name|emul
operator|->
name|emulation_name
argument_list|)
expr_stmt|;
name|emul
operator|->
name|list_options
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|options_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|options_found
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"  no emulation specific options.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ldemul_find_potential_libraries
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|find_potential_libraries
condition|)
return|return
name|ld_emulation
operator|->
name|find_potential_libraries
argument_list|(
name|name
argument_list|,
name|entry
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|bfd_elf_version_expr
modifier|*
name|ldemul_new_vers_pattern
parameter_list|(
name|struct
name|bfd_elf_version_expr
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|ld_emulation
operator|->
name|new_vers_pattern
condition|)
name|entry
operator|=
call|(
modifier|*
name|ld_emulation
operator|->
name|new_vers_pattern
call|)
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

end_unit

