begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldctor.c -- constructor support routines    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.    By Steve Chamberlain<sac@cygnus.com>  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|ctor_prio
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctor_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of statements needed to handle constructors.  These are    invoked by the command CONSTRUCTORS in the linker script.  */
end_comment

begin_decl_stmt
name|lang_statement_list_type
name|constructor_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether the constructors should be sorted.  Note that this is    global for the entire link; we assume that there is only a single    CONSTRUCTORS command in the linker script.  */
end_comment

begin_decl_stmt
name|boolean
name|constructors_sorted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sets we have seen.  */
end_comment

begin_decl_stmt
name|struct
name|set_info
modifier|*
name|sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add an entry to a set.  H is the entry in the linker hash table.    RELOC is the relocation to use for an entry in the set.  SECTION    and VALUE are the value to add.  This is called during the first    phase of the link, when we are still gathering symbols together.    We just record the information now.  The ldctor_find_constructors    function will construct the sets.  */
end_comment

begin_function
name|void
name|ldctor_add_set_entry
parameter_list|(
name|h
parameter_list|,
name|reloc
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|struct
name|set_info
modifier|*
name|p
decl_stmt|;
name|struct
name|set_element
modifier|*
name|e
decl_stmt|;
name|struct
name|set_element
modifier|*
modifier|*
name|epp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sets
init|;
name|p
operator|!=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|h
operator|==
name|h
condition|)
break|break;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set_info
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sets
expr_stmt|;
name|sets
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|reloc
operator|!=
name|reloc
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: Different relocs used in set %s\n"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't permit a set to be constructed from different object          file formats.  The same reloc may have different results.  We          actually could sometimes handle this, but the case is          unlikely to ever arise.  Sometimes constructor symbols are in          unusual sections, such as the absolute section--this appears          to be the case in Linux a.out--and in such cases we just          assume everything is OK.  */
if|if
condition|(
name|p
operator|->
name|elements
operator|!=
name|NULL
operator|&&
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: Different object file formats composing set %s\n"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|e
operator|=
operator|(
expr|struct
name|set_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set_element
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|e
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|e
operator|->
name|value
operator|=
name|value
expr_stmt|;
for|for
control|(
name|epp
operator|=
operator|&
name|p
operator|->
name|elements
init|;
operator|*
name|epp
operator|!=
name|NULL
condition|;
name|epp
operator|=
operator|&
operator|(
operator|*
name|epp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|epp
operator|=
name|e
expr_stmt|;
operator|++
name|p
operator|->
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the priority of a g++ global constructor or destructor from the    symbol name.  */
end_comment

begin_function
specifier|static
name|int
name|ctor_prio
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* The name will look something like _GLOBAL_$I$65535$test02__Fv.      There might be extra leading underscores, and the $ characters      might be something else.  The I might be a D.  */
while|while
condition|(
operator|*
name|name
operator|==
literal|'_'
condition|)
operator|++
name|name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"GLOBAL_"
argument_list|,
sizeof|sizeof
expr|"GLOBAL_"
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|name
operator|+=
sizeof|sizeof
expr|"GLOBAL_"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
name|name
index|[
literal|2
index|]
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|!=
literal|'I'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'D'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|atoi
argument_list|(
name|name
operator|+
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is used to sort constructor elements by priority.  It    is called via qsort.  */
end_comment

begin_function
specifier|static
name|int
name|ctor_cmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|set_element
modifier|*
modifier|*
name|pe1
init|=
operator|(
specifier|const
expr|struct
name|set_element
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|set_element
modifier|*
modifier|*
name|pe2
init|=
operator|(
specifier|const
expr|struct
name|set_element
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
specifier|const
name|char
modifier|*
name|n1
decl_stmt|;
specifier|const
name|char
modifier|*
name|n2
decl_stmt|;
name|int
name|prio1
decl_stmt|;
name|int
name|prio2
decl_stmt|;
name|n1
operator|=
operator|(
operator|*
name|pe1
operator|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|n1
operator|==
name|NULL
condition|)
name|n1
operator|=
literal|""
expr_stmt|;
name|n2
operator|=
operator|(
operator|*
name|pe2
operator|)
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|n2
operator|==
name|NULL
condition|)
name|n2
operator|=
literal|""
expr_stmt|;
comment|/* We need to sort in reverse order by priority.  When two      constructors have the same priority, we should maintain their      current relative position.  */
name|prio1
operator|=
name|ctor_prio
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|prio2
operator|=
name|ctor_prio
argument_list|(
name|n2
argument_list|)
expr_stmt|;
comment|/* We sort in reverse order because that is what g++ expects.  */
if|if
condition|(
name|prio1
operator|<
name|prio2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|prio1
operator|>
name|prio2
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Force a stable sort.  */
if|if
condition|(
name|pe1
operator|<
name|pe2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|pe1
operator|>
name|pe2
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function is called after the first phase of the link and    before the second phase.  At this point all set information has    been gathered.  We now put the statements to build the sets    themselves into constructor_list.  */
end_comment

begin_function
name|void
name|ldctor_build_sets
parameter_list|()
block|{
specifier|static
name|boolean
name|called
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|old
decl_stmt|;
name|boolean
name|header_printed
decl_stmt|;
name|struct
name|set_info
modifier|*
name|p
decl_stmt|;
comment|/* The emulation code may call us directly, but we only want to do      this once.  */
if|if
condition|(
name|called
condition|)
return|return;
name|called
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|constructors_sorted
condition|)
block|{
for|for
control|(
name|p
operator|=
name|sets
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|set_element
modifier|*
name|e
decl_stmt|;
name|struct
name|set_element
modifier|*
modifier|*
name|array
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|elements
operator|==
name|NULL
condition|)
continue|continue;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|elements
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
operator|++
name|c
expr_stmt|;
name|array
operator|=
operator|(
expr|struct
name|set_element
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|c
operator|*
sizeof|sizeof
expr|*
name|array
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|elements
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
name|array
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|qsort
argument_list|(
name|array
argument_list|,
name|c
argument_list|,
sizeof|sizeof
expr|*
name|array
argument_list|,
name|ctor_cmp
argument_list|)
expr_stmt|;
name|e
operator|=
name|array
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|e
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|array
index|[
name|i
index|]
operator|->
name|next
operator|=
name|array
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|array
index|[
name|i
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
name|old
operator|=
name|stat_ptr
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|constructor_list
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sets
init|;
name|p
operator|!=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|set_element
modifier|*
name|e
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|reloc_size
decl_stmt|,
name|size
decl_stmt|;
comment|/* If the symbol is defined, we may have been invoked from 	 collect, and the sets may already have been built, so we do 	 not do anything.  */
if|if
condition|(
name|p
operator|->
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|p
operator|->
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
continue|continue;
comment|/* For each set we build: 	   set: 	     .long number_of_elements 	     .long element0 	     ... 	     .long elementN 	     .long 0 	 except that we use the right size instead of .long.  When 	 generating relocateable output, we generate relocs instead of 	 addresses.  */
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: %s does not support reloc %s for set %s\n"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|p
operator|->
name|reloc
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is not a relocateable link, all we need is the 	     size, which we can get from the input BFD.  */
if|if
condition|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|,
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: %s does not support reloc %s for set %s\n"
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|p
operator|->
name|reloc
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|reloc_size
operator|=
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reloc_size
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
name|BYTE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
name|SHORT
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
name|LONG
expr_stmt|;
break|break;
case|case
literal|8
case|:
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|==
name|complain_overflow_signed
condition|)
name|size
operator|=
name|SQUAD
expr_stmt|;
else|else
name|size
operator|=
name|QUAD
expr_stmt|;
break|break;
default|default:
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%X: Unsupported size %d for set %s\n"
argument_list|)
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|size
operator|=
name|LONG
expr_stmt|;
break|break;
block|}
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
literal|"."
argument_list|,
name|exp_unop
argument_list|(
name|ALIGN_K
argument_list|,
name|exp_intop
argument_list|(
name|reloc_size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|exp_nameop
argument_list|(
name|NAME
argument_list|,
literal|"."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_intop
argument_list|(
operator|(
name|bfd_vma
operator|)
name|p
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|elements
init|;
name|e
operator|!=
operator|(
expr|struct
name|set_element
operator|*
operator|)
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|minfo
argument_list|(
name|_
argument_list|(
literal|"\nSet                 Symbol\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|true
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|19
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|20
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%T\n"
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"%G\n"
argument_list|,
name|e
operator|->
name|section
operator|->
name|owner
argument_list|,
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Need SEC_KEEP for --gc-sections.  */
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|e
operator|->
name|section
argument_list|)
condition|)
name|e
operator|->
name|section
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
name|lang_add_reloc
argument_list|(
name|p
operator|->
name|reloc
argument_list|,
name|howto
argument_list|,
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|name
argument_list|,
name|exp_intop
argument_list|(
name|e
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_relop
argument_list|(
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_intop
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stat_ptr
operator|=
name|old
expr_stmt|;
block|}
end_function

end_unit

