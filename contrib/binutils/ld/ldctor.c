begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldctor.c -- constructor support routines    Copyright (C) 1991, 92, 93, 94, 1995 Free Software Foundation, Inc.    By Steve Chamberlain<sac@cygnus.com>     This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldctor.h"
end_include

begin_comment
comment|/* The list of statements needed to handle constructors.  These are    invoked by the command CONSTRUCTORS in the linker script.  */
end_comment

begin_decl_stmt
name|lang_statement_list_type
name|constructor_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sets we have seen.  */
end_comment

begin_decl_stmt
name|struct
name|set_info
modifier|*
name|sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add an entry to a set.  H is the entry in the linker hash table.    RELOC is the relocation to use for an entry in the set.  SECTION    and VALUE are the value to add.  This is called during the first    phase of the link, when we are still gathering symbols together.    We just record the information now.  The ldctor_find_constructors    function will construct the sets.  */
end_comment

begin_function
name|void
name|ldctor_add_set_entry
parameter_list|(
name|h
parameter_list|,
name|reloc
parameter_list|,
name|name
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_reloc_code_real_type
name|reloc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|struct
name|set_info
modifier|*
name|p
decl_stmt|;
name|struct
name|set_element
modifier|*
name|e
decl_stmt|;
name|struct
name|set_element
modifier|*
modifier|*
name|epp
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sets
init|;
name|p
operator|!=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|h
operator|==
name|h
condition|)
break|break;
if|if
condition|(
name|p
operator|==
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set_info
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|sets
expr_stmt|;
name|sets
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|p
operator|->
name|reloc
operator|=
name|reloc
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|elements
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|reloc
operator|!=
name|reloc
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%X: Different relocs used in set %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't permit a set to be constructed from different object          file formats.  The same reloc may have different results.  We          actually could sometimes handle this, but the case is          unlikely to ever arise.  Sometimes constructor symbols are in          unusual sections, such as the absolute section--this appears          to be the case in Linux a.out--and in such cases we just          assume everything is OK.  */
if|if
condition|(
name|p
operator|->
name|elements
operator|!=
name|NULL
operator|&&
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%X: Different object file formats composing set %s\n"
argument_list|,
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|e
operator|=
operator|(
expr|struct
name|set_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|set_element
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|e
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|e
operator|->
name|value
operator|=
name|value
expr_stmt|;
for|for
control|(
name|epp
operator|=
operator|&
name|p
operator|->
name|elements
init|;
operator|*
name|epp
operator|!=
name|NULL
condition|;
name|epp
operator|=
operator|&
operator|(
operator|*
name|epp
operator|)
operator|->
name|next
control|)
empty_stmt|;
operator|*
name|epp
operator|=
name|e
expr_stmt|;
operator|++
name|p
operator|->
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called after the first phase of the link and    before the second phase.  At this point all set information has    been gathered.  We now put the statements to build the sets    themselves into constructor_list.  */
end_comment

begin_function
name|void
name|ldctor_build_sets
parameter_list|()
block|{
specifier|static
name|boolean
name|called
decl_stmt|;
name|lang_statement_list_type
modifier|*
name|old
decl_stmt|;
name|boolean
name|header_printed
decl_stmt|;
name|struct
name|set_info
modifier|*
name|p
decl_stmt|;
comment|/* The emulation code may call us directly, but we only want to do      this once.  */
if|if
condition|(
name|called
condition|)
return|return;
name|called
operator|=
name|true
expr_stmt|;
name|old
operator|=
name|stat_ptr
expr_stmt|;
name|stat_ptr
operator|=
operator|&
name|constructor_list
expr_stmt|;
name|lang_list_init
argument_list|(
name|stat_ptr
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|false
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sets
init|;
name|p
operator|!=
operator|(
expr|struct
name|set_info
operator|*
operator|)
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|set_element
modifier|*
name|e
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* If the symbol is defined, we may have been invoked from 	 collect, and the sets may already have been built, so we do 	 not do anything.  */
if|if
condition|(
name|p
operator|->
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|p
operator|->
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
continue|continue;
comment|/* For each set we build: 	   set: 	     .long number_of_elements 	     .long element0 	     ... 	     .long elementN 	     .long 0 	 except that we use the right size instead of .long.  When 	 generating relocateable output, we generate relocs instead of 	 addresses.  */
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|output_bfd
argument_list|,
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%X: %s does not support reloc %s for set %s\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|p
operator|->
name|reloc
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is not a relocateable link, all we need is the 	     size, which we can get from the input BFD.  */
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|,
name|p
operator|->
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
literal|"%P%X: %s does not support reloc %s for set %s\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|p
operator|->
name|elements
operator|->
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_reloc_code_name
argument_list|(
name|p
operator|->
name|reloc
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
switch|switch
condition|(
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
name|BYTE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
name|SHORT
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
name|LONG
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|size
operator|=
name|QUAD
expr_stmt|;
break|break;
default|default:
name|einfo
argument_list|(
literal|"%P%X: Unsupported size %d for set %s\n"
argument_list|,
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|size
operator|=
name|LONG
expr_stmt|;
break|break;
block|}
name|lang_add_assignment
argument_list|(
name|exp_assop
argument_list|(
literal|'='
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|,
name|exp_nameop
argument_list|(
name|NAME
argument_list|,
literal|"."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_intop
argument_list|(
operator|(
name|bfd_vma
operator|)
name|p
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|p
operator|->
name|elements
init|;
name|e
operator|!=
operator|(
expr|struct
name|set_element
operator|*
operator|)
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|config
operator|.
name|map_file
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|header_printed
condition|)
block|{
name|minfo
argument_list|(
literal|"\nSet                 Symbol\n\n"
argument_list|)
expr_stmt|;
name|header_printed
operator|=
name|true
expr_stmt|;
block|}
name|minfo
argument_list|(
literal|"%s"
argument_list|,
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|h
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|19
condition|)
block|{
name|print_nl
argument_list|()
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|<
literal|20
condition|)
block|{
name|print_space
argument_list|()
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|name
operator|!=
name|NULL
condition|)
name|minfo
argument_list|(
literal|"%T\n"
argument_list|,
name|e
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|minfo
argument_list|(
literal|"%G\n"
argument_list|,
name|e
operator|->
name|section
operator|->
name|owner
argument_list|,
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_info
operator|.
name|relocateable
condition|)
name|lang_add_reloc
argument_list|(
name|p
operator|->
name|reloc
argument_list|,
name|howto
argument_list|,
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|name
argument_list|,
name|exp_intop
argument_list|(
name|e
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_relop
argument_list|(
name|e
operator|->
name|section
argument_list|,
name|e
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lang_add_data
argument_list|(
name|size
argument_list|,
name|exp_intop
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stat_ptr
operator|=
name|old
expr_stmt|;
block|}
end_function

end_unit

