begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldmisc.c    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2002, 2003    Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_comment
comment|/*  %% literal %  %F error is fatal  %P print program name  %S print script file and linenumber  %E current bfd error or errno  %I filename from a lang_input_statement_type  %B filename from a bfd  %T symbol name  %X no object output, fail return  %V hex bfd_vma  %v hex bfd_vma, no leading zeros  %W hex bfd_vma with 0x with no leading zeros taking up 8 spaces  %C clever filename:linenumber with function  %D like %C, but no function name  %G like %D, but only function name  %R info about a relent  %s arbitrary string, like printf  %d integer, like printf  %u integer, like printf */
end_comment

begin_function
specifier|static
name|void
name|vfinfo
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|arg
parameter_list|)
block|{
name|bfd_boolean
name|fatal
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
operator|&&
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
name|putc
argument_list|(
operator|*
name|fmt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%%%c"
argument_list|,
name|fmt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* literal % */
name|putc
argument_list|(
literal|'%'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* no object output, fail return */
name|config
operator|.
name|make_executable
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* hex bfd_vma */
block|{
name|bfd_vma
name|value
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
decl_stmt|;
name|fprintf_vma
argument_list|(
name|fp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* hex bfd_vma, no leading zeros */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|bfd_vma
name|value
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
decl_stmt|;
name|sprintf_vma
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|p
operator|--
expr_stmt|;
name|fputs
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'W'
case|:
comment|/* hex bfd_vma with 0x with no leading zeroes taking up 		 8 spaces.  */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|value
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|==
literal|'0'
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|8
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"0x%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* Symbol name.  */
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"no symbol"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|demangling
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
name|demangled
operator|=
name|demangle
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|demangled
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* filename from a bfd */
block|{
name|bfd
modifier|*
name|abfd
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s(%s)"
argument_list|,
name|abfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Error is fatal.  */
name|fatal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Print program name.  */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* current bfd error or errno */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* filename from a lang_input_statement_type */
block|{
name|lang_input_statement_type
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|lang_input_statement_type
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|i
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|i
operator|->
name|local_sym_name
argument_list|,
name|i
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" (%s)"
argument_list|,
name|i
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* Print script file and linenumber.  */
if|if
condition|(
name|parsing_defsym
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"--defsym %s"
argument_list|,
name|lex_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ldfile_input_filename
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:%u"
argument_list|,
name|ldfile_input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"built in linker script:%u"
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Print all that's interesting about a relent.  */
block|{
name|arelent
modifier|*
name|relent
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|arelent
operator|*
argument_list|)
decl_stmt|;
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%s+0x%v (type %s)"
argument_list|,
operator|(
operator|*
operator|(
name|relent
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|name
argument_list|,
name|relent
operator|->
name|addend
argument_list|,
name|relent
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'G'
case|:
comment|/* Clever filename:linenumber with function name if possible. 		 The arguments are a BFD, a section, and an offset.  */
block|{
specifier|static
name|bfd
modifier|*
name|last_bfd
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_function
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|linenumber
decl_stmt|;
name|bfd_boolean
name|discard_last
decl_stmt|;
name|abfd
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd
operator|*
argument_list|)
expr_stmt|;
name|section
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|asection
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|abfd
operator|->
name|usrdata
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
operator|&&
name|entry
operator|->
name|asymbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|asymbols
operator|=
name|entry
operator|->
name|asymbols
expr_stmt|;
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symbol_count
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|asymbols
operator|=
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symbol_count
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|entry
operator|->
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|entry
operator|->
name|symbol_count
operator|=
name|symbol_count
expr_stmt|;
block|}
block|}
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B(%s+0x%v)"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|discard_last
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|asymbols
argument_list|,
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|linenumber
argument_list|)
condition|)
block|{
name|bfd_boolean
name|need_colon
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
name|fmt
index|[
operator|-
literal|1
index|]
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
name|last_bfd
operator|==
name|NULL
operator|||
name|last_file
operator|==
name|NULL
operator|||
name|last_function
operator|==
name|NULL
operator|||
name|last_bfd
operator|!=
name|abfd
operator|||
operator|(
name|filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|last_file
argument_list|,
name|filename
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|last_function
argument_list|,
name|functionname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|lfinfo
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|": In function `%T':\n"
argument_list|)
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
name|need_colon
operator|=
name|FALSE
expr_stmt|;
name|last_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|last_file
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_function
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_function
argument_list|)
expr_stmt|;
name|last_function
operator|=
name|xstrdup
argument_list|(
name|functionname
argument_list|)
expr_stmt|;
block|}
name|discard_last
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|need_colon
condition|)
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|filename
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
name|fmt
index|[
operator|-
literal|1
index|]
operator|==
literal|'G'
condition|)
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|":%T"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|linenumber
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|":%u"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asymbols
operator|!=
name|NULL
operator|&&
name|entry
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard_last
condition|)
block|{
name|last_bfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|last_function
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|last_function
argument_list|)
expr_stmt|;
name|last_function
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* arbitrary string, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|va_arg
argument_list|(
name|arg
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* integer, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|va_arg
argument_list|(
name|arg
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* unsigned integer, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|va_arg
argument_list|(
argument|arg
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|config
operator|.
name|fatal_warnings
condition|)
name|config
operator|.
name|make_executable
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper around cplus_demangle.  Strips leading underscores and    other such chars that would otherwise confuse the demangler.  */
end_comment

begin_function
name|char
modifier|*
name|demangle
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
name|bfd_get_symbol_leading_char
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|name
index|[
literal|0
index|]
condition|)
operator|++
name|name
expr_stmt|;
comment|/* This is a hack for better error reporting on XCOFF, PowerPC64-ELF      or the MS PE format.  These formats have a number of leading '.'s      on at least some symbols, so we remove all dots to avoid      confusing the demangler.  */
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|++
name|p
expr_stmt|;
name|res
operator|=
name|cplus_demangle
argument_list|(
name|p
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|size_t
name|dots
init|=
name|p
operator|-
name|name
decl_stmt|;
comment|/* Now put back any stripped dots.  */
if|if
condition|(
name|dots
operator|!=
literal|0
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|res
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|add_dots
init|=
name|xmalloc
argument_list|(
name|len
operator|+
name|dots
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|add_dots
argument_list|,
name|name
argument_list|,
name|dots
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|add_dots
operator|+
name|dots
argument_list|,
name|res
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|add_dots
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
return|return
name|xstrdup
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format info message and print on stdout.  */
end_comment

begin_comment
comment|/* (You would think this should be called just "info", but then you    would be hosed by LynxOS, which defines that name in its libc.)  */
end_comment

begin_function
name|void
name|info_msg
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfinfo
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ('e' for error.) Format info message and print on stderr.  */
end_comment

begin_function
name|void
name|einfo
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfinfo
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|info_assert
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: internal error %s %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ('m' for map) Format info message and print on map.  */
end_comment

begin_function
name|void
name|minfo
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfinfo
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lfinfo
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfinfo
argument_list|(
name|file
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to print the link map.  */
end_comment

begin_function
name|void
name|print_space
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_nl
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A more or less friendly abort message.  In ld.h abort is defined to    call this function.  */
end_comment

begin_function
name|void
name|ld_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: internal error: aborting at %s line %d in %s\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: internal error: aborting at %s line %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: please report this bug\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|error_handler
parameter_list|(
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|arg
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
default|default:
break|break;
comment|/* We can be called with  	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 0);  	to make this error non-fatal and  	error_handler (-LD_DEFINITION_IN_DISCARDED_SECTION, "", 1);  	to make this error fatal.  */
case|case
operator|-
name|LD_DEFINITION_IN_DISCARDED_SECTION
case|:
case|case
name|LD_DEFINITION_IN_DISCARDED_SECTION
case|:
block|{
specifier|static
name|struct
name|bfd_hash_table
modifier|*
name|hash
decl_stmt|;
specifier|static
name|int
name|fatal
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
name|LD_DEFINITION_IN_DISCARDED_SECTION
condition|)
block|{
name|fatal
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|int
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|name
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Only warn once about a particular undefined symbol.  */
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|hash
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|hash
argument_list|,
name|bfd_hash_newfunc
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_table_init failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|bfd_hash_lookup
argument_list|(
name|hash
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: bfd_hash_lookup failed: %E\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
condition|)
name|config
operator|.
name|make_executable
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
name|vfinfo
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|out
label|:
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

