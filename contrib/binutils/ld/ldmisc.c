begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ldmisc.c    Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000    Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|USE_STDARG
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_define
define|#
directive|define
name|USE_STDARG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|vfinfo
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  %% literal %  %F error is fatal  %P print program name  %S print script file and linenumber  %E current bfd error or errno  %I filename from a lang_input_statement_type  %B filename from a bfd  %T symbol name  %X no object output, fail return  %V hex bfd_vma  %v hex bfd_vma, no leading zeros  %W hex bfd_vma with 0x with no leading zeros taking up 8 spaces  %C clever filename:linenumber with function  %D like %C, but no function name  %G like %D, but only function name  %R info about a relent  %s arbitrary string, like printf  %d integer, like printf  %u integer, like printf */
end_comment

begin_function
name|char
modifier|*
name|demangle
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
name|bfd_get_symbol_leading_char
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|string
index|[
literal|0
index|]
condition|)
operator|++
name|string
expr_stmt|;
comment|/* This is a hack for better error reporting on XCOFF, or the MS PE      format.  Xcoff has a single '.', while the NT PE for PPC has      '..'.  So we remove all of them.  */
while|while
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|string
expr_stmt|;
name|res
operator|=
name|cplus_demangle
argument_list|(
name|string
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
return|return
name|res
condition|?
name|res
else|:
name|xstrdup
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfinfo
parameter_list|(
name|fp
parameter_list|,
name|fmt
parameter_list|,
name|arg
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_list
name|arg
decl_stmt|;
block|{
name|boolean
name|fatal
init|=
name|false
decl_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
operator|&&
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
name|putc
argument_list|(
operator|*
name|fmt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%%%c"
argument_list|,
name|fmt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* literal % */
name|putc
argument_list|(
literal|'%'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* no object output, fail return */
name|config
operator|.
name|make_executable
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* hex bfd_vma */
block|{
name|bfd_vma
name|value
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
decl_stmt|;
name|fprintf_vma
argument_list|(
name|fp
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* hex bfd_vma, no leading zeros */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|bfd_vma
name|value
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
decl_stmt|;
name|sprintf_vma
argument_list|(
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|p
operator|--
expr_stmt|;
name|fputs
argument_list|(
name|p
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'W'
case|:
comment|/* hex bfd_vma with 0x with no leading zeroes taking up                  8 spaces.  */
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|value
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|==
literal|'0'
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|8
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"0x%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* Symbol name.  */
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
operator|||
operator|*
name|name
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"no symbol"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|demangling
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
name|demangled
operator|=
name|demangle
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|demangled
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* filename from a bfd */
block|{
name|bfd
modifier|*
name|abfd
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|my_archive
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s(%s)"
argument_list|,
name|abfd
operator|->
name|my_archive
operator|->
name|filename
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Error is fatal.  */
name|fatal
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Print program name.  */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* current bfd error or errno */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* filename from a lang_input_statement_type */
block|{
name|lang_input_statement_type
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|lang_input_statement_type
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"(%s)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|i
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_my_archive
argument_list|(
name|i
operator|->
name|the_bfd
argument_list|)
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|i
operator|->
name|local_sym_name
argument_list|,
name|i
operator|->
name|filename
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" (%s)"
argument_list|,
name|i
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* Print script file and linenumber.  */
if|if
condition|(
name|parsing_defsym
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"--defsym %s"
argument_list|,
name|lex_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ldfile_input_filename
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:%u"
argument_list|,
name|ldfile_input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"built in linker script:%u"
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Print all that's interesting about a relent.  */
block|{
name|arelent
modifier|*
name|relent
init|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|arelent
operator|*
argument_list|)
decl_stmt|;
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%s+0x%v (type %s)"
argument_list|,
operator|(
operator|*
operator|(
name|relent
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|name
argument_list|,
name|relent
operator|->
name|addend
argument_list|,
name|relent
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'G'
case|:
comment|/* Clever filename:linenumber with function name if possible, 		 or section name as a last resort.  The arguments are a BFD, 		 a section, and an offset.  */
block|{
specifier|static
name|bfd
modifier|*
name|last_bfd
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_function
init|=
name|NULL
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asymbols
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|functionname
decl_stmt|;
name|unsigned
name|int
name|linenumber
decl_stmt|;
name|boolean
name|discard_last
decl_stmt|;
name|abfd
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd
operator|*
argument_list|)
expr_stmt|;
name|section
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|asection
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|bfd_vma
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|abfd
operator|->
name|usrdata
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
operator|&&
name|entry
operator|->
name|asymbols
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
condition|)
name|asymbols
operator|=
name|entry
operator|->
name|asymbols
expr_stmt|;
else|else
block|{
name|long
name|symsize
decl_stmt|;
name|long
name|symbol_count
decl_stmt|;
name|symsize
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symsize
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|asymbols
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|symbol_count
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|asymbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol_count
operator|<
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%B%F: could not read symbols\n"
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|lang_input_statement_type
operator|*
operator|)
name|NULL
condition|)
block|{
name|entry
operator|->
name|asymbols
operator|=
name|asymbols
expr_stmt|;
name|entry
operator|->
name|symbol_count
operator|=
name|symbol_count
expr_stmt|;
block|}
block|}
name|discard_last
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|bfd_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|asymbols
argument_list|,
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|functionname
argument_list|,
operator|&
name|linenumber
argument_list|)
condition|)
block|{
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
name|fmt
index|[
operator|-
literal|1
index|]
operator|==
literal|'G'
condition|)
block|{
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B:"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%T"
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|functionname
operator|!=
name|NULL
operator|&&
name|fmt
index|[
operator|-
literal|1
index|]
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
name|filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|filename
operator|=
name|abfd
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|last_bfd
operator|==
name|NULL
operator|||
name|last_file
operator|==
name|NULL
operator|||
name|last_function
operator|==
name|NULL
operator|||
name|last_bfd
operator|!=
name|abfd
operator|||
name|strcmp
argument_list|(
name|last_file
argument_list|,
name|filename
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|last_function
argument_list|,
name|functionname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We use abfd->filename in this initial line, 			       in case filename is a .h file or something 			       similarly unhelpful.  */
name|lfinfo
argument_list|(
name|fp
argument_list|,
name|_
argument_list|(
literal|"%B: In function `%T':\n"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|functionname
argument_list|)
expr_stmt|;
name|last_bfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|buystring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_function
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_function
argument_list|)
expr_stmt|;
name|last_function
operator|=
name|buystring
argument_list|(
name|functionname
argument_list|)
expr_stmt|;
block|}
name|discard_last
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|linenumber
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s:%u"
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
else|else
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%s(%s+0x%v)"
argument_list|,
name|filename
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B(%s+0x%v)"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenumber
operator|!=
literal|0
condition|)
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|":%u"
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linenumber
operator|!=
literal|0
condition|)
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B:%s:%u"
argument_list|,
name|abfd
argument_list|,
name|filename
argument_list|,
name|linenumber
argument_list|)
expr_stmt|;
else|else
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B(%s+0x%v):%s"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|offset
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|lfinfo
argument_list|(
name|fp
argument_list|,
literal|"%B(%s+0x%v)"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard_last
condition|)
block|{
name|last_bfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|last_file
argument_list|)
expr_stmt|;
name|last_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|last_function
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|last_function
argument_list|)
expr_stmt|;
name|last_function
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* arbitrary string, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|va_arg
argument_list|(
name|arg
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* integer, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|va_arg
argument_list|(
name|arg
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* unsigned integer, like printf */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|va_arg
argument_list|(
argument|arg
argument_list|,
argument|unsigned int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|fatal
operator|==
name|true
condition|)
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format info message and print on stdout.  */
end_comment

begin_comment
comment|/* (You would think this should be called just "info", but then you    would hosed by LynxOS, which defines that name in its libc.)  */
end_comment

begin_function
name|void
if|#
directive|if
name|USE_STDARG
name|info_msg
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|info_msg
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|arg
decl_stmt|;
if|#
directive|if
operator|!
name|USE_STDARG
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfinfo
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ('e' for error.) Format info message and print on stderr.  */
end_comment

begin_function
name|void
if|#
directive|if
name|USE_STDARG
name|einfo
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|einfo
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|arg
decl_stmt|;
if|#
directive|if
operator|!
name|USE_STDARG
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfinfo
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|info_assert
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: internal error %s %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|buystring
parameter_list|(
name|x
parameter_list|)
name|CONST
name|char
modifier|*
name|CONST
name|x
decl_stmt|;
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|x
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|xmalloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|x
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* ('m' for map) Format info message and print on map.  */
end_comment

begin_function
name|void
if|#
directive|if
name|USE_STDARG
name|minfo
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|minfo
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|arg
decl_stmt|;
if|#
directive|if
operator|!
name|USE_STDARG
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfinfo
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
if|#
directive|if
name|USE_STDARG
name|lfinfo
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|lfinfo
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|arg
decl_stmt|;
if|#
directive|if
operator|!
name|USE_STDARG
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|va_start
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|file
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|arg
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|arg
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfinfo
argument_list|(
name|file
argument_list|,
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to print the link map.  */
end_comment

begin_function
name|void
name|print_space
parameter_list|()
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_nl
parameter_list|()
block|{
name|fprintf
argument_list|(
name|config
operator|.
name|map_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A more or less friendly abort message.  In ld.h abort is defined to    call this function.  */
end_comment

begin_function
name|void
name|ld_abort
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|fn
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
decl_stmt|;
block|{
if|if
condition|(
name|fn
operator|!=
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: internal error: aborting at %s line %d in %s\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: internal error: aborting at %s line %d\n"
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: please report this bug\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

