begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linker file opening and searching.    Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.  This file is part of GLD, the Gnu Linker.  GLD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GLD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GLD; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* ldfile.c:  look after all the file stuff.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|"ldgram.h"
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ldfile_input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|ldfile_assumed_script
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ldfile_output_machine_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|ldfile_output_machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|bfd_architecture
name|ldfile_output_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|search_dirs_type
modifier|*
name|search_head
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MPW
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|slash
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|slash
init|=
literal|"\\"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|slash
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MPW */
end_comment

begin_comment
comment|/* The MPW path char is a colon.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|slash
init|=
literal|":"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPW */
end_comment

begin_comment
comment|/* LOCAL */
end_comment

begin_decl_stmt
specifier|static
name|search_dirs_type
modifier|*
modifier|*
name|search_tail_ptr
init|=
operator|&
name|search_head
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|search_arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|search_arch
modifier|*
name|next
decl_stmt|;
block|}
name|search_arch_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|search_arch_type
modifier|*
name|search_arch_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|search_arch_type
modifier|*
modifier|*
name|search_arch_tail_ptr
init|=
operator|&
name|search_arch_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|try_open
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
specifier|const
name|char
operator|*
name|exten
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ldfile_add_library_path
parameter_list|(
name|name
parameter_list|,
name|cmdline
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|boolean
name|cmdline
decl_stmt|;
block|{
name|search_dirs_type
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|search_dirs_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|search_dirs_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|cmdline
operator|=
name|cmdline
expr_stmt|;
operator|*
name|search_tail_ptr
operator|=
name|new
expr_stmt|;
name|search_tail_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to open a BFD for a lang_input_statement.  */
end_comment

begin_function
name|boolean
name|ldfile_try_open_bfd
parameter_list|(
name|attempt
parameter_list|,
name|entry
parameter_list|)
specifier|const
name|char
modifier|*
name|attempt
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
block|{
name|entry
operator|->
name|the_bfd
operator|=
name|bfd_openr
argument_list|(
name|attempt
argument_list|,
name|entry
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"attempt to open %s failed\n"
argument_list|)
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"attempt to open %s succeeded\n"
argument_list|)
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_target
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid BFD target `%s'\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|target
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* If we are searching for this file, see if the architecture is      compatible with the output file.  If it isn't, keep searching.      If we can't open the file as an object file, stop the search      here.  */
if|if
condition|(
name|entry
operator|->
name|search_dirs_flag
condition|)
block|{
name|bfd
modifier|*
name|check
decl_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|check
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|check
operator|=
name|entry
operator|->
name|the_bfd
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|check
argument_list|,
name|bfd_object
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_arch_get_compatible
argument_list|(
name|check
argument_list|,
name|output_bfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: skipping incompatible %s when searching for %s\n"
argument_list|)
argument_list|,
name|attempt
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Search for and open the file specified by ENTRY.  If it is an    archive, use ARCH, LIB and SUFFIX to modify the file name.  */
end_comment

begin_function
name|boolean
name|ldfile_open_file_search
parameter_list|(
name|arch
parameter_list|,
name|entry
parameter_list|,
name|lib
parameter_list|,
name|suffix
parameter_list|)
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|lib
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
block|{
name|search_dirs_type
modifier|*
name|search
decl_stmt|;
comment|/* If this is not an archive, try to open it in the current      directory first.  */
if|if
condition|(
operator|!
name|entry
operator|->
name|is_archive
condition|)
block|{
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
argument_list|)
condition|)
return|return
name|true
return|;
block|}
for|for
control|(
name|search
operator|=
name|search_head
init|;
name|search
operator|!=
operator|(
name|search_dirs_type
operator|*
operator|)
name|NULL
condition|;
name|search
operator|=
name|search
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|dynamic
operator|&&
operator|!
name|link_info
operator|.
name|relocateable
condition|)
block|{
if|if
condition|(
name|ldemul_open_dynamic_archive
argument_list|(
name|arch
argument_list|,
name|search
argument_list|,
name|entry
argument_list|)
condition|)
return|return
name|true
return|;
block|}
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|search
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|lib
argument_list|)
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|arch
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_archive
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s%s%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|lib
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|arch
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|entry
operator|->
name|filename
index|[
literal|0
index|]
operator|==
literal|'.'
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|entry
operator|->
name|filename
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|||
operator|(
name|isalpha
argument_list|(
name|entry
operator|->
name|filename
index|[
literal|0
index|]
argument_list|)
operator|&&
name|entry
operator|->
name|filename
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
endif|#
directive|endif
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|string
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|->
name|filename
operator|=
name|string
expr_stmt|;
return|return
name|true
return|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Open the input file specified by ENTRY.  */
end_comment

begin_function
name|void
name|ldfile_open_file
parameter_list|(
name|entry
parameter_list|)
name|lang_input_statement_type
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|entry
operator|->
name|search_dirs_flag
condition|)
block|{
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
argument_list|)
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot open %s for %s: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot open %s: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|search_arch_type
modifier|*
name|arch
decl_stmt|;
name|boolean
name|found
init|=
name|false
decl_stmt|;
comment|/* Try to open<filename><suffix> or lib<filename><suffix>.a */
for|for
control|(
name|arch
operator|=
name|search_arch_head
init|;
name|arch
operator|!=
operator|(
name|search_arch_type
operator|*
operator|)
name|NULL
condition|;
name|arch
operator|=
name|arch
operator|->
name|next
control|)
block|{
name|found
operator|=
name|ldfile_open_file_search
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|,
literal|"lib"
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
ifdef|#
directive|ifdef
name|VMS
name|found
operator|=
name|ldfile_open_file_search
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|,
literal|":lib"
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
endif|#
directive|endif
name|found
operator|=
name|ldemul_find_potential_libraries
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
block|}
comment|/* If we have found the file, we don't need to search directories 	 again.  */
if|if
condition|(
name|found
condition|)
name|entry
operator|->
name|search_dirs_flag
operator|=
name|false
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot find %s\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to open NAME; if that fails, try NAME with EXTEN appended to it.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|try_open
parameter_list|(
name|name
parameter_list|,
name|exten
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|exten
decl_stmt|;
block|{
name|FILE
modifier|*
name|result
decl_stmt|;
name|char
name|buff
index|[
literal|1000
index|]
decl_stmt|;
name|result
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"cannot find script file %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"opened script file %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|*
name|exten
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|result
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"cannot find script file %s\n"
argument_list|)
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"opened script file %s\n"
argument_list|)
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Try to open NAME; if that fails, look for it in any directories    specified with -L, without and with EXTEND apppended.  */
end_comment

begin_function
name|FILE
modifier|*
name|ldfile_find_command_file
parameter_list|(
name|name
parameter_list|,
name|extend
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|extend
decl_stmt|;
block|{
name|search_dirs_type
modifier|*
name|search
decl_stmt|;
name|FILE
modifier|*
name|result
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
comment|/* First try raw name.  */
name|result
operator|=
name|try_open
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Try now prefixes.  */
for|for
control|(
name|search
operator|=
name|search_head
init|;
name|search
operator|!=
operator|(
name|search_dirs_type
operator|*
operator|)
name|NULL
condition|;
name|search
operator|=
name|search
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|try_open
argument_list|(
name|buffer
argument_list|,
name|extend
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|ldfile_open_command_file
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|ldlex_input_stack
decl_stmt|;
name|ldlex_input_stack
operator|=
name|ldfile_find_command_file
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldlex_input_stack
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open linker script file %s: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|lex_push_file
argument_list|(
name|ldlex_input_stack
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ldfile_input_filename
operator|=
name|name
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|had_script
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GNU960
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|gnu960_map_archname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
struct|struct
name|tabentry
block|{
name|char
modifier|*
name|cmd_switch
decl_stmt|;
name|char
modifier|*
name|arch
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|tabentry
name|arch_tab
index|[]
init|=
block|{
literal|""
block|,
literal|""
block|,
literal|"KA"
block|,
literal|"ka"
block|,
literal|"KB"
block|,
literal|"kb"
block|,
literal|"KC"
block|,
literal|"mc"
block|,
comment|/* Synonym for MC */
literal|"MC"
block|,
literal|"mc"
block|,
literal|"CA"
block|,
literal|"ca"
block|,
literal|"SA"
block|,
literal|"ka"
block|,
comment|/* Functionally equivalent to KA */
literal|"SB"
block|,
literal|"kb"
block|,
comment|/* Functionally equivalent to KB */
name|NULL
block|,
literal|""
block|}
decl_stmt|;
name|struct
name|tabentry
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|arch_tab
init|;
name|tp
operator|->
name|cmd_switch
operator|!=
name|NULL
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|cmd_switch
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|cmd_switch
operator|==
name|NULL
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: unknown architecture: %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|tp
operator|->
name|arch
return|;
block|}
end_function

begin_function
name|void
name|ldfile_add_arch
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|search_arch_type
modifier|*
name|new
init|=
operator|(
name|search_arch_type
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|bfd_size_type
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|search_arch_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ldfile_output_machine_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: target architecture respecified\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ldfile_output_machine_name
operator|=
name|name
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
operator|(
name|search_arch_type
operator|*
operator|)
name|NULL
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|gnu960_map_archname
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|search_arch_tail_ptr
operator|=
name|new
expr_stmt|;
name|search_arch_tail_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not GNU960 */
end_comment

begin_function
name|void
name|ldfile_add_arch
parameter_list|(
name|in_name
parameter_list|)
name|CONST
name|char
modifier|*
name|in_name
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|in_name
argument_list|)
decl_stmt|;
name|search_arch_type
modifier|*
name|new
init|=
operator|(
name|search_arch_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|search_arch_type
argument_list|)
argument_list|)
decl_stmt|;
name|ldfile_output_machine_name
operator|=
name|in_name
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|next
operator|=
operator|(
name|search_arch_type
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
argument_list|)
condition|)
operator|*
name|name
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
argument_list|)
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
operator|*
name|search_arch_tail_ptr
operator|=
name|new
expr_stmt|;
name|search_arch_tail_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set the output architecture.  */
end_comment

begin_function
name|void
name|ldfile_set_output_arch
parameter_list|(
name|string
parameter_list|)
name|CONST
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|arch
condition|)
block|{
name|ldfile_output_architecture
operator|=
name|arch
operator|->
name|arch
expr_stmt|;
name|ldfile_output_machine
operator|=
name|arch
operator|->
name|mach
expr_stmt|;
name|ldfile_output_machine_name
operator|=
name|arch
operator|->
name|printable_name
expr_stmt|;
block|}
else|else
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot represent machine `%s'\n"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

