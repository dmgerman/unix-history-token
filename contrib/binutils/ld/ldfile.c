begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linker file opening and searching.    Copyright 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of GLD, the Gnu Linker.     GLD is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GLD is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GLD; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_comment
comment|/* ldfile.c:  look after all the file stuff.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_include
include|#
directive|include
file|"ldmisc.h"
end_include

begin_include
include|#
directive|include
file|"ldexp.h"
end_include

begin_include
include|#
directive|include
file|"ldlang.h"
end_include

begin_include
include|#
directive|include
file|"ldfile.h"
end_include

begin_include
include|#
directive|include
file|"ldmain.h"
end_include

begin_include
include|#
directive|include
file|<ldgram.h>
end_include

begin_include
include|#
directive|include
file|"ldlex.h"
end_include

begin_include
include|#
directive|include
file|"ldemul.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ldfile_input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|ldfile_assumed_script
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ldfile_output_machine_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|ldfile_output_machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|bfd_architecture
name|ldfile_output_architecture
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|search_dirs_type
modifier|*
name|search_head
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|slash
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|slash
init|=
literal|"\\"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|slash
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|search_arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|search_arch
modifier|*
name|next
decl_stmt|;
block|}
name|search_arch_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|search_dirs_type
modifier|*
modifier|*
name|search_tail_ptr
init|=
operator|&
name|search_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|search_arch_type
modifier|*
name|search_arch_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|search_arch_type
modifier|*
modifier|*
name|search_arch_tail_ptr
init|=
operator|&
name|search_arch_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test whether a pathname, after canonicalization, is the same or a    sub-directory of the sysroot directory.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_sysrooted_pathname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|notsame
parameter_list|)
block|{
name|char
modifier|*
name|realname
init|=
name|ld_canon_sysroot
condition|?
name|lrealpath
argument_list|(
name|name
argument_list|)
else|:
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bfd_boolean
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|realname
condition|)
return|return
name|FALSE
return|;
name|len
operator|=
name|strlen
argument_list|(
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|!
name|notsame
operator|&&
name|len
operator|==
name|ld_canon_sysroot_len
operator|)
operator|||
operator|(
name|len
operator|>=
name|ld_canon_sysroot_len
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|realname
index|[
name|ld_canon_sysroot_len
index|]
argument_list|)
operator|&&
operator|(
name|realname
index|[
name|ld_canon_sysroot_len
index|]
operator|=
literal|'\0'
operator|)
operator|==
literal|'\0'
operator|)
operator|)
operator|&&
name|FILENAME_CMP
argument_list|(
name|ld_canon_sysroot
argument_list|,
name|realname
argument_list|)
operator|==
literal|0
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
else|else
name|result
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|realname
condition|)
name|free
argument_list|(
name|realname
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Adds NAME to the library search path.    Makes a copy of NAME using xmalloc().  */
end_comment

begin_function
name|void
name|ldfile_add_library_path
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_boolean
name|cmdline
parameter_list|)
block|{
name|search_dirs_type
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|cmdline
operator|&&
name|config
operator|.
name|only_cmd_line_lib_dirs
condition|)
return|return;
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|search_dirs_type
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|cmdline
operator|=
name|cmdline
expr_stmt|;
operator|*
name|search_tail_ptr
operator|=
name|new
expr_stmt|;
name|search_tail_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
comment|/* If a directory is marked as honoring sysroot, prepend the sysroot path      now.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|new
operator|->
name|name
operator|=
name|concat
argument_list|(
name|ld_sysroot
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|sysrooted
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|new
operator|->
name|sysrooted
operator|=
name|is_sysrooted_pathname
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to open a BFD for a lang_input_statement.  */
end_comment

begin_function
name|bfd_boolean
name|ldfile_try_open_bfd
parameter_list|(
specifier|const
name|char
modifier|*
name|attempt
parameter_list|,
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|the_bfd
operator|=
name|bfd_openr
argument_list|(
name|attempt
argument_list|,
name|entry
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"attempt to open %s failed\n"
argument_list|)
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"attempt to open %s succeeded\n"
argument_list|)
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_invalid_target
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: invalid BFD target `%s'\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|target
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* If we are searching for this file, see if the architecture is      compatible with the output file.  If it isn't, keep searching.      If we can't open the file as an object file, stop the search      here.  If we are statically linking, ensure that we don't link      a dynamic object.  */
if|if
condition|(
name|entry
operator|->
name|search_dirs_flag
operator|||
operator|!
name|entry
operator|->
name|dynamic
condition|)
block|{
name|bfd
modifier|*
name|check
decl_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
name|check
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|check
operator|=
name|entry
operator|->
name|the_bfd
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|check
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
if|if
condition|(
name|check
operator|==
name|entry
operator|->
name|the_bfd
operator|&&
name|entry
operator|->
name|search_dirs_flag
operator|&&
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_not_recognized
operator|&&
operator|!
name|ldemul_unrecognized_file
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|int
name|token
decl_stmt|,
name|skip
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
comment|/* Try to interpret the file as a linker script.  */
name|ldfile_open_command_file
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|TRUE
expr_stmt|;
name|parser_input
operator|=
name|input_selected
expr_stmt|;
name|ldlex_both
argument_list|()
expr_stmt|;
name|token
operator|=
name|INPUT_SCRIPT
expr_stmt|;
while|while
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|OUTPUT_FORMAT
case|:
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
literal|'('
condition|)
continue|continue;
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
name|NAME
condition|)
continue|continue;
name|arg1
operator|=
name|yylval
operator|.
name|name
expr_stmt|;
name|arg2
operator|=
name|NULL
expr_stmt|;
name|arg3
operator|=
name|NULL
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
name|NAME
condition|)
block|{
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arg2
operator|=
name|yylval
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
literal|','
operator|||
operator|(
name|token
operator|=
name|yylex
argument_list|()
operator|)
operator|!=
name|NAME
condition|)
block|{
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arg3
operator|=
name|yylval
operator|.
name|name
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
literal|')'
condition|)
block|{
switch|switch
condition|(
name|command_line
operator|.
name|endian
condition|)
block|{
default|default:
case|case
name|ENDIAN_UNSET
case|:
name|arg
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|ENDIAN_BIG
case|:
name|arg
operator|=
name|arg2
condition|?
name|arg2
else|:
name|arg1
expr_stmt|;
break|break;
case|case
name|ENDIAN_LITTLE
case|:
name|arg
operator|=
name|arg3
condition|?
name|arg3
else|:
name|arg1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|lang_get_output_target
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|free
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAME
case|:
case|case
name|LNAME
case|:
case|case
name|VERS_IDENTIFIER
case|:
case|case
name|VERS_TAG
case|:
name|free
argument_list|(
name|yylval
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
if|if
condition|(
name|yylval
operator|.
name|bigint
operator|.
name|str
condition|)
name|free
argument_list|(
name|yylval
operator|.
name|bigint
operator|.
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
name|ldlex_popstate
argument_list|()
expr_stmt|;
name|ldfile_assumed_script
operator|=
name|FALSE
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: skipping incompatible %s when searching for %s\n"
argument_list|)
argument_list|,
name|attempt
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|entry
operator|->
name|dynamic
operator|&&
operator|(
name|entry
operator|->
name|the_bfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: attempted static link of dynamic object `%s'\n"
argument_list|)
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|search_dirs_flag
operator|&&
operator|!
name|bfd_arch_get_compatible
argument_list|(
name|check
argument_list|,
name|output_bfd
argument_list|,
name|command_line
operator|.
name|accept_unknown_input_arch
argument_list|)
comment|/* XCOFF archives can have 32 and 64 bit objects.  */
operator|&&
operator|!
operator|(
name|bfd_get_flavour
argument_list|(
name|check
argument_list|)
operator|==
name|bfd_target_xcoff_flavour
operator|&&
name|bfd_get_flavour
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|bfd_target_xcoff_flavour
operator|&&
name|bfd_check_format
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|,
name|bfd_archive
argument_list|)
operator|)
condition|)
block|{
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P: skipping incompatible %s when searching for %s\n"
argument_list|)
argument_list|,
name|attempt
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|entry
operator|->
name|the_bfd
argument_list|)
expr_stmt|;
name|entry
operator|->
name|the_bfd
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Search for and open the file specified by ENTRY.  If it is an    archive, use ARCH, LIB and SUFFIX to modify the file name.  */
end_comment

begin_function
name|bfd_boolean
name|ldfile_open_file_search
parameter_list|(
specifier|const
name|char
modifier|*
name|arch
parameter_list|,
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|,
specifier|const
name|char
modifier|*
name|lib
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
name|search_dirs_type
modifier|*
name|search
decl_stmt|;
comment|/* If this is not an archive, try to open it in the current      directory first.  */
if|if
condition|(
operator|!
name|entry
operator|->
name|is_archive
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|sysrooted
operator|&&
name|IS_ABSOLUTE_PATH
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|concat
argument_list|(
name|ld_sysroot
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|name
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|->
name|filename
operator|=
name|name
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|->
name|sysrooted
operator|=
name|IS_ABSOLUTE_PATH
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
operator|&&
name|is_sysrooted_pathname
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|search
operator|=
name|search_head
init|;
name|search
operator|!=
name|NULL
condition|;
name|search
operator|=
name|search
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|dynamic
operator|&&
operator|!
name|link_info
operator|.
name|relocatable
condition|)
block|{
if|if
condition|(
name|ldemul_open_dynamic_archive
argument_list|(
name|arch
argument_list|,
name|search
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|->
name|sysrooted
operator|=
name|search
operator|->
name|sysrooted
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|search
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|slash
argument_list|)
operator|+
name|strlen
argument_list|(
name|lib
argument_list|)
operator|+
name|strlen
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|arch
argument_list|)
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|is_archive
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s%s%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|lib
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|arch
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|string
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|->
name|filename
operator|=
name|string
expr_stmt|;
name|entry
operator|->
name|sysrooted
operator|=
name|search
operator|->
name|sysrooted
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Open the input file specified by ENTRY.  */
end_comment

begin_function
name|void
name|ldfile_open_file
parameter_list|(
name|lang_input_statement_type
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|the_bfd
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|entry
operator|->
name|search_dirs_flag
condition|)
block|{
if|if
condition|(
name|ldfile_try_open_bfd
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
argument_list|)
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
operator|!=
literal|0
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: %s (%s): No such file: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: %s: No such file: %E\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|search_arch_type
modifier|*
name|arch
decl_stmt|;
name|bfd_boolean
name|found
init|=
name|FALSE
decl_stmt|;
comment|/* Try to open<filename><suffix> or lib<filename><suffix>.a */
for|for
control|(
name|arch
operator|=
name|search_arch_head
init|;
name|arch
operator|!=
name|NULL
condition|;
name|arch
operator|=
name|arch
operator|->
name|next
control|)
block|{
name|found
operator|=
name|ldfile_open_file_search
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|,
literal|"lib"
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
ifdef|#
directive|ifdef
name|VMS
name|found
operator|=
name|ldfile_open_file_search
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|,
literal|":lib"
argument_list|,
literal|".a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
endif|#
directive|endif
name|found
operator|=
name|ldemul_find_potential_libraries
argument_list|(
name|arch
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
block|}
comment|/* If we have found the file, we don't need to search directories 	 again.  */
if|if
condition|(
name|found
condition|)
name|entry
operator|->
name|search_dirs_flag
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|sysrooted
operator|&&
name|ld_sysroot
operator|&&
name|IS_ABSOLUTE_PATH
argument_list|(
name|entry
operator|->
name|local_sym_name
argument_list|)
condition|)
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot find %s inside %s\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|,
name|ld_sysroot
argument_list|)
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%F%P: cannot find %s\n"
argument_list|)
argument_list|,
name|entry
operator|->
name|local_sym_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to open NAME; if that fails, try NAME with EXTEN appended to it.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|try_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|exten
parameter_list|)
block|{
name|FILE
modifier|*
name|result
decl_stmt|;
name|char
name|buff
index|[
literal|1000
index|]
decl_stmt|;
name|result
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"cannot find script file %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"opened script file %s\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
return|return
name|result
return|;
if|if
condition|(
operator|*
name|exten
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|result
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_file_tries
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"cannot find script file %s\n"
argument_list|)
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|else
name|info_msg
argument_list|(
name|_
argument_list|(
literal|"opened script file %s\n"
argument_list|)
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Try to open NAME; if that fails, look for it in any directories    specified with -L, without and with EXTEND appended.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|ldfile_find_command_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|extend
parameter_list|)
block|{
name|search_dirs_type
modifier|*
name|search
decl_stmt|;
name|FILE
modifier|*
name|result
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
comment|/* First try raw name.  */
name|result
operator|=
name|try_open
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
comment|/* Try now prefixes.  */
for|for
control|(
name|search
operator|=
name|search_head
init|;
name|search
operator|!=
name|NULL
condition|;
name|search
operator|=
name|search
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s%s%s"
argument_list|,
name|search
operator|->
name|name
argument_list|,
name|slash
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|try_open
argument_list|(
name|buffer
argument_list|,
name|extend
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|ldfile_open_command_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|ldlex_input_stack
decl_stmt|;
name|ldlex_input_stack
operator|=
name|ldfile_find_command_file
argument_list|(
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldlex_input_stack
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot open linker script file %s: %E\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|lex_push_file
argument_list|(
name|ldlex_input_stack
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ldfile_input_filename
operator|=
name|name
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|saved_script_handle
operator|=
name|ldlex_input_stack
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ldfile_add_arch
parameter_list|(
specifier|const
name|char
modifier|*
name|in_name
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|in_name
argument_list|)
decl_stmt|;
name|search_arch_type
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|search_arch_type
argument_list|)
argument_list|)
decl_stmt|;
name|ldfile_output_machine_name
operator|=
name|in_name
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
operator|*
name|name
operator|=
name|TOLOWER
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
operator|*
name|search_arch_tail_ptr
operator|=
name|new
expr_stmt|;
name|search_arch_tail_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output architecture.  */
end_comment

begin_function
name|void
name|ldfile_set_output_arch
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|enum
name|bfd_architecture
name|defarch
parameter_list|)
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|arch
condition|)
block|{
name|ldfile_output_architecture
operator|=
name|arch
operator|->
name|arch
expr_stmt|;
name|ldfile_output_machine
operator|=
name|arch
operator|->
name|mach
expr_stmt|;
name|ldfile_output_machine_name
operator|=
name|arch
operator|->
name|printable_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defarch
operator|!=
name|bfd_arch_unknown
condition|)
name|ldfile_output_architecture
operator|=
name|defarch
expr_stmt|;
else|else
name|einfo
argument_list|(
name|_
argument_list|(
literal|"%P%F: cannot represent machine `%s'\n"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

