begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|<<'SKIP';
endif|#
directive|endif
end_endif

begin_comment
comment|/* ----------------------------------------------------------------------      ppport.h -- Perl/Pollution/Portability Version 3.19      Automatically created by Devel::PPPort running under perl 5.014002.      Do NOT edit this file directly! -- Edit PPPort_pm.PL and the     includes in parts/inc/ instead.      Use 'perldoc ppport.h' to view the documentation below.  ----------------------------------------------------------------------  SKIP  =pod  =head1 NAME  ppport.h - Perl/Pollution/Portability version 3.19  =head1 SYNOPSIS    perl ppport.h [options] [source files]    Searches current directory for files if no [source files] are given    --help                      show short help    --version                   show version    --patch=file                write one patch file with changes   --copy=suffix               write changed copies with suffix   --diff=program              use diff program and options    --compat-version=version    provide compatibility with Perl version   --cplusplus                 accept C++ comments    --quiet                     don't output anything except fatal errors   --nodiag                    don't show diagnostics   --nohints                   don't show hints   --nochanges                 don't suggest changes   --nofilter                  don't filter input files    --strip                     strip all script and doc functionality from                               ppport.h    --list-provided             list provided API   --list-unsupported          list unsupported API   --api-info=name             show Perl API portability information  =head1 COMPATIBILITY  This version of F<ppport.h> is designed to support operation with Perl installations back to 5.003, and has been tested up to 5.10.0.  =head1 OPTIONS  =head2 --help  Display a brief usage summary.  =head2 --version  Display the version of F<ppport.h>.  =head2 --patch=I<file>  If this option is given, a single patch file will be created if any changes are suggested. This requires a working diff program to be installed on your system.  =head2 --copy=I<suffix>  If this option is given, a copy of each file will be saved with the given suffix that contains the suggested changes. This does not require any external programs. Note that this does not automagially add a dot between the original filename and the suffix. If you want the dot, you have to include it in the option argument.  If neither C<--patch> or C<--copy> are given, the default is to simply print the diffs for each file. This requires either C<Text::Diff> or a C<diff> program to be installed.  =head2 --diff=I<program>  Manually set the diff program and options to use. The default is to use C<Text::Diff>, when installed, and output unified context diffs.  =head2 --compat-version=I<version>  Tell F<ppport.h> to check for compatibility with the given Perl version. The default is to check for compatibility with Perl version 5.003. You can use this option to reduce the output of F<ppport.h> if you intend to be backward compatible only down to a certain Perl version.  =head2 --cplusplus  Usually, F<ppport.h> will detect C++ style comments and replace them with C style comments for portability reasons. Using this option instructs F<ppport.h> to leave C++ comments untouched.  =head2 --quiet  Be quiet. Don't print anything except fatal errors.  =head2 --nodiag  Don't output any diagnostic messages. Only portability alerts will be printed.  =head2 --nohints  Don't output any hints. Hints often contain useful portability notes. Warnings will still be displayed.  =head2 --nochanges  Don't suggest any changes. Only give diagnostic output and hints unless these are also deactivated.  =head2 --nofilter  Don't filter the list of input files. By default, files not looking like source code (i.e. not *.xs, *.c, *.cc, *.cpp or *.h) are skipped.  =head2 --strip  Strip all script and documentation functionality from F<ppport.h>. This reduces the size of F<ppport.h> dramatically and may be useful if you want to include F<ppport.h> in smaller modules without increasing their distribution size too much.  The stripped F<ppport.h> will have a C<--unstrip> option that allows you to undo the stripping, but only if an appropriate C<Devel::PPPort> module is installed.  =head2 --list-provided  Lists the API elements for which compatibility is provided by F<ppport.h>. Also lists if it must be explicitly requested, if it has dependencies, and if there are hints or warnings for it.  =head2 --list-unsupported  Lists the API elements that are known not to be supported by F<ppport.h> and below which version of Perl they probably won't be available or work.  =head2 --api-info=I<name>  Show portability information for API elements matching I<name>. If I<name> is surrounded by slashes, it is interpreted as a regular expression.  =head1 DESCRIPTION  In order for a Perl extension (XS) module to be as portable as possible across differing versions of Perl itself, certain steps need to be taken.  =over 4  =item *  Including this header is the first major one. This alone will give you access to a large part of the Perl API that hasn't been available in earlier Perl releases. Use      perl ppport.h --list-provided  to see which API elements are provided by ppport.h.  =item *  You should avoid using deprecated parts of the API. For example, using global Perl variables without the C<PL_> prefix is deprecated. Also, some API functions used to have a C<perl_> prefix. Using this form is also deprecated. You can safely use the supported API, as F<ppport.h> will provide wrappers for older Perl versions.  =item *  If you use one of a few functions or variables that were not present in earlier versions of Perl, and that can't be provided using a macro, you have to explicitly request support for these functions by adding one or more C<#define>s in your source code before the inclusion of F<ppport.h>.  These functions or variables will be marked C<explicit> in the list shown by C<--list-provided>.  Depending on whether you module has a single or multiple files that use such functions or variables, you want either C<static> or global variants.  For a C<static> function or variable (used only in a single source file), use:      #define NEED_function     #define NEED_variable  For a global function or variable (used in multiple source files), use:      #define NEED_function_GLOBAL     #define NEED_variable_GLOBAL  Note that you mustn't have more than one global request for the same function or variable in your project.      Function / Variable       Static Request               Global Request     -----------------------------------------------------------------------------------------     PL_parser                 NEED_PL_parser               NEED_PL_parser_GLOBAL     PL_signals                NEED_PL_signals              NEED_PL_signals_GLOBAL     eval_pv()                 NEED_eval_pv                 NEED_eval_pv_GLOBAL     grok_bin()                NEED_grok_bin                NEED_grok_bin_GLOBAL     grok_hex()                NEED_grok_hex                NEED_grok_hex_GLOBAL     grok_number()             NEED_grok_number             NEED_grok_number_GLOBAL     grok_numeric_radix()      NEED_grok_numeric_radix      NEED_grok_numeric_radix_GLOBAL     grok_oct()                NEED_grok_oct                NEED_grok_oct_GLOBAL     load_module()             NEED_load_module             NEED_load_module_GLOBAL     my_snprintf()             NEED_my_snprintf             NEED_my_snprintf_GLOBAL     my_sprintf()              NEED_my_sprintf              NEED_my_sprintf_GLOBAL     my_strlcat()              NEED_my_strlcat              NEED_my_strlcat_GLOBAL     my_strlcpy()              NEED_my_strlcpy              NEED_my_strlcpy_GLOBAL     newCONSTSUB()             NEED_newCONSTSUB             NEED_newCONSTSUB_GLOBAL     newRV_noinc()             NEED_newRV_noinc             NEED_newRV_noinc_GLOBAL     newSV_type()              NEED_newSV_type              NEED_newSV_type_GLOBAL     newSVpvn_flags()          NEED_newSVpvn_flags          NEED_newSVpvn_flags_GLOBAL     newSVpvn_share()          NEED_newSVpvn_share          NEED_newSVpvn_share_GLOBAL     pv_display()              NEED_pv_display              NEED_pv_display_GLOBAL     pv_escape()               NEED_pv_escape               NEED_pv_escape_GLOBAL     pv_pretty()               NEED_pv_pretty               NEED_pv_pretty_GLOBAL     sv_2pv_flags()            NEED_sv_2pv_flags            NEED_sv_2pv_flags_GLOBAL     sv_2pvbyte()              NEED_sv_2pvbyte              NEED_sv_2pvbyte_GLOBAL     sv_catpvf_mg()            NEED_sv_catpvf_mg            NEED_sv_catpvf_mg_GLOBAL     sv_catpvf_mg_nocontext()  NEED_sv_catpvf_mg_nocontext  NEED_sv_catpvf_mg_nocontext_GLOBAL     sv_pvn_force_flags()      NEED_sv_pvn_force_flags      NEED_sv_pvn_force_flags_GLOBAL     sv_setpvf_mg()            NEED_sv_setpvf_mg            NEED_sv_setpvf_mg_GLOBAL     sv_setpvf_mg_nocontext()  NEED_sv_setpvf_mg_nocontext  NEED_sv_setpvf_mg_nocontext_GLOBAL     vload_module()            NEED_vload_module            NEED_vload_module_GLOBAL     vnewSVpvf()               NEED_vnewSVpvf               NEED_vnewSVpvf_GLOBAL     warner()                  NEED_warner                  NEED_warner_GLOBAL  To avoid namespace conflicts, you can change the namespace of the explicitly exported functions / variables using the C<DPPP_NAMESPACE> macro. Just C<#define> the macro before including C<ppport.h>:      #define DPPP_NAMESPACE MyOwnNamespace_     #include "ppport.h"  The default namespace is C<DPPP_>.  =back  The good thing is that most of the above can be checked by running F<ppport.h> on your source code. See the next section for details.  =head1 EXAMPLES  To verify whether F<ppport.h> is needed for your module, whether you should make any changes to your code, and whether any special defines should be used, F<ppport.h> can be run as a Perl script to check your source code. Simply say:      perl ppport.h  The result will usually be a list of patches suggesting changes that should at least be acceptable, if not necessarily the most efficient solution, or a fix for all possible problems.  If you know that your XS module uses features only available in newer Perl releases, if you're aware that it uses C++ comments, and if you want all suggestions as a single patch file, you could use something like this:      perl ppport.h --compat-version=5.6.0 --cplusplus --patch=test.diff  If you only want your code to be scanned without any suggestions for changes, use:      perl ppport.h --nochanges  You can specify a different C<diff> program or options, using the C<--diff> option:      perl ppport.h --diff='diff -C 10'  This would output context diffs with 10 lines of context.  If you want to create patched copies of your files instead, use:      perl ppport.h --copy=.new  To display portability information for the C<newSVpvn> function, use:      perl ppport.h --api-info=newSVpvn  Since the argument to C<--api-info> can be a regular expression, you can use      perl ppport.h --api-info=/_nomg$/  to display portability information for all C<_nomg> functions or      perl ppport.h --api-info=/./  to display information for all known API elements.  =head1 BUGS  If this version of F<ppport.h> is causing failure during the compilation of this module, please check if newer versions of either this module or C<Devel::PPPort> are available on CPAN before sending a bug report.  If F<ppport.h> was generated using the latest version of C<Devel::PPPort> and is causing failure of this module, please file a bug report using the CPAN Request Tracker at L<http://rt.cpan.org/>.  Please include the following information:  =over 4  =item 1.  The complete output from running "perl -V"  =item 2.  This file.  =item 3.  The name and version of the module you were trying to build.  =item 4.  A full log of the build that failed.  =item 5.  Any other information that you think could be relevant.  =back  For the latest version of this code, please get the C<Devel::PPPort> module from CPAN.  =head1 COPYRIGHT  Version 3.x, Copyright (c) 2004-2009, Marcus Holland-Moritz.  Version 2.x, Copyright (C) 2001, Paul Marquess.  Version 1.x, Copyright (C) 1999, Kenneth Albanowski.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.  =head1 SEE ALSO  See L<Devel::PPPort>.  =cut  use strict;  # Disable broken TRIE-optimization BEGIN { eval '${^RE_TRIE_MAXBUF} = -1' if $]>= 5.009004&& $]<= 5.009005 }  my $VERSION = 3.19;  my %opt = (   quiet     => 0,   diag      => 1,   hints     => 1,   changes   => 1,   cplusplus => 0,   filter    => 1,   strip     => 0,   version   => 0, );  my($ppport) = $0 =~ /([\w.]+)$/; my $LF = '(?:\r\n|[\r\n])';   # line feed my $HS = "[ \t]";             # horizontal whitespace  # Never use C comments in this file! my $ccs  = '/'.'*'; my $cce  = '*'.'/'; my $rccs = quotemeta $ccs; my $rcce = quotemeta $cce;  eval {   require Getopt::Long;   Getopt::Long::GetOptions(\%opt, qw(     help quiet diag! filter! hints! changes! cplusplus strip version     patch=s copy=s diff=s compat-version=s     list-provided list-unsupported api-info=s   )) or usage(); };  if ($@ and grep /^-/, @ARGV) {   usage() if "@ARGV" =~ /^--?h(?:elp)?$/;   die "Getopt::Long not found. Please don't use any options.\n"; }  if ($opt{version}) {   print "This is $0 $VERSION.\n";   exit 0; }  usage() if $opt{help}; strip() if $opt{strip};  if (exists $opt{'compat-version'}) {   my($r,$v,$s) = eval { parse_version($opt{'compat-version'}) };   if ($@) {     die "Invalid version number format: '$opt{'compat-version'}'\n";   }   die "Only Perl 5 is supported\n" if $r != 5;   die "Invalid version number: $opt{'compat-version'}\n" if $v>= 1000 || $s>= 1000;   $opt{'compat-version'} = sprintf "%d.%03d%03d", $r, $v, $s; } else {   $opt{'compat-version'} = 5; }  my %API = map { /^(\w+)\|([^|]*)\|([^|]*)\|(\w*)$/                 ? ( $1 => {                       ($2                  ? ( base     => $2 ) : ()),                       ($3                  ? ( todo     => $3 ) : ()),                       (index($4, 'v')>= 0 ? ( varargs  => 1  ) : ()),                       (index($4, 'p')>= 0 ? ( provided => 1  ) : ()),                       (index($4, 'n')>= 0 ? ( nothxarg => 1  ) : ()),                     } )                 : die "invalid spec: $_" } qw( AvFILLp|5.004050||p AvFILL||| CLASS|||n CPERLscope|5.005000||p CX_CURPAD_SAVE||| CX_CURPAD_SV||| CopFILEAV|5.006000||p CopFILEGV_set|5.006000||p CopFILEGV|5.006000||p CopFILESV|5.006000||p CopFILE_set|5.006000||p CopFILE|5.006000||p CopSTASHPV_set|5.006000||p CopSTASHPV|5.006000||p CopSTASH_eq|5.006000||p CopSTASH_set|5.006000||p CopSTASH|5.006000||p CopyD|5.009002||p Copy||| CvPADLIST||| CvSTASH||| CvWEAKOUTSIDE||| DEFSV_set|5.011000||p DEFSV|5.004050||p END_EXTERN_C|5.005000||p ENTER||| ERRSV|5.004050||p EXTEND||| EXTERN_C|5.005000||p F0convert|||n FREETMPS||| GIMME_V||5.004000|n GIMME|||n GROK_NUMERIC_RADIX|5.007002||p G_ARRAY||| G_DISCARD||| G_EVAL||| G_METHOD|5.006001||p G_NOARGS||| G_SCALAR||| G_VOID||5.004000| GetVars||| GvSVn|5.009003||p GvSV||| Gv_AMupdate||| HEf_SVKEY||5.004000| HeHASH||5.004000| HeKEY||5.004000| HeKLEN||5.004000| HePV||5.004000| HeSVKEY_force||5.004000| HeSVKEY_set||5.004000| HeSVKEY||5.004000| HeUTF8||5.011000| HeVAL||5.004000| HvNAMELEN_get|5.009003||p HvNAME_get|5.009003||p HvNAME||| INT2PTR|5.006000||p IN_LOCALE_COMPILETIME|5.007002||p IN_LOCALE_RUNTIME|5.007002||p IN_LOCALE|5.007002||p IN_PERL_COMPILETIME|5.008001||p IS_NUMBER_GREATER_THAN_UV_MAX|5.007002||p IS_NUMBER_INFINITY|5.007002||p IS_NUMBER_IN_UV|5.007002||p IS_NUMBER_NAN|5.007003||p IS_NUMBER_NEG|5.007002||p IS_NUMBER_NOT_INT|5.007002||p IVSIZE|5.006000||p IVTYPE|5.006000||p IVdf|5.006000||p LEAVE||| LVRET||| MARK||| MULTICALL||5.011000| MY_CXT_CLONE|5.009002||p MY_CXT_INIT|5.007003||p MY_CXT|5.007003||p MoveD|5.009002||p Move||| NOOP|5.005000||p NUM2PTR|5.006000||p NVTYPE|5.006000||p NVef|5.006001||p NVff|5.006001||p NVgf|5.006001||p Newxc|5.009003||p Newxz|5.009003||p Newx|5.009003||p Nullav||| Nullch||| Nullcv||| Nullhv||| Nullsv||| ORIGMARK||| PAD_BASE_SV||| PAD_CLONE_VARS||| PAD_COMPNAME_FLAGS||| PAD_COMPNAME_GEN_set||| PAD_COMPNAME_GEN||| PAD_COMPNAME_OURSTASH||| PAD_COMPNAME_PV||| PAD_COMPNAME_TYPE||| PAD_DUP||| PAD_RESTORE_LOCAL||| PAD_SAVE_LOCAL||| PAD_SAVE_SETNULLPAD||| PAD_SETSV||| PAD_SET_CUR_NOSAVE||| PAD_SET_CUR||| PAD_SVl||| PAD_SV||| PERLIO_FUNCS_CAST|5.009003||p PERLIO_FUNCS_DECL|5.009003||p PERL_ABS|5.008001||p PERL_BCDVERSION|5.011000||p PERL_GCC_BRACE_GROUPS_FORBIDDEN|5.008001||p PERL_HASH|5.004000||p PERL_INT_MAX|5.004000||p PERL_INT_MIN|5.004000||p PERL_LONG_MAX|5.004000||p PERL_LONG_MIN|5.004000||p PERL_MAGIC_arylen|5.007002||p PERL_MAGIC_backref|5.007002||p PERL_MAGIC_bm|5.007002||p PERL_MAGIC_collxfrm|5.007002||p PERL_MAGIC_dbfile|5.007002||p PERL_MAGIC_dbline|5.007002||p PERL_MAGIC_defelem|5.007002||p PERL_MAGIC_envelem|5.007002||p PERL_MAGIC_env|5.007002||p PERL_MAGIC_ext|5.007002||p PERL_MAGIC_fm|5.007002||p PERL_MAGIC_glob|5.011000||p PERL_MAGIC_isaelem|5.007002||p PERL_MAGIC_isa|5.007002||p PERL_MAGIC_mutex|5.011000||p PERL_MAGIC_nkeys|5.007002||p PERL_MAGIC_overload_elem|5.007002||p PERL_MAGIC_overload_table|5.007002||p PERL_MAGIC_overload|5.007002||p PERL_MAGIC_pos|5.007002||p PERL_MAGIC_qr|5.007002||p PERL_MAGIC_regdata|5.007002||p PERL_MAGIC_regdatum|5.007002||p PERL_MAGIC_regex_global|5.007002||p PERL_MAGIC_shared_scalar|5.007003||p PERL_MAGIC_shared|5.007003||p PERL_MAGIC_sigelem|5.007002||p PERL_MAGIC_sig|5.007002||p PERL_MAGIC_substr|5.007002||p PERL_MAGIC_sv|5.007002||p PERL_MAGIC_taint|5.007002||p PERL_MAGIC_tiedelem|5.007002||p PERL_MAGIC_tiedscalar|5.007002||p PERL_MAGIC_tied|5.007002||p PERL_MAGIC_utf8|5.008001||p PERL_MAGIC_uvar_elem|5.007003||p PERL_MAGIC_uvar|5.007002||p PERL_MAGIC_vec|5.007002||p PERL_MAGIC_vstring|5.008001||p PERL_PV_ESCAPE_ALL|5.009004||p PERL_PV_ESCAPE_FIRSTCHAR|5.009004||p PERL_PV_ESCAPE_NOBACKSLASH|5.009004||p PERL_PV_ESCAPE_NOCLEAR|5.009004||p PERL_PV_ESCAPE_QUOTE|5.009004||p PERL_PV_ESCAPE_RE|5.009005||p PERL_PV_ESCAPE_UNI_DETECT|5.009004||p PERL_PV_ESCAPE_UNI|5.009004||p PERL_PV_PRETTY_DUMP|5.009004||p PERL_PV_PRETTY_ELLIPSES|5.010000||p PERL_PV_PRETTY_LTGT|5.009004||p PERL_PV_PRETTY_NOCLEAR|5.010000||p PERL_PV_PRETTY_QUOTE|5.009004||p PERL_PV_PRETTY_REGPROP|5.009004||p PERL_QUAD_MAX|5.004000||p PERL_QUAD_MIN|5.004000||p PERL_REVISION|5.006000||p PERL_SCAN_ALLOW_UNDERSCORES|5.007003||p PERL_SCAN_DISALLOW_PREFIX|5.007003||p PERL_SCAN_GREATER_THAN_UV_MAX|5.007003||p PERL_SCAN_SILENT_ILLDIGIT|5.008001||p PERL_SHORT_MAX|5.004000||p PERL_SHORT_MIN|5.004000||p PERL_SIGNALS_UNSAFE_FLAG|5.008001||p PERL_SUBVERSION|5.006000||p PERL_SYS_INIT3||5.006000| PERL_SYS_INIT||| PERL_SYS_TERM||5.011000| PERL_UCHAR_MAX|5.004000||p PERL_UCHAR_MIN|5.004000||p PERL_UINT_MAX|5.004000||p PERL_UINT_MIN|5.004000||p PERL_ULONG_MAX|5.004000||p PERL_ULONG_MIN|5.004000||p PERL_UNUSED_ARG|5.009003||p PERL_UNUSED_CONTEXT|5.009004||p PERL_UNUSED_DECL|5.007002||p PERL_UNUSED_VAR|5.007002||p PERL_UQUAD_MAX|5.004000||p PERL_UQUAD_MIN|5.004000||p PERL_USE_GCC_BRACE_GROUPS|5.009004||p PERL_USHORT_MAX|5.004000||p PERL_USHORT_MIN|5.004000||p PERL_VERSION|5.006000||p PL_DBsignal|5.005000||p PL_DBsingle|||pn PL_DBsub|||pn PL_DBtrace|||pn PL_Sv|5.005000||p PL_bufend|5.011000||p PL_bufptr|5.011000||p PL_compiling|5.004050||p PL_copline|5.011000||p PL_curcop|5.004050||p PL_curstash|5.004050||p PL_debstash|5.004050||p PL_defgv|5.004050||p PL_diehook|5.004050||p PL_dirty|5.004050||p PL_dowarn|||pn PL_errgv|5.004050||p PL_error_count|5.011000||p PL_expect|5.011000||p PL_hexdigit|5.005000||p PL_hints|5.005000||p PL_in_my_stash|5.011000||p PL_in_my|5.011000||p PL_last_in_gv|||n PL_laststatval|5.005000||p PL_lex_state|5.011000||p PL_lex_stuff|5.011000||p PL_linestr|5.011000||p PL_modglobal||5.005000|n PL_na|5.004050||pn PL_no_modify|5.006000||p PL_ofsgv|||n PL_parser|5.009005||p PL_perl_destruct_level|5.004050||p PL_perldb|5.004050||p PL_ppaddr|5.006000||p PL_rsfp_filters|5.004050||p PL_rsfp|5.004050||p PL_rs|||n PL_signals|5.008001||p PL_stack_base|5.004050||p PL_stack_sp|5.004050||p PL_statcache|5.005000||p PL_stdingv|5.004050||p PL_sv_arenaroot|5.004050||p PL_sv_no|5.004050||pn PL_sv_undef|5.004050||pn PL_sv_yes|5.004050||pn PL_tainted|5.004050||p PL_tainting|5.004050||p PL_tokenbuf|5.011000||p POP_MULTICALL||5.011000| POPi|||n POPl|||n POPn|||n POPpbytex||5.007001|n POPpx||5.005030|n POPp|||n POPs|||n PTR2IV|5.006000||p PTR2NV|5.006000||p PTR2UV|5.006000||p PTR2nat|5.009003||p PTR2ul|5.007001||p PTRV|5.006000||p PUSHMARK||| PUSH_MULTICALL||5.011000| PUSHi||| PUSHmortal|5.009002||p PUSHn||| PUSHp||| PUSHs||| PUSHu|5.004000||p PUTBACK||| PerlIO_clearerr||5.007003| PerlIO_close||5.007003| PerlIO_context_layers||5.009004| PerlIO_eof||5.007003| PerlIO_error||5.007003| PerlIO_fileno||5.007003| PerlIO_fill||5.007003| PerlIO_flush||5.007003| PerlIO_get_base||5.007003| PerlIO_get_bufsiz||5.007003| PerlIO_get_cnt||5.007003| PerlIO_get_ptr||5.007003| PerlIO_read||5.007003| PerlIO_seek||5.007003| PerlIO_set_cnt||5.007003| PerlIO_set_ptrcnt||5.007003| PerlIO_setlinebuf||5.007003| PerlIO_stderr||5.007003| PerlIO_stdin||5.007003| PerlIO_stdout||5.007003| PerlIO_tell||5.007003| PerlIO_unread||5.007003| PerlIO_write||5.007003| Perl_signbit||5.009005|n PoisonFree|5.009004||p PoisonNew|5.009004||p PoisonWith|5.009004||p Poison|5.008000||p RETVAL|||n Renewc||| Renew||| SAVECLEARSV||| SAVECOMPPAD||| SAVEPADSV||| SAVETMPS||| SAVE_DEFSV|5.004050||p SPAGAIN||| SP||| START_EXTERN_C|5.005000||p START_MY_CXT|5.007003||p STMT_END|||p STMT_START|||p STR_WITH_LEN|5.009003||p ST||| SV_CONST_RETURN|5.009003||p SV_COW_DROP_PV|5.008001||p SV_COW_SHARED_HASH_KEYS|5.009005||p SV_GMAGIC|5.007002||p SV_HAS_TRAILING_NUL|5.009004||p SV_IMMEDIATE_UNREF|5.007001||p SV_MUTABLE_RETURN|5.009003||p SV_NOSTEAL|5.009002||p SV_SMAGIC|5.009003||p SV_UTF8_NO_ENCODING|5.008001||p SVfARG|5.009005||p SVf_UTF8|5.006000||p SVf|5.006000||p SVt_IV||| SVt_NV||| SVt_PVAV||| SVt_PVCV||| SVt_PVHV||| SVt_PVMG||| SVt_PV||| Safefree||| Slab_Alloc||| Slab_Free||| Slab_to_rw||| StructCopy||| SvCUR_set||| SvCUR||| SvEND||| SvGAMAGIC||5.006001| SvGETMAGIC|5.004050||p SvGROW||| SvIOK_UV||5.006000| SvIOK_notUV||5.006000| SvIOK_off||| SvIOK_only_UV||5.006000| SvIOK_only||| SvIOK_on||| SvIOKp||| SvIOK||| SvIVX||| SvIV_nomg|5.009001||p SvIV_set||| SvIVx||| SvIV||| SvIsCOW_shared_hash||5.008003| SvIsCOW||5.008003| SvLEN_set||| SvLEN||| SvLOCK||5.007003| SvMAGIC_set|5.009003||p SvNIOK_off||| SvNIOKp||| SvNIOK||| SvNOK_off||| SvNOK_only||| SvNOK_on||| SvNOKp||| SvNOK||| SvNVX||| SvNV_set||| SvNVx||| SvNV||| SvOK||| SvOOK_offset||5.011000| SvOOK||| SvPOK_off||| SvPOK_only_UTF8||5.006000| SvPOK_only||| SvPOK_on||| SvPOKp||| SvPOK||| SvPVX_const|5.009003||p SvPVX_mutable|5.009003||p SvPVX||| SvPV_const|5.009003||p SvPV_flags_const_nolen|5.009003||p SvPV_flags_const|5.009003||p SvPV_flags_mutable|5.009003||p SvPV_flags|5.007002||p SvPV_force_flags_mutable|5.009003||p SvPV_force_flags_nolen|5.009003||p SvPV_force_flags|5.007002||p SvPV_force_mutable|5.009003||p SvPV_force_nolen|5.009003||p SvPV_force_nomg_nolen|5.009003||p SvPV_force_nomg|5.007002||p SvPV_force|||p SvPV_mutable|5.009003||p SvPV_nolen_const|5.009003||p SvPV_nolen|5.006000||p SvPV_nomg_const_nolen|5.009003||p SvPV_nomg_const|5.009003||p SvPV_nomg|5.007002||p SvPV_renew|5.009003||p SvPV_set||| SvPVbyte_force||5.009002| SvPVbyte_nolen||5.006000| SvPVbytex_force||5.006000| SvPVbytex||5.006000| SvPVbyte|5.006000||p SvPVutf8_force||5.006000| SvPVutf8_nolen||5.006000| SvPVutf8x_force||5.006000| SvPVutf8x||5.006000| SvPVutf8||5.006000| SvPVx||| SvPV||| SvREFCNT_dec||| SvREFCNT_inc_NN|5.009004||p SvREFCNT_inc_simple_NN|5.009004||p SvREFCNT_inc_simple_void_NN|5.009004||p SvREFCNT_inc_simple_void|5.009004||p SvREFCNT_inc_simple|5.009004||p SvREFCNT_inc_void_NN|5.009004||p SvREFCNT_inc_void|5.009004||p SvREFCNT_inc|||p SvREFCNT||| SvROK_off||| SvROK_on||| SvROK||| SvRV_set|5.009003||p SvRV||| SvRXOK||5.009005| SvRX||5.009005| SvSETMAGIC||| SvSHARED_HASH|5.009003||p SvSHARE||5.007003| SvSTASH_set|5.009003||p SvSTASH||| SvSetMagicSV_nosteal||5.004000| SvSetMagicSV||5.004000| SvSetSV_nosteal||5.004000| SvSetSV||| SvTAINTED_off||5.004000| SvTAINTED_on||5.004000| SvTAINTED||5.004000| SvTAINT||| SvTRUE||| SvTYPE||| SvUNLOCK||5.007003| SvUOK|5.007001|5.006000|p SvUPGRADE||| SvUTF8_off||5.006000| SvUTF8_on||5.006000| SvUTF8||5.006000| SvUVXx|5.004000||p SvUVX|5.004000||p SvUV_nomg|5.009001||p SvUV_set|5.009003||p SvUVx|5.004000||p SvUV|5.004000||p SvVOK||5.008001| SvVSTRING_mg|5.009004||p THIS|||n UNDERBAR|5.009002||p UTF8_MAXBYTES|5.009002||p UVSIZE|5.006000||p UVTYPE|5.006000||p UVXf|5.007001||p UVof|5.006000||p UVuf|5.006000||p UVxf|5.006000||p WARN_ALL|5.006000||p WARN_AMBIGUOUS|5.006000||p WARN_ASSERTIONS|5.011000||p WARN_BAREWORD|5.006000||p WARN_CLOSED|5.006000||p WARN_CLOSURE|5.006000||p WARN_DEBUGGING|5.006000||p WARN_DEPRECATED|5.006000||p WARN_DIGIT|5.006000||p WARN_EXEC|5.006000||p WARN_EXITING|5.006000||p WARN_GLOB|5.006000||p WARN_INPLACE|5.006000||p WARN_INTERNAL|5.006000||p WARN_IO|5.006000||p WARN_LAYER|5.008000||p WARN_MALLOC|5.006000||p WARN_MISC|5.006000||p WARN_NEWLINE|5.006000||p WARN_NUMERIC|5.006000||p WARN_ONCE|5.006000||p WARN_OVERFLOW|5.006000||p WARN_PACK|5.006000||p WARN_PARENTHESIS|5.006000||p WARN_PIPE|5.006000||p WARN_PORTABLE|5.006000||p WARN_PRECEDENCE|5.006000||p WARN_PRINTF|5.006000||p WARN_PROTOTYPE|5.006000||p WARN_QW|5.006000||p WARN_RECURSION|5.006000||p WARN_REDEFINE|5.006000||p WARN_REGEXP|5.006000||p WARN_RESERVED|5.006000||p WARN_SEMICOLON|5.006000||p WARN_SEVERE|5.006000||p WARN_SIGNAL|5.006000||p WARN_SUBSTR|5.006000||p WARN_SYNTAX|5.006000||p WARN_TAINT|5.006000||p WARN_THREADS|5.008000||p WARN_UNINITIALIZED|5.006000||p WARN_UNOPENED|5.006000||p WARN_UNPACK|5.006000||p WARN_UNTIE|5.006000||p WARN_UTF8|5.006000||p WARN_VOID|5.006000||p XCPT_CATCH|5.009002||p XCPT_RETHROW|5.009002||p XCPT_TRY_END|5.009002||p XCPT_TRY_START|5.009002||p XPUSHi||| XPUSHmortal|5.009002||p XPUSHn||| XPUSHp||| XPUSHs||| XPUSHu|5.004000||p XSPROTO|5.010000||p XSRETURN_EMPTY||| XSRETURN_IV||| XSRETURN_NO||| XSRETURN_NV||| XSRETURN_PV||| XSRETURN_UNDEF||| XSRETURN_UV|5.008001||p XSRETURN_YES||| XSRETURN|||p XST_mIV||| XST_mNO||| XST_mNV||| XST_mPV||| XST_mUNDEF||| XST_mUV|5.008001||p XST_mYES||| XS_VERSION_BOOTCHECK||| XS_VERSION||| XSprePUSH|5.006000||p XS||| ZeroD|5.009002||p Zero||| _aMY_CXT|5.007003||p _pMY_CXT|5.007003||p aMY_CXT_|5.007003||p aMY_CXT|5.007003||p aTHXR_|5.011000||p aTHXR|5.011000||p aTHX_|5.006000||p aTHX|5.006000||p add_data|||n addmad||| allocmy||| amagic_call||| amagic_cmp_locale||| amagic_cmp||| amagic_i_ncmp||| amagic_ncmp||| any_dup||| ao||| append_elem||| append_list||| append_madprops||| apply_attrs_my||| apply_attrs_string||5.006001| apply_attrs||| apply||| atfork_lock||5.007003|n atfork_unlock||5.007003|n av_arylen_p||5.009003| av_clear||| av_create_and_push||5.009005| av_create_and_unshift_one||5.009005| av_delete||5.006000| av_exists||5.006000| av_extend||| av_fetch||| av_fill||| av_iter_p||5.011000| av_len||| av_make||| av_pop||| av_push||| av_reify||| av_shift||| av_store||| av_undef||| av_unshift||| ax|||n bad_type||| bind_match||| block_end||| block_gimme||5.004000| block_start||| boolSV|5.004000||p boot_core_PerlIO||| boot_core_UNIVERSAL||| boot_core_mro||| bytes_from_utf8||5.007001| bytes_to_uni|||n bytes_to_utf8||5.006001| call_argv|5.006000||p call_atexit||5.006000| call_list||5.004000| call_method|5.006000||p call_pv|5.006000||p call_sv|5.006000||p calloc||5.007002|n cando||| cast_i32||5.006000| cast_iv||5.006000| cast_ulong||5.006000| cast_uv||5.006000| check_type_and_open||| check_uni||| checkcomma||| checkposixcc||| ckWARN|5.006000||p ck_anoncode||| ck_bitop||| ck_concat||| ck_defined||| ck_delete||| ck_die||| ck_each||| ck_eof||| ck_eval||| ck_exec||| ck_exists||| ck_exit||| ck_ftst||| ck_fun||| ck_glob||| ck_grep||| ck_index||| ck_join||| ck_lfun||| ck_listiob||| ck_match||| ck_method||| ck_null||| ck_open||| ck_readline||| ck_repeat||| ck_require||| ck_return||| ck_rfun||| ck_rvconst||| ck_sassign||| ck_select||| ck_shift||| ck_sort||| ck_spair||| ck_split||| ck_subr||| ck_substr||| ck_svconst||| ck_trunc||| ck_unpack||| ckwarn_d||5.009003| ckwarn||5.009003| cl_and|||n cl_anything|||n cl_init_zero|||n cl_init|||n cl_is_anything|||n cl_or|||n clear_placeholders||| closest_cop||| convert||| cop_free||| cr_textfilter||| create_eval_scope||| croak_nocontext|||vn croak_xs_usage||5.011000| croak|||v csighandler||5.009003|n curmad||| custom_op_desc||5.007003| custom_op_name||5.007003| cv_ckproto_len||| cv_clone||| cv_const_sv||5.004000| cv_dump||| cv_undef||| cx_dump||5.005000| cx_dup||| cxinc||| dAXMARK|5.009003||p dAX|5.007002||p dITEMS|5.007002||p dMARK||| dMULTICALL||5.009003| dMY_CXT_SV|5.007003||p dMY_CXT|5.007003||p dNOOP|5.006000||p dORIGMARK||| dSP||| dTHR|5.004050||p dTHXR|5.011000||p dTHXa|5.006000||p dTHXoa|5.006000||p dTHX|5.006000||p dUNDERBAR|5.009002||p dVAR|5.009003||p dXCPT|5.009002||p dXSARGS||| dXSI32||| dXSTARG|5.006000||p deb_curcv||| deb_nocontext|||vn deb_stack_all||| deb_stack_n||| debop||5.005000| debprofdump||5.005000| debprof||| debstackptrs||5.007003| debstack||5.007003| debug_start_match||| deb||5.007003|v del_sv||| delete_eval_scope||| delimcpy||5.004000| deprecate_old||| deprecate||| despatch_signals||5.007001| destroy_matcher||| die_nocontext|||vn die_where||| die|||v dirp_dup||| div128||| djSP||| do_aexec5||| do_aexec||| do_aspawn||| do_binmode||5.004050| do_chomp||| do_chop||| do_close||| do_dump_pad||| do_eof||| do_exec3||| do_execfree||| do_exec||| do_gv_dump||5.006000| do_gvgv_dump||5.006000| do_hv_dump||5.006000| do_ipcctl||| do_ipcget||| do_join||| do_kv||| do_magic_dump||5.006000| do_msgrcv||| do_msgsnd||| do_oddball||| do_op_dump||5.006000| do_op_xmldump||| do_open9||5.006000| do_openn||5.007001| do_open||5.004000| do_pmop_dump||5.006000| do_pmop_xmldump||| do_print||| do_readline||| do_seek||| do_semop||| do_shmio||| do_smartmatch||| do_spawn_nowait||| do_spawn||| do_sprintf||| do_sv_dump||5.006000| do_sysseek||| do_tell||| do_trans_complex_utf8||| do_trans_complex||| do_trans_count_utf8||| do_trans_count||| do_trans_simple_utf8||| do_trans_simple||| do_trans||| do_vecget||| do_vecset||| do_vop||| docatch||| doeval||| dofile||| dofindlabel||| doform||| doing_taint||5.008001|n dooneliner||| doopen_pm||| doparseform||| dopoptoeval||| dopoptogiven||| dopoptolabel||| dopoptoloop||| dopoptosub_at||| dopoptowhen||| doref||5.009003| dounwind||| dowantarray||| dump_all||5.006000| dump_eval||5.006000| dump_exec_pos||| dump_fds||| dump_form||5.006000| dump_indent||5.006000|v dump_mstats||| dump_packsubs||5.006000| dump_sub||5.006000| dump_sv_child||| dump_trie_interim_list||| dump_trie_interim_table||| dump_trie||| dump_vindent||5.006000| dumpuntil||| dup_attrlist||| emulate_cop_io||| eval_pv|5.006000||p eval_sv|5.006000||p exec_failed||| expect_number||| fbm_compile||5.005000| fbm_instr||5.005000| feature_is_enabled||| fetch_cop_label||5.011000| filter_add||| filter_del||| filter_gets||| filter_read||| find_and_forget_pmops||| find_array_subscript||| find_beginning||| find_byclass||| find_hash_subscript||| find_in_my_stash||| find_runcv||5.008001| find_rundefsvoffset||5.009002| find_script||| find_uninit_var||| first_symbol|||n fold_constants||| forbid_setid||| force_ident||| force_list||| force_next||| force_version||| force_word||| forget_pmop||| form_nocontext|||vn form||5.004000|v fp_dup||| fprintf_nocontext|||vn free_global_struct||| free_tied_hv_pool||| free_tmps||| gen_constant_list||| get_arena||| get_aux_mg||| get_av|5.006000||p get_context||5.006000|n get_cvn_flags||5.009005| get_cv|5.006000||p get_db_sub||| get_debug_opts||| get_hash_seed||| get_hv|5.006000||p get_isa_hash||| get_mstats||| get_no_modify||| get_num||| get_op_descs||5.005000| get_op_names||5.005000| get_opargs||| get_ppaddr||5.006000| get_re_arg||| get_sv|5.006000||p get_vtbl||5.005030| getcwd_sv||5.007002| getenv_len||| glob_2number||| glob_assign_glob||| glob_assign_ref||| gp_dup||| gp_free||| gp_ref||| grok_bin|5.007003||p grok_hex|5.007003||p grok_number|5.007002||p grok_numeric_radix|5.007002||p grok_oct|5.007003||p group_end||| gv_AVadd||| gv_HVadd||| gv_IOadd||| gv_SVadd||| gv_autoload4||5.004000| gv_check||| gv_const_sv||5.009003| gv_dump||5.006000| gv_efullname3||5.004000| gv_efullname4||5.006001| gv_efullname||| gv_ename||| gv_fetchfile_flags||5.009005| gv_fetchfile||| gv_fetchmeth_autoload||5.007003| gv_fetchmethod_autoload||5.004000| gv_fetchmethod_flags||5.011000| gv_fetchmethod||| gv_fetchmeth||| gv_fetchpvn_flags|5.009002||p gv_fetchpvs|5.009004||p gv_fetchpv||| gv_fetchsv||5.009002| gv_fullname3||5.004000| gv_fullname4||5.006001| gv_fullname||| gv_get_super_pkg||| gv_handler||5.007001| gv_init_sv||| gv_init||| gv_name_set||5.009004| gv_stashpvn|5.004000||p gv_stashpvs|5.009003||p gv_stashpv||| gv_stashsv||| he_dup||| hek_dup||| hfreeentries||| hsplit||| hv_assert||5.011000| hv_auxinit|||n hv_backreferences_p||| hv_clear_placeholders||5.009001| hv_clear||| hv_common_key_len||5.010000| hv_common||5.010000| hv_copy_hints_hv||| hv_delayfree_ent||5.004000| hv_delete_common||| hv_delete_ent||5.004000| hv_delete||| hv_eiter_p||5.009003| hv_eiter_set||5.009003| hv_exists_ent||5.004000| hv_exists||| hv_fetch_ent||5.004000| hv_fetchs|5.009003||p hv_fetch||| hv_free_ent||5.004000| hv_iterinit||| hv_iterkeysv||5.004000| hv_iterkey||| hv_iternext_flags||5.008000| hv_iternextsv||| hv_iternext||| hv_iterval||| hv_kill_backrefs||| hv_ksplit||5.004000| hv_magic_check|||n hv_magic||| hv_name_set||5.009003| hv_notallowed||| hv_placeholders_get||5.009003| hv_placeholders_p||5.009003| hv_placeholders_set||5.009003| hv_riter_p||5.009003| hv_riter_set||5.009003| hv_scalar||5.009001| hv_store_ent||5.004000| hv_store_flags||5.008000| hv_stores|5.009004||p hv_store||| hv_undef||| ibcmp_locale||5.004000| ibcmp_utf8||5.007003| ibcmp||| incline||| incpush_if_exists||| incpush_use_sep||| incpush||| ingroup||| init_argv_symbols||| init_debugger||| init_global_struct||| init_i18nl10n||5.006000| init_i18nl14n||5.006000| init_ids||| init_interp||| init_main_stash||| init_perllib||| init_postdump_symbols||| init_predump_symbols||| init_stacks||5.005000| init_tm||5.007002| instr||| intro_my||| intuit_method||| intuit_more||| invert||| io_close||| isALNUMC|5.006000||p isALNUM||| isALPHA||| isASCII|5.006000||p isBLANK|5.006001||p isCNTRL|5.006000||p isDIGIT||| isGRAPH|5.006000||p isGV_with_GP|5.009004||p isLOWER||| isPRINT|5.004000||p isPSXSPC|5.006001||p isPUNCT|5.006000||p isSPACE||| isUPPER||| isXDIGIT|5.006000||p is_an_int||| is_gv_magical_sv||| is_handle_constructor|||n is_list_assignment||| is_lvalue_sub||5.007001| is_uni_alnum_lc||5.006000| is_uni_alnumc_lc||5.006000| is_uni_alnumc||5.006000| is_uni_alnum||5.006000| is_uni_alpha_lc||5.006000| is_uni_alpha||5.006000| is_uni_ascii_lc||5.006000| is_uni_ascii||5.006000| is_uni_cntrl_lc||5.006000| is_uni_cntrl||5.006000| is_uni_digit_lc||5.006000| is_uni_digit||5.006000| is_uni_graph_lc||5.006000| is_uni_graph||5.006000| is_uni_idfirst_lc||5.006000| is_uni_idfirst||5.006000| is_uni_lower_lc||5.006000| is_uni_lower||5.006000| is_uni_print_lc||5.006000| is_uni_print||5.006000| is_uni_punct_lc||5.006000| is_uni_punct||5.006000| is_uni_space_lc||5.006000| is_uni_space||5.006000| is_uni_upper_lc||5.006000| is_uni_upper||5.006000| is_uni_xdigit_lc||5.006000| is_uni_xdigit||5.006000| is_utf8_alnumc||5.006000| is_utf8_alnum||5.006000| is_utf8_alpha||5.006000| is_utf8_ascii||5.006000| is_utf8_char_slow|||n is_utf8_char||5.006000| is_utf8_cntrl||5.006000| is_utf8_common||| is_utf8_digit||5.006000| is_utf8_graph||5.006000| is_utf8_idcont||5.008000| is_utf8_idfirst||5.006000| is_utf8_lower||5.006000| is_utf8_mark||5.006000| is_utf8_print||5.006000| is_utf8_punct||5.006000| is_utf8_space||5.006000| is_utf8_string_loclen||5.009003| is_utf8_string_loc||5.008001| is_utf8_string||5.006001| is_utf8_upper||5.006000| is_utf8_xdigit||5.006000| isa_lookup||| items|||n ix|||n jmaybe||| join_exact||| keyword||| leave_scope||| lex_end||| lex_start||| linklist||| listkids||| list||| load_module_nocontext|||vn load_module|5.006000||pv localize||| looks_like_bool||| looks_like_number||| lop||| mPUSHi|5.009002||p mPUSHn|5.009002||p mPUSHp|5.009002||p mPUSHs|5.011000||p mPUSHu|5.009002||p mXPUSHi|5.009002||p mXPUSHn|5.009002||p mXPUSHp|5.009002||p mXPUSHs|5.011000||p mXPUSHu|5.009002||p mad_free||| madlex||| madparse||| magic_clear_all_env||| magic_clearenv||| magic_clearhint||| magic_clearisa||| magic_clearpack||| magic_clearsig||| magic_dump||5.006000| magic_existspack||| magic_freearylen_p||| magic_freeovrld||| magic_getarylen||| magic_getdefelem||| magic_getnkeys||| magic_getpack||| magic_getpos||| magic_getsig||| magic_getsubstr||| magic_gettaint||| magic_getuvar||| magic_getvec||| magic_get||| magic_killbackrefs||| magic_len||| magic_methcall||| magic_methpack||| magic_nextpack||| magic_regdata_cnt||| magic_regdatum_get||| magic_regdatum_set||| magic_scalarpack||| magic_set_all_env||| magic_setamagic||| magic_setarylen||| magic_setcollxfrm||| magic_setdbline||| magic_setdefelem||| magic_setenv||| magic_sethint||| magic_setisa||| magic_setmglob||| magic_setnkeys||| magic_setpack||| magic_setpos||| magic_setregexp||| magic_setsig||| magic_setsubstr||| magic_settaint||| magic_setutf8||| magic_setuvar||| magic_setvec||| magic_set||| magic_sizepack||| magic_wipepack||| make_matcher||| make_trie_failtable||| make_trie||| malloc_good_size|||n malloced_size|||n malloc||5.007002|n markstack_grow||| matcher_matches_sv||| measure_struct||| memEQ|5.004000||p memNE|5.004000||p mem_collxfrm||| mem_log_common|||n mess_alloc||| mess_nocontext|||vn mess||5.006000|v method_common||| mfree||5.007002|n mg_clear||| mg_copy||| mg_dup||| mg_find||| mg_free||| mg_get||| mg_length||5.005000| mg_localize||| mg_magical||| mg_set||| mg_size||5.005000| mini_mktime||5.007002| missingterm||| mode_from_discipline||| modkids||| mod||| more_bodies||| more_sv||| moreswitches||| mro_get_from_name||5.011000| mro_get_linear_isa_dfs||| mro_get_linear_isa||5.009005| mro_get_private_data||5.011000| mro_isa_changed_in||| mro_meta_dup||| mro_meta_init||| mro_method_changed_in||5.009005| mro_register||5.011000| mro_set_mro||5.011000| mro_set_private_data||5.011000| mul128||| mulexp10|||n my_atof2||5.007002| my_atof||5.006000| my_attrs||| my_bcopy|||n my_betoh16|||n my_betoh32|||n my_betoh64|||n my_betohi|||n my_betohl|||n my_betohs|||n my_bzero|||n my_chsize||| my_clearenv||| my_cxt_index||| my_cxt_init||| my_dirfd||5.009005| my_exit_jump||| my_exit||| my_failure_exit||5.004000| my_fflush_all||5.006000| my_fork||5.007003|n my_htobe16|||n my_htobe32|||n my_htobe64|||n my_htobei|||n my_htobel|||n my_htobes|||n my_htole16|||n my_htole32|||n my_htole64|||n my_htolei|||n my_htolel|||n my_htoles|||n my_htonl||| my_kid||| my_letoh16|||n my_letoh32|||n my_letoh64|||n my_letohi|||n my_letohl|||n my_letohs|||n my_lstat||| my_memcmp||5.004000|n my_memset|||n my_ntohl||| my_pclose||5.004000| my_popen_list||5.007001| my_popen||5.004000| my_setenv||| my_snprintf|5.009004||pvn my_socketpair||5.007003|n my_sprintf|5.009003||pvn my_stat||| my_strftime||5.007002| my_strlcat|5.009004||pn my_strlcpy|5.009004||pn my_swabn|||n my_swap||| my_unexec||| my_vsnprintf||5.009004|n need_utf8|||n newANONATTRSUB||5.006000| newANONHASH||| newANONLIST||| newANONSUB||| newASSIGNOP||| newATTRSUB||5.006000| newAVREF||| newAV||| newBINOP||| newCONDOP||| newCONSTSUB|5.004050||p newCVREF||| newDEFSVOP||| newFORM||| newFOROP||| newGIVENOP||5.009003| newGIVWHENOP||| newGP||| newGVOP||| newGVREF||| newGVgen||| newHVREF||| newHVhv||5.005000| newHV||| newIO||| newLISTOP||| newLOGOP||| newLOOPEX||| newLOOPOP||| newMADPROP||| newMADsv||| newMYSUB||| newNULLLIST||| newOP||| newPADOP||| newPMOP||| newPROG||| newPVOP||| newRANGE||| newRV_inc|5.004000||p newRV_noinc|5.004000||p newRV||| newSLICEOP||| newSTATEOP||| newSUB||| newSVOP||| newSVREF||| newSV_type|5.009005||p newSVhek||5.009003| newSViv||| newSVnv||| newSVpvf_nocontext|||vn newSVpvf||5.004000|v newSVpvn_flags|5.011000||p newSVpvn_share|5.007001||p newSVpvn_utf8|5.011000||p newSVpvn|5.004050||p newSVpvs_flags|5.011000||p newSVpvs_share||5.009003| newSVpvs|5.009003||p newSVpv||| newSVrv||| newSVsv||| newSVuv|5.006000||p newSV||| newTOKEN||| newUNOP||| newWHENOP||5.009003| newWHILEOP||5.009003| newXS_flags||5.009004| newXSproto||5.006000| newXS||5.006000| new_collate||5.006000| new_constant||| new_ctype||5.006000| new_he||| new_logop||| new_numeric||5.006000| new_stackinfo||5.005000| new_version||5.009000| new_warnings_bitfield||| next_symbol||| nextargv||| nextchar||| ninstr||| no_bareword_allowed||| no_fh_allowed||| no_op||| not_a_number||| nothreadhook||5.008000| nuke_stacks||| num_overflow|||n offer_nice_chunk||| oopsAV||| oopsHV||| op_clear||| op_const_sv||| op_dump||5.006000| op_free||| op_getmad_weak||| op_getmad||| op_null||5.007002| op_refcnt_dec||| op_refcnt_inc||| op_refcnt_lock||5.009002| op_refcnt_unlock||5.009002| op_xmldump||| open_script||| pMY_CXT_|5.007003||p pMY_CXT|5.007003||p pTHX_|5.006000||p pTHX|5.006000||p packWARN|5.007003||p pack_cat||5.007003| pack_rec||| package||| packlist||5.008001| pad_add_anon||| pad_add_name||| pad_alloc||| pad_block_start||| pad_check_dup||| pad_compname_type||| pad_findlex||| pad_findmy||| pad_fixup_inner_anons||| pad_free||| pad_leavemy||| pad_new||| pad_peg|||n pad_push||| pad_reset||| pad_setsv||| pad_sv||5.011000| pad_swipe||| pad_tidy||| pad_undef||| parse_body||| parse_unicode_opts||| parser_dup||| parser_free||| path_is_absolute|||n peep||| pending_Slabs_to_ro||| perl_alloc_using|||n perl_alloc|||n perl_clone_using|||n perl_clone|||n perl_construct|||n perl_destruct||5.007003|n perl_free|||n perl_parse||5.006000|n perl_run|||n pidgone||| pm_description||| pmflag||| pmop_dump||5.006000| pmop_xmldump||| pmruntime||| pmtrans||| pop_scope||| pregcomp||5.009005| pregexec||| pregfree2||5.011000| pregfree||| prepend_elem||| prepend_madprops||| printbuf||| printf_nocontext|||vn process_special_blocks||| ptr_table_clear||5.009005| ptr_table_fetch||5.009005| ptr_table_find|||n ptr_table_free||5.009005| ptr_table_new||5.009005| ptr_table_split||5.009005| ptr_table_store||5.009005| push_scope||| put_byte||| pv_display|5.006000||p pv_escape|5.009004||p pv_pretty|5.009004||p pv_uni_display||5.007003| qerror||| qsortsvu||| re_compile||5.009005| re_croak2||| re_dup_guts||| re_intuit_start||5.009005| re_intuit_string||5.006000| readpipe_override||| realloc||5.007002|n reentrant_free||| reentrant_init||| reentrant_retry|||vn reentrant_size||| ref_array_or_hash||| refcounted_he_chain_2hv||| refcounted_he_fetch||| refcounted_he_free||| refcounted_he_new_common||| refcounted_he_new||| refcounted_he_value||| refkids||| refto||| ref||5.011000| reg_check_named_buff_matched||| reg_named_buff_all||5.009005| reg_named_buff_exists||5.009005| reg_named_buff_fetch||5.009005| reg_named_buff_firstkey||5.009005| reg_named_buff_iter||| reg_named_buff_nextkey||5.009005| reg_named_buff_scalar||5.009005| reg_named_buff||| reg_namedseq||| reg_node||| reg_numbered_buff_fetch||| reg_numbered_buff_length||| reg_numbered_buff_store||| reg_qr_package||| reg_recode||| reg_scan_name||| reg_skipcomment||| reg_temp_copy||| reganode||| regatom||| regbranch||| regclass_swash||5.009004| regclass||| regcppop||| regcppush||| regcurly|||n regdump_extflags||| regdump||5.005000| regdupe_internal||| regexec_flags||5.005000| regfree_internal||5.009005| reghop3|||n reghop4|||n reghopmaybe3|||n reginclass||| reginitcolors||5.006000| reginsert||| regmatch||| regnext||5.005000| regpiece||| regpposixcc||| regprop||| regrepeat||| regtail_study||| regtail||| regtry||| reguni||| regwhite|||n reg||| repeatcpy||| report_evil_fh||| report_uninit||| require_pv||5.006000| require_tie_mod||| restore_magic||| rninstr||| rsignal_restore||| rsignal_save||| rsignal_state||5.004000| rsignal||5.004000| run_body||| run_user_filter||| runops_debug||5.005000| runops_standard||5.005000| rvpv_dup||| rxres_free||| rxres_restore||| rxres_save||| safesyscalloc||5.006000|n safesysfree||5.006000|n safesysmalloc||5.006000|n safesysrealloc||5.006000|n same_dirent||| save_I16||5.004000| save_I32||| save_I8||5.006000| save_adelete||5.011000| save_aelem||5.004050| save_alloc||5.006000| save_aptr||| save_ary||| save_bool||5.008001| save_clearsv||| save_delete||| save_destructor_x||5.006000| save_destructor||5.006000| save_freeop||| save_freepv||| save_freesv||| save_generic_pvref||5.006001| save_generic_svref||5.005030| save_gp||5.004000| save_hash||| save_hek_flags|||n save_helem_flags||5.011000| save_helem||5.004050| save_hints||| save_hptr||| save_int||| save_item||| save_iv||5.005000| save_lines||| save_list||| save_long||| save_magic||| save_mortalizesv||5.007001| save_nogv||| save_op||| save_padsv_and_mortalize||5.011000| save_pptr||| save_pushi32ptr||| save_pushptri32ptr||| save_pushptrptr||| save_pushptr||5.011000| save_re_context||5.006000| save_scalar_at||| save_scalar||| save_set_svflags||5.009000| save_shared_pvref||5.007003| save_sptr||| save_svref||| save_vptr||5.006000| savepvn||| savepvs||5.009003| savepv||| savesharedpvn||5.009005| savesharedpv||5.007003| savestack_grow_cnt||5.008001| savestack_grow||| savesvpv||5.009002| sawparens||| scalar_mod_type|||n scalarboolean||| scalarkids||| scalarseq||| scalarvoid||| scalar||| scan_bin||5.006000| scan_commit||| scan_const||| scan_formline||| scan_heredoc||| scan_hex||| scan_ident||| scan_inputsymbol||| scan_num||5.007001| scan_oct||| scan_pat||| scan_str||| scan_subst||| scan_trans||| scan_version||5.009001| scan_vstring||5.009005| scan_word||| scope||| screaminstr||5.005000| search_const||| seed||5.008001| sequence_num||| sequence_tail||| sequence||| set_context||5.006000|n set_numeric_local||5.006000| set_numeric_radix||5.006000| set_numeric_standard||5.006000| setdefout||| share_hek_flags||| share_hek||5.004000| si_dup||| sighandler|||n simplify_sort||| skipspace0||| skipspace1||| skipspace2||| skipspace||| softref2xv||| sortcv_stacked||| sortcv_xsub||| sortcv||| sortsv_flags||5.009003| sortsv||5.007003| space_join_names_mortal||| ss_dup||| stack_grow||| start_force||| start_glob||| start_subparse||5.004000| stashpv_hvname_match||5.011000| stdize_locale||| store_cop_label||| strEQ||| strGE||| strGT||| strLE||| strLT||| strNE||| str_to_version||5.006000| strip_return||| strnEQ||| strnNE||| study_chunk||| sub_crush_depth||| sublex_done||| sublex_push||| sublex_start||| sv_2bool||| sv_2cv||| sv_2io||| sv_2iuv_common||| sv_2iuv_non_preserve||| sv_2iv_flags||5.009001| sv_2iv||| sv_2mortal||| sv_2num||| sv_2nv||| sv_2pv_flags|5.007002||p sv_2pv_nolen|5.006000||p sv_2pvbyte_nolen|5.006000||p sv_2pvbyte|5.006000||p sv_2pvutf8_nolen||5.006000| sv_2pvutf8||5.006000| sv_2pv||| sv_2uv_flags||5.009001| sv_2uv|5.004000||p sv_add_arena||| sv_add_backref||| sv_backoff||| sv_bless||| sv_cat_decode||5.008001| sv_catpv_mg|5.004050||p sv_catpvf_mg_nocontext|||pvn sv_catpvf_mg|5.006000|5.004000|pv sv_catpvf_nocontext|||vn sv_catpvf||5.004000|v sv_catpvn_flags||5.007002| sv_catpvn_mg|5.004050||p sv_catpvn_nomg|5.007002||p sv_catpvn||| sv_catpvs|5.009003||p sv_catpv||| sv_catsv_flags||5.007002| sv_catsv_mg|5.004050||p sv_catsv_nomg|5.007002||p sv_catsv||| sv_catxmlpvn||| sv_catxmlsv||| sv_chop||| sv_clean_all||| sv_clean_objs||| sv_clear||| sv_cmp_locale||5.004000| sv_cmp||| sv_collxfrm||| sv_compile_2op||5.008001| sv_copypv||5.007003| sv_dec||| sv_del_backref||| sv_derived_from||5.004000| sv_destroyable||5.010000| sv_does||5.009004| sv_dump||| sv_dup_inc_multiple||| sv_dup||| sv_eq||| sv_exp_grow||| sv_force_normal_flags||5.007001| sv_force_normal||5.006000| sv_free2||| sv_free_arenas||| sv_free||| sv_gets||5.004000| sv_grow||| sv_i_ncmp||| sv_inc||| sv_insert_flags||5.011000| sv_insert||| sv_isa||| sv_isobject||| sv_iv||5.005000| sv_kill_backrefs||| sv_len_utf8||5.006000| sv_len||| sv_magic_portable|5.011000|5.004000|p sv_magicext||5.007003| sv_magic||| sv_mortalcopy||| sv_ncmp||| sv_newmortal||| sv_newref||| sv_nolocking||5.007003| sv_nosharing||5.007003| sv_nounlocking||| sv_nv||5.005000| sv_peek||5.005000| sv_pos_b2u_midway||| sv_pos_b2u||5.006000| sv_pos_u2b_cached||| sv_pos_u2b_forwards|||n sv_pos_u2b_midway|||n sv_pos_u2b||5.006000| sv_pvbyten_force||5.006000| sv_pvbyten||5.006000| sv_pvbyte||5.006000| sv_pvn_force_flags|5.007002||p sv_pvn_force||| sv_pvn_nomg|5.007003|5.005000|p sv_pvn||5.005000| sv_pvutf8n_force||5.006000| sv_pvutf8n||5.006000| sv_pvutf8||5.006000| sv_pv||5.006000| sv_recode_to_utf8||5.007003| sv_reftype||| sv_release_COW||| sv_replace||| sv_report_used||| sv_reset||| sv_rvweaken||5.006000| sv_setiv_mg|5.004050||p sv_setiv||| sv_setnv_mg|5.006000||p sv_setnv||| sv_setpv_mg|5.004050||p sv_setpvf_mg_nocontext|||pvn sv_setpvf_mg|5.006000|5.004000|pv sv_setpvf_nocontext|||vn sv_setpvf||5.004000|v sv_setpviv_mg||5.008001| sv_setpviv||5.008001| sv_setpvn_mg|5.004050||p sv_setpvn||| sv_setpvs|5.009004||p sv_setpv||| sv_setref_iv||| sv_setref_nv||| sv_setref_pvn||| sv_setref_pv||| sv_setref_uv||5.007001| sv_setsv_cow||| sv_setsv_flags||5.007002| sv_setsv_mg|5.004050||p sv_setsv_nomg|5.007002||p sv_setsv||| sv_setuv_mg|5.004050||p sv_setuv|5.004000||p sv_tainted||5.004000| sv_taint||5.004000| sv_true||5.005000| sv_unglob||| sv_uni_display||5.007003| sv_unmagic||| sv_unref_flags||5.007001| sv_unref||| sv_untaint||5.004000| sv_upgrade||| sv_usepvn_flags||5.009004| sv_usepvn_mg|5.004050||p sv_usepvn||| sv_utf8_decode||5.006000| sv_utf8_downgrade||5.006000| sv_utf8_encode||5.006000| sv_utf8_upgrade_flags_grow||5.011000| sv_utf8_upgrade_flags||5.007002| sv_utf8_upgrade_nomg||5.007002| sv_utf8_upgrade||5.007001| sv_uv|5.005000||p sv_vcatpvf_mg|5.006000|5.004000|p sv_vcatpvfn||5.004000| sv_vcatpvf|5.006000|5.004000|p sv_vsetpvf_mg|5.006000|5.004000|p sv_vsetpvfn||5.004000| sv_vsetpvf|5.006000|5.004000|p sv_xmlpeek||| svtype||| swallow_bom||| swap_match_buff||| swash_fetch||5.007002| swash_get||| swash_init||5.006000| sys_init3||5.010000|n sys_init||5.010000|n sys_intern_clear||| sys_intern_dup||| sys_intern_init||| sys_term||5.010000|n taint_env||| taint_proper||| tmps_grow||5.006000| toLOWER||| toUPPER||| to_byte_substr||| to_uni_fold||5.007003| to_uni_lower_lc||5.006000| to_uni_lower||5.007003| to_uni_title_lc||5.006000| to_uni_title||5.007003| to_uni_upper_lc||5.006000| to_uni_upper||5.007003| to_utf8_case||5.007003| to_utf8_fold||5.007003| to_utf8_lower||5.007003| to_utf8_substr||| to_utf8_title||5.007003| to_utf8_upper||5.007003| token_free||| token_getmad||| tokenize_use||| tokeq||| tokereport||| too_few_arguments||| too_many_arguments||| uiv_2buf|||n unlnk||| unpack_rec||| unpack_str||5.007003| unpackstring||5.008001| unshare_hek_or_pvn||| unshare_hek||| unsharepvn||5.004000| unwind_handler_stack||| update_debugger_info||| upg_version||5.009005| usage||| utf16_to_utf8_reversed||5.006001| utf16_to_utf8||5.006001| utf8_distance||5.006000| utf8_hop||5.006000| utf8_length||5.007001| utf8_mg_pos_cache_update||| utf8_to_bytes||5.006001| utf8_to_uvchr||5.007001| utf8_to_uvuni||5.007001| utf8n_to_uvchr||| utf8n_to_uvuni||5.007001| utilize||| uvchr_to_utf8_flags||5.007003| uvchr_to_utf8||| uvuni_to_utf8_flags||5.007003| uvuni_to_utf8||5.007001| validate_suid||| varname||| vcmp||5.009000| vcroak||5.006000| vdeb||5.007003| vdie_common||| vdie_croak_common||| vdie||| vform||5.006000| visit||| vivify_defelem||| vivify_ref||| vload_module|5.006000||p vmess||5.006000| vnewSVpvf|5.006000|5.004000|p vnormal||5.009002| vnumify||5.009000| vstringify||5.009000| vverify||5.009003| vwarner||5.006000| vwarn||5.006000| wait4pid||| warn_nocontext|||vn warner_nocontext|||vn warner|5.006000|5.004000|pv warn|||v watch||| whichsig||| write_no_mem||| write_to_stderr||| xmldump_all||| xmldump_attr||| xmldump_eval||| xmldump_form||| xmldump_indent|||v xmldump_packsubs||| xmldump_sub||| xmldump_vindent||| yyerror||| yylex||| yyparse||| yywarn||| );  if (exists $opt{'list-unsupported'}) {   my $f;   for $f (sort { lc $a cmp lc $b } keys %API) {     next unless $API{$f}{todo};     print "$f ", '.'x(40-length($f)), " ", format_version($API{$f}{todo}), "\n";   }   exit 0; }  # Scan for possible replacement candidates  my(%replace, %need, %hints, %warnings, %depends); my $replace = 0; my($hint, $define, $function);  sub find_api {   my $code = shift;   $code =~ s{     / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)   | "[^"\\]*(?:\\.[^"\\]*)*"   | '[^'\\]*(?:\\.[^'\\]*)*' }{}egsx;   grep { exists $API{$_} } $code =~ /(\w+)/mg; }  while (<DATA>) {   if ($hint) {     my $h = $hint->[0] eq 'Hint' ? \%hints : \%warnings;     if (m{^\s*\*\s(.*?)\s*$}) {       for (@{$hint->[1]}) {         $h->{$_} ||= '';  # suppress warning with older perls         $h->{$_} .= "$1\n";       }     }     else { undef $hint }   }    $hint = [$1, [split /,?\s+/, $2]]       if m{^\s*$rccs\s+(Hint|Warning):\s+(\w+(?:,?\s+\w+)*)\s*$};    if ($define) {     if ($define->[1] =~ /\\$/) {       $define->[1] .= $_;     }     else {       if (exists $API{$define->[0]}&& $define->[1] !~ /^DPPP_\(/) {         my @n = find_api($define->[1]);         push @{$depends{$define->[0]}}, @n if @n       }       undef $define;     }   }    $define = [$1, $2] if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(.*)};    if ($function) {     if (/^}/) {       if (exists $API{$function->[0]}) {         my @n = find_api($function->[1]);         push @{$depends{$function->[0]}}, @n if @n       }       undef $function;     }     else {       $function->[1] .= $_;     }   }    $function = [$1, ''] if m{^DPPP_\(my_(\w+)\)};    $replace     = $1 if m{^\s*$rccs\s+Replace:\s+(\d+)\s+$rcce\s*$};   $replace{$2} = $1 if $replace and m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+)};   $replace{$2} = $1 if m{^\s*#\s*define\s+(\w+)(?:\([^)]*\))?\s+(\w+).*$rccs\s+Replace\s+$rcce};   $replace{$1} = $2 if m{^\s*$rccs\s+Replace (\w+) with (\w+)\s+$rcce\s*$};    if (m{^\s*$rccs\s+(\w+(\s*,\s*\w+)*)\s+depends\s+on\s+(\w+(\s*,\s*\w+)*)\s+$rcce\s*$}) {     my @deps = map { s/\s+//g; $_ } split /,/, $3;     my $d;     for $d (map { s/\s+//g; $_ } split /,/, $1) {       push @{$depends{$d}}, @deps;     }   }    $need{$1} = 1 if m{^#if\s+defined\(NEED_(\w+)(?:_GLOBAL)?\)}; }  for (values %depends) {   my %s;   $_ = [sort grep !$s{$_}++, @$_]; }  if (exists $opt{'api-info'}) {   my $f;   my $count = 0;   my $match = $opt{'api-info'} =~ m!^/(.*)/$! ? $1 : "^\Q$opt{'api-info'}\E\$";   for $f (sort { lc $a cmp lc $b } keys %API) {     next unless $f =~ /$match/;     print "\n=== $f ===\n\n";     my $info = 0;     if ($API{$f}{base} || $API{$f}{todo}) {       my $base = format_version($API{$f}{base} || $API{$f}{todo});       print "Supported at least starting from perl-$base.\n";       $info++;     }     if ($API{$f}{provided}) {       my $todo = $API{$f}{todo} ? format_version($API{$f}{todo}) : "5.003";       print "Support by $ppport provided back to perl-$todo.\n";       print "Support needs to be explicitly requested by NEED_$f.\n" if exists $need{$f};       print "Depends on: ", join(', ', @{$depends{$f}}), ".\n" if exists $depends{$f};       print "\n$hints{$f}" if exists $hints{$f};       print "\nWARNING:\n$warnings{$f}" if exists $warnings{$f};       $info++;     }     print "No portability information available.\n" unless $info;     $count++;   }   $count or print "Found no API matching '$opt{'api-info'}'.";   print "\n";   exit 0; }  if (exists $opt{'list-provided'}) {   my $f;   for $f (sort { lc $a cmp lc $b } keys %API) {     next unless $API{$f}{provided};     my @flags;     push @flags, 'explicit' if exists $need{$f};     push @flags, 'depend'   if exists $depends{$f};     push @flags, 'hint'     if exists $hints{$f};     push @flags, 'warning'  if exists $warnings{$f};     my $flags = @flags ? '  ['.join(', ', @flags).']' : '';     print "$f$flags\n";   }   exit 0; }  my @files; my @srcext = qw( .xs .c .h .cc .cpp -c.inc -xs.inc ); my $srcext = join '|', map { quotemeta $_ } @srcext;  if (@ARGV) {   my %seen;   for (@ARGV) {     if (-e) {       if (-f) {         push @files, $_ unless $seen{$_}++;       }       else { warn "'$_' is not a file.\n" }     }     else {       my @new = grep { -f } glob $_           or warn "'$_' does not exist.\n";       push @files, grep { !$seen{$_}++ } @new;     }   } } else {   eval {     require File::Find;     File::Find::find(sub {       $File::Find::name =~ /($srcext)$/i           and push @files, $File::Find::name;     }, '.');   };   if ($@) {     @files = map { glob "*$_" } @srcext;   } }  if (!@ARGV || $opt{filter}) {   my(@in, @out);   my %xsc = map { /(.*)\.xs$/ ? ("$1.c" => 1, "$1.cc" => 1) : () } @files;   for (@files) {     my $out = exists $xsc{$_} || /\b\Q$ppport\E$/i || !/($srcext)$/i;     push @{ $out ? \@out : \@in }, $_;   }   if (@ARGV&& @out) {     warning("Skipping the following files (use --nofilter to avoid this):\n| ", join "\n| ", @out);   }   @files = @in; }  die "No input files given!\n" unless @files;  my(%files, %global, %revreplace); %revreplace = reverse %replace; my $filename; my $patch_opened = 0;  for $filename (@files) {   unless (open IN, "<$filename") {     warn "Unable to read from $filename: $!\n";     next;   }    info("Scanning $filename ...");    my $c = do { local $/;<IN> };   close IN;    my %file = (orig => $c, changes => 0);    # Temporarily remove C/XS comments and strings from the code   my @ccom;    $c =~ s{     ( ^$HS*\#$HS*include\b[^\r\n]+\b(?:\Q$ppport\E|XSUB\.h)\b[^\r\n]*     | ^$HS*\#$HS*(?:define|elif|if(?:def)?)\b[^\r\n]* )   | ( ^$HS*\#[^\r\n]*     | "[^"\\]*(?:\\.[^"\\]*)*"     | '[^'\\]*(?:\\.[^'\\]*)*'     | / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]* ) )   }{ defined $2 and push @ccom, $2;      defined $1 ? $1 : "$ccs$#ccom$cce" }mgsex;    $file{ccom} = \@ccom;   $file{code} = $c;   $file{has_inc_ppport} = $c =~ /^$HS*#$HS*include[^\r\n]+\b\Q$ppport\E\b/m;    my $func;    for $func (keys %API) {     my $match = $func;     $match .= "|$revreplace{$func}" if exists $revreplace{$func};     if ($c =~ /\b(?:Perl_)?($match)\b/) {       $file{uses_replace}{$1}++ if exists $revreplace{$func}&& $1 eq $revreplace{$func};       $file{uses_Perl}{$func}++ if $c =~ /\bPerl_$func\b/;       if (exists $API{$func}{provided}) {         $file{uses_provided}{$func}++;         if (!exists $API{$func}{base} || $API{$func}{base}> $opt{'compat-version'}) {           $file{uses}{$func}++;           my @deps = rec_depend($func);           if (@deps) {             $file{uses_deps}{$func} = \@deps;             for (@deps) {               $file{uses}{$_} = 0 unless exists $file{uses}{$_};             }           }           for ($func, @deps) {             $file{needs}{$_} = 'static' if exists $need{$_};           }         }       }       if (exists $API{$func}{todo}&& $API{$func}{todo}> $opt{'compat-version'}) {         if ($c =~ /\b$func\b/) {           $file{uses_todo}{$func}++;         }       }     }   }    while ($c =~ /^$HS*#$HS*define$HS+(NEED_(\w+?)(_GLOBAL)?)\b/mg) {     if (exists $need{$2}) {       $file{defined $3 ? 'needed_global' : 'needed_static'}{$2}++;     }     else { warning("Possibly wrong #define $1 in $filename") }   }    for (qw(uses needs uses_todo needed_global needed_static)) {     for $func (keys %{$file{$_}}) {       push @{$global{$_}{$func}}, $filename;     }   }    $files{$filename} = \%file; }  # Globally resolve NEED_'s my $need; for $need (keys %{$global{needs}}) {   if (@{$global{needs}{$need}}> 1) {     my @targets = @{$global{needs}{$need}};     my @t = grep $files{$_}{needed_global}{$need}, @targets;     @targets = @t if @t;     @t = grep /\.xs$/i, @targets;     @targets = @t if @t;     my $target = shift @targets;     $files{$target}{needs}{$need} = 'global';     for (@{$global{needs}{$need}}) {       $files{$_}{needs}{$need} = 'extern' if $_ ne $target;     }   } }  for $filename (@files) {   exists $files{$filename} or next;    info("=== Analyzing $filename ===");    my %file = %{$files{$filename}};   my $func;   my $c = $file{code};   my $warnings = 0;    for $func (sort keys %{$file{uses_Perl}}) {     if ($API{$func}{varargs}) {       unless ($API{$func}{nothxarg}) {         my $changes = ($c =~ s{\b(Perl_$func\s*\(\s*)(?!aTHX_?)(\)|[^\s)]*\))}                               { $1 . ($2 eq ')' ? 'aTHX' : 'aTHX_ ') . $2 }ge);         if ($changes) {           warning("Doesn't pass interpreter argument aTHX to Perl_$func");           $file{changes} += $changes;         }       }     }     else {       warning("Uses Perl_$func instead of $func");       $file{changes} += ($c =~ s{\bPerl_$func(\s*)\((\s*aTHX_?)?\s*}                                 {$func$1(}g);     }   }    for $func (sort keys %{$file{uses_replace}}) {     warning("Uses $func instead of $replace{$func}");     $file{changes} += ($c =~ s/\b$func\b/$replace{$func}/g);   }    for $func (sort keys %{$file{uses_provided}}) {     if ($file{uses}{$func}) {       if (exists $file{uses_deps}{$func}) {         diag("Uses $func, which depends on ", join(', ', @{$file{uses_deps}{$func}}));       }       else {         diag("Uses $func");       }     }     $warnings += hint($func);   }    unless ($opt{quiet}) {     for $func (sort keys %{$file{uses_todo}}) {       print "*** WARNING: Uses $func, which may not be portable below perl ",             format_version($API{$func}{todo}), ", even with '$ppport'\n";       $warnings++;     }   }    for $func (sort keys %{$file{needed_static}}) {     my $message = '';     if (not exists $file{uses}{$func}) {       $message = "No need to define NEED_$func if $func is never used";     }     elsif (exists $file{needs}{$func}&& $file{needs}{$func} ne 'static') {       $message = "No need to define NEED_$func when already needed globally";     }     if ($message) {       diag($message);       $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_$func\b.*$LF//mg);     }   }    for $func (sort keys %{$file{needed_global}}) {     my $message = '';     if (not exists $global{uses}{$func}) {       $message = "No need to define NEED_${func}_GLOBAL if $func is never used";     }     elsif (exists $file{needs}{$func}) {       if ($file{needs}{$func} eq 'extern') {         $message = "No need to define NEED_${func}_GLOBAL when already needed globally";       }       elsif ($file{needs}{$func} eq 'static') {         $message = "No need to define NEED_${func}_GLOBAL when only used in this file";       }     }     if ($message) {       diag($message);       $file{changes} += ($c =~ s/^$HS*#$HS*define$HS+NEED_${func}_GLOBAL\b.*$LF//mg);     }   }    $file{needs_inc_ppport} = keys %{$file{uses}};    if ($file{needs_inc_ppport}) {     my $pp = '';      for $func (sort keys %{$file{needs}}) {       my $type = $file{needs}{$func};       next if $type eq 'extern';       my $suffix = $type eq 'global' ? '_GLOBAL' : '';       unless (exists $file{"needed_$type"}{$func}) {         if ($type eq 'global') {           diag("Files [@{$global{needs}{$func}}] need $func, adding global request");         }         else {           diag("File needs $func, adding static request");         }         $pp .= "#define NEED_$func$suffix\n";       }     }      if ($pp&& ($c =~ s/^(?=$HS*#$HS*define$HS+NEED_\w+)/$pp/m)) {       $pp = '';       $file{changes}++;     }      unless ($file{has_inc_ppport}) {       diag("Needs to include '$ppport'");       $pp .= qq(#include "$ppport"\n)     }      if ($pp) {       $file{changes} += ($c =~ s/^($HS*#$HS*define$HS+NEED_\w+.*?)^/$1$pp/ms)                      || ($c =~ s/^(?=$HS*#$HS*include.*\Q$ppport\E)/$pp/m)                      || ($c =~ s/^($HS*#$HS*include.*XSUB.*\s*?)^/$1$pp/m)                      || ($c =~ s/^/$pp/);     }   }   else {     if ($file{has_inc_ppport}) {       diag("No need to include '$ppport'");       $file{changes} += ($c =~ s/^$HS*?#$HS*include.*\Q$ppport\E.*?$LF//m);     }   }    # put back in our C comments   my $ix;   my $cppc = 0;   my @ccom = @{$file{ccom}};   for $ix (0 .. $#ccom) {     if (!$opt{cplusplus}&& $ccom[$ix] =~ s!^//!!) {       $cppc++;       $file{changes} += $c =~ s/$rccs$ix$rcce/$ccs$ccom[$ix] $cce/;     }     else {       $c =~ s/$rccs$ix$rcce/$ccom[$ix]/;     }   }    if ($cppc) {     my $s = $cppc != 1 ? 's' : '';     warning("Uses $cppc C++ style comment$s, which is not portable");   }    my $s = $warnings != 1 ? 's' : '';   my $warn = $warnings ? " ($warnings warning$s)" : '';   info("Analysis completed$warn");    if ($file{changes}) {     if (exists $opt{copy}) {       my $newfile = "$filename$opt{copy}";       if (-e $newfile) {         error("'$newfile' already exists, refusing to write copy of '$filename'");       }       else {         local *F;         if (open F, ">$newfile") {           info("Writing copy of '$filename' with changes to '$newfile'");           print F $c;           close F;         }         else {           error("Cannot open '$newfile' for writing: $!");         }       }     }     elsif (exists $opt{patch} || $opt{changes}) {       if (exists $opt{patch}) {         unless ($patch_opened) {           if (open PATCH, ">$opt{patch}") {             $patch_opened = 1;           }           else {             error("Cannot open '$opt{patch}' for writing: $!");             delete $opt{patch};             $opt{changes} = 1;             goto fallback;           }         }         mydiff(\*PATCH, $filename, $c);       }       else { fallback:         info("Suggested changes:");         mydiff(\*STDOUT, $filename, $c);       }     }     else {       my $s = $file{changes} == 1 ? '' : 's';       info("$file{changes} potentially required change$s detected");     }   }   else {     info("Looks good");   } }  close PATCH if $patch_opened;  exit 0;   sub try_use { eval "use @_;"; return $@ eq '' }  sub mydiff {   local *F = shift;   my($file, $str) = @_;   my $diff;    if (exists $opt{diff}) {     $diff = run_diff($opt{diff}, $file, $str);   }    if (!defined $diff and try_use('Text::Diff')) {     $diff = Text::Diff::diff($file, \$str, { STYLE => 'Unified' });     $diff =<<HEADER . $diff; --- $file +++ $file.patched HEADER   }    if (!defined $diff) {     $diff = run_diff('diff -u', $file, $str);   }    if (!defined $diff) {     $diff = run_diff('diff', $file, $str);   }    if (!defined $diff) {     error("Cannot generate a diff. Please install Text::Diff or use --copy.");     return;   }    print F $diff; }  sub run_diff {   my($prog, $file, $str) = @_;   my $tmp = 'dppptemp';   my $suf = 'aaa';   my $diff = '';   local *F;    while (-e "$tmp.$suf") { $suf++ }   $tmp = "$tmp.$suf";    if (open F, ">$tmp") {     print F $str;     close F;      if (open F, "$prog $file $tmp |") {       while (<F>) {         s/\Q$tmp\E/$file.patched/;         $diff .= $_;       }       close F;       unlink $tmp;       return $diff;     }      unlink $tmp;   }   else {     error("Cannot open '$tmp' for writing: $!");   }    return undef; }  sub rec_depend {   my($func, $seen) = @_;   return () unless exists $depends{$func};   $seen = {%{$seen||{}}};   return () if $seen->{$func}++;   my %s;   grep !$s{$_}++, map { ($_, rec_depend($_, $seen)) } @{$depends{$func}}; }  sub parse_version {   my $ver = shift;    if ($ver =~ /^(\d+)\.(\d+)\.(\d+)$/) {     return ($1, $2, $3);   }   elsif ($ver !~ /^\d+\.[\d_]+$/) {     die "cannot parse version '$ver'\n";   }    $ver =~ s/_//g;   $ver =~ s/$/000000/;    my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;    $v = int $v;   $s = int $s;    if ($r< 5 || ($r == 5&& $v< 6)) {     if ($s % 10) {       die "cannot parse version '$ver'\n";     }   }    return ($r, $v, $s); }  sub format_version {   my $ver = shift;    $ver =~ s/$/000000/;   my($r,$v,$s) = $ver =~ /(\d+)\.(\d{3})(\d{3})/;    $v = int $v;   $s = int $s;    if ($r< 5 || ($r == 5&& $v< 6)) {     if ($s % 10) {       die "invalid version '$ver'\n";     }     $s /= 10;      $ver = sprintf "%d.%03d", $r, $v;     $s> 0 and $ver .= sprintf "_%02d", $s;      return $ver;   }    return sprintf "%d.%d.%d", $r, $v, $s; }  sub info {   $opt{quiet} and return;   print @_, "\n"; }  sub diag {   $opt{quiet} and return;   $opt{diag} and print @_, "\n"; }  sub warning {   $opt{quiet} and return;   print "*** ", @_, "\n"; }  sub error {   print "*** ERROR: ", @_, "\n"; }  my %given_hints; my %given_warnings; sub hint {   $opt{quiet} and return;   my $func = shift;   my $rv = 0;   if (exists $warnings{$func}&& !$given_warnings{$func}++) {     my $warn = $warnings{$func};     $warn =~ s!^!*** !mg;     print "*** WARNING: $func\n", $warn;     $rv++;   }   if ($opt{hints}&& exists $hints{$func}&& !$given_hints{$func}++) {     my $hint = $hints{$func};     $hint =~ s/^/   /mg;     print "   --- hint for $func ---\n", $hint;   }   $rv; }  sub usage {   my($usage) = do { local(@ARGV,$/)=($0);<> } =~ /^=head\d$HS+SYNOPSIS\s*^(.*?)\s*^=/ms;   my %M = ( 'I' => '*' );   $usage =~ s/^\s*perl\s+\S+/$^X $0/;   $usage =~ s/([A-Z])<([^>]+)>/$M{$1}$2$M{$1}/g;    print<<ENDUSAGE;  Usage: $usage  See perldoc $0 for details.  ENDUSAGE    exit 2; }  sub strip {   my $self = do { local(@ARGV,$/)=($0);<> };   my($copy) = $self =~ /^=head\d\s+COPYRIGHT\s*^(.*?)^=\w+/ms;   $copy =~ s/^(?=\S+)/    /gms;   $self =~ s/^$HS+Do NOT edit.*?(?=^-)/$copy/ms;   $self =~ s/^SKIP.*(?=^__DATA__)/SKIP if (\@ARGV&& \$ARGV[0] eq '--unstrip') {   eval { require Devel::PPPort };   \$@ and die "Cannot require Devel::PPPort, please install.\\n";   if (eval \$Devel::PPPort::VERSION< $VERSION) {     die "$0 was originally generated with Devel::PPPort $VERSION.\\n"       . "Your Devel::PPPort is only version \$Devel::PPPort::VERSION.\\n"       . "Please install a newer version, or --unstrip will not work.\\n";   }   Devel::PPPort::WriteFile(\$0);   exit 0; } print<<END;  Sorry, but this is a stripped version of \$0.  To be able to use its original script and doc functionality, please try to regenerate this file using:    \$^X \$0 --unstrip  END /ms;   my($pl, $c) = $self =~ /(.*^__DATA__)(.*)/ms;   $c =~ s{     / (?: \*[^*]*\*+(?:[^$ccs][^*]*\*+)* / | /[^\r\n]*)   | ( "[^"\\]*(?:\\.[^"\\]*)*"     | '[^'\\]*(?:\\.[^'\\]*)*' )   | ($HS+) }{ defined $2 ? ' ' : ($1 || '') }gsex;   $c =~ s!\s+$!!mg;   $c =~ s!^$LF!!mg;   $c =~ s!^\s*#\s*!#!mg;   $c =~ s!^\s+!!mg;    open OUT, ">$0" or die "cannot strip $0: $!\n";   print OUT "$pl$c\n";    exit 0; }  __DATA__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_P_P_PORTABILITY_H_
end_ifndef

begin_define
define|#
directive|define
name|_P_P_PORTABILITY_H_
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DPPP_NAMESPACE
end_ifndef

begin_define
define|#
directive|define
name|DPPP_NAMESPACE
value|DPPP_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DPPP_CAT2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CAT2(x,y)
end_define

begin_define
define|#
directive|define
name|DPPP_
parameter_list|(
name|name
parameter_list|)
value|DPPP_CAT2(DPPP_NAMESPACE, name)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_REVISION
end_ifndef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__PATCHLEVEL_H_INCLUDED__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|PATCHLEVEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SUBVERSION
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|PERL_PATCHLEVEL_H_IMPLICIT
end_define

begin_include
include|#
directive|include
file|<patchlevel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|PERL_VERSION
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SUBVERSION
argument_list|)
operator|&&
name|defined
argument_list|(
name|PATCHLEVEL
argument_list|)
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<could_not_find_Perl_patchlevel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_REVISION
end_ifndef

begin_define
define|#
directive|define
name|PERL_REVISION
value|(5)
end_define

begin_comment
comment|/* Replace: 1 */
end_comment

begin_define
define|#
directive|define
name|PERL_VERSION
value|PATCHLEVEL
end_define

begin_define
define|#
directive|define
name|PERL_SUBVERSION
value|SUBVERSION
end_define

begin_comment
comment|/* Replace PERL_PATCHLEVEL with PERL_VERSION */
end_comment

begin_comment
comment|/* Replace: 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_dpppDEC2BCD
parameter_list|(
name|dec
parameter_list|)
value|((((dec)/100)<<8)|((((dec)%100)/10)<<4)|((dec)%10))
end_define

begin_define
define|#
directive|define
name|PERL_BCDVERSION
value|((_dpppDEC2BCD(PERL_REVISION)<<24)|(_dpppDEC2BCD(PERL_VERSION)<<12)|_dpppDEC2BCD(PERL_SUBVERSION))
end_define

begin_comment
comment|/* It is very unlikely that anyone will try to use this with Perl 6    (or greater), but who knows.  */
end_comment

begin_if
if|#
directive|if
name|PERL_REVISION
operator|!=
literal|5
end_if

begin_error
error|#
directive|error
error|ppport.h only works with Perl version 5
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PERL_REVISION != 5 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|dTHR
end_ifndef

begin_define
define|#
directive|define
name|dTHR
value|dNOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dTHX
end_ifndef

begin_define
define|#
directive|define
name|dTHX
value|dNOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dTHXa
end_ifndef

begin_define
define|#
directive|define
name|dTHXa
parameter_list|(
name|x
parameter_list|)
value|dNOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pTHX
end_ifndef

begin_define
define|#
directive|define
name|pTHX
value|void
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pTHX_
end_ifndef

begin_define
define|#
directive|define
name|pTHX_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|aTHX
end_ifndef

begin_define
define|#
directive|define
name|aTHX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|aTHX_
end_ifndef

begin_define
define|#
directive|define
name|aTHX_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5006000
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|USE_THREADS
end_ifdef

begin_define
define|#
directive|define
name|aTHXR
value|thr
end_define

begin_define
define|#
directive|define
name|aTHXR_
value|thr,
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|aTHXR
end_define

begin_define
define|#
directive|define
name|aTHXR_
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|dTHXR
value|dTHR
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|aTHXR
value|aTHX
end_define

begin_define
define|#
directive|define
name|aTHXR_
value|aTHX_
end_define

begin_define
define|#
directive|define
name|dTHXR
value|dTHX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dTHXoa
end_ifndef

begin_define
define|#
directive|define
name|dTHXoa
parameter_list|(
name|x
parameter_list|)
value|dTHXa(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_LIMITS
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UCHAR_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_UCHAR_MIN
value|((unsigned char)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UCHAR_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|UCHAR_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_UCHAR_MAX
value|((unsigned char)UCHAR_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXUCHAR
end_ifdef

begin_define
define|#
directive|define
name|PERL_UCHAR_MAX
value|((unsigned char)MAXUCHAR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UCHAR_MAX
value|((unsigned char)~(unsigned)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_USHORT_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_USHORT_MIN
value|((unsigned short)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_USHORT_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USHORT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_USHORT_MAX
value|((unsigned short)USHORT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXUSHORT
end_ifdef

begin_define
define|#
directive|define
name|PERL_USHORT_MAX
value|((unsigned short)MAXUSHORT)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USHRT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_USHORT_MAX
value|((unsigned short)USHRT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_USHORT_MAX
value|((unsigned short)~(unsigned)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SHORT_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_SHORT_MAX
value|((short)SHORT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXSHORT
end_ifdef

begin_comment
comment|/* Often used in<values.h> */
end_comment

begin_define
define|#
directive|define
name|PERL_SHORT_MAX
value|((short)MAXSHORT)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SHRT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_SHORT_MAX
value|((short)SHRT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_SHORT_MAX
value|((short) (PERL_USHORT_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SHORT_MIN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_MIN
end_ifdef

begin_define
define|#
directive|define
name|PERL_SHORT_MIN
value|((short)SHORT_MIN)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MINSHORT
end_ifdef

begin_define
define|#
directive|define
name|PERL_SHORT_MIN
value|((short)MINSHORT)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SHRT_MIN
end_ifdef

begin_define
define|#
directive|define
name|PERL_SHORT_MIN
value|((short)SHRT_MIN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_SHORT_MIN
value|(-PERL_SHORT_MAX - ((3& -1) == 3))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UINT_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|UINT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_UINT_MAX
value|((unsigned int)UINT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXUINT
end_ifdef

begin_define
define|#
directive|define
name|PERL_UINT_MAX
value|((unsigned int)MAXUINT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UINT_MAX
value|(~(unsigned int)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UINT_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_UINT_MIN
value|((unsigned int)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_INT_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_INT_MAX
value|((int)INT_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXINT
end_ifdef

begin_comment
comment|/* Often used in<values.h> */
end_comment

begin_define
define|#
directive|define
name|PERL_INT_MAX
value|((int)MAXINT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_INT_MAX
value|((int)(PERL_UINT_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_INT_MIN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_MIN
end_ifdef

begin_define
define|#
directive|define
name|PERL_INT_MIN
value|((int)INT_MIN)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MININT
end_ifdef

begin_define
define|#
directive|define
name|PERL_INT_MIN
value|((int)MININT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_INT_MIN
value|(-PERL_INT_MAX - ((3& -1) == 3))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_ULONG_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ULONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_ULONG_MAX
value|((unsigned long)ULONG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXULONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_ULONG_MAX
value|((unsigned long)MAXULONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_ULONG_MAX
value|(~(unsigned long)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_ULONG_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_ULONG_MIN
value|((unsigned long)0L)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_LONG_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_LONG_MAX
value|((long)LONG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXLONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_LONG_MAX
value|((long)MAXLONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_LONG_MAX
value|((long) (PERL_ULONG_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_LONG_MIN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LONG_MIN
end_ifdef

begin_define
define|#
directive|define
name|PERL_LONG_MIN
value|((long)LONG_MIN)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MINLONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_LONG_MIN
value|((long)MINLONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_LONG_MIN
value|(-PERL_LONG_MAX - ((3& -1) == 3))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_QUAD
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|convex
argument_list|)
operator|||
name|defined
argument_list|(
name|uts
argument_list|)
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UQUAD_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|ULONGLONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_UQUAD_MAX
value|((unsigned long long)ULONGLONG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXULONGLONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_UQUAD_MAX
value|((unsigned long long)MAXULONGLONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UQUAD_MAX
value|(~(unsigned long long)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UQUAD_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_UQUAD_MIN
value|((unsigned long long)0L)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_QUAD_MAX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LONGLONG_MAX
end_ifdef

begin_define
define|#
directive|define
name|PERL_QUAD_MAX
value|((long long)LONGLONG_MAX)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MAXLONGLONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_QUAD_MAX
value|((long long)MAXLONGLONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_QUAD_MAX
value|((long long) (PERL_UQUAD_MAX>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_QUAD_MIN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LONGLONG_MIN
end_ifdef

begin_define
define|#
directive|define
name|PERL_QUAD_MIN
value|((long long)LONGLONG_MIN)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MINLONGLONG
end_ifdef

begin_define
define|#
directive|define
name|PERL_QUAD_MIN
value|((long long)MINLONGLONG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_QUAD_MIN
value|(-PERL_QUAD_MAX - ((3& -1) == 3))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is based on code from 5.003 perl.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_QUAD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|cray
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IVTYPE
end_ifndef

begin_define
define|#
directive|define
name|IVTYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MIN
end_ifndef

begin_define
define|#
directive|define
name|IV_MIN
value|PERL_INT_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MAX
end_ifndef

begin_define
define|#
directive|define
name|IV_MAX
value|PERL_INT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MIN
end_ifndef

begin_define
define|#
directive|define
name|UV_MIN
value|PERL_UINT_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|UV_MAX
value|PERL_UINT_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INTSIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IVSIZE
end_ifndef

begin_define
define|#
directive|define
name|IVSIZE
value|INTSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|convex
argument_list|)
operator|||
name|defined
argument_list|(
name|uts
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|IVTYPE
end_ifndef

begin_define
define|#
directive|define
name|IVTYPE
value|long long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MIN
end_ifndef

begin_define
define|#
directive|define
name|IV_MIN
value|PERL_QUAD_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MAX
end_ifndef

begin_define
define|#
directive|define
name|IV_MAX
value|PERL_QUAD_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MIN
end_ifndef

begin_define
define|#
directive|define
name|UV_MIN
value|PERL_UQUAD_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|UV_MAX
value|PERL_UQUAD_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LONGLONGSIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IVSIZE
end_ifndef

begin_define
define|#
directive|define
name|IVSIZE
value|LONGLONGSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|IVTYPE
end_ifndef

begin_define
define|#
directive|define
name|IVTYPE
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MIN
end_ifndef

begin_define
define|#
directive|define
name|IV_MIN
value|PERL_LONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MAX
end_ifndef

begin_define
define|#
directive|define
name|IV_MAX
value|PERL_LONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MIN
end_ifndef

begin_define
define|#
directive|define
name|UV_MIN
value|PERL_ULONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|UV_MAX
value|PERL_ULONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LONGSIZE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IVSIZE
end_ifndef

begin_define
define|#
directive|define
name|IVSIZE
value|LONGSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IVSIZE
end_ifndef

begin_define
define|#
directive|define
name|IVSIZE
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_QUAD_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_QUAD_MIN
value|IV_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_QUAD_MAX
end_ifndef

begin_define
define|#
directive|define
name|PERL_QUAD_MAX
value|IV_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UQUAD_MIN
end_ifndef

begin_define
define|#
directive|define
name|PERL_UQUAD_MIN
value|UV_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UQUAD_MAX
end_ifndef

begin_define
define|#
directive|define
name|PERL_UQUAD_MAX
value|UV_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|IVTYPE
end_ifndef

begin_define
define|#
directive|define
name|IVTYPE
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MIN
end_ifndef

begin_define
define|#
directive|define
name|IV_MIN
value|PERL_LONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IV_MAX
end_ifndef

begin_define
define|#
directive|define
name|IV_MAX
value|PERL_LONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MIN
end_ifndef

begin_define
define|#
directive|define
name|UV_MIN
value|PERL_ULONG_MIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|UV_MAX
value|PERL_ULONG_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IVSIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LONGSIZE
end_ifdef

begin_define
define|#
directive|define
name|IVSIZE
value|LONGSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IVSIZE
value|4
end_define

begin_comment
comment|/* A bold guess, but the best we can make. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UVTYPE
end_ifndef

begin_define
define|#
directive|define
name|UVTYPE
value|unsigned IVTYPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UVSIZE
end_ifndef

begin_define
define|#
directive|define
name|UVSIZE
value|IVSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setuv
end_ifndef

begin_define
define|#
directive|define
name|sv_setuv
parameter_list|(
name|sv
parameter_list|,
name|uv
parameter_list|)
define|\
value|STMT_START {                         \                  UV TeMpUv = uv;                    \                  if (TeMpUv<= IV_MAX)              \                    sv_setiv(sv, TeMpUv);            \                  else                               \                    sv_setnv(sv, (double)TeMpUv);    \                } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVuv
end_ifndef

begin_define
define|#
directive|define
name|newSVuv
parameter_list|(
name|uv
parameter_list|)
value|((uv)<= IV_MAX ? newSViv((IV)uv) : newSVnv((NV)uv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_2uv
end_ifndef

begin_define
define|#
directive|define
name|sv_2uv
parameter_list|(
name|sv
parameter_list|)
value|((PL_Sv = (sv)), (UV) (SvNOK(PL_Sv) ? SvNV(PL_Sv) : sv_2nv(PL_Sv)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvUVX
end_ifndef

begin_define
define|#
directive|define
name|SvUVX
parameter_list|(
name|sv
parameter_list|)
value|((UV)SvIVX(sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvUVXx
end_ifndef

begin_define
define|#
directive|define
name|SvUVXx
parameter_list|(
name|sv
parameter_list|)
value|SvUVX(sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvUV
end_ifndef

begin_define
define|#
directive|define
name|SvUV
parameter_list|(
name|sv
parameter_list|)
value|(SvIOK(sv) ? SvUVX(sv) : sv_2uv(sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvUVx
end_ifndef

begin_define
define|#
directive|define
name|SvUVx
parameter_list|(
name|sv
parameter_list|)
value|((PL_Sv = (sv)), SvUV(PL_Sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: sv_uv  * Always use the SvUVx() macro instead of sv_uv().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sv_uv
end_ifndef

begin_define
define|#
directive|define
name|sv_uv
parameter_list|(
name|sv
parameter_list|)
value|SvUVx(sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SvUOK
argument_list|)
operator|&&
name|defined
argument_list|(
name|SvIOK_UV
argument_list|)
end_if

begin_define
define|#
directive|define
name|SvUOK
parameter_list|(
name|sv
parameter_list|)
value|SvIOK_UV(sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XST_mUV
end_ifndef

begin_define
define|#
directive|define
name|XST_mUV
parameter_list|(
name|i
parameter_list|,
name|v
parameter_list|)
value|(ST(i) = sv_2mortal(newSVuv(v))  )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XSRETURN_UV
end_ifndef

begin_define
define|#
directive|define
name|XSRETURN_UV
parameter_list|(
name|v
parameter_list|)
value|STMT_START { XST_mUV(0,v);  XSRETURN(1); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUSHu
end_ifndef

begin_define
define|#
directive|define
name|PUSHu
parameter_list|(
name|u
parameter_list|)
value|STMT_START { sv_setuv(TARG, (UV)(u)); PUSHTARG;  } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XPUSHu
end_ifndef

begin_define
define|#
directive|define
name|XPUSHu
parameter_list|(
name|u
parameter_list|)
value|STMT_START { sv_setuv(TARG, (UV)(u)); XPUSHTARG; } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MEMCMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|memNE
end_ifndef

begin_define
define|#
directive|define
name|memNE
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|l
parameter_list|)
value|(memcmp(s1,s2,l))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|memEQ
end_ifndef

begin_define
define|#
directive|define
name|memEQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|l
parameter_list|)
value|(!memcmp(s1,s2,l))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|memNE
end_ifndef

begin_define
define|#
directive|define
name|memNE
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|l
parameter_list|)
value|(bcmp(s1,s2,l))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|memEQ
end_ifndef

begin_define
define|#
directive|define
name|memEQ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|l
parameter_list|)
value|(!bcmp(s1,s2,l))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MoveD
end_ifndef

begin_define
define|#
directive|define
name|MoveD
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|memmove((char*)(d),(char*)(s), (n) * sizeof(t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopyD
end_ifndef

begin_define
define|#
directive|define
name|CopyD
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|memcpy((char*)(d),(char*)(s), (n) * sizeof(t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MEMSET
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ZeroD
end_ifndef

begin_define
define|#
directive|define
name|ZeroD
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|memzero((char*)(d), (n) * sizeof(t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|ZeroD
end_ifndef

begin_define
define|#
directive|define
name|ZeroD
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|((void)memzero((char*)(d), (n) * sizeof(t)), d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PoisonWith
end_ifndef

begin_define
define|#
directive|define
name|PoisonWith
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|,
name|b
parameter_list|)
value|(void)memset((char*)(d), (U8)(b), (n) * sizeof(t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PoisonNew
end_ifndef

begin_define
define|#
directive|define
name|PoisonNew
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|PoisonWith(d,n,t,0xAB)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PoisonFree
end_ifndef

begin_define
define|#
directive|define
name|PoisonFree
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|PoisonWith(d,n,t,0xEF)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Poison
end_ifndef

begin_define
define|#
directive|define
name|Poison
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|PoisonFree(d,n,t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Newx
end_ifndef

begin_define
define|#
directive|define
name|Newx
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|New(0,v,n,t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Newxc
end_ifndef

begin_define
define|#
directive|define
name|Newxc
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|,
name|c
parameter_list|)
value|Newc(0,v,n,t,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Newxz
end_ifndef

begin_define
define|#
directive|define
name|Newxz
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|,
name|t
parameter_list|)
value|Newz(0,v,n,t)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UNUSED_DECL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HASATTRIBUTE
end_ifdef

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
end_if

begin_define
define|#
directive|define
name|PERL_UNUSED_DECL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UNUSED_DECL
value|__attribute__((unused))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UNUSED_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UNUSED_ARG
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_SPLINT_S
argument_list|)
end_if

begin_comment
comment|/* www.splint.org */
end_comment

begin_include
include|#
directive|include
file|<note.h>
end_include

begin_define
define|#
directive|define
name|PERL_UNUSED_ARG
parameter_list|(
name|x
parameter_list|)
value|NOTE(ARGUNUSED(x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UNUSED_ARG
parameter_list|(
name|x
parameter_list|)
value|((void)x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UNUSED_VAR
end_ifndef

begin_define
define|#
directive|define
name|PERL_UNUSED_VAR
parameter_list|(
name|x
parameter_list|)
value|((void)x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_UNUSED_CONTEXT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ITHREADS
end_ifdef

begin_define
define|#
directive|define
name|PERL_UNUSED_CONTEXT
value|PERL_UNUSED_ARG(my_perl)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERL_UNUSED_CONTEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOOP
end_ifndef

begin_define
define|#
directive|define
name|NOOP
comment|/*EMPTY*/
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dNOOP
end_ifndef

begin_define
define|#
directive|define
name|dNOOP
value|extern int
comment|/*@unused@*/
value|Perl___notused PERL_UNUSED_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NVTYPE
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_LONG_DOUBLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|NVTYPE
value|long double
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NVTYPE
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|NVTYPE
name|NV
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT2PTR
end_ifndef

begin_if
if|#
directive|if
operator|(
name|IVSIZE
operator|==
name|PTRSIZE
operator|)
operator|&&
operator|(
name|UVSIZE
operator|==
name|PTRSIZE
operator|)
end_if

begin_define
define|#
directive|define
name|PTRV
value|UV
end_define

begin_define
define|#
directive|define
name|INT2PTR
parameter_list|(
name|any
parameter_list|,
name|d
parameter_list|)
value|(any)(d)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|PTRSIZE
operator|==
name|LONGSIZE
end_if

begin_define
define|#
directive|define
name|PTRV
value|unsigned long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTRV
value|unsigned
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INT2PTR
parameter_list|(
name|any
parameter_list|,
name|d
parameter_list|)
value|(any)(PTRV)(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR2ul
end_ifndef

begin_if
if|#
directive|if
name|PTRSIZE
operator|==
name|LONGSIZE
end_if

begin_define
define|#
directive|define
name|PTR2ul
parameter_list|(
name|p
parameter_list|)
value|(unsigned long)(p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTR2ul
parameter_list|(
name|p
parameter_list|)
value|INT2PTR(unsigned long,p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR2nat
end_ifndef

begin_define
define|#
directive|define
name|PTR2nat
parameter_list|(
name|p
parameter_list|)
value|(PTRV)(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NUM2PTR
end_ifndef

begin_define
define|#
directive|define
name|NUM2PTR
parameter_list|(
name|any
parameter_list|,
name|d
parameter_list|)
value|(any)PTR2nat(d)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR2IV
end_ifndef

begin_define
define|#
directive|define
name|PTR2IV
parameter_list|(
name|p
parameter_list|)
value|INT2PTR(IV,p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR2UV
end_ifndef

begin_define
define|#
directive|define
name|PTR2UV
parameter_list|(
name|p
parameter_list|)
value|INT2PTR(UV,p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR2NV
end_ifndef

begin_define
define|#
directive|define
name|PTR2NV
parameter_list|(
name|p
parameter_list|)
value|NUM2PTR(NV,p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|START_EXTERN_C
end_undef

begin_undef
undef|#
directive|undef
name|END_EXTERN_C
end_undef

begin_undef
undef|#
directive|undef
name|EXTERN_C
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_define
define|#
directive|define
name|START_EXTERN_C
value|extern "C" {
end_define

begin_define
define|#
directive|define
name|END_EXTERN_C
value|}
end_define

begin_define
define|#
directive|define
name|EXTERN_C
value|extern "C"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|START_EXTERN_C
end_define

begin_define
define|#
directive|define
name|END_EXTERN_C
end_define

begin_define
define|#
directive|define
name|EXTERN_C
value|extern
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PERL_GCC_PEDANTIC
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_GCC_BRACE_GROUPS_FORBIDDEN
end_ifndef

begin_define
define|#
directive|define
name|PERL_GCC_BRACE_GROUPS_FORBIDDEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PERL_GCC_BRACE_GROUPS_FORBIDDEN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifndef

begin_define
define|#
directive|define
name|PERL_USE_GCC_BRACE_GROUPS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|STMT_START
end_undef

begin_undef
undef|#
directive|undef
name|STMT_END
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifdef

begin_define
define|#
directive|define
name|STMT_START
value|(void)(
end_define

begin_comment
comment|/* gcc supports ``({ STATEMENTS; })'' */
end_comment

begin_define
define|#
directive|define
name|STMT_END
value|)
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VOIDFLAGS
argument_list|)
operator|&&
operator|(
name|VOIDFLAGS
operator|)
operator|&&
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
name|defined
argument_list|(
name|__sun__
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|STMT_START
value|if (1)
end_define

begin_define
define|#
directive|define
name|STMT_END
value|else (void)0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STMT_START
value|do
end_define

begin_define
define|#
directive|define
name|STMT_END
value|while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|boolSV
end_ifndef

begin_define
define|#
directive|define
name|boolSV
parameter_list|(
name|b
parameter_list|)
value|((b) ?&PL_sv_yes :&PL_sv_no)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEFSV appears first in 5.004_56 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFSV
end_ifndef

begin_define
define|#
directive|define
name|DEFSV
value|GvSV(PL_defgv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SAVE_DEFSV
end_ifndef

begin_define
define|#
directive|define
name|SAVE_DEFSV
value|SAVESPTR(GvSV(PL_defgv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFSV_set
end_ifndef

begin_define
define|#
directive|define
name|DEFSV_set
parameter_list|(
name|sv
parameter_list|)
value|(DEFSV = (sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Older perls (<=5.003) lack AvFILLp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AvFILLp
end_ifndef

begin_define
define|#
directive|define
name|AvFILLp
value|AvFILL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ERRSV
end_ifndef

begin_define
define|#
directive|define
name|ERRSV
value|get_sv("@",FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: gv_stashpvn  * This function's backport doesn't support the length parameter, but  * rather ignores it. Portability can only be ensured if the length  * parameter is used for speed reasons, but the length can always be  * correctly computed from the string argument.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|gv_stashpvn
end_ifndef

begin_define
define|#
directive|define
name|gv_stashpvn
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|create
parameter_list|)
value|gv_stashpv(str,create)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Replace: 1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|get_cv
end_ifndef

begin_define
define|#
directive|define
name|get_cv
value|perl_get_cv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|get_sv
end_ifndef

begin_define
define|#
directive|define
name|get_sv
value|perl_get_sv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|get_av
end_ifndef

begin_define
define|#
directive|define
name|get_av
value|perl_get_av
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|get_hv
end_ifndef

begin_define
define|#
directive|define
name|get_hv
value|perl_get_hv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Replace: 0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|dUNDERBAR
end_ifndef

begin_define
define|#
directive|define
name|dUNDERBAR
value|dNOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNDERBAR
end_ifndef

begin_define
define|#
directive|define
name|UNDERBAR
value|DEFSV
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dAX
end_ifndef

begin_define
define|#
directive|define
name|dAX
value|I32 ax = MARK - PL_stack_base + 1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dITEMS
end_ifndef

begin_define
define|#
directive|define
name|dITEMS
value|I32 items = SP - MARK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dXSTARG
end_ifndef

begin_define
define|#
directive|define
name|dXSTARG
value|SV * targ = sv_newmortal()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dAXMARK
end_ifndef

begin_define
define|#
directive|define
name|dAXMARK
value|I32 ax = POPMARK; \                                register SV ** const mark = PL_stack_base + ax++
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XSprePUSH
end_ifndef

begin_define
define|#
directive|define
name|XSprePUSH
value|(sp = PL_stack_base + ax - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5005000
operator|)
end_if

begin_undef
undef|#
directive|undef
name|XSRETURN
end_undef

begin_define
define|#
directive|define
name|XSRETURN
parameter_list|(
name|off
parameter_list|)
define|\
value|STMT_START {                                        \           PL_stack_sp = PL_stack_base + ax + ((off) - 1); \           return;                                         \       } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|XSPROTO
end_ifndef

begin_define
define|#
directive|define
name|XSPROTO
parameter_list|(
name|name
parameter_list|)
value|void name(pTHX_ CV* cv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SVfARG
end_ifndef

begin_define
define|#
directive|define
name|SVfARG
parameter_list|(
name|p
parameter_list|)
value|((void*)(p))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_ABS
end_ifndef

begin_define
define|#
directive|define
name|PERL_ABS
parameter_list|(
name|x
parameter_list|)
value|((x)< 0 ? -(x) : (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|dVAR
end_ifndef

begin_define
define|#
directive|define
name|dVAR
value|dNOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SVf
end_ifndef

begin_define
define|#
directive|define
name|SVf
value|"_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UTF8_MAXBYTES
end_ifndef

begin_define
define|#
directive|define
name|UTF8_MAXBYTES
value|UTF8_MAXLEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CPERLscope
end_ifndef

begin_define
define|#
directive|define
name|CPERLscope
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_HASH
end_ifndef

begin_define
define|#
directive|define
name|PERL_HASH
parameter_list|(
name|hash
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
define|\
value|STMT_START	{ \ 	const char *s_PeRlHaSh = str; \ 	I32 i_PeRlHaSh = len; \ 	U32 hash_PeRlHaSh = 0; \ 	while (i_PeRlHaSh--) \ 	    hash_PeRlHaSh = hash_PeRlHaSh * 33 + *s_PeRlHaSh++; \ 	(hash) = hash_PeRlHaSh; \     } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERLIO_FUNCS_DECL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERLIO_FUNCS_CONST
end_ifdef

begin_define
define|#
directive|define
name|PERLIO_FUNCS_DECL
parameter_list|(
name|funcs
parameter_list|)
value|const PerlIO_funcs funcs
end_define

begin_define
define|#
directive|define
name|PERLIO_FUNCS_CAST
parameter_list|(
name|funcs
parameter_list|)
value|(PerlIO_funcs*)(funcs)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PERLIO_FUNCS_DECL
parameter_list|(
name|funcs
parameter_list|)
value|PerlIO_funcs funcs
end_define

begin_define
define|#
directive|define
name|PERLIO_FUNCS_CAST
parameter_list|(
name|funcs
parameter_list|)
value|(funcs)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* provide these typedefs for older perls */
end_comment

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5009003
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|ARGSproto
end_ifdef

begin_typedef
typedef|typedef
name|OP
argument_list|*
operator|(
name|CPERLscope
argument_list|(
operator|*
name|Perl_ppaddr_t
argument_list|)
operator|)
operator|(
name|ARGSproto
operator|)
argument_list|;
else|#
directive|else
argument_list|typedef
name|OP
operator|*
operator|(
name|CPERLscope
argument_list|(
operator|*
name|Perl_ppaddr_t
argument_list|)
operator|)
operator|(
name|pTHX
operator|)
argument_list|;
endif|#
directive|endif
argument_list|typedef
name|OP
operator|*
operator|(
name|CPERLscope
argument_list|(
operator|*
name|Perl_check_t
argument_list|)
operator|)
operator|(
name|pTHX_
name|OP
operator|*
operator|)
argument_list|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isPSXSPC
define|#
directive|define
name|isPSXSPC
parameter_list|(
name|c
parameter_list|)
value|(isSPACE(c) || (c) == '\v')
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isBLANK
define|#
directive|define
name|isBLANK
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBCDIC
ifndef|#
directive|ifndef
name|isALNUMC
define|#
directive|define
name|isALNUMC
parameter_list|(
name|c
parameter_list|)
value|isalnum(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isASCII
define|#
directive|define
name|isASCII
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isCNTRL
define|#
directive|define
name|isCNTRL
parameter_list|(
name|c
parameter_list|)
value|iscntrl(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isGRAPH
define|#
directive|define
name|isGRAPH
parameter_list|(
name|c
parameter_list|)
value|isgraph(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isPRINT
define|#
directive|define
name|isPRINT
parameter_list|(
name|c
parameter_list|)
value|isprint(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isPUNCT
define|#
directive|define
name|isPUNCT
parameter_list|(
name|c
parameter_list|)
value|ispunct(c)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isXDIGIT
define|#
directive|define
name|isXDIGIT
parameter_list|(
name|c
parameter_list|)
value|isxdigit(c)
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5010000
operator|)
comment|/* Hint: isPRINT  * The implementation in older perl versions includes all of the  * isSPACE() characters, which is wrong. The version provided by  * Devel::PPPort always overrides a present buggy version.  */
undef|#
directive|undef
name|isPRINT
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isALNUMC
define|#
directive|define
name|isALNUMC
parameter_list|(
name|c
parameter_list|)
value|(isALPHA(c) || isDIGIT(c))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isASCII
define|#
directive|define
name|isASCII
parameter_list|(
name|c
parameter_list|)
value|((c)<= 127)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isCNTRL
define|#
directive|define
name|isCNTRL
parameter_list|(
name|c
parameter_list|)
value|((c)< ' ' || (c) == 127)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isGRAPH
define|#
directive|define
name|isGRAPH
parameter_list|(
name|c
parameter_list|)
value|(isALNUM(c) || isPUNCT(c))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isPRINT
define|#
directive|define
name|isPRINT
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 32&& (c)< 127))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isPUNCT
define|#
directive|define
name|isPUNCT
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 33&& (c)<= 47) || ((c)>= 58&& (c)<= 64)  || ((c)>= 91&& (c)<= 96) || ((c)>= 123&& (c)<= 126))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|isXDIGIT
define|#
directive|define
name|isXDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isDIGIT(c) || ((c)>= 'a'&& (c)<= 'f') || ((c)>= 'A'&& (c)<= 'F'))
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_SIGNALS_UNSAFE_FLAG
define|#
directive|define
name|PERL_SIGNALS_UNSAFE_FLAG
value|0x0001
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5008000
operator|)
define|#
directive|define
name|D_PPP_PERL_SIGNALS_INIT
value|PERL_SIGNALS_UNSAFE_FLAG
else|#
directive|else
define|#
directive|define
name|D_PPP_PERL_SIGNALS_INIT
value|0
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|NEED_PL_signals
argument_list|)
specifier|static
name|U32
name|DPPP_
argument_list|(
name|my_PL_signals
argument_list|)
operator|=
name|D_PPP_PERL_SIGNALS_INIT
argument_list|;
elif|#
directive|elif
name|defined
argument_list|(
name|NEED_PL_signals_GLOBAL
argument_list|)
name|U32
name|DPPP_
argument_list|(
name|my_PL_signals
argument_list|)
operator|=
name|D_PPP_PERL_SIGNALS_INIT
argument_list|;
else|#
directive|else
specifier|extern
name|U32
name|DPPP_
argument_list|(
name|my_PL_signals
argument_list|)
argument_list|;
endif|#
directive|endif
define|#
directive|define
name|PL_signals
value|DPPP_(my_PL_signals)
endif|#
directive|endif
comment|/* Hint: PL_ppaddr  * Calling an op via PL_ppaddr requires passing a context argument  * for threaded builds. Since the context argument is different for  * 5.005 perls, you can use aTHXR (supplied by ppport.h), which will  * automatically be defined as the correct argument.  */
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<=
literal|0x5005005
operator|)
comment|/* Replace: 1 */
define|#
directive|define
name|PL_ppaddr
value|ppaddr
define|#
directive|define
name|PL_no_modify
value|no_modify
comment|/* Replace: 0 */
endif|#
directive|endif
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<=
literal|0x5004005
operator|)
comment|/* Replace: 1 */
define|#
directive|define
name|PL_DBsignal
value|DBsignal
define|#
directive|define
name|PL_DBsingle
value|DBsingle
define|#
directive|define
name|PL_DBsub
value|DBsub
define|#
directive|define
name|PL_DBtrace
value|DBtrace
define|#
directive|define
name|PL_Sv
value|Sv
define|#
directive|define
name|PL_bufend
value|bufend
define|#
directive|define
name|PL_bufptr
value|bufptr
define|#
directive|define
name|PL_compiling
value|compiling
define|#
directive|define
name|PL_copline
value|copline
define|#
directive|define
name|PL_curcop
value|curcop
define|#
directive|define
name|PL_curstash
value|curstash
define|#
directive|define
name|PL_debstash
value|debstash
define|#
directive|define
name|PL_defgv
value|defgv
define|#
directive|define
name|PL_diehook
value|diehook
define|#
directive|define
name|PL_dirty
value|dirty
define|#
directive|define
name|PL_dowarn
value|dowarn
define|#
directive|define
name|PL_errgv
value|errgv
define|#
directive|define
name|PL_error_count
value|error_count
define|#
directive|define
name|PL_expect
value|expect
define|#
directive|define
name|PL_hexdigit
value|hexdigit
define|#
directive|define
name|PL_hints
value|hints
define|#
directive|define
name|PL_in_my
value|in_my
define|#
directive|define
name|PL_laststatval
value|laststatval
define|#
directive|define
name|PL_lex_state
value|lex_state
define|#
directive|define
name|PL_lex_stuff
value|lex_stuff
define|#
directive|define
name|PL_linestr
value|linestr
define|#
directive|define
name|PL_na
value|na
define|#
directive|define
name|PL_perl_destruct_level
value|perl_destruct_level
define|#
directive|define
name|PL_perldb
value|perldb
define|#
directive|define
name|PL_rsfp_filters
value|rsfp_filters
define|#
directive|define
name|PL_rsfp
value|rsfp
define|#
directive|define
name|PL_stack_base
value|stack_base
define|#
directive|define
name|PL_stack_sp
value|stack_sp
define|#
directive|define
name|PL_statcache
value|statcache
define|#
directive|define
name|PL_stdingv
value|stdingv
define|#
directive|define
name|PL_sv_arenaroot
value|sv_arenaroot
define|#
directive|define
name|PL_sv_no
value|sv_no
define|#
directive|define
name|PL_sv_undef
value|sv_undef
define|#
directive|define
name|PL_sv_yes
value|sv_yes
define|#
directive|define
name|PL_tainted
value|tainted
define|#
directive|define
name|PL_tainting
value|tainting
define|#
directive|define
name|PL_tokenbuf
value|tokenbuf
comment|/* Replace: 0 */
endif|#
directive|endif
comment|/* Warning: PL_parser  * For perl versions earlier than 5.9.5, this is an always  * non-NULL dummy. Also, it cannot be dereferenced. Don't  * use it if you can avoid is and unless you absolutely know  * what you're doing.  * If you always check that PL_parser is non-NULL, you can  * define DPPP_PL_parser_NO_DUMMY to avoid the creation of  * a dummy parser structure.  */
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5009005
operator|)
ifdef|#
directive|ifdef
name|DPPP_PL_parser_NO_DUMMY
define|#
directive|define
name|D_PPP_my_PL_parser_var
parameter_list|(
name|var
parameter_list|)
value|((PL_parser ? PL_parser : \                 (croak("panic: PL_parser == NULL in %s:%d", \                        __FILE__, __LINE__), (yy_parser *) NULL))->var)
else|#
directive|else
ifdef|#
directive|ifdef
name|DPPP_PL_parser_NO_DUMMY_WARNING
define|#
directive|define
name|D_PPP_parser_dummy_warning
parameter_list|(
name|var
parameter_list|)
else|#
directive|else
define|#
directive|define
name|D_PPP_parser_dummy_warning
parameter_list|(
name|var
parameter_list|)
define|\
value|warn("warning: dummy PL_" #var " used in %s:%d", __FILE__, __LINE__),
endif|#
directive|endif
define|#
directive|define
name|D_PPP_my_PL_parser_var
parameter_list|(
name|var
parameter_list|)
value|((PL_parser ? PL_parser : \                 (D_PPP_parser_dummy_warning(var)&DPPP_(dummy_PL_parser)))->var)
if|#
directive|if
name|defined
argument_list|(
name|NEED_PL_parser
argument_list|)
specifier|static
name|yy_parser
name|DPPP_
argument_list|(
name|dummy_PL_parser
argument_list|)
argument_list|;
elif|#
directive|elif
name|defined
argument_list|(
name|NEED_PL_parser_GLOBAL
argument_list|)
name|yy_parser
name|DPPP_
argument_list|(
name|dummy_PL_parser
argument_list|)
argument_list|;
else|#
directive|else
specifier|extern
name|yy_parser
name|DPPP_
argument_list|(
name|dummy_PL_parser
argument_list|)
argument_list|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf depends on PL_parser */
comment|/* Warning: PL_expect, PL_copline, PL_rsfp, PL_rsfp_filters, PL_linestr, PL_bufptr, PL_bufend, PL_lex_state, PL_lex_stuff, PL_tokenbuf  * Do not use this variable unless you know exactly what you're  * doint. It is internal to the perl parser and may change or even  * be removed in the future. As of perl 5.9.5, you have to check  * for (PL_parser != NULL) for this variable to have any effect.  * An always non-NULL PL_parser dummy is provided for earlier  * perl versions.  * If PL_parser is NULL when you try to access this variable, a  * dummy is being accessed instead and a warning is issued unless  * you define DPPP_PL_parser_NO_DUMMY_WARNING.  * If DPPP_PL_parser_NO_DUMMY is defined, the code trying to access  * this variable will croak with a panic message.  */
define|#
directive|define
name|PL_expect
value|D_PPP_my_PL_parser_var(expect)
define|#
directive|define
name|PL_copline
value|D_PPP_my_PL_parser_var(copline)
define|#
directive|define
name|PL_rsfp
value|D_PPP_my_PL_parser_var(rsfp)
define|#
directive|define
name|PL_rsfp_filters
value|D_PPP_my_PL_parser_var(rsfp_filters)
define|#
directive|define
name|PL_linestr
value|D_PPP_my_PL_parser_var(linestr)
define|#
directive|define
name|PL_bufptr
value|D_PPP_my_PL_parser_var(bufptr)
define|#
directive|define
name|PL_bufend
value|D_PPP_my_PL_parser_var(bufend)
define|#
directive|define
name|PL_lex_state
value|D_PPP_my_PL_parser_var(lex_state)
define|#
directive|define
name|PL_lex_stuff
value|D_PPP_my_PL_parser_var(lex_stuff)
define|#
directive|define
name|PL_tokenbuf
value|D_PPP_my_PL_parser_var(tokenbuf)
define|#
directive|define
name|PL_in_my
value|D_PPP_my_PL_parser_var(in_my)
define|#
directive|define
name|PL_in_my_stash
value|D_PPP_my_PL_parser_var(in_my_stash)
define|#
directive|define
name|PL_error_count
value|D_PPP_my_PL_parser_var(error_count)
else|#
directive|else
comment|/* ensure that PL_parser != NULL and cannot be dereferenced */
define|#
directive|define
name|PL_parser
value|((void *) 1)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mPUSHs
define|#
directive|define
name|mPUSHs
parameter_list|(
name|s
parameter_list|)
value|PUSHs(sv_2mortal(s))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PUSHmortal
define|#
directive|define
name|PUSHmortal
value|PUSHs(sv_newmortal())
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mPUSHp
define|#
directive|define
name|mPUSHp
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|sv_setpvn(PUSHmortal, (p), (l))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mPUSHn
define|#
directive|define
name|mPUSHn
parameter_list|(
name|n
parameter_list|)
value|sv_setnv(PUSHmortal, (NV)(n))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mPUSHi
define|#
directive|define
name|mPUSHi
parameter_list|(
name|i
parameter_list|)
value|sv_setiv(PUSHmortal, (IV)(i))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mPUSHu
define|#
directive|define
name|mPUSHu
parameter_list|(
name|u
parameter_list|)
value|sv_setuv(PUSHmortal, (UV)(u))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mXPUSHs
define|#
directive|define
name|mXPUSHs
parameter_list|(
name|s
parameter_list|)
value|XPUSHs(sv_2mortal(s))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|XPUSHmortal
define|#
directive|define
name|XPUSHmortal
value|XPUSHs(sv_newmortal())
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mXPUSHp
define|#
directive|define
name|mXPUSHp
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|STMT_START { EXTEND(sp,1); sv_setpvn(PUSHmortal, (p), (l)); } STMT_END
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mXPUSHn
define|#
directive|define
name|mXPUSHn
parameter_list|(
name|n
parameter_list|)
value|STMT_START { EXTEND(sp,1); sv_setnv(PUSHmortal, (NV)(n)); } STMT_END
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mXPUSHi
define|#
directive|define
name|mXPUSHi
parameter_list|(
name|i
parameter_list|)
value|STMT_START { EXTEND(sp,1); sv_setiv(PUSHmortal, (IV)(i)); } STMT_END
endif|#
directive|endif
ifndef|#
directive|ifndef
name|mXPUSHu
define|#
directive|define
name|mXPUSHu
parameter_list|(
name|u
parameter_list|)
value|STMT_START { EXTEND(sp,1); sv_setuv(PUSHmortal, (UV)(u)); } STMT_END
endif|#
directive|endif
comment|/* Replace: 1 */
ifndef|#
directive|ifndef
name|call_sv
define|#
directive|define
name|call_sv
value|perl_call_sv
endif|#
directive|endif
ifndef|#
directive|ifndef
name|call_pv
define|#
directive|define
name|call_pv
value|perl_call_pv
endif|#
directive|endif
ifndef|#
directive|ifndef
name|call_argv
define|#
directive|define
name|call_argv
value|perl_call_argv
endif|#
directive|endif
ifndef|#
directive|ifndef
name|call_method
define|#
directive|define
name|call_method
value|perl_call_method
endif|#
directive|endif
ifndef|#
directive|ifndef
name|eval_sv
define|#
directive|define
name|eval_sv
value|perl_eval_sv
endif|#
directive|endif
comment|/* Replace: 0 */
ifndef|#
directive|ifndef
name|PERL_LOADMOD_DENY
define|#
directive|define
name|PERL_LOADMOD_DENY
value|0x1
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_LOADMOD_NOIMPORT
define|#
directive|define
name|PERL_LOADMOD_NOIMPORT
value|0x2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PERL_LOADMOD_IMPORT_OPS
define|#
directive|define
name|PERL_LOADMOD_IMPORT_OPS
value|0x4
endif|#
directive|endif
ifndef|#
directive|ifndef
name|G_METHOD
define|#
directive|define
name|G_METHOD
value|64
ifdef|#
directive|ifdef
name|call_sv
undef|#
directive|undef
name|call_sv
endif|#
directive|endif
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5006000
operator|)
define|#
directive|define
name|call_sv
parameter_list|(
name|sv
parameter_list|,
name|flags
parameter_list|)
value|((flags)& G_METHOD ? perl_call_method((char *) SvPV_nolen_const(sv), \ 				(flags)& ~G_METHOD) : perl_call_sv(sv, flags))
else|#
directive|else
define|#
directive|define
name|call_sv
parameter_list|(
name|sv
parameter_list|,
name|flags
parameter_list|)
value|((flags)& G_METHOD ? Perl_call_method(aTHX_ (char *) SvPV_nolen_const(sv), \ 				(flags)& ~G_METHOD) : Perl_call_sv(aTHX_ sv, flags))
endif|#
directive|endif
endif|#
directive|endif
comment|/* Replace perl_eval_pv with eval_pv */
ifndef|#
directive|ifndef
name|eval_pv
if|#
directive|if
name|defined
argument_list|(
name|NEED_eval_pv
argument_list|)
specifier|static
name|SV
operator|*
name|DPPP_
argument_list|(
argument|my_eval_pv
argument_list|)
operator|(
name|char
operator|*
name|p
operator|,
name|I32
name|croak_on_error
operator|)
argument_list|;
specifier|static
else|#
directive|else
specifier|extern
name|SV
operator|*
name|DPPP_
argument_list|(
argument|my_eval_pv
argument_list|)
operator|(
name|char
operator|*
name|p
operator|,
name|I32
name|croak_on_error
operator|)
argument_list|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|eval_pv
undef|#
directive|undef
name|eval_pv
endif|#
directive|endif
define|#
directive|define
name|eval_pv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|DPPP_(my_eval_pv)(aTHX_ a,b)
define|#
directive|define
name|Perl_eval_pv
value|DPPP_(my_eval_pv)
if|#
directive|if
name|defined
argument_list|(
name|NEED_eval_pv
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_eval_pv_GLOBAL
argument_list|)
name|SV
operator|*
name|DPPP_
argument_list|(
argument|my_eval_pv
argument_list|)
operator|(
name|char
operator|*
name|p
operator|,
name|I32
name|croak_on_error
operator|)
block|{
name|dSP
block|;
name|SV
operator|*
name|sv
operator|=
name|newSVpv
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
block|;
name|PUSHMARK
argument_list|(
name|sp
argument_list|)
block|;
name|eval_sv
argument_list|(
name|sv
argument_list|,
name|G_SCALAR
argument_list|)
block|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
block|;
name|SPAGAIN
block|;
name|sv
operator|=
name|POPs
block|;
name|PUTBACK
block|;
if|if
condition|(
name|croak_on_error
operator|&&
name|SvTRUE
argument_list|(
name|GvSV
argument_list|(
name|errgv
argument_list|)
argument_list|)
condition|)
name|croak
argument_list|(
name|SvPVx
argument_list|(
name|GvSV
argument_list|(
name|errgv
argument_list|)
argument_list|,
name|na
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
end_typedef

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|vload_module
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_vload_module
argument_list|)
end_if

begin_function_decl
unit|static
name|void
name|DPPP_
function_decl|(
name|my_vload_module
function_decl|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_vload_module
function_decl|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vload_module
end_ifdef

begin_undef
undef|#
directive|undef
name|vload_module
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|vload_module
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|DPPP_(my_vload_module)(aTHX_ a,b,c,d)
end_define

begin_define
define|#
directive|define
name|Perl_vload_module
value|DPPP_(my_vload_module)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_vload_module
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_vload_module_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_vload_module
function|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
name|dTHR
expr_stmt|;
name|dVAR
expr_stmt|;
name|OP
modifier|*
name|veop
decl_stmt|,
modifier|*
name|imop
decl_stmt|;
name|OP
modifier|*
specifier|const
name|modname
init|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* 5.005 has a somewhat hacky force_normal that doesn't croak on        SvREADONLY() if PL_compling is true. Current perls take care in        ck_require() to correctly turn off SvREADONLY before calling        force_normal_flags(). This seems a better fix than fudging PL_compling      */
name|SvREADONLY_off
argument_list|(
operator|(
operator|(
name|SVOP
operator|*
operator|)
name|modname
operator|)
operator|->
name|op_sv
argument_list|)
expr_stmt|;
name|modname
operator|->
name|op_private
operator||=
name|OPpCONST_BARE
expr_stmt|;
if|if
condition|(
name|ver
condition|)
block|{
name|veop
operator|=
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|ver
argument_list|)
expr_stmt|;
block|}
else|else
name|veop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PERL_LOADMOD_NOIMPORT
condition|)
block|{
name|imop
operator|=
name|sawparens
argument_list|(
name|newNULLLIST
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|PERL_LOADMOD_IMPORT_OPS
condition|)
block|{
name|imop
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|OP
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|imop
operator|=
name|NULL
expr_stmt|;
name|sv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|sv
condition|)
block|{
name|imop
operator|=
name|append_elem
argument_list|(
name|OP_LIST
argument_list|,
name|imop
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
name|va_arg
argument_list|(
operator|*
name|args
argument_list|,
name|SV
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
block|{
specifier|const
name|line_t
name|ocopline
init|=
name|PL_copline
decl_stmt|;
name|COP
modifier|*
specifier|const
name|ocurcop
init|=
name|PL_curcop
decl_stmt|;
specifier|const
name|int
name|oexpect
init|=
name|PL_expect
decl_stmt|;
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
name|utilize
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|PERL_LOADMOD_DENY
operator|)
argument_list|,
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|veop
argument_list|,
name|modname
argument_list|,
name|imop
argument_list|)
expr_stmt|;
else|#
directive|else
name|utilize
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|PERL_LOADMOD_DENY
operator|)
argument_list|,
name|start_subparse
argument_list|()
argument_list|,
name|modname
argument_list|,
name|imop
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PL_expect
operator|=
name|oexpect
expr_stmt|;
name|PL_copline
operator|=
name|ocopline
expr_stmt|;
name|PL_curcop
operator|=
name|ocurcop
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|load_module
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_load_module
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_load_module
function_decl|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_load_module
function_decl|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|load_module
end_ifdef

begin_undef
undef|#
directive|undef
name|load_module
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|load_module
value|DPPP_(my_load_module)
end_define

begin_define
define|#
directive|define
name|Perl_load_module
value|DPPP_(my_load_module)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_load_module
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_load_module_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_load_module
function|)
parameter_list|(
name|U32
name|flags
parameter_list|,
name|SV
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|ver
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|vload_module
argument_list|(
name|flags
argument_list|,
name|name
argument_list|,
name|ver
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newRV_inc
end_ifndef

begin_define
define|#
directive|define
name|newRV_inc
parameter_list|(
name|sv
parameter_list|)
value|newRV(sv)
end_define

begin_comment
comment|/* Replace */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newRV_noinc
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newRV_noinc
argument_list|)
end_if

begin_function_decl
specifier|static
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newRV_noinc
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newRV_noinc
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|newRV_noinc
end_ifdef

begin_undef
undef|#
directive|undef
name|newRV_noinc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|newRV_noinc
parameter_list|(
name|a
parameter_list|)
value|DPPP_(my_newRV_noinc)(aTHX_ a)
end_define

begin_define
define|#
directive|define
name|Perl_newRV_noinc
value|DPPP_(my_newRV_noinc)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newRV_noinc
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_newRV_noinc_GLOBAL
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|DPPP_
function|(
name|my_newRV_noinc
function|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|SV
modifier|*
name|rv
init|=
operator|(
name|SV
operator|*
operator|)
name|newRV
argument_list|(
name|sv
argument_list|)
decl_stmt|;
name|SvREFCNT_dec
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: newCONSTSUB  * Returns a CV* as of perl-5.7.1. This return value is not supported  * by Devel::PPPort.  */
end_comment

begin_comment
comment|/* newCONSTSUB from IO.xs is in the core starting with 5.004_63 */
end_comment

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5004063
operator|)
operator|&&
operator|(
name|PERL_BCDVERSION
operator|!=
literal|0x5004005
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newCONSTSUB
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_newCONSTSUB
function_decl|)
parameter_list|(
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_newCONSTSUB
function_decl|)
parameter_list|(
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|newCONSTSUB
end_ifdef

begin_undef
undef|#
directive|undef
name|newCONSTSUB
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|newCONSTSUB
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_newCONSTSUB)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_newCONSTSUB
value|DPPP_(my_newCONSTSUB)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newCONSTSUB
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_newCONSTSUB_GLOBAL
argument_list|)
end_if

begin_comment
comment|/* This is just a trick to avoid a dependency of newCONSTSUB on PL_parser */
end_comment

begin_comment
comment|/* (There's no PL_parser in perl< 5.005, so this is completely safe)     */
end_comment

begin_define
define|#
directive|define
name|D_PPP_PL_copline
value|PL_copline
end_define

begin_function
name|void
name|DPPP_
function|(
name|my_newCONSTSUB
function|)
parameter_list|(
name|HV
modifier|*
name|stash
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|SV
modifier|*
name|sv
parameter_list|)
block|{
name|U32
name|oldhints
init|=
name|PL_hints
decl_stmt|;
name|HV
modifier|*
name|old_cop_stash
init|=
name|PL_curcop
operator|->
name|cop_stash
decl_stmt|;
name|HV
modifier|*
name|old_curstash
init|=
name|PL_curstash
decl_stmt|;
name|line_t
name|oldline
init|=
name|PL_curcop
operator|->
name|cop_line
decl_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|D_PPP_PL_copline
expr_stmt|;
name|PL_hints
operator|&=
operator|~
name|HINT_BLOCK_SCOPE
expr_stmt|;
if|if
condition|(
name|stash
condition|)
name|PL_curstash
operator|=
name|PL_curcop
operator|->
name|cop_stash
operator|=
name|stash
expr_stmt|;
name|newSUB
argument_list|(
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5003022
operator|)
name|start_subparse
argument_list|()
argument_list|,
elif|#
directive|elif
operator|(
name|PERL_BCDVERSION
operator|==
literal|0x5003022
operator|)
name|start_subparse
argument_list|(
literal|0
argument_list|)
argument_list|,
else|#
directive|else
comment|/* 5.003_23  onwards */
name|start_subparse
argument_list|(
name|FALSE
argument_list|,
literal|0
argument_list|)
argument_list|,
endif|#
directive|endif
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|newSVpv
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
operator|&
name|PL_sv_no
argument_list|)
argument_list|,
comment|/* SvPV(&PL_sv_no) == "" -- GMB */
name|newSTATEOP
argument_list|(
literal|0
argument_list|,
name|Nullch
argument_list|,
name|newSVOP
argument_list|(
name|OP_CONST
argument_list|,
literal|0
argument_list|,
name|sv
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PL_hints
operator|=
name|oldhints
expr_stmt|;
name|PL_curcop
operator|->
name|cop_stash
operator|=
name|old_cop_stash
expr_stmt|;
name|PL_curstash
operator|=
name|old_curstash
expr_stmt|;
name|PL_curcop
operator|->
name|cop_line
operator|=
name|oldline
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Boilerplate macros for initializing and accessing interpreter-local  * data from C.  All statics in extensions should be reworked to use  * this, if you want to make the extension thread-safe.  See ext/re/re.xs  * for an example of the use of these macros.  *  * Code that uses these macros is responsible for the following:  * 1. #define MY_CXT_KEY to a unique string, e.g. "DynaLoader_guts"  * 2. Declare a typedef named my_cxt_t that is a structure that contains  *    all the data that needs to be interpreter-local.  * 3. Use the START_MY_CXT macro after the declaration of my_cxt_t.  * 4. Use the MY_CXT_INIT macro such that it is called exactly once  *    (typically put in the BOOT: section).  * 5. Use the members of the my_cxt_t structure everywhere as  *    MY_CXT.member.  * 6. Use the dMY_CXT macro (a declaration) in all the functions that  *    access MY_CXT.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MULTIPLICITY
argument_list|)
operator|||
name|defined
argument_list|(
name|PERL_OBJECT
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|PERL_CAPI
argument_list|)
operator|||
name|defined
argument_list|(
name|PERL_IMPLICIT_CONTEXT
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|START_MY_CXT
end_ifndef

begin_comment
comment|/* This must appear in all extensions that define a my_cxt_t structure,  * right after the definition (i.e. at file scope).  The non-threads  * case below uses it to declare the data as static. */
end_comment

begin_define
define|#
directive|define
name|START_MY_CXT
end_define

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5004068
operator|)
end_if

begin_comment
comment|/* Fetches the SV that keeps the per-interpreter data. */
end_comment

begin_define
define|#
directive|define
name|dMY_CXT_SV
define|\
value|SV *my_cxt_sv = get_sv(MY_CXT_KEY, FALSE)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*>= perl5.004_68 */
end_comment

begin_define
define|#
directive|define
name|dMY_CXT_SV
define|\
value|SV *my_cxt_sv = *hv_fetch(PL_modglobal, MY_CXT_KEY,		\ 				  sizeof(MY_CXT_KEY)-1, TRUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*< perl5.004_68 */
end_comment

begin_comment
comment|/* This declaration should be used within all functions that use the  * interpreter-local data. */
end_comment

begin_define
define|#
directive|define
name|dMY_CXT
define|\
value|dMY_CXT_SV;							\ 	my_cxt_t *my_cxtp = INT2PTR(my_cxt_t*,SvUV(my_cxt_sv))
end_define

begin_comment
comment|/* Creates and zeroes the per-interpreter data.  * (We allocate my_cxtp in a Perl SV so that it will be released when  * the interpreter goes away.) */
end_comment

begin_define
define|#
directive|define
name|MY_CXT_INIT
define|\
value|dMY_CXT_SV;							\
comment|/* newSV() allocates one more than needed */
value|\ 	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\ 	Zero(my_cxtp, 1, my_cxt_t);					\ 	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
end_define

begin_comment
comment|/* This macro must be used to access members of the my_cxt_t structure.  * e.g. MYCXT.some_data */
end_comment

begin_define
define|#
directive|define
name|MY_CXT
value|(*my_cxtp)
end_define

begin_comment
comment|/* Judicious use of these macros can reduce the number of times dMY_CXT  * is used.  Use is similar to pTHX, aTHX etc. */
end_comment

begin_define
define|#
directive|define
name|pMY_CXT
value|my_cxt_t *my_cxtp
end_define

begin_define
define|#
directive|define
name|pMY_CXT_
value|pMY_CXT,
end_define

begin_define
define|#
directive|define
name|_pMY_CXT
value|,pMY_CXT
end_define

begin_define
define|#
directive|define
name|aMY_CXT
value|my_cxtp
end_define

begin_define
define|#
directive|define
name|aMY_CXT_
value|aMY_CXT,
end_define

begin_define
define|#
directive|define
name|_aMY_CXT
value|,aMY_CXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* START_MY_CXT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_CXT_CLONE
end_ifndef

begin_comment
comment|/* Clones the per-interpreter data. */
end_comment

begin_define
define|#
directive|define
name|MY_CXT_CLONE
define|\
value|dMY_CXT_SV;							\ 	my_cxt_t *my_cxtp = (my_cxt_t*)SvPVX(newSV(sizeof(my_cxt_t)-1));\ 	Copy(INT2PTR(my_cxt_t*, SvUV(my_cxt_sv)), my_cxtp, 1, my_cxt_t);\ 	sv_setuv(my_cxt_sv, PTR2UV(my_cxtp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* single interpreter */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|START_MY_CXT
end_ifndef

begin_define
define|#
directive|define
name|START_MY_CXT
value|static my_cxt_t my_cxt;
end_define

begin_define
define|#
directive|define
name|dMY_CXT_SV
value|dNOOP
end_define

begin_define
define|#
directive|define
name|dMY_CXT
value|dNOOP
end_define

begin_define
define|#
directive|define
name|MY_CXT_INIT
value|NOOP
end_define

begin_define
define|#
directive|define
name|MY_CXT
value|my_cxt
end_define

begin_define
define|#
directive|define
name|pMY_CXT
value|void
end_define

begin_define
define|#
directive|define
name|pMY_CXT_
end_define

begin_define
define|#
directive|define
name|_pMY_CXT
end_define

begin_define
define|#
directive|define
name|aMY_CXT
end_define

begin_define
define|#
directive|define
name|aMY_CXT_
end_define

begin_define
define|#
directive|define
name|_aMY_CXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* START_MY_CXT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_CXT_CLONE
end_ifndef

begin_define
define|#
directive|define
name|MY_CXT_CLONE
value|NOOP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IVdf
end_ifndef

begin_if
if|#
directive|if
name|IVSIZE
operator|==
name|LONGSIZE
end_if

begin_define
define|#
directive|define
name|IVdf
value|"ld"
end_define

begin_define
define|#
directive|define
name|UVuf
value|"lu"
end_define

begin_define
define|#
directive|define
name|UVof
value|"lo"
end_define

begin_define
define|#
directive|define
name|UVxf
value|"lx"
end_define

begin_define
define|#
directive|define
name|UVXf
value|"lX"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|IVSIZE
operator|==
name|INTSIZE
end_if

begin_define
define|#
directive|define
name|IVdf
value|"d"
end_define

begin_define
define|#
directive|define
name|UVuf
value|"u"
end_define

begin_define
define|#
directive|define
name|UVof
value|"o"
end_define

begin_define
define|#
directive|define
name|UVxf
value|"x"
end_define

begin_define
define|#
directive|define
name|UVXf
value|"X"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NVef
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_LONG_DOUBLE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_LONG_DOUBLE
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PERL_PRIfldbl
argument_list|)
operator|&&
operator|(
name|PERL_BCDVERSION
operator|!=
literal|0x5006000
operator|)
end_if

begin_comment
comment|/* Not very likely, but let's try anyway. */
end_comment

begin_define
define|#
directive|define
name|NVef
value|PERL_PRIeldbl
end_define

begin_define
define|#
directive|define
name|NVff
value|PERL_PRIfldbl
end_define

begin_define
define|#
directive|define
name|NVgf
value|PERL_PRIgldbl
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NVef
value|"e"
end_define

begin_define
define|#
directive|define
name|NVff
value|"f"
end_define

begin_define
define|#
directive|define
name|NVgf
value|"g"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifdef

begin_define
define|#
directive|define
name|SvREFCNT_inc
parameter_list|(
name|sv
parameter_list|)
define|\
value|({				\           SV * const _sv = (SV*)(sv);	\           if (_sv)			\                (SvREFCNT(_sv))++;	\           _sv;				\       })
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SvREFCNT_inc
parameter_list|(
name|sv
parameter_list|)
define|\
value|((PL_Sv=(SV*)(sv)) ? (++(SvREFCNT(PL_Sv)),PL_Sv) : NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_simple
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifdef

begin_define
define|#
directive|define
name|SvREFCNT_inc_simple
parameter_list|(
name|sv
parameter_list|)
define|\
value|({					\           if (sv)				\                (SvREFCNT(sv))++;		\           (SV *)(sv);				\       })
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SvREFCNT_inc_simple
parameter_list|(
name|sv
parameter_list|)
define|\
value|((sv) ? (SvREFCNT(sv)++,(SV*)(sv)) : NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_NN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifdef

begin_define
define|#
directive|define
name|SvREFCNT_inc_NN
parameter_list|(
name|sv
parameter_list|)
define|\
value|({					\           SV * const _sv = (SV*)(sv);	\           SvREFCNT(_sv)++;		\           _sv;				\       })
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SvREFCNT_inc_NN
parameter_list|(
name|sv
parameter_list|)
define|\
value|(PL_Sv=(SV*)(sv),++(SvREFCNT(PL_Sv)),PL_Sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_void
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_USE_GCC_BRACE_GROUPS
end_ifdef

begin_define
define|#
directive|define
name|SvREFCNT_inc_void
parameter_list|(
name|sv
parameter_list|)
define|\
value|({					\           SV * const _sv = (SV*)(sv);	\           if (_sv)			\               (void)(SvREFCNT(_sv)++);	\       })
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SvREFCNT_inc_void
parameter_list|(
name|sv
parameter_list|)
define|\
value|(void)((PL_Sv=(SV*)(sv)) ? ++(SvREFCNT(PL_Sv)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_simple_void
end_ifndef

begin_define
define|#
directive|define
name|SvREFCNT_inc_simple_void
parameter_list|(
name|sv
parameter_list|)
value|STMT_START { if (sv) SvREFCNT(sv)++; } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_simple_NN
end_ifndef

begin_define
define|#
directive|define
name|SvREFCNT_inc_simple_NN
parameter_list|(
name|sv
parameter_list|)
value|(++SvREFCNT(sv), (SV*)(sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_void_NN
end_ifndef

begin_define
define|#
directive|define
name|SvREFCNT_inc_void_NN
parameter_list|(
name|sv
parameter_list|)
value|(void)(++SvREFCNT((SV*)(sv)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvREFCNT_inc_simple_void_NN
end_ifndef

begin_define
define|#
directive|define
name|SvREFCNT_inc_simple_void_NN
parameter_list|(
name|sv
parameter_list|)
value|(void)(++SvREFCNT((SV*)(sv)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSV_type
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSV_type
argument_list|)
end_if

begin_function_decl
specifier|static
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSV_type
function_decl|)
parameter_list|(
name|pTHX_
name|svtype
specifier|const
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSV_type
function_decl|)
parameter_list|(
name|pTHX_
name|svtype
specifier|const
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|newSV_type
end_ifdef

begin_undef
undef|#
directive|undef
name|newSV_type
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|newSV_type
parameter_list|(
name|a
parameter_list|)
value|DPPP_(my_newSV_type)(aTHX_ a)
end_define

begin_define
define|#
directive|define
name|Perl_newSV_type
value|DPPP_(my_newSV_type)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSV_type
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_newSV_type_GLOBAL
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|DPPP_
function|(
name|my_newSV_type
function|)
parameter_list|(
name|pTHX_
name|svtype
specifier|const
name|t
parameter_list|)
block|{
name|SV
modifier|*
specifier|const
name|sv
init|=
name|newSV
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5006000
operator|)
end_if

begin_define
define|#
directive|define
name|D_PPP_CONSTPV_ARG
parameter_list|(
name|x
parameter_list|)
value|((char *) (x))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|D_PPP_CONSTPV_ARG
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvn
end_ifndef

begin_define
define|#
directive|define
name|newSVpvn
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|)
value|((data)                                              \                                     ? ((len) ? newSVpv((data), (len)) : newSVpv("", 0)) \                                     : newSV(0))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvn_utf8
end_ifndef

begin_define
define|#
directive|define
name|newSVpvn_utf8
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|u
parameter_list|)
value|newSVpvn_flags((s), (len), (u) ? SVf_UTF8 : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SVf_UTF8
end_ifndef

begin_define
define|#
directive|define
name|SVf_UTF8
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvn_flags
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSVpvn_flags
argument_list|)
end_if

begin_function_decl
specifier|static
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSVpvn_flags
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSVpvn_flags
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|newSVpvn_flags
end_ifdef

begin_undef
undef|#
directive|undef
name|newSVpvn_flags
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|newSVpvn_flags
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_newSVpvn_flags)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_newSVpvn_flags
value|DPPP_(my_newSVpvn_flags)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSVpvn_flags
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_newSVpvn_flags_GLOBAL
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|DPPP_
function|(
name|my_newSVpvn_flags
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|U32
name|flags
parameter_list|)
block|{
name|SV
modifier|*
name|sv
init|=
name|newSVpvn
argument_list|(
name|D_PPP_CONSTPV_ARG
argument_list|(
name|s
argument_list|)
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|SvFLAGS
argument_list|(
name|sv
argument_list|)
operator||=
operator|(
name|flags
operator|&
name|SVf_UTF8
operator|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|SVs_TEMP
operator|)
condition|?
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
else|:
name|sv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Backwards compatibility stuff... :-( */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEED_sv_2pv_flags
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_sv_2pv_nolen
argument_list|)
end_if

begin_define
define|#
directive|define
name|NEED_sv_2pv_flags
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NEED_sv_2pv_flags_GLOBAL
argument_list|)
operator|&&
name|defined
argument_list|(
name|NEED_sv_2pv_nolen_GLOBAL
argument_list|)
end_if

begin_define
define|#
directive|define
name|NEED_sv_2pv_flags_GLOBAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: sv_2pv_nolen  * Use the SvPV_nolen() or SvPV_nolen_const() macros instead of sv_2pv_nolen().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sv_2pv_nolen
end_ifndef

begin_define
define|#
directive|define
name|sv_2pv_nolen
parameter_list|(
name|sv
parameter_list|)
value|SvPV_nolen(sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SvPVbyte
end_ifdef

begin_comment
comment|/* Hint: SvPVbyte  * Does not work in perl-5.6.1, ppport.h implements a version  * borrowed from perl-5.7.3.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5007000
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_2pvbyte
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_2pvbyte
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_2pvbyte
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sv_2pvbyte
end_ifdef

begin_undef
undef|#
directive|undef
name|sv_2pvbyte
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_2pvbyte
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|DPPP_(my_sv_2pvbyte)(aTHX_ a,b)
end_define

begin_define
define|#
directive|define
name|Perl_sv_2pvbyte
value|DPPP_(my_sv_2pvbyte)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_2pvbyte
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_2pvbyte_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_sv_2pvbyte
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|)
block|{
name|sv_utf8_downgrade
argument_list|(
name|sv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SvPV
argument_list|(
name|sv
argument_list|,
operator|*
name|lp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: sv_2pvbyte  * Use the SvPVbyte() macro instead of sv_2pvbyte().  */
end_comment

begin_undef
undef|#
directive|undef
name|SvPVbyte
end_undef

begin_define
define|#
directive|define
name|SvPVbyte
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK|SVf_UTF8)) == (SVf_POK)                \          ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pvbyte(sv,&lp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SvPVbyte
value|SvPV
end_define

begin_define
define|#
directive|define
name|sv_2pvbyte
value|sv_2pv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_2pvbyte_nolen
end_ifndef

begin_define
define|#
directive|define
name|sv_2pvbyte_nolen
parameter_list|(
name|sv
parameter_list|)
value|sv_2pv_nolen(sv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: sv_pvn  * Always use the SvPV() macro instead of sv_pvn().  */
end_comment

begin_comment
comment|/* Hint: sv_pvn_force  * Always use the SvPV_force() macro instead of sv_pvn_force().  */
end_comment

begin_comment
comment|/* If these are undefined, they're not handled by the core anyway */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SV_IMMEDIATE_UNREF
end_ifndef

begin_define
define|#
directive|define
name|SV_IMMEDIATE_UNREF
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_GMAGIC
end_ifndef

begin_define
define|#
directive|define
name|SV_GMAGIC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_COW_DROP_PV
end_ifndef

begin_define
define|#
directive|define
name|SV_COW_DROP_PV
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_UTF8_NO_ENCODING
end_ifndef

begin_define
define|#
directive|define
name|SV_UTF8_NO_ENCODING
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_NOSTEAL
end_ifndef

begin_define
define|#
directive|define
name|SV_NOSTEAL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_CONST_RETURN
end_ifndef

begin_define
define|#
directive|define
name|SV_CONST_RETURN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_MUTABLE_RETURN
end_ifndef

begin_define
define|#
directive|define
name|SV_MUTABLE_RETURN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_SMAGIC
end_ifndef

begin_define
define|#
directive|define
name|SV_SMAGIC
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_HAS_TRAILING_NUL
end_ifndef

begin_define
define|#
directive|define
name|SV_HAS_TRAILING_NUL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SV_COW_SHARED_HASH_KEYS
end_ifndef

begin_define
define|#
directive|define
name|SV_COW_SHARED_HASH_KEYS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5007002
operator|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_2pv_flags
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_2pv_flags
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_2pv_flags
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sv_2pv_flags
end_ifdef

begin_undef
undef|#
directive|undef
name|sv_2pv_flags
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_2pv_flags
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_sv_2pv_flags)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_sv_2pv_flags
value|DPPP_(my_sv_2pv_flags)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_2pv_flags
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_2pv_flags_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_sv_2pv_flags
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|STRLEN
name|n_a
init|=
operator|(
name|STRLEN
operator|)
name|flags
decl_stmt|;
return|return
name|sv_2pv
argument_list|(
name|sv
argument_list|,
name|lp
condition|?
name|lp
else|:
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_pvn_force_flags
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_pvn_force_flags
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_sv_pvn_force_flags
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sv_pvn_force_flags
end_ifdef

begin_undef
undef|#
directive|undef
name|sv_pvn_force_flags
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_pvn_force_flags
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_sv_pvn_force_flags)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_sv_pvn_force_flags
value|DPPP_(my_sv_pvn_force_flags)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_pvn_force_flags
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_pvn_force_flags_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_sv_pvn_force_flags
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
name|STRLEN
modifier|*
name|lp
parameter_list|,
name|I32
name|flags
parameter_list|)
block|{
name|STRLEN
name|n_a
init|=
operator|(
name|STRLEN
operator|)
name|flags
decl_stmt|;
return|return
name|sv_pvn_force
argument_list|(
name|sv
argument_list|,
name|lp
condition|?
name|lp
else|:
operator|&
name|n_a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5008008
operator|)
operator|||
operator|(
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5009000
operator|)
operator|&&
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5009003
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|DPPP_SVPV_NOLEN_LP_ARG
value|&PL_na
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPPP_SVPV_NOLEN_LP_ARG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_const
end_ifndef

begin_define
define|#
directive|define
name|SvPV_const
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_flags_const(sv, lp, SV_GMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPV_mutable
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_flags_mutable(sv, lp, SV_GMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_flags
end_ifndef

begin_define
define|#
directive|define
name|SvPV_flags
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_2pv_flags(sv,&lp, flags))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_flags_const
end_ifndef

begin_define
define|#
directive|define
name|SvPV_flags_const
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? ((lp = SvCUR(sv)), SvPVX_const(sv)) : \                   (const char*) sv_2pv_flags(sv,&lp, flags|SV_CONST_RETURN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_flags_const_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_flags_const_nolen
parameter_list|(
name|sv
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? SvPVX_const(sv) : \                   (const char*) sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags|SV_CONST_RETURN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_flags_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPV_flags_mutable
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) : \                   sv_2pv_flags(sv,&lp, flags|SV_MUTABLE_RETURN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_force_flags(sv, lp, SV_GMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_nolen
parameter_list|(
name|sv
parameter_list|)
value|SvPV_force_flags_nolen(sv, SV_GMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_mutable
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_force_flags_mutable(sv, lp, SV_GMAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_nomg
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_nomg
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_force_flags(sv, lp, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_nomg_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_nomg_nolen
parameter_list|(
name|sv
parameter_list|)
value|SvPV_force_flags_nolen(sv, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_flags
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_flags
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK|SVf_THINKFIRST)) == SVf_POK \                  ? ((lp = SvCUR(sv)), SvPVX(sv)) : sv_pvn_force_flags(sv,&lp, flags))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_flags_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_flags_nolen
parameter_list|(
name|sv
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK|SVf_THINKFIRST)) == SVf_POK \                  ? SvPVX(sv) : sv_pvn_force_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, flags))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_force_flags_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPV_force_flags_mutable
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|,
name|flags
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK|SVf_THINKFIRST)) == SVf_POK \                  ? ((lp = SvCUR(sv)), SvPVX_mutable(sv)) \                   : sv_pvn_force_flags(sv,&lp, flags|SV_MUTABLE_RETURN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_nolen
parameter_list|(
name|sv
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? SvPVX(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_nolen_const
end_ifndef

begin_define
define|#
directive|define
name|SvPV_nolen_const
parameter_list|(
name|sv
parameter_list|)
define|\
value|((SvFLAGS(sv)& (SVf_POK)) == SVf_POK \                   ? SvPVX_const(sv) : sv_2pv_flags(sv, DPPP_SVPV_NOLEN_LP_ARG, SV_GMAGIC|SV_CONST_RETURN))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_nomg
end_ifndef

begin_define
define|#
directive|define
name|SvPV_nomg
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_flags(sv, lp, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_nomg_const
end_ifndef

begin_define
define|#
directive|define
name|SvPV_nomg_const
parameter_list|(
name|sv
parameter_list|,
name|lp
parameter_list|)
value|SvPV_flags_const(sv, lp, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_nomg_const_nolen
end_ifndef

begin_define
define|#
directive|define
name|SvPV_nomg_const_nolen
parameter_list|(
name|sv
parameter_list|)
value|SvPV_flags_const_nolen(sv, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPV_renew
end_ifndef

begin_define
define|#
directive|define
name|SvPV_renew
parameter_list|(
name|sv
parameter_list|,
name|n
parameter_list|)
value|STMT_START { SvLEN_set(sv, n); \                  SvPV_set((sv), (char *) saferealloc(          \                        (Malloc_t)SvPVX(sv), (MEM_SIZE)((n)))); \                } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvMAGIC_set
end_ifndef

begin_define
define|#
directive|define
name|SvMAGIC_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv)>= SVt_PVMG); \                 (((XPVMG*) SvANY(sv))->xmg_magic = (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5009003
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SvPVX_const
end_ifndef

begin_define
define|#
directive|define
name|SvPVX_const
parameter_list|(
name|sv
parameter_list|)
value|((const char*) (0 + SvPVX(sv)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPVX_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPVX_mutable
parameter_list|(
name|sv
parameter_list|)
value|(0 + SvPVX(sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvRV_set
end_ifndef

begin_define
define|#
directive|define
name|SvRV_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv)>=  SVt_RV); \                 (((XRV*) SvANY(sv))->xrv_rv = (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SvPVX_const
end_ifndef

begin_define
define|#
directive|define
name|SvPVX_const
parameter_list|(
name|sv
parameter_list|)
value|((const char*)((sv)->sv_u.svu_pv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvPVX_mutable
end_ifndef

begin_define
define|#
directive|define
name|SvPVX_mutable
parameter_list|(
name|sv
parameter_list|)
value|((sv)->sv_u.svu_pv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvRV_set
end_ifndef

begin_define
define|#
directive|define
name|SvRV_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv)>=  SVt_RV); \                 ((sv)->sv_u.svu_rv = (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvSTASH_set
end_ifndef

begin_define
define|#
directive|define
name|SvSTASH_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv)>= SVt_PVMG); \                 (((XPVMG*) SvANY(sv))->xmg_stash = (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5004000
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|SvUV_set
end_ifndef

begin_define
define|#
directive|define
name|SvUV_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv)>= SVt_PVIV); \                 (((XPVIV*) SvANY(sv))->xiv_iv = (IV) (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|SvUV_set
end_ifndef

begin_define
define|#
directive|define
name|SvUV_set
parameter_list|(
name|sv
parameter_list|,
name|val
parameter_list|)
define|\
value|STMT_START { assert(SvTYPE(sv) == SVt_IV || SvTYPE(sv)>= SVt_PVIV); \                 (((XPVUV*) SvANY(sv))->xuv_uv = (val)); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|vnewSVpvf
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_vnewSVpvf
argument_list|)
end_if

begin_function_decl
specifier|static
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_vnewSVpvf
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_vnewSVpvf
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vnewSVpvf
end_ifdef

begin_undef
undef|#
directive|undef
name|vnewSVpvf
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|vnewSVpvf
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|DPPP_(my_vnewSVpvf)(aTHX_ a,b)
end_define

begin_define
define|#
directive|define
name|Perl_vnewSVpvf
value|DPPP_(my_vnewSVpvf)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_vnewSVpvf
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_vnewSVpvf_GLOBAL
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|DPPP_
function|(
name|my_vnewSVpvf
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|va_list
modifier|*
name|args
parameter_list|)
block|{
specifier|register
name|SV
modifier|*
name|sv
init|=
name|newSV
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_vcatpvf
argument_list|)
end_if

begin_define
define|#
directive|define
name|sv_vcatpvf
parameter_list|(
name|sv
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
value|sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_vsetpvf
argument_list|)
end_if

begin_define
define|#
directive|define
name|sv_vsetpvf
parameter_list|(
name|sv
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
value|sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_catpvf_mg
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_catpvf_mg
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_sv_catpvf_mg
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_sv_catpvf_mg
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Perl_sv_catpvf_mg
value|DPPP_(my_sv_catpvf_mg)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_catpvf_mg
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_catpvf_mg_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_sv_catpvf_mg
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_catpvf_mg_nocontext
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_catpvf_mg_nocontext
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_sv_catpvf_mg_nocontext
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_sv_catpvf_mg_nocontext
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_catpvf_mg_nocontext
value|DPPP_(my_sv_catpvf_mg_nocontext)
end_define

begin_define
define|#
directive|define
name|Perl_sv_catpvf_mg_nocontext
value|DPPP_(my_sv_catpvf_mg_nocontext)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_catpvf_mg_nocontext
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_catpvf_mg_nocontext_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_sv_catpvf_mg_nocontext
function|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vcatpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sv_catpvf_mg depends on sv_catpvf_mg_nocontext */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catpvf_mg
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_define
define|#
directive|define
name|sv_catpvf_mg
value|Perl_sv_catpvf_mg_nocontext
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sv_catpvf_mg
value|Perl_sv_catpvf_mg
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_vcatpvf_mg
argument_list|)
end_if

begin_define
define|#
directive|define
name|sv_vcatpvf_mg
parameter_list|(
name|sv
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
define|\
value|STMT_START {                                                            \      sv_vcatpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \      SvSETMAGIC(sv);                                                       \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_setpvf_mg
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_setpvf_mg
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_sv_setpvf_mg
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_sv_setpvf_mg
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Perl_sv_setpvf_mg
value|DPPP_(my_sv_setpvf_mg)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_setpvf_mg
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_setpvf_mg_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_sv_setpvf_mg
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_setpvf_mg_nocontext
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_setpvf_mg_nocontext
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_sv_setpvf_mg_nocontext
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_sv_setpvf_mg_nocontext
function_decl|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sv_setpvf_mg_nocontext
value|DPPP_(my_sv_setpvf_mg_nocontext)
end_define

begin_define
define|#
directive|define
name|Perl_sv_setpvf_mg_nocontext
value|DPPP_(my_sv_setpvf_mg_nocontext)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_sv_setpvf_mg_nocontext
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_sv_setpvf_mg_nocontext_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_sv_setpvf_mg_nocontext
function|)
parameter_list|(
name|SV
modifier|*
name|sv
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv_vsetpvfn
argument_list|(
name|sv
argument_list|,
name|pat
argument_list|,
name|strlen
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|args
argument_list|,
name|Null
argument_list|(
name|SV
operator|*
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Null
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SvSETMAGIC
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sv_setpvf_mg depends on sv_setpvf_mg_nocontext */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setpvf_mg
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PERL_IMPLICIT_CONTEXT
end_ifdef

begin_define
define|#
directive|define
name|sv_setpvf_mg
value|Perl_sv_setpvf_mg_nocontext
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sv_setpvf_mg
value|Perl_sv_setpvf_mg
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|sv_vsetpvf_mg
argument_list|)
end_if

begin_define
define|#
directive|define
name|sv_vsetpvf_mg
parameter_list|(
name|sv
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
define|\
value|STMT_START {                                                            \      sv_vsetpvfn(sv, pat, strlen(pat), args, Null(SV**), 0, Null(bool*));  \      SvSETMAGIC(sv);                                                       \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvn_share
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSVpvn_share
argument_list|)
end_if

begin_function_decl
specifier|static
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSVpvn_share
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|SV
modifier|*
name|DPPP_
function_decl|(
name|my_newSVpvn_share
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|newSVpvn_share
end_ifdef

begin_undef
undef|#
directive|undef
name|newSVpvn_share
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|newSVpvn_share
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_newSVpvn_share)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_newSVpvn_share
value|DPPP_(my_newSVpvn_share)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_newSVpvn_share
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_newSVpvn_share_GLOBAL
argument_list|)
end_if

begin_function
name|SV
modifier|*
name|DPPP_
function|(
name|my_newSVpvn_share
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|I32
name|len
parameter_list|,
name|U32
name|hash
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|=
operator|-
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|hash
condition|)
name|PERL_HASH
argument_list|(
name|hash
argument_list|,
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv
operator|=
name|newSVpvn
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sv_upgrade
argument_list|(
name|sv
argument_list|,
name|SVt_PVIV
argument_list|)
expr_stmt|;
name|SvIVX
argument_list|(
name|sv
argument_list|)
operator|=
name|hash
expr_stmt|;
name|SvREADONLY_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|SvPOK_on
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|sv
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvSHARED_HASH
end_ifndef

begin_define
define|#
directive|define
name|SvSHARED_HASH
parameter_list|(
name|sv
parameter_list|)
value|(0 + SvUVX(sv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HvNAME_get
end_ifndef

begin_define
define|#
directive|define
name|HvNAME_get
parameter_list|(
name|hv
parameter_list|)
value|HvNAME(hv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HvNAMELEN_get
end_ifndef

begin_define
define|#
directive|define
name|HvNAMELEN_get
parameter_list|(
name|hv
parameter_list|)
value|(HvNAME_get(hv) ? (I32)strlen(HvNAME_get(hv)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GvSVn
end_ifndef

begin_define
define|#
directive|define
name|GvSVn
parameter_list|(
name|gv
parameter_list|)
value|GvSV(gv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isGV_with_GP
end_ifndef

begin_define
define|#
directive|define
name|isGV_with_GP
parameter_list|(
name|gv
parameter_list|)
value|isGV(gv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_ALL
end_ifndef

begin_define
define|#
directive|define
name|WARN_ALL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_CLOSURE
end_ifndef

begin_define
define|#
directive|define
name|WARN_CLOSURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_DEPRECATED
end_ifndef

begin_define
define|#
directive|define
name|WARN_DEPRECATED
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_EXITING
end_ifndef

begin_define
define|#
directive|define
name|WARN_EXITING
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_GLOB
end_ifndef

begin_define
define|#
directive|define
name|WARN_GLOB
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_IO
end_ifndef

begin_define
define|#
directive|define
name|WARN_IO
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_CLOSED
end_ifndef

begin_define
define|#
directive|define
name|WARN_CLOSED
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_EXEC
end_ifndef

begin_define
define|#
directive|define
name|WARN_EXEC
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_LAYER
end_ifndef

begin_define
define|#
directive|define
name|WARN_LAYER
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_NEWLINE
end_ifndef

begin_define
define|#
directive|define
name|WARN_NEWLINE
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PIPE
end_ifndef

begin_define
define|#
directive|define
name|WARN_PIPE
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_UNOPENED
end_ifndef

begin_define
define|#
directive|define
name|WARN_UNOPENED
value|11
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_MISC
end_ifndef

begin_define
define|#
directive|define
name|WARN_MISC
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_NUMERIC
end_ifndef

begin_define
define|#
directive|define
name|WARN_NUMERIC
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_ONCE
end_ifndef

begin_define
define|#
directive|define
name|WARN_ONCE
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_OVERFLOW
end_ifndef

begin_define
define|#
directive|define
name|WARN_OVERFLOW
value|15
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PACK
end_ifndef

begin_define
define|#
directive|define
name|WARN_PACK
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PORTABLE
end_ifndef

begin_define
define|#
directive|define
name|WARN_PORTABLE
value|17
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_RECURSION
end_ifndef

begin_define
define|#
directive|define
name|WARN_RECURSION
value|18
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_REDEFINE
end_ifndef

begin_define
define|#
directive|define
name|WARN_REDEFINE
value|19
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_REGEXP
end_ifndef

begin_define
define|#
directive|define
name|WARN_REGEXP
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_SEVERE
end_ifndef

begin_define
define|#
directive|define
name|WARN_SEVERE
value|21
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_DEBUGGING
end_ifndef

begin_define
define|#
directive|define
name|WARN_DEBUGGING
value|22
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_INPLACE
end_ifndef

begin_define
define|#
directive|define
name|WARN_INPLACE
value|23
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_INTERNAL
end_ifndef

begin_define
define|#
directive|define
name|WARN_INTERNAL
value|24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_MALLOC
end_ifndef

begin_define
define|#
directive|define
name|WARN_MALLOC
value|25
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_SIGNAL
end_ifndef

begin_define
define|#
directive|define
name|WARN_SIGNAL
value|26
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_SUBSTR
end_ifndef

begin_define
define|#
directive|define
name|WARN_SUBSTR
value|27
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_SYNTAX
end_ifndef

begin_define
define|#
directive|define
name|WARN_SYNTAX
value|28
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_AMBIGUOUS
end_ifndef

begin_define
define|#
directive|define
name|WARN_AMBIGUOUS
value|29
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_BAREWORD
end_ifndef

begin_define
define|#
directive|define
name|WARN_BAREWORD
value|30
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_DIGIT
end_ifndef

begin_define
define|#
directive|define
name|WARN_DIGIT
value|31
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PARENTHESIS
end_ifndef

begin_define
define|#
directive|define
name|WARN_PARENTHESIS
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PRECEDENCE
end_ifndef

begin_define
define|#
directive|define
name|WARN_PRECEDENCE
value|33
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PRINTF
end_ifndef

begin_define
define|#
directive|define
name|WARN_PRINTF
value|34
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_PROTOTYPE
end_ifndef

begin_define
define|#
directive|define
name|WARN_PROTOTYPE
value|35
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_QW
end_ifndef

begin_define
define|#
directive|define
name|WARN_QW
value|36
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_RESERVED
end_ifndef

begin_define
define|#
directive|define
name|WARN_RESERVED
value|37
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_SEMICOLON
end_ifndef

begin_define
define|#
directive|define
name|WARN_SEMICOLON
value|38
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_TAINT
end_ifndef

begin_define
define|#
directive|define
name|WARN_TAINT
value|39
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_THREADS
end_ifndef

begin_define
define|#
directive|define
name|WARN_THREADS
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_UNINITIALIZED
end_ifndef

begin_define
define|#
directive|define
name|WARN_UNINITIALIZED
value|41
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_UNPACK
end_ifndef

begin_define
define|#
directive|define
name|WARN_UNPACK
value|42
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_UNTIE
end_ifndef

begin_define
define|#
directive|define
name|WARN_UNTIE
value|43
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_UTF8
end_ifndef

begin_define
define|#
directive|define
name|WARN_UTF8
value|44
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_VOID
end_ifndef

begin_define
define|#
directive|define
name|WARN_VOID
value|45
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WARN_ASSERTIONS
end_ifndef

begin_define
define|#
directive|define
name|WARN_ASSERTIONS
value|46
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|packWARN
end_ifndef

begin_define
define|#
directive|define
name|packWARN
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ckWARN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|G_WARN_ON
end_ifdef

begin_define
define|#
directive|define
name|ckWARN
parameter_list|(
name|a
parameter_list|)
value|(PL_dowarn& G_WARN_ON)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ckWARN
parameter_list|(
name|a
parameter_list|)
value|PL_dowarn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|>=
literal|0x5004000
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|warner
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_warner
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|DPPP_
function_decl|(
name|my_warner
function_decl|)
parameter_list|(
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|void
name|DPPP_
function_decl|(
name|my_warner
function_decl|)
parameter_list|(
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Perl_warner
value|DPPP_(my_warner)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_warner
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_warner_GLOBAL
argument_list|)
end_if

begin_function
name|void
name|DPPP_
function|(
name|my_warner
function|)
parameter_list|(
name|U32
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|SV
modifier|*
name|sv
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|PERL_UNUSED_ARG
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|sv
operator|=
name|vnewSVpvf
argument_list|(
name|pat
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sv_2mortal
argument_list|(
name|sv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|SvPV_nolen
argument_list|(
name|sv
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|warner
value|Perl_warner
end_define

begin_define
define|#
directive|define
name|Perl_warner_nocontext
value|Perl_warner
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* concatenating with "" ensures that only literal strings are accepted as argument  * note that STR_WITH_LEN() can't be used as argument to macros or functions that  * under some configurations might be macros  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STR_WITH_LEN
end_ifndef

begin_define
define|#
directive|define
name|STR_WITH_LEN
parameter_list|(
name|s
parameter_list|)
value|(s ""), (sizeof(s)-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvs
end_ifndef

begin_define
define|#
directive|define
name|newSVpvs
parameter_list|(
name|str
parameter_list|)
value|newSVpvn(str "", sizeof(str) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|newSVpvs_flags
end_ifndef

begin_define
define|#
directive|define
name|newSVpvs_flags
parameter_list|(
name|str
parameter_list|,
name|flags
parameter_list|)
value|newSVpvn_flags(str "", sizeof(str) - 1, flags)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catpvs
end_ifndef

begin_define
define|#
directive|define
name|sv_catpvs
parameter_list|(
name|sv
parameter_list|,
name|str
parameter_list|)
value|sv_catpvn(sv, str "", sizeof(str) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setpvs
end_ifndef

begin_define
define|#
directive|define
name|sv_setpvs
parameter_list|(
name|sv
parameter_list|,
name|str
parameter_list|)
value|sv_setpvn(sv, str "", sizeof(str) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|hv_fetchs
end_ifndef

begin_define
define|#
directive|define
name|hv_fetchs
parameter_list|(
name|hv
parameter_list|,
name|key
parameter_list|,
name|lval
parameter_list|)
value|hv_fetch(hv, key "", sizeof(key) - 1, lval)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|hv_stores
end_ifndef

begin_define
define|#
directive|define
name|hv_stores
parameter_list|(
name|hv
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
value|hv_store(hv, key "", sizeof(key) - 1, val, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|gv_fetchpvn_flags
end_ifndef

begin_define
define|#
directive|define
name|gv_fetchpvn_flags
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|,
name|svt
parameter_list|)
value|gv_fetchpv(name, flags, svt)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|gv_fetchpvs
end_ifndef

begin_define
define|#
directive|define
name|gv_fetchpvs
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|svt
parameter_list|)
value|gv_fetchpvn_flags(name "", sizeof(name) - 1, flags, svt)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|gv_stashpvs
end_ifndef

begin_define
define|#
directive|define
name|gv_stashpvs
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
value|gv_stashpvn(name "", sizeof(name) - 1, flags)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvGETMAGIC
end_ifndef

begin_define
define|#
directive|define
name|SvGETMAGIC
parameter_list|(
name|x
parameter_list|)
value|STMT_START { if (SvGMAGICAL(x)) mg_get(x); } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_sv
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_sv
value|'\0'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_overload
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_overload
value|'A'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_overload_elem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_overload_elem
value|'a'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_overload_table
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_overload_table
value|'c'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_bm
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_bm
value|'B'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_regdata
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_regdata
value|'D'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_regdatum
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_regdatum
value|'d'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_env
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_env
value|'E'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_envelem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_envelem
value|'e'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_fm
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_fm
value|'f'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_regex_global
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_regex_global
value|'g'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_isa
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_isa
value|'I'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_isaelem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_isaelem
value|'i'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_nkeys
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_nkeys
value|'k'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_dbfile
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_dbfile
value|'L'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_dbline
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_dbline
value|'l'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_mutex
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_mutex
value|'m'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_shared
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_shared
value|'N'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_shared_scalar
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_shared_scalar
value|'n'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_collxfrm
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_collxfrm
value|'o'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_tied
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_tied
value|'P'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_tiedelem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_tiedelem
value|'p'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_tiedscalar
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_tiedscalar
value|'q'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_qr
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_qr
value|'r'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_sig
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_sig
value|'S'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_sigelem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_sigelem
value|'s'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_taint
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_taint
value|'t'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_uvar
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_uvar
value|'U'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_uvar_elem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_uvar_elem
value|'u'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_vstring
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_vstring
value|'V'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_vec
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_vec
value|'v'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_utf8
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_utf8
value|'w'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_substr
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_substr
value|'x'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_defelem
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_defelem
value|'y'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_glob
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_glob
value|'*'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_arylen
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_arylen
value|'#'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_pos
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_pos
value|'.'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_backref
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_backref
value|'<'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_MAGIC_ext
end_ifndef

begin_define
define|#
directive|define
name|PERL_MAGIC_ext
value|'~'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* That's the best we can do... */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catpvn_nomg
end_ifndef

begin_define
define|#
directive|define
name|sv_catpvn_nomg
value|sv_catpvn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catsv_nomg
end_ifndef

begin_define
define|#
directive|define
name|sv_catsv_nomg
value|sv_catsv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setsv_nomg
end_ifndef

begin_define
define|#
directive|define
name|sv_setsv_nomg
value|sv_setsv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_pvn_nomg
end_ifndef

begin_define
define|#
directive|define
name|sv_pvn_nomg
value|sv_pvn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvIV_nomg
end_ifndef

begin_define
define|#
directive|define
name|SvIV_nomg
value|SvIV
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvUV_nomg
end_ifndef

begin_define
define|#
directive|define
name|SvUV_nomg
value|SvUV
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catpv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_catpv_mg
parameter_list|(
name|sv
parameter_list|,
name|ptr
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_catpv(TeMpSv,ptr);              \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catpvn_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_catpvn_mg
parameter_list|(
name|sv
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_catpvn(TeMpSv,ptr,len);         \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_catsv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_catsv_mg
parameter_list|(
name|dsv
parameter_list|,
name|ssv
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = dsv;                  \      sv_catsv(TeMpSv,ssv);              \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setiv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setiv_mg
parameter_list|(
name|sv
parameter_list|,
name|i
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_setiv(TeMpSv,i);                \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setnv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setnv_mg
parameter_list|(
name|sv
parameter_list|,
name|num
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_setnv(TeMpSv,num);              \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setpv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setpv_mg
parameter_list|(
name|sv
parameter_list|,
name|ptr
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_setpv(TeMpSv,ptr);              \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setpvn_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setpvn_mg
parameter_list|(
name|sv
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_setpvn(TeMpSv,ptr,len);         \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setsv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setsv_mg
parameter_list|(
name|dsv
parameter_list|,
name|ssv
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = dsv;                  \      sv_setsv(TeMpSv,ssv);              \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_setuv_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_setuv_mg
parameter_list|(
name|sv
parameter_list|,
name|i
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_setuv(TeMpSv,i);                \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sv_usepvn_mg
end_ifndef

begin_define
define|#
directive|define
name|sv_usepvn_mg
parameter_list|(
name|sv
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
define|\
value|STMT_START {                         \      SV *TeMpSv = sv;                   \      sv_usepvn(TeMpSv,ptr,len);         \      SvSETMAGIC(TeMpSv);                \    } STMT_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SvVSTRING_mg
end_ifndef

begin_define
define|#
directive|define
name|SvVSTRING_mg
parameter_list|(
name|sv
parameter_list|)
value|(SvMAGICAL(sv) ? mg_find(sv, PERL_MAGIC_vstring) : NULL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: sv_magic_portable  * This is a compatibility function that is only available with  * Devel::PPPort. It is NOT in the perl core.  * Its purpose is to mimic the 5.8.0 behaviour of sv_magic() when  * it is being passed a name pointer with namlen == 0. In that  * case, perl 5.8.0 and later store the pointer, not a copy of it.  * The compatibility can be provided back to perl 5.004. With  * earlier versions, the code will not compile.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5004000
operator|)
end_if

begin_comment
comment|/* code that uses sv_magic_portable will not compile */
end_comment

begin_elif
elif|#
directive|elif
operator|(
name|PERL_BCDVERSION
operator|<
literal|0x5008000
operator|)
end_elif

begin_define
define|#
directive|define
name|sv_magic_portable
parameter_list|(
name|sv
parameter_list|,
name|obj
parameter_list|,
name|how
parameter_list|,
name|name
parameter_list|,
name|namlen
parameter_list|)
define|\
value|STMT_START {                                             \      SV *SvMp_sv = (sv);                                    \      char *SvMp_name = (char *) (name);                     \      I32 SvMp_namlen = (namlen);                            \      if (SvMp_name&& SvMp_namlen == 0)                     \      {                                                      \        MAGIC *mg;                                           \        sv_magic(SvMp_sv, obj, how, 0, 0);                   \        mg = SvMAGIC(SvMp_sv);                               \        mg->mg_len = -42;
comment|/* XXX: this is the tricky part */
value|\        mg->mg_ptr = SvMp_name;                              \      }                                                      \      else                                                   \      {                                                      \        sv_magic(SvMp_sv, obj, how, SvMp_name, SvMp_namlen); \      }                                                      \    } STMT_END
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sv_magic_portable
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|sv_magic(a, b, c, d, e)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ITHREADS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILE
end_ifndef

begin_define
define|#
directive|define
name|CopFILE
parameter_list|(
name|c
parameter_list|)
value|((c)->cop_file)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILEGV
end_ifndef

begin_define
define|#
directive|define
name|CopFILEGV
parameter_list|(
name|c
parameter_list|)
value|(CopFILE(c) ? gv_fetchfile(CopFILE(c)) : Nullgv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILE_set
end_ifndef

begin_define
define|#
directive|define
name|CopFILE_set
parameter_list|(
name|c
parameter_list|,
name|pv
parameter_list|)
value|((c)->cop_file = savepv(pv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILESV
end_ifndef

begin_define
define|#
directive|define
name|CopFILESV
parameter_list|(
name|c
parameter_list|)
value|(CopFILE(c) ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILEAV
end_ifndef

begin_define
define|#
directive|define
name|CopFILEAV
parameter_list|(
name|c
parameter_list|)
value|(CopFILE(c) ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASHPV
end_ifndef

begin_define
define|#
directive|define
name|CopSTASHPV
parameter_list|(
name|c
parameter_list|)
value|((c)->cop_stashpv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASHPV_set
end_ifndef

begin_define
define|#
directive|define
name|CopSTASHPV_set
parameter_list|(
name|c
parameter_list|,
name|pv
parameter_list|)
value|((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH
parameter_list|(
name|c
parameter_list|)
value|(CopSTASHPV(c) ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH_set
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH_set
parameter_list|(
name|c
parameter_list|,
name|hv
parameter_list|)
value|CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH_eq
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH_eq
parameter_list|(
name|c
parameter_list|,
name|hv
parameter_list|)
value|((hv)&& (CopSTASHPV(c) == HvNAME(hv) \ 					|| (CopSTASHPV(c)&& HvNAME(hv) \&& strEQ(CopSTASHPV(c), HvNAME(hv)))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILEGV
end_ifndef

begin_define
define|#
directive|define
name|CopFILEGV
parameter_list|(
name|c
parameter_list|)
value|((c)->cop_filegv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILEGV_set
end_ifndef

begin_define
define|#
directive|define
name|CopFILEGV_set
parameter_list|(
name|c
parameter_list|,
name|gv
parameter_list|)
value|((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILE_set
end_ifndef

begin_define
define|#
directive|define
name|CopFILE_set
parameter_list|(
name|c
parameter_list|,
name|pv
parameter_list|)
value|CopFILEGV_set((c), gv_fetchfile(pv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILESV
end_ifndef

begin_define
define|#
directive|define
name|CopFILESV
parameter_list|(
name|c
parameter_list|)
value|(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILEAV
end_ifndef

begin_define
define|#
directive|define
name|CopFILEAV
parameter_list|(
name|c
parameter_list|)
value|(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopFILE
end_ifndef

begin_define
define|#
directive|define
name|CopFILE
parameter_list|(
name|c
parameter_list|)
value|(CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH
parameter_list|(
name|c
parameter_list|)
value|((c)->cop_stash)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH_set
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH_set
parameter_list|(
name|c
parameter_list|,
name|hv
parameter_list|)
value|((c)->cop_stash = (hv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASHPV
end_ifndef

begin_define
define|#
directive|define
name|CopSTASHPV
parameter_list|(
name|c
parameter_list|)
value|(CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASHPV_set
end_ifndef

begin_define
define|#
directive|define
name|CopSTASHPV_set
parameter_list|(
name|c
parameter_list|,
name|pv
parameter_list|)
value|CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CopSTASH_eq
end_ifndef

begin_define
define|#
directive|define
name|CopSTASH_eq
parameter_list|(
name|c
parameter_list|,
name|hv
parameter_list|)
value|(CopSTASH(c) == (hv))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ITHREADS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_PERL_COMPILETIME
end_ifndef

begin_define
define|#
directive|define
name|IN_PERL_COMPILETIME
value|(PL_curcop ==&PL_compiling)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IN_LOCALE_RUNTIME
end_ifndef

begin_define
define|#
directive|define
name|IN_LOCALE_RUNTIME
value|(PL_curcop->op_private& HINT_LOCALE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IN_LOCALE_COMPILETIME
end_ifndef

begin_define
define|#
directive|define
name|IN_LOCALE_COMPILETIME
value|(PL_hints& HINT_LOCALE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IN_LOCALE
end_ifndef

begin_define
define|#
directive|define
name|IN_LOCALE
value|(IN_PERL_COMPILETIME ? IN_LOCALE_COMPILETIME : IN_LOCALE_RUNTIME)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_IN_UV
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_IN_UV
value|0x01
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_GREATER_THAN_UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_GREATER_THAN_UV_MAX
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_NOT_INT
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_NOT_INT
value|0x04
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_NEG
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_NEG
value|0x08
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_INFINITY
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_INFINITY
value|0x10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IS_NUMBER_NAN
end_ifndef

begin_define
define|#
directive|define
name|IS_NUMBER_NAN
value|0x20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GROK_NUMERIC_RADIX
end_ifndef

begin_define
define|#
directive|define
name|GROK_NUMERIC_RADIX
parameter_list|(
name|sp
parameter_list|,
name|send
parameter_list|)
value|grok_numeric_radix(sp, send)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SCAN_GREATER_THAN_UV_MAX
end_ifndef

begin_define
define|#
directive|define
name|PERL_SCAN_GREATER_THAN_UV_MAX
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SCAN_SILENT_ILLDIGIT
end_ifndef

begin_define
define|#
directive|define
name|PERL_SCAN_SILENT_ILLDIGIT
value|0x04
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SCAN_ALLOW_UNDERSCORES
end_ifndef

begin_define
define|#
directive|define
name|PERL_SCAN_ALLOW_UNDERSCORES
value|0x01
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_SCAN_DISALLOW_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PERL_SCAN_DISALLOW_PREFIX
value|0x02
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|grok_numeric_radix
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_numeric_radix
argument_list|)
end_if

begin_function_decl
specifier|static
name|bool
name|DPPP_
function_decl|(
name|my_grok_numeric_radix
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|send
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|bool
name|DPPP_
function_decl|(
name|my_grok_numeric_radix
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|send
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|grok_numeric_radix
end_ifdef

begin_undef
undef|#
directive|undef
name|grok_numeric_radix
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|grok_numeric_radix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|DPPP_(my_grok_numeric_radix)(aTHX_ a,b)
end_define

begin_define
define|#
directive|define
name|Perl_grok_numeric_radix
value|DPPP_(my_grok_numeric_radix)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_numeric_radix
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_grok_numeric_radix_GLOBAL
argument_list|)
end_if

begin_function
name|bool
name|DPPP_
function|(
name|my_grok_numeric_radix
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|send
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LOCALE_NUMERIC
ifdef|#
directive|ifdef
name|PL_numeric_radix_sv
if|if
condition|(
name|PL_numeric_radix_sv
operator|&&
name|IN_LOCALE
condition|)
block|{
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|radix
init|=
name|SvPV
argument_list|(
name|PL_numeric_radix_sv
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sp
operator|+
name|len
operator|<=
name|send
operator|&&
name|memEQ
argument_list|(
operator|*
name|sp
argument_list|,
name|radix
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|+=
name|len
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
else|#
directive|else
comment|/* older perls don't have PL_numeric_radix_sv so the radix      * must manually be requested from locale.h      */
include|#
directive|include
file|<locale.h>
name|dTHR
expr_stmt|;
comment|/* needed for older threaded perls */
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
name|char
modifier|*
name|radix
init|=
name|lc
operator|->
name|decimal_point
decl_stmt|;
if|if
condition|(
name|radix
operator|&&
name|IN_LOCALE
condition|)
block|{
name|STRLEN
name|len
init|=
name|strlen
argument_list|(
name|radix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sp
operator|+
name|len
operator|<=
name|send
operator|&&
name|memEQ
argument_list|(
operator|*
name|sp
argument_list|,
name|radix
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|+=
name|len
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_LOCALE_NUMERIC */
comment|/* always try "." if numeric radix didn't match because      * we may have data from different locales mixed */
if|if
condition|(
operator|*
name|sp
operator|<
name|send
operator|&&
operator|*
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
operator|++
operator|*
name|sp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|grok_number
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_number
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|DPPP_
function_decl|(
name|my_grok_number
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|UV
modifier|*
name|valuep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|int
name|DPPP_
function_decl|(
name|my_grok_number
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|UV
modifier|*
name|valuep
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|grok_number
end_ifdef

begin_undef
undef|#
directive|undef
name|grok_number
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|grok_number
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|DPPP_(my_grok_number)(aTHX_ a,b,c)
end_define

begin_define
define|#
directive|define
name|Perl_grok_number
value|DPPP_(my_grok_number)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_number
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_grok_number_GLOBAL
argument_list|)
end_if

begin_function
name|int
name|DPPP_
function|(
name|my_grok_number
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|UV
modifier|*
name|valuep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|pv
decl_stmt|;
specifier|const
name|char
modifier|*
name|send
init|=
name|pv
operator|+
name|len
decl_stmt|;
specifier|const
name|UV
name|max_div_10
init|=
name|UV_MAX
operator|/
literal|10
decl_stmt|;
specifier|const
name|char
name|max_mod_10
init|=
name|UV_MAX
operator|%
literal|10
decl_stmt|;
name|int
name|numtype
init|=
literal|0
decl_stmt|;
name|int
name|sawinf
init|=
literal|0
decl_stmt|;
name|int
name|sawnan
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|numtype
operator|=
name|IS_NUMBER_NEG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
return|return
literal|0
return|;
comment|/* next must be digit or the radix separator or beginning of infinity */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
comment|/* UVs are at least 32 bits, so the first 9 decimal digits cannot        overflow.  */
name|UV
name|value
init|=
operator|*
name|s
operator|-
literal|'0'
decl_stmt|;
comment|/* This construction seems to be more optimiser friendly.        (without it gcc does the isDIGIT test and the *s - '0' separately)        With it gcc on arm is managing 6 instructions (6 cycles) per digit.        In theory the optimiser could deduce how far to unroll the loop        before checking for overflow.  */
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|int
name|digit
init|=
operator|*
name|s
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
block|{
comment|/* Now got 9 digits, so need to check                                          each time for overflow.  */
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
operator|&&
operator|(
name|value
operator|<
name|max_div_10
operator|||
operator|(
name|value
operator|==
name|max_div_10
operator|&&
name|digit
operator|<=
name|max_mod_10
operator|)
operator|)
condition|)
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
if|if
condition|(
operator|++
name|s
operator|<
name|send
condition|)
name|digit
operator|=
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|9
operator|&&
operator|(
name|s
operator|<
name|send
operator|)
condition|)
block|{
comment|/* value overflowed.                                            skip the remaining digits, don't                                            worry about setting *valuep.  */
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
name|numtype
operator||=
name|IS_NUMBER_GREATER_THAN_UV_MAX
expr_stmt|;
goto|goto
name|skip_value
goto|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|numtype
operator||=
name|IS_NUMBER_IN_UV
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
name|skip_value
label|:
if|if
condition|(
name|GROK_NUMERIC_RADIX
argument_list|(
operator|&
name|s
argument_list|,
name|send
argument_list|)
condition|)
block|{
name|numtype
operator||=
name|IS_NUMBER_NOT_INT
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
comment|/* optional digits after the radix */
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GROK_NUMERIC_RADIX
argument_list|(
operator|&
name|s
argument_list|,
name|send
argument_list|)
condition|)
block|{
name|numtype
operator||=
name|IS_NUMBER_NOT_INT
operator||
name|IS_NUMBER_IN_UV
expr_stmt|;
comment|/* valuep assigned below */
comment|/* no digits before the radix means we need digits after it */
if|if
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|valuep
condition|)
block|{
comment|/* integer approximation is valid - it's 0.  */
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'I'
operator|||
operator|*
name|s
operator|==
literal|'i'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'N'
operator|&&
operator|*
name|s
operator|!=
literal|'n'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'F'
operator|&&
operator|*
name|s
operator|!=
literal|'f'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'I'
operator|||
operator|*
name|s
operator|==
literal|'i'
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'N'
operator|&&
operator|*
name|s
operator|!=
literal|'n'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'I'
operator|&&
operator|*
name|s
operator|!=
literal|'i'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'T'
operator|&&
operator|*
name|s
operator|!=
literal|'t'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'Y'
operator|&&
operator|*
name|s
operator|!=
literal|'y'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
block|}
name|sawinf
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'N'
operator|||
operator|*
name|s
operator|==
literal|'n'
condition|)
block|{
comment|/* XXX TODO: There are signaling NaNs and quiet NaNs. */
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'A'
operator|&&
operator|*
name|s
operator|!=
literal|'a'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'N'
operator|&&
operator|*
name|s
operator|!=
literal|'n'
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
name|sawnan
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|sawinf
condition|)
block|{
name|numtype
operator|&=
name|IS_NUMBER_NEG
expr_stmt|;
comment|/* Keep track of sign  */
name|numtype
operator||=
name|IS_NUMBER_INFINITY
operator||
name|IS_NUMBER_NOT_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sawnan
condition|)
block|{
name|numtype
operator|&=
name|IS_NUMBER_NEG
expr_stmt|;
comment|/* Keep track of sign  */
name|numtype
operator||=
name|IS_NUMBER_NAN
operator||
name|IS_NUMBER_NOT_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|<
name|send
condition|)
block|{
comment|/* we can have an optional exponent part */
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'E'
condition|)
block|{
comment|/* The only flag we keep is sign.  Blow away any "it's UV"  */
name|numtype
operator|&=
name|IS_NUMBER_NEG
expr_stmt|;
name|numtype
operator||=
name|IS_NUMBER_NOT_INT
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|||
operator|*
name|s
operator|==
literal|'+'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
return|return
name|numtype
return|;
if|if
condition|(
name|len
operator|==
literal|10
operator|&&
name|memEQ
argument_list|(
name|pv
argument_list|,
literal|"0 but true"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
return|return
name|IS_NUMBER_IN_UV
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The grok_* routines have been modified to use warn() instead of  * Perl_warner(). Also, 'hexdigit' was the former name of PL_hexdigit,  * which is why the stack variable has been renamed to 'xdigit'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|grok_bin
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_bin
argument_list|)
end_if

begin_function_decl
specifier|static
name|UV
name|DPPP_
function_decl|(
name|my_grok_bin
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|UV
name|DPPP_
function_decl|(
name|my_grok_bin
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|grok_bin
end_ifdef

begin_undef
undef|#
directive|undef
name|grok_bin
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|grok_bin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|DPPP_(my_grok_bin)(aTHX_ a,b,c,d)
end_define

begin_define
define|#
directive|define
name|Perl_grok_bin
value|DPPP_(my_grok_bin)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_bin
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_grok_bin_GLOBAL
argument_list|)
end_if

begin_function
name|UV
name|DPPP_
function|(
name|my_grok_bin
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
name|STRLEN
name|len
init|=
operator|*
name|len_p
decl_stmt|;
name|UV
name|value
init|=
literal|0
decl_stmt|;
name|NV
name|value_nv
init|=
literal|0
decl_stmt|;
specifier|const
name|UV
name|max_div_2
init|=
name|UV_MAX
operator|/
literal|2
decl_stmt|;
name|bool
name|allow_underscores
init|=
operator|*
name|flags
operator|&
name|PERL_SCAN_ALLOW_UNDERSCORES
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|PERL_SCAN_DISALLOW_PREFIX
operator|)
condition|)
block|{
comment|/* strip off leading b or 0b.            for compatibility silently suffer "b" and "0b" as valid binary            numbers. */
if|if
condition|(
name|len
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'b'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|char
name|bit
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|bit
operator|==
literal|'0'
operator|||
name|bit
operator|==
literal|'1'
condition|)
block|{
comment|/* Write it in this wonky order with a goto to attempt to get the                compiler to make the common case integer-only loop pretty tight.                With gcc seems to be much straighter code than old scan_bin.  */
name|redo
label|:
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
if|if
condition|(
name|value
operator|<=
name|max_div_2
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|1
operator|)
operator||
operator|(
name|bit
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Bah. We're just overflowed.  */
name|warn
argument_list|(
literal|"Integer overflow in binary number"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|value_nv
operator|=
operator|(
name|NV
operator|)
name|value
expr_stmt|;
block|}
name|value_nv
operator|*=
literal|2.0
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent a UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply value_nv by the 	     * right amount. */
name|value_nv
operator|+=
call|(
name|NV
call|)
argument_list|(
name|bit
operator|-
literal|'0'
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bit
operator|==
literal|'_'
operator|&&
name|len
operator|&&
name|allow_underscores
operator|&&
operator|(
name|bit
operator|=
name|s
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|bit
operator|==
literal|'0'
operator|||
name|bit
operator|==
literal|'1'
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|PERL_SCAN_SILENT_ILLDIGIT
operator|)
condition|)
name|warn
argument_list|(
literal|"Illegal binary digit '%c' ignored"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|value_nv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|value
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
name|warn
argument_list|(
literal|"Binary number> 0b11111111111111111111111111111111 non-portable"
argument_list|)
expr_stmt|;
block|}
operator|*
name|len_p
operator|=
name|s
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
operator|*
name|flags
operator|=
name|PERL_SCAN_GREATER_THAN_UV_MAX
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|value_nv
expr_stmt|;
return|return
name|UV_MAX
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|grok_hex
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_hex
argument_list|)
end_if

begin_function_decl
specifier|static
name|UV
name|DPPP_
function_decl|(
name|my_grok_hex
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|UV
name|DPPP_
function_decl|(
name|my_grok_hex
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|grok_hex
end_ifdef

begin_undef
undef|#
directive|undef
name|grok_hex
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|grok_hex
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|DPPP_(my_grok_hex)(aTHX_ a,b,c,d)
end_define

begin_define
define|#
directive|define
name|Perl_grok_hex
value|DPPP_(my_grok_hex)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_hex
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_grok_hex_GLOBAL
argument_list|)
end_if

begin_function
name|UV
name|DPPP_
function|(
name|my_grok_hex
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
name|STRLEN
name|len
init|=
operator|*
name|len_p
decl_stmt|;
name|UV
name|value
init|=
literal|0
decl_stmt|;
name|NV
name|value_nv
init|=
literal|0
decl_stmt|;
specifier|const
name|UV
name|max_div_16
init|=
name|UV_MAX
operator|/
literal|16
decl_stmt|;
name|bool
name|allow_underscores
init|=
operator|*
name|flags
operator|&
name|PERL_SCAN_ALLOW_UNDERSCORES
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|xdigit
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|PERL_SCAN_DISALLOW_PREFIX
operator|)
condition|)
block|{
comment|/* strip off leading x or 0x.            for compatibility silently suffer "x" and "0x" as valid hex numbers.         */
if|if
condition|(
name|len
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'x'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|xdigit
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_hexdigit
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdigit
condition|)
block|{
comment|/* Write it in this wonky order with a goto to attempt to get the                compiler to make the common case integer-only loop pretty tight.                With gcc seems to be much straighter code than old scan_hex.  */
name|redo
label|:
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
if|if
condition|(
name|value
operator|<=
name|max_div_16
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|xdigit
operator|-
name|PL_hexdigit
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
continue|continue;
block|}
name|warn
argument_list|(
literal|"Integer overflow in hexadecimal number"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|value_nv
operator|=
operator|(
name|NV
operator|)
name|value
expr_stmt|;
block|}
name|value_nv
operator|*=
literal|16.0
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent a UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply value_nv by the 	     * right amount of 16-tuples. */
name|value_nv
operator|+=
call|(
name|NV
call|)
argument_list|(
operator|(
name|xdigit
operator|-
name|PL_hexdigit
operator|)
operator|&
literal|15
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
operator|&&
name|len
operator|&&
name|allow_underscores
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
operator|(
name|xdigit
operator|=
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PL_hexdigit
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|PERL_SCAN_SILENT_ILLDIGIT
operator|)
condition|)
name|warn
argument_list|(
literal|"Illegal hexadecimal digit '%c' ignored"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|value_nv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|value
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
name|warn
argument_list|(
literal|"Hexadecimal number> 0xffffffff non-portable"
argument_list|)
expr_stmt|;
block|}
operator|*
name|len_p
operator|=
name|s
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
operator|*
name|flags
operator|=
name|PERL_SCAN_GREATER_THAN_UV_MAX
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|value_nv
expr_stmt|;
return|return
name|UV_MAX
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|grok_oct
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_oct
argument_list|)
end_if

begin_function_decl
specifier|static
name|UV
name|DPPP_
function_decl|(
name|my_grok_oct
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|UV
name|DPPP_
function_decl|(
name|my_grok_oct
function_decl|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|grok_oct
end_ifdef

begin_undef
undef|#
directive|undef
name|grok_oct
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|grok_oct
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|DPPP_(my_grok_oct)(aTHX_ a,b,c,d)
end_define

begin_define
define|#
directive|define
name|Perl_grok_oct
value|DPPP_(my_grok_oct)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_grok_oct
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_grok_oct_GLOBAL
argument_list|)
end_if

begin_function
name|UV
name|DPPP_
function|(
name|my_grok_oct
function|)
parameter_list|(
name|pTHX_
specifier|const
name|char
modifier|*
name|start
parameter_list|,
name|STRLEN
modifier|*
name|len_p
parameter_list|,
name|I32
modifier|*
name|flags
parameter_list|,
name|NV
modifier|*
name|result
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
name|STRLEN
name|len
init|=
operator|*
name|len_p
decl_stmt|;
name|UV
name|value
init|=
literal|0
decl_stmt|;
name|NV
name|value_nv
init|=
literal|0
decl_stmt|;
specifier|const
name|UV
name|max_div_8
init|=
name|UV_MAX
operator|/
literal|8
decl_stmt|;
name|bool
name|allow_underscores
init|=
operator|*
name|flags
operator|&
name|PERL_SCAN_ALLOW_UNDERSCORES
decl_stmt|;
name|bool
name|overflowed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
init|;
name|len
operator|--
operator|&&
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
comment|/* gcc 2.95 optimiser not smart enough to figure that this subtraction             out front allows slicker code.  */
name|int
name|digit
init|=
operator|*
name|s
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|7
condition|)
block|{
comment|/* Write it in this wonky order with a goto to attempt to get the                compiler to make the common case integer-only loop pretty tight.             */
name|redo
label|:
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
if|if
condition|(
name|value
operator|<=
name|max_div_8
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|3
operator|)
operator||
name|digit
expr_stmt|;
continue|continue;
block|}
comment|/* Bah. We're just overflowed.  */
name|warn
argument_list|(
literal|"Integer overflow in octal number"
argument_list|)
expr_stmt|;
name|overflowed
operator|=
name|TRUE
expr_stmt|;
name|value_nv
operator|=
operator|(
name|NV
operator|)
name|value
expr_stmt|;
block|}
name|value_nv
operator|*=
literal|8.0
expr_stmt|;
comment|/* If an NV has not enough bits in its mantissa to 	     * represent a UV this summing of small low-order numbers 	     * is a waste of time (because the NV cannot preserve 	     * the low-order bits anyway): we could just remember when 	     * did we overflow and in the end just multiply value_nv by the 	     * right amount of 8-tuples. */
name|value_nv
operator|+=
operator|(
name|NV
operator|)
name|digit
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|digit
operator|==
operator|(
literal|'_'
operator|-
literal|'0'
operator|)
operator|&&
name|len
operator|&&
name|allow_underscores
operator|&&
operator|(
name|digit
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|&&
operator|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<=
literal|7
operator|)
condition|)
block|{
operator|--
name|len
expr_stmt|;
operator|++
name|s
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
comment|/* Allow \octal to work the DWIM way (that is, stop scanning          * as soon as non-octal characters are seen, complain only iff          * someone seems to want to use the digits eight and nine). */
if|if
condition|(
name|digit
operator|==
literal|8
operator|||
name|digit
operator|==
literal|9
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|PERL_SCAN_SILENT_ILLDIGIT
operator|)
condition|)
name|warn
argument_list|(
literal|"Illegal octal digit '%c' ignored"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|overflowed
operator|&&
name|value_nv
operator|>
literal|4294967295.0
operator|)
if|#
directive|if
name|UVSIZE
operator|>
literal|4
operator|||
operator|(
operator|!
name|overflowed
operator|&&
name|value
operator|>
literal|0xffffffff
operator|)
endif|#
directive|endif
condition|)
block|{
name|warn
argument_list|(
literal|"Octal number> 037777777777 non-portable"
argument_list|)
expr_stmt|;
block|}
operator|*
name|len_p
operator|=
name|s
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|overflowed
condition|)
block|{
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
operator|*
name|flags
operator|=
name|PERL_SCAN_GREATER_THAN_UV_MAX
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
name|value_nv
expr_stmt|;
return|return
name|UV_MAX
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|my_snprintf
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_snprintf
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|DPPP_
function_decl|(
name|my_my_snprintf
function_decl|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|Size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|int
name|DPPP_
function_decl|(
name|my_my_snprintf
function_decl|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|Size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|my_snprintf
value|DPPP_(my_my_snprintf)
end_define

begin_define
define|#
directive|define
name|Perl_my_snprintf
value|DPPP_(my_my_snprintf)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_snprintf
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_my_snprintf_GLOBAL
argument_list|)
end_if

begin_function
name|int
name|DPPP_
function|(
name|my_my_snprintf
function|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|Size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|dTHX
expr_stmt|;
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_VSNPRINTF
name|retval
operator|=
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
operator|||
operator|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|Size_t
operator|)
name|retval
operator|>=
name|len
operator|)
condition|)
name|Perl_croak
argument_list|(
name|aTHX_
literal|"panic: my_snprintf buffer overflow"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|my_sprintf
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_sprintf
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|DPPP_
function_decl|(
name|my_my_sprintf
function_decl|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|int
name|DPPP_
function_decl|(
name|my_my_sprintf
function_decl|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|my_sprintf
value|DPPP_(my_my_sprintf)
end_define

begin_define
define|#
directive|define
name|Perl_my_sprintf
value|DPPP_(my_my_sprintf)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_sprintf
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_my_sprintf_GLOBAL
argument_list|)
end_if

begin_function
name|int
name|DPPP_
function|(
name|my_my_sprintf
function|)
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_XSLOCKS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|dJMPENV
end_ifdef

begin_define
define|#
directive|define
name|dXCPT
value|dJMPENV; int rEtV = 0
end_define

begin_define
define|#
directive|define
name|XCPT_TRY_START
value|JMPENV_PUSH(rEtV); if (rEtV == 0)
end_define

begin_define
define|#
directive|define
name|XCPT_TRY_END
value|JMPENV_POP;
end_define

begin_define
define|#
directive|define
name|XCPT_CATCH
value|if (rEtV != 0)
end_define

begin_define
define|#
directive|define
name|XCPT_RETHROW
value|JMPENV_JUMP(rEtV)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dXCPT
value|Sigjmp_buf oldTOP; int rEtV = 0
end_define

begin_define
define|#
directive|define
name|XCPT_TRY_START
value|Copy(top_env, oldTOP, 1, Sigjmp_buf); rEtV = Sigsetjmp(top_env, 1); if (rEtV == 0)
end_define

begin_define
define|#
directive|define
name|XCPT_TRY_END
value|Copy(oldTOP, top_env, 1, Sigjmp_buf);
end_define

begin_define
define|#
directive|define
name|XCPT_CATCH
value|if (rEtV != 0)
end_define

begin_define
define|#
directive|define
name|XCPT_RETHROW
value|Siglongjmp(top_env, rEtV)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|my_strlcat
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_strlcat
argument_list|)
end_if

begin_function_decl
specifier|static
name|Size_t
name|DPPP_
function_decl|(
name|my_my_strlcat
function_decl|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|Size_t
name|DPPP_
function_decl|(
name|my_my_strlcat
function_decl|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|my_strlcat
value|DPPP_(my_my_strlcat)
end_define

begin_define
define|#
directive|define
name|Perl_my_strlcat
value|DPPP_(my_my_strlcat)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_strlcat
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_my_strlcat_GLOBAL
argument_list|)
end_if

begin_function
name|Size_t
name|DPPP_
function|(
name|my_my_strlcat
function|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
block|{
name|Size_t
name|used
decl_stmt|,
name|length
decl_stmt|,
name|copy
decl_stmt|;
name|used
operator|=
name|strlen
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|used
operator|<
name|size
operator|-
literal|1
condition|)
block|{
name|copy
operator|=
operator|(
name|length
operator|>=
name|size
operator|-
name|used
operator|)
condition|?
name|size
operator|-
name|used
operator|-
literal|1
else|:
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
name|used
argument_list|,
name|src
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|dst
index|[
name|used
operator|+
name|copy
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|used
operator|+
name|length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|my_strlcpy
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_strlcpy
argument_list|)
end_if

begin_function_decl
specifier|static
name|Size_t
name|DPPP_
function_decl|(
name|my_my_strlcpy
function_decl|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|Size_t
name|DPPP_
function_decl|(
name|my_my_strlcpy
function_decl|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|my_strlcpy
value|DPPP_(my_my_strlcpy)
end_define

begin_define
define|#
directive|define
name|Perl_my_strlcpy
value|DPPP_(my_my_strlcpy)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_my_strlcpy
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_my_strlcpy_GLOBAL
argument_list|)
end_if

begin_function
name|Size_t
name|DPPP_
function|(
name|my_my_strlcpy
function|)
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|Size_t
name|size
parameter_list|)
block|{
name|Size_t
name|length
decl_stmt|,
name|copy
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|copy
operator|=
operator|(
name|length
operator|>=
name|size
operator|)
condition|?
name|size
operator|-
literal|1
else|:
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|dst
index|[
name|copy
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_QUOTE
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_QUOTE
value|0x0001
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_QUOTE
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_QUOTE
value|PERL_PV_ESCAPE_QUOTE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_ELLIPSES
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_ELLIPSES
value|0x0002
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_LTGT
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_LTGT
value|0x0004
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_FIRSTCHAR
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_FIRSTCHAR
value|0x0008
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_UNI
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_UNI
value|0x0100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_UNI_DETECT
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_UNI_DETECT
value|0x0200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_ALL
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_ALL
value|0x1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_NOBACKSLASH
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_NOBACKSLASH
value|0x2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_NOCLEAR
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_NOCLEAR
value|0x4000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_ESCAPE_RE
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_ESCAPE_RE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_NOCLEAR
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_NOCLEAR
value|PERL_PV_ESCAPE_NOCLEAR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_DUMP
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_DUMP
value|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_QUOTE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PERL_PV_PRETTY_REGPROP
end_ifndef

begin_define
define|#
directive|define
name|PERL_PV_PRETTY_REGPROP
value|PERL_PV_PRETTY_ELLIPSES|PERL_PV_PRETTY_LTGT|PERL_PV_ESCAPE_RE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hint: pv_escape  * Note that unicode functionality is only backported to  * those perl versions that support it. For older perl  * versions, the implementation will fall back to bytes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|pv_escape
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_escape
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_escape
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|STRLEN
modifier|*
specifier|const
name|escaped
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_escape
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|STRLEN
modifier|*
specifier|const
name|escaped
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pv_escape
end_ifdef

begin_undef
undef|#
directive|undef
name|pv_escape
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pv_escape
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|)
value|DPPP_(my_pv_escape)(aTHX_ a,b,c,d,e,f)
end_define

begin_define
define|#
directive|define
name|Perl_pv_escape
value|DPPP_(my_pv_escape)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_escape
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_pv_escape_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_pv_escape
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|STRLEN
modifier|*
specifier|const
name|escaped
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
block|{
specifier|const
name|char
name|esc
init|=
name|flags
operator|&
name|PERL_PV_ESCAPE_RE
condition|?
literal|'%'
else|:
literal|'\\'
decl_stmt|;
specifier|const
name|char
name|dq
init|=
name|flags
operator|&
name|PERL_PV_ESCAPE_QUOTE
condition|?
literal|'"'
else|:
name|esc
decl_stmt|;
name|char
name|octbuf
index|[
literal|32
index|]
init|=
literal|"%123456789ABCDF"
decl_stmt|;
name|STRLEN
name|wrote
init|=
literal|0
decl_stmt|;
name|STRLEN
name|chsize
init|=
literal|0
decl_stmt|;
name|STRLEN
name|readsize
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|is_utf8_string
argument_list|)
operator|&&
name|defined
argument_list|(
name|utf8_to_uvchr
argument_list|)
name|bool
name|isuni
init|=
name|flags
operator|&
name|PERL_PV_ESCAPE_UNI
condition|?
literal|1
else|:
literal|0
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|pv
init|=
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
name|pv
operator|+
name|count
decl_stmt|;
name|octbuf
index|[
literal|0
index|]
operator|=
name|esc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PERL_PV_ESCAPE_NOCLEAR
operator|)
condition|)
name|sv_setpvs
argument_list|(
name|dsv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|is_utf8_string
argument_list|)
operator|&&
name|defined
argument_list|(
name|utf8_to_uvchr
argument_list|)
if|if
condition|(
operator|(
name|flags
operator|&
name|PERL_PV_ESCAPE_UNI_DETECT
operator|)
operator|&&
name|is_utf8_string
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv
argument_list|,
name|count
argument_list|)
condition|)
name|isuni
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|pv
operator|<
name|end
operator|&&
operator|(
operator|!
name|max
operator|||
name|wrote
operator|<
name|max
operator|)
condition|;
name|pv
operator|+=
name|readsize
control|)
block|{
specifier|const
name|UV
name|u
init|=
if|#
directive|if
name|defined
argument_list|(
name|is_utf8_string
argument_list|)
operator|&&
name|defined
argument_list|(
name|utf8_to_uvchr
argument_list|)
name|isuni
condition|?
name|utf8_to_uvchr
argument_list|(
operator|(
name|U8
operator|*
operator|)
name|pv
argument_list|,
operator|&
name|readsize
argument_list|)
else|:
endif|#
directive|endif
operator|(
name|U8
operator|)
operator|*
name|pv
decl_stmt|;
specifier|const
name|U8
name|c
init|=
operator|(
name|U8
operator|)
name|u
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|u
operator|>
literal|255
operator|||
operator|(
name|flags
operator|&
name|PERL_PV_ESCAPE_ALL
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PERL_PV_ESCAPE_FIRSTCHAR
condition|)
name|chsize
operator|=
name|my_snprintf
argument_list|(
name|octbuf
argument_list|,
sizeof|sizeof
name|octbuf
argument_list|,
literal|"%"
name|UVxf
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|chsize
operator|=
name|my_snprintf
argument_list|(
name|octbuf
argument_list|,
sizeof|sizeof
name|octbuf
argument_list|,
literal|"%cx{%"
name|UVxf
literal|"}"
argument_list|,
name|esc
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|PERL_PV_ESCAPE_NOBACKSLASH
condition|)
block|{
name|chsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|dq
operator|||
name|c
operator|==
name|esc
operator|||
operator|!
name|isPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chsize
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* fallthrough */
case|case
literal|'%'
case|:
if|if
condition|(
name|c
operator|==
name|esc
condition|)
name|octbuf
index|[
literal|1
index|]
operator|=
name|esc
expr_stmt|;
else|else
name|chsize
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|dq
operator|==
literal|'"'
condition|)
name|octbuf
index|[
literal|1
index|]
operator|=
literal|'"'
expr_stmt|;
else|else
name|chsize
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|chsize
operator|=
name|my_snprintf
argument_list|(
name|octbuf
argument_list|,
sizeof|sizeof
name|octbuf
argument_list|,
name|pv
operator|<
name|end
operator|&&
name|isDIGIT
argument_list|(
operator|(
name|U8
operator|)
operator|*
operator|(
name|pv
operator|+
name|readsize
operator|)
argument_list|)
condition|?
literal|"%c%03o"
else|:
literal|"%c%o"
argument_list|,
name|esc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|chsize
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max
operator|&&
name|wrote
operator|+
name|chsize
operator|>
name|max
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|chsize
operator|>
literal|1
condition|)
block|{
name|sv_catpvn
argument_list|(
name|dsv
argument_list|,
name|octbuf
argument_list|,
name|chsize
argument_list|)
expr_stmt|;
name|wrote
operator|+=
name|chsize
expr_stmt|;
block|}
else|else
block|{
name|char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|my_snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sv_catpvn
argument_list|(
name|dsv
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrote
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PERL_PV_ESCAPE_FIRSTCHAR
condition|)
break|break;
block|}
if|if
condition|(
name|escaped
operator|!=
name|NULL
condition|)
operator|*
name|escaped
operator|=
name|pv
operator|-
name|str
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|dsv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pv_pretty
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_pretty
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_pretty
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|start_color
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|end_color
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_pretty
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|start_color
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|end_color
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pv_pretty
end_ifdef

begin_undef
undef|#
directive|undef
name|pv_pretty
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pv_pretty
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|)
value|DPPP_(my_pv_pretty)(aTHX_ a,b,c,d,e,f,g)
end_define

begin_define
define|#
directive|define
name|Perl_pv_pretty
value|DPPP_(my_pv_pretty)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_pretty
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_pv_pretty_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_pv_pretty
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|str
parameter_list|,
specifier|const
name|STRLEN
name|count
parameter_list|,
specifier|const
name|STRLEN
name|max
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|start_color
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
name|end_color
parameter_list|,
specifier|const
name|U32
name|flags
parameter_list|)
block|{
specifier|const
name|U8
name|dq
init|=
operator|(
name|flags
operator|&
name|PERL_PV_PRETTY_QUOTE
operator|)
condition|?
literal|'"'
else|:
literal|'%'
decl_stmt|;
name|STRLEN
name|escaped
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PERL_PV_PRETTY_NOCLEAR
operator|)
condition|)
name|sv_setpvs
argument_list|(
name|dsv
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dq
operator|==
literal|'"'
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PERL_PV_PRETTY_LTGT
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_color
operator|!=
name|NULL
condition|)
name|sv_catpv
argument_list|(
name|dsv
argument_list|,
name|D_PPP_CONSTPV_ARG
argument_list|(
name|start_color
argument_list|)
argument_list|)
expr_stmt|;
name|pv_escape
argument_list|(
name|dsv
argument_list|,
name|str
argument_list|,
name|count
argument_list|,
name|max
argument_list|,
operator|&
name|escaped
argument_list|,
name|flags
operator||
name|PERL_PV_ESCAPE_NOCLEAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_color
operator|!=
name|NULL
condition|)
name|sv_catpv
argument_list|(
name|dsv
argument_list|,
name|D_PPP_CONSTPV_ARG
argument_list|(
name|end_color
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dq
operator|==
literal|'"'
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|PERL_PV_PRETTY_LTGT
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PERL_PV_PRETTY_ELLIPSES
operator|)
operator|&&
name|escaped
operator|<
name|count
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|dsv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pv_display
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_display
argument_list|)
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_display
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|cur
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
name|pvlim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
else|#
directive|else
specifier|extern
name|char
modifier|*
name|DPPP_
function_decl|(
name|my_pv_display
function_decl|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|cur
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
name|pvlim
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pv_display
end_ifdef

begin_undef
undef|#
directive|undef
name|pv_display
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pv_display
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|DPPP_(my_pv_display)(aTHX_ a,b,c,d,e)
end_define

begin_define
define|#
directive|define
name|Perl_pv_display
value|DPPP_(my_pv_display)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_pv_display
argument_list|)
operator|||
name|defined
argument_list|(
name|NEED_pv_display_GLOBAL
argument_list|)
end_if

begin_function
name|char
modifier|*
name|DPPP_
function|(
name|my_pv_display
function|)
parameter_list|(
name|pTHX_
name|SV
modifier|*
name|dsv
parameter_list|,
specifier|const
name|char
modifier|*
name|pv
parameter_list|,
name|STRLEN
name|cur
parameter_list|,
name|STRLEN
name|len
parameter_list|,
name|STRLEN
name|pvlim
parameter_list|)
block|{
name|pv_pretty
argument_list|(
name|dsv
argument_list|,
name|pv
argument_list|,
name|cur
argument_list|,
name|pvlim
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PERL_PV_PRETTY_DUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cur
operator|&&
name|pv
index|[
name|cur
index|]
operator|==
literal|'\0'
condition|)
name|sv_catpvs
argument_list|(
name|dsv
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
return|return
name|SvPVX
argument_list|(
name|dsv
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _P_P_PORTABILITY_H_ */
end_comment

begin_comment
comment|/* End of File ppport.h */
end_comment

end_unit

