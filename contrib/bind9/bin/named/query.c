begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: query.c,v 1.198.2.13.4.36 2005/08/11 05:25:20 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/byaddr.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/order.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/tkey.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<dns/zt.h>
end_include

begin_include
include|#
directive|include
file|<named/client.h>
end_include

begin_include
include|#
directive|include
file|<named/log.h>
end_include

begin_include
include|#
directive|include
file|<named/server.h>
end_include

begin_include
include|#
directive|include
file|<named/sortlist.h>
end_include

begin_include
include|#
directive|include
file|<named/xfrout.h>
end_include

begin_define
define|#
directive|define
name|PARTIALANSWER
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_PARTIALANSWER) != 0)
end_define

begin_define
define|#
directive|define
name|USECACHE
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_CACHEOK) != 0)
end_define

begin_define
define|#
directive|define
name|RECURSIONOK
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_RECURSIONOK) != 0)
end_define

begin_define
define|#
directive|define
name|RECURSING
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_RECURSING) != 0)
end_define

begin_define
define|#
directive|define
name|CACHEGLUEOK
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_CACHEGLUEOK) != 0)
end_define

begin_define
define|#
directive|define
name|WANTRECURSION
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_WANTRECURSION) != 0)
end_define

begin_define
define|#
directive|define
name|WANTDNSSEC
parameter_list|(
name|c
parameter_list|)
value|(((c)->attributes& \ 				  NS_CLIENTATTR_WANTDNSSEC) != 0)
end_define

begin_define
define|#
directive|define
name|NOAUTHORITY
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_NOAUTHORITY) != 0)
end_define

begin_define
define|#
directive|define
name|NOADDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_NOADDITIONAL) != 0)
end_define

begin_define
define|#
directive|define
name|SECURE
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_SECURE) != 0)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(ns_g_lctx, \ 				      NS_LOGCATEGORY_CLIENT, \ 				      NS_LOGMODULE_QUERY, \ 				      ISC_LOG_DEBUG(3), \ 				      "client %p: %s", client, (m))
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(ns_g_lctx, \ 				      NS_LOGCATEGORY_GENERAL, \ 				      NS_LOGMODULE_QUERY, \ 				      ISC_LOG_DEBUG(3), \ 				      "query %p: %s", query, (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)m)
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)m)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DNS_GETDB_NOEXACT
value|0x01U
end_define

begin_define
define|#
directive|define
name|DNS_GETDB_NOLOG
value|0x02U
end_define

begin_define
define|#
directive|define
name|DNS_GETDB_PARTIAL
value|0x04U
end_define

begin_function_decl
specifier|static
name|void
name|query_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_fetchevent_t
modifier|*
name|event
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Increment query statistics counters.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_statscounter_t
name|counter
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
init|=
name|client
operator|->
name|query
operator|.
name|authzone
decl_stmt|;
name|REQUIRE
argument_list|(
name|counter
operator|<
name|DNS_STATS_NCOUNTERS
argument_list|)
expr_stmt|;
name|ns_g_server
operator|->
name|querystats
index|[
name|counter
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
block|{
name|isc_uint64_t
modifier|*
name|zonestats
init|=
name|dns_zone_getstatscounters
argument_list|(
name|zone
argument_list|)
decl_stmt|;
if|if
condition|(
name|zonestats
operator|!=
name|NULL
condition|)
name|zonestats
index|[
name|counter
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|query_send
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_statscounter_t
name|counter
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
condition|)
block|{
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|message
operator|->
name|sections
index|[
name|DNS_SECTION_ANSWER
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|isreferral
condition|)
block|{
name|counter
operator|=
name|dns_statscounter_referral
expr_stmt|;
block|}
else|else
block|{
name|counter
operator|=
name|dns_statscounter_nxrrset
expr_stmt|;
block|}
block|}
else|else
block|{
name|counter
operator|=
name|dns_statscounter_success
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
block|{
name|counter
operator|=
name|dns_statscounter_nxdomain
expr_stmt|;
block|}
else|else
block|{
comment|/* We end up here in case of YXDOMAIN, and maybe others */
name|counter
operator|=
name|dns_statscounter_failure
expr_stmt|;
block|}
name|inc_stats
argument_list|(
name|client
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|ns_client_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_error
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_statscounter_failure
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_next
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_statscounter_failure
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_maybeputqname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|restarts
operator|>
literal|0
condition|)
block|{
comment|/* 		 * client->query.qname was dynamically allocated. 		 */
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_freefreeversions
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_boolean_t
name|everything
parameter_list|)
block|{
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|,
modifier|*
name|dbversion_next
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|dbversion_next
operator|,
name|i
operator|++
control|)
block|{
name|dbversion_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * If we're not freeing everything, we keep the first three 		 * dbversions structures around. 		 */
if|if
condition|(
name|i
operator|>
literal|3
operator|||
name|everything
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|dbversion
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbversion
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_query_cancel
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|!=
name|NULL
condition|)
block|{
name|dns_resolver_cancelfetch
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_reset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_boolean_t
name|everything
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
modifier|*
name|dbuf_next
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|,
modifier|*
name|dbversion_next
decl_stmt|;
comment|/* 	 * Reset the query state of a client to its default state. 	 */
comment|/* 	 * Cancel the fetch if it's running. 	 */
name|ns_query_cancel
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup any active versions. 	 */
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|dbversion_next
control|)
block|{
name|dbversion_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|dbversion
operator|->
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|dbversion
operator|->
name|db
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|authdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|authdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|authzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|authzone
argument_list|)
expr_stmt|;
name|query_freefreeversions
argument_list|(
name|client
argument_list|,
name|everything
argument_list|)
expr_stmt|;
for|for
control|(
name|dbuf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
init|;
name|dbuf
operator|!=
name|NULL
condition|;
name|dbuf
operator|=
name|dbuf_next
control|)
block|{
name|dbuf_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf_next
operator|!=
name|NULL
operator|||
name|everything
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|,
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|dbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|query_maybeputqname
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|=
operator|(
name|NS_QUERYATTR_RECURSIONOK
operator||
name|NS_QUERYATTR_CACHEOK
operator||
name|NS_QUERYATTR_SECURE
operator|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|restarts
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|origqname
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dboptions
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetchoptions
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_next_callback
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_query_free
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_newnamebuf
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_newnamebuf"
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a name buffer. 	 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
operator|&
name|dbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newnamebuf: isc_buffer_allocate failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|,
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newnamebuf: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_buffer_t
modifier|*
name|query_getnamebuf
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_getnamebuf"
argument_list|)
expr_stmt|;
comment|/* 	 * Return a name buffer with space for a maximal name, allocating 	 * a new one if necessary. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_getnamebuf: query_newnamebuf failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|dbuf
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|255
condition|)
block|{
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_getnamebuf: query_newnamebuf failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbuf
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
literal|255
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_getnamebuf: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_keepname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_keepname"
argument_list|)
expr_stmt|;
comment|/* 	 * 'name' is using space in 'dbuf', but 'dbuf' has not yet been 	 * adjusted to take account of that.  We do the adjustment. 	 */
name|REQUIRE
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|name
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|dbuf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_name_setbuffer
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_releasename
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
operator|*
name|namep
decl_stmt|;
comment|/* 	 * 'name' is no longer needed.  Return it to our pool of temporary 	 * names.  If it is using a name buffer, relinquish its exclusive 	 * rights on the buffer. 	 */
name|CTRACE
argument_list|(
literal|"query_releasename"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_hasbuffer
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
block|}
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_releasename: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_name_t
modifier|*
name|query_newname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|isc_buffer_t
modifier|*
name|nbuf
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newname"
argument_list|)
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newname: dns_message_gettempname failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
name|nbuf
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_setbuffer
argument_list|(
name|name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newname: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rdataset_t
modifier|*
name|query_newrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_newrdataset"
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newrdataset: "
literal|"dns_message_gettemprdataset failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newrdataset: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_putrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
operator|*
name|rdatasetp
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_putrdataset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_putrdataset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_newdbversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dbversion
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbversion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|!=
name|NULL
condition|)
block|{
name|dbversion
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dbversion
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We only return ISC_R_NOMEMORY if we couldn't 			 * allocate anything. 			 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ns_dbversion_t
modifier|*
name|query_getdbversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_newdbversion
argument_list|(
name|client
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dbversion
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbversion
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_query_init
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|restarts
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authzone
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_FALSE
expr_stmt|;
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|result
operator|=
name|query_newdbversion
argument_list|(
name|client
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|query_freefreeversions
argument_list|(
name|client
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ns_dbversion_t
modifier|*
name|query_findversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
modifier|*
name|newzonep
parameter_list|)
block|{
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
comment|/* 	 * We may already have done a query related to this 	 * database.  If so, we must be sure to make subsequent 	 * queries from the same version. 	 */
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dbversion
operator|->
name|db
operator|==
name|db
condition|)
break|break;
block|}
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is a new zone for this query.  Add it to 		 * the active list. 		 */
name|dbversion
operator|=
name|query_getdbversion
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|version
argument_list|)
expr_stmt|;
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|newzonep
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
operator|*
name|newzonep
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|dbversion
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getzonedb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|check_acl
decl_stmt|,
name|new_zone
decl_stmt|;
name|dns_acl_t
modifier|*
name|queryacl
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
name|unsigned
name|int
name|ztoptions
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|partial
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find a zone database to answer the query. 	 */
name|ztoptions
operator|=
operator|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|)
condition|?
name|DNS_ZTFIND_NOEXACT
else|:
literal|0
expr_stmt|;
name|result
operator|=
name|dns_zt_find
argument_list|(
name|client
operator|->
name|view
operator|->
name|zonetable
argument_list|,
name|name
argument_list|,
name|ztoptions
argument_list|,
name|NULL
argument_list|,
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|partial
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * This limits our searching to the zone where the first name 	 * (the query target) was looked for.  This prevents following 	 * CNAMES or DNAMES into other zones and prevents returning  	 * additional data from other zones. 	 */
if|if
condition|(
operator|!
name|client
operator|->
name|view
operator|->
name|additionalfromauth
operator|&&
name|client
operator|->
name|query
operator|.
name|authdbset
operator|&&
name|db
operator|!=
name|client
operator|->
name|query
operator|.
name|authdb
condition|)
goto|goto
name|refuse
goto|;
comment|/* 	 * If the zone has an ACL, we'll check it, otherwise 	 * we use the view's "allow-query" ACL.  Each ACL is only checked 	 * once per query. 	 * 	 * Also, get the database version to use. 	 */
name|check_acl
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Keep compiler happy. */
name|queryacl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Get the current version of this database. 	 */
name|dbversion
operator|=
name|query_findversion
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
operator|&
name|new_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|new_zone
condition|)
block|{
name|check_acl
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dbversion
operator|->
name|queryok
condition|)
block|{
goto|goto
name|refuse
goto|;
block|}
else|else
block|{
name|check_acl
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|queryacl
operator|=
name|dns_zone_getqueryacl
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryacl
operator|==
name|NULL
condition|)
block|{
name|queryacl
operator|=
name|client
operator|->
name|view
operator|->
name|queryacl
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOKVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We've evaluated the view's queryacl already.  If 			 * NS_QUERYATTR_QUERYOK is set, then the client is 			 * allowed to make queries, otherwise the query should 			 * be refused. 			 */
name|check_acl
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|refuse
goto|;
block|}
else|else
block|{
comment|/* 			 * We haven't evaluated the view's queryacl yet. 			 */
name|check_acl
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_acl
condition|)
block|{
name|isc_boolean_t
name|log
init|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOLOG
operator|)
operator|==
literal|0
argument_list|)
decl_stmt|;
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|queryacl
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
name|char
name|msg
index|[
name|NS_CLIENT_ACLMSGSIZE
argument_list|(
literal|"query"
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s approved"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s denied"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|queryacl
operator|==
name|client
operator|->
name|view
operator|->
name|queryacl
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * We were allowed by the default 				 * "allow-query" ACL.  Remember this so we 				 * don't have to check again. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOK
expr_stmt|;
block|}
comment|/* 			 * We've now evaluated the view's query ACL, and 			 * the NS_QUERYATTR_QUERYOK attribute is now valid. 			 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOKVALID
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|refuse
goto|;
block|}
comment|/* Approved. */
comment|/* 	 * Remember the result of the ACL check so we 	 * don't have to check again. 	 */
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Transfer ownership. */
operator|*
name|zonep
operator|=
name|zone
expr_stmt|;
operator|*
name|dbp
operator|=
name|db
expr_stmt|;
operator|*
name|versionp
operator|=
name|dbversion
operator|->
name|version
expr_stmt|;
if|if
condition|(
name|partial
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_PARTIAL
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DNS_R_PARTIALMATCH
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|refuse
label|:
name|result
operator|=
name|DNS_R_REFUSED
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getcachedb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|check_acl
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find a cache database to answer the query. 	 * This may fail with DNS_R_REFUSED if the client 	 * is not allowed to use the cache. 	 */
if|if
condition|(
operator|!
name|USECACHE
argument_list|(
name|client
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOKVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We've evaluated the view's queryacl already.  If 		 * NS_QUERYATTR_QUERYOK is set, then the client is 		 * allowed to make queries, otherwise the query should 		 * be refused. 		 */
name|check_acl
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|refuse
goto|;
block|}
else|else
block|{
comment|/* 		 * We haven't evaluated the view's queryacl yet. 		 */
name|check_acl
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|check_acl
condition|)
block|{
name|isc_boolean_t
name|log
init|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOLOG
operator|)
operator|==
literal|0
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
name|NS_CLIENT_ACLMSGSIZE
argument_list|(
literal|"query (cache)"
argument_list|)
index|]
decl_stmt|;
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|view
operator|->
name|queryacl
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We were allowed by the default 			 * "allow-query" ACL.  Remember this so we 			 * don't have to check again. 			 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOK
expr_stmt|;
if|if
condition|(
name|log
operator|&&
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query (cache)"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s approved"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|log
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query (cache)"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s denied"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We've now evaluated the view's query ACL, and 		 * the NS_QUERYATTR_QUERYOK attribute is now valid. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOKVALID
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|refuse
goto|;
block|}
comment|/* Approved. */
comment|/* Transfer ownership. */
operator|*
name|dbp
operator|=
name|db
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|refuse
label|:
name|result
operator|=
name|DNS_R_REFUSED
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getdb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
modifier|*
name|is_zonep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|options
argument_list|,
name|zonep
argument_list|,
name|dbp
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|is_zonep
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|result
operator|=
name|query_getcachedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|dbp
argument_list|,
name|options
argument_list|)
expr_stmt|;
operator|*
name|is_zonep
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|query_isduplicate
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|mnamep
parameter_list|)
block|{
name|dns_section_t
name|section
decl_stmt|;
name|dns_name_t
modifier|*
name|mname
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_isduplicate"
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|DNS_SECTION_ANSWER
init|;
name|section
operator|<=
name|DNS_SECTION_ADDITIONAL
condition|;
name|section
operator|++
control|)
block|{
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|mname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We've already got this RRset in the response. 			 */
name|CTRACE
argument_list|(
literal|"query_isduplicate: true: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
comment|/* 			 * The name exists, but the rdataset does not. 			 */
if|if
condition|(
name|section
operator|==
name|DNS_SECTION_ADDITIONAL
condition|)
break|break;
block|}
else|else
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXDOMAIN
argument_list|)
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the dns_name_t we're looking up is already in the message, 	 * we don't want to trigger the caller's name replacement logic. 	 */
if|if
condition|(
name|name
operator|==
name|mname
condition|)
name|mname
operator|=
name|NULL
expr_stmt|;
operator|*
name|mnamep
operator|=
name|mname
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_isduplicate: false: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_addadditional
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
init|=
name|arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|trdataset
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|isc_boolean_t
name|added_something
decl_stmt|,
name|need_addname
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|qtype
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_rdatatype_isdnssec
argument_list|(
name|qtype
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|CTRACE
argument_list|(
literal|"query_addadditional"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|trdataset
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|added_something
operator|=
name|ISC_FALSE
expr_stmt|;
name|need_addname
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We treat type A additional section processing as if it 	 * were "any address type" additional section processing. 	 * To avoid multiple lookups, we do an 'any' database 	 * lookup and iterate over the node. 	 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_a
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
comment|/* 	 * Get some resources. 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Look for a zone database that might contain authoritative 	 * additional data. 	 */
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|try_cache
goto|;
name|CTRACE
argument_list|(
literal|"query_addadditional: db_find"
argument_list|)
expr_stmt|;
comment|/* 	 * Since we are looking for authoritative data, we do not set 	 * the GLUEOK flag.  Glue will be looked for later, but not 	 * necessarily in the same database. 	 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * No authoritative data was found.  The cache is our next best bet. 	 */
name|try_cache
label|:
name|result
operator|=
name|query_getcachedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
operator|&
name|db
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
comment|/* 		 * Most likely the client isn't allowed to query the cache. 		 */
goto|goto
name|try_glue
goto|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
name|try_glue
label|:
comment|/* 	 * No cached data was found.  Glue is our last chance. 	 * RFC1035 sayeth: 	 * 	 *	NS records cause both the usual additional section 	 *	processing to locate a type A record, and, when used 	 *	in a referral, a special search of the zone in which 	 *	they reside for glue information. 	 * 	 * This is the "special search".  Note that we must search 	 * the zone where the NS record resides, not the zone it 	 * points to, and that we only do the search in the delegation 	 * case (identified by client->query.gluedb being set). 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|gluedb
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Don't poision caches using the bailiwick protection model. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|)
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_GLUEOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_ZONECUT
operator|||
name|result
operator|==
name|DNS_R_GLUE
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|found
label|:
comment|/* 	 * We have found a potential additional data rdataset, or 	 * at least a node to iterate over. 	 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an rdataset, add it to the additional data 	 * section. 	 */
name|mname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|&&
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|type
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|trdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Note: we only add SIGs if we've added the type they cover, 		 * so we do not need to check if the SIG rdataset is already 		 * in the response. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_a
condition|)
block|{
comment|/* 		 * We now go looking for A and AAAA records, along with 		 * their signatures. 		 * 		 * XXXRTH  This code could be more efficient. 		 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
comment|/* 			 * Negative cache entries don't have sigrdatasets. 			 */
name|INSIST
argument_list|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_a
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
else|else
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|addname
label|:
name|CTRACE
argument_list|(
literal|"query_addadditional: addname"
argument_list|)
expr_stmt|;
comment|/* 	 * If we haven't added anything, then we're done. 	 */
if|if
condition|(
operator|!
name|added_something
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * We may have added our rdatasets to an existing name, if so, then 	 * need_addname will be ISC_FALSE.  Whether we used an existing name 	 * or a new one, we must set fname to NULL to prevent cleanup. 	 */
if|if
condition|(
name|need_addname
condition|)
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|fname
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In a few cases, we want to add additional data for additional 	 * data.  It's simpler to just deal with special cases here than 	 * to try to create a general purpose mechanism and allow the 	 * rdata implementations to do it themselves. 	 * 	 * This involves recursion, but the depth is limited.  The 	 * most complex case is adding a SRV rdataset, which involves 	 * recursing to add address records, which in turn can cause 	 * recursion to add KEYs. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_srv
operator|&&
name|trdataset
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're adding SRV records to the additional data 		 * section, it's helpful if we add the SRV additional data 		 * as well. 		 */
name|eresult
operator|=
name|dns_rdataset_additionaldata
argument_list|(
name|trdataset
argument_list|,
name|query_addadditional
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_addadditional: cleanup"
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addadditional: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_addrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
comment|/* 	 * Add 'rdataset' and any pertinent additional data to 	 * 'fname', a name in the response message for 'client'. 	 */
name|CTRACE
argument_list|(
literal|"query_addrdataset"
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|order
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|dns_order_find
argument_list|(
name|client
operator|->
name|view
operator|->
name|order
argument_list|,
name|fname
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOADDITIONAL
argument_list|(
name|client
argument_list|)
condition|)
return|return;
comment|/* 	 * Add additional data. 	 * 	 * We don't care if dns_rdataset_additionaldata() fails. 	 */
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|query_addadditional
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addrdataset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addrrset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|mrdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * To the current response for 'client', add the answer RRset 	 * '*rdatasetp' and an optional signature set '*sigrdatasetp', with 	 * owner name '*namep', to section 'section', unless they are 	 * already there.  Also add any pertinent additional data. 	 * 	 * If 'dbuf' is not NULL, then '*namep' is the name whose data is 	 * stored in 'dbuf'.  In this case, query_addrrset() guarantees that 	 * when it returns the name will either have been kept or released. 	 */
name|CTRACE
argument_list|(
literal|"query_addrrset"
argument_list|)
expr_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
name|rdataset
operator|=
operator|*
name|rdatasetp
expr_stmt|;
if|if
condition|(
name|sigrdatasetp
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|=
operator|*
name|sigrdatasetp
expr_stmt|;
else|else
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
name|mrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|mrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * We've already got an RRset of the given name and type. 		 * There's nothing else to do; 		 */
name|CTRACE
argument_list|(
literal|"query_addrrset: dns_message_findname succeeded: done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
comment|/* 		 * The name doesn't exist. 		 */
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_keepname
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
name|mname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXRRSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|&&
operator|(
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|||
name|section
operator|==
name|DNS_SECTION_AUTHORITY
operator|)
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
comment|/* 	 * Note: we only add SIGs if we've added the type they cover, so 	 * we do not need to check if the SIG rdataset is already in the 	 * response. 	 */
name|query_addrdataset
argument_list|(
name|client
argument_list|,
name|mname
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
operator|*
name|rdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
comment|/* 		 * We have a signature.  Add it to the response. 		 */
name|ISC_LIST_APPEND
argument_list|(
name|mname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_addrrset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_addsoa
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|zero_ttl
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
init|=
name|NULL
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addsoa"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
comment|/* 	 * Get resources and make 'name' be the database origin. 	 */
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Find the SOA. 	 */
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * This is bad.  We tried to get the SOA RR at the zone top 		 * and it didn't work! 		 */
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Extract the SOA MINIMUM. 		 */
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|zero_ttl
condition|)
block|{
name|rdataset
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Add the SOA and its SIG to the response, with the 		 * TTLs adjusted per RFC2308 section 3. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|>
name|soa
operator|.
name|minimum
condition|)
name|rdataset
operator|->
name|ttl
operator|=
name|soa
operator|.
name|minimum
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|sigrdataset
operator|->
name|ttl
operator|>
name|soa
operator|.
name|minimum
condition|)
name|sigrdataset
operator|->
name|ttl
operator|=
name|soa
operator|.
name|minimum
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_addns
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
init|=
name|NULL
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
comment|/* 	 * Get resources and make 'name' be the database origin. 	 */
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: dns_message_gettempname failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: query_newrdataset failed"
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: query_newrdataset failed"
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Find the NS rdataset. 	 */
name|CTRACE
argument_list|(
literal|"query_addns: calling dns_db_find"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns: dns_db_find complete"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: dns_db_find failed"
argument_list|)
expr_stmt|;
comment|/* 		 * This is bad.  We tried to get the NS rdataset at the zone 		 * top and it didn't work! 		 */
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_addns: cleanup"
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_addcnamelike
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|tname
parameter_list|,
name|dns_trust_t
name|trust
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|anamep
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
comment|/* 	 * We assume the name data referred to by tname won't go away. 	 */
name|REQUIRE
argument_list|(
name|anamep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|qname
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
operator|*
name|anamep
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rdatalist
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|rdatalist
operator|->
name|rdclass
operator|=
name|client
operator|->
name|message
operator|->
name|rdclass
expr_stmt|;
name|rdatalist
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|tname
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|data
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|rdata
operator|->
name|length
operator|=
name|r
operator|.
name|length
expr_stmt|;
name|rdata
operator|->
name|rdclass
operator|=
name|client
operator|->
name|message
operator|->
name|rdclass
expr_stmt|;
name|rdata
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|trust
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
name|anamep
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addbestns
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|zdb
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|zfname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|zrdataset
decl_stmt|,
modifier|*
name|zsigrdataset
decl_stmt|;
name|isc_boolean_t
name|is_zone
decl_stmt|,
name|use_zone
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addbestns"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|zdb
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|use_zone
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Find the right database. 	 */
name|result
operator|=
name|query_getdb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|db_find
label|:
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Now look for the zonecut. 	 */
if|if
condition|(
name|is_zone
condition|)
block|{
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_DELEGATION
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|USECACHE
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|zdb
operator|=
name|db
expr_stmt|;
name|zfname
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_db_findzonecut
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|zfname
operator|!=
name|NULL
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
name|zfname
argument_list|)
condition|)
block|{
comment|/* 				 * We found a zonecut in the cache, but our 				 * zone delegation is better. 				 */
name|use_zone
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|&&
name|zfname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We didn't find anything in the cache, but we 			 * have a zone delegation, so use it. 			 */
name|use_zone
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|use_zone
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|zfname
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We've already done query_keepname() on 		 * zfname, so we must set dbuf to NULL to 		 * prevent query_addrrset() from trying to 		 * call query_keepname() again. 		 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|zrdataset
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|zsigrdataset
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|dboptions
operator|&
name|DNS_DBFIND_PENDINGOK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_pending
operator|||
operator|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|sigrdataset
operator|->
name|trust
operator|==
name|dns_trust_pending
operator|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|SECURE
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|||
operator|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|sigrdataset
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdb
operator|!=
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zsigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|zfname
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zdb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|query_addds
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|rname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addds"
argument_list|)
expr_stmt|;
name|rname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Look for the DS record, which may or may not be present. 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ds
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't find it, look for an NSEC. */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * We've already added the NS record, so if the name's not there, 	 * we have other problems.  Use this name rather than calling 	 * query_addrrset(). 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|rname
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|rname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|ISC_LIST_APPEND
argument_list|(
name|rname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addwildcardproof
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|ispositive
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_fixedname_t
name|wfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|wname
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|olabels
decl_stmt|,
name|nlabels
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_nsec_t
name|nsec
decl_stmt|;
name|isc_boolean_t
name|have_wname
decl_stmt|;
name|int
name|order
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addwildcardproof"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Get the NOQNAME proof then if !ispositve 	 * get the NOWILDCARD proof. 	 * 	 * DNS_DBFIND_NOWILD finds the NSEC records that covers the 	 * name ignoring any wildcard.  From the owner and next names 	 * of this record you can compute which wildcard (if it exists) 	 * will match by finding the longest common suffix of the 	 * owner name and next names with the qname and prefixing that 	 * with the wildcard label. 	 * 	 * e.g. 	 *   Given: 	 *	example SOA 	 *	example NSEC b.example 	 * 	b.example A 	 * 	b.example NSEC a.d.example 	 * 	a.d.example A 	 * 	a.d.example NSEC g.f.example 	 * 	g.f.example A 	 * 	g.f.example NSEC z.i.example 	 * 	z.i.example A 	 * 	z.i.example NSEC example 	 * 	 *   QNAME: 	 *   a.example -> example NSEC b.example 	 * 	owner common example 	 * 	next common example 	 * 	wild *.example 	 *   d.b.example -> b.example NSEC a.d.example 	 *	owner common b.example 	 *	next common example 	 *	wild *.b.example 	 *   a.f.example -> a.d.example NSEC g.f.example 	 *	owner common example 	 *	next common f.example 	 *	wild *.f.example 	 *  j.example -> z.i.example NSEC example 	 *	owner common example 	 * 	next common example 	 *	wild *.f.example 	 */
name|options
operator|=
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_NOWILD
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|wfixed
argument_list|)
expr_stmt|;
name|wname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|wfixed
argument_list|)
expr_stmt|;
name|again
label|:
name|have_wname
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
if|if
condition|(
operator|!
name|ispositive
condition|)
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|olabels
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
operator|&
name|nsec
operator|.
name|next
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
if|if
condition|(
name|olabels
operator|>
name|nlabels
condition|)
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|olabels
argument_list|,
name|NULL
argument_list|,
name|wname
argument_list|)
expr_stmt|;
else|else
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|nlabels
argument_list|,
name|NULL
argument_list|,
name|wname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|wname
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_wname
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|nsec
argument_list|)
expr_stmt|;
block|}
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_wname
condition|)
block|{
name|ispositive
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* prevent loop */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|wname
argument_list|)
condition|)
block|{
name|name
operator|=
name|wname
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addnxrrsetnsec
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|==
literal|0
condition|)
block|{
name|query_addrrset
argument_list|(
name|client
argument_list|,
name|namep
argument_list|,
name|rdatasetp
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigrdatasetp
operator|==
name|NULL
condition|)
return|return;
name|sigrdataset
operator|=
operator|*
name|sigrdatasetp
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
return|return;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|sig
operator|.
name|labels
operator|+
literal|1
operator|>=
name|labels
condition|)
return|return;
comment|/* XXX */
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
return|return;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return;
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|sig
operator|.
name|labels
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* This will succeed, since we've stripped labels. */
name|RUNTIME_CHECK
argument_list|(
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
name|rdatasetp
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_resume
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|devent
init|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_boolean_t
name|fetch_cancelled
decl_stmt|,
name|client_shuttingdown
decl_stmt|;
comment|/* 	 * Resume a query after recursion. 	 */
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|client
operator|=
name|devent
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|RECURSING
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This is the fetch we've been waiting for. 		 */
name|INSIST
argument_list|(
name|devent
operator|->
name|fetch
operator|==
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
name|fetch_cancelled
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Update client->now. 		 */
name|isc_stdtime_get
argument_list|(
operator|&
name|client
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fetch completion event for a cancelled fetch. 		 * Clean up and don't resume the find. 		 */
name|fetch_cancelled
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_RECURSING
expr_stmt|;
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|devent
operator|->
name|fetch
argument_list|)
expr_stmt|;
comment|/* 	 * If this client is shutting down, or this transaction 	 * has timed out, do not resume the find. 	 */
name|client_shuttingdown
operator|=
name|ns_client_shuttingdown
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_cancelled
operator|||
name|client_shuttingdown
condition|)
block|{
if|if
condition|(
name|devent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|devent
operator|->
name|db
argument_list|,
operator|&
name|devent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|devent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|devent
operator|->
name|db
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|devent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|devent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|devent
operator|->
name|sigrdataset
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_cancelled
condition|)
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
else|else
name|query_next
argument_list|(
name|client
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
comment|/* 		 * This may destroy the client. 		 */
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|query_find
argument_list|(
name|client
argument_list|,
name|devent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_recurse
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qdomain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_statscounter_recursion
argument_list|)
expr_stmt|;
comment|/* 	 * We are about to recurse, which means that this client will 	 * be unavailable for serving new requests for an indeterminate 	 * amount of time.  If this client is currently responsible 	 * for handling incoming queries, set up a new client 	 * object to handle them while we are waiting for a 	 * response.  There is no need to replace TCP clients 	 * because those have already been replaced when the 	 * connection was accepted (if allowed by the TCP quota). 	 */
if|if
condition|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_quota_attach
argument_list|(
operator|&
name|ns_g_server
operator|->
name|recursionquota
argument_list|,
operator|&
name|client
operator|->
name|recursionquota
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SOFTQUOTA
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"recursive-clients soft limit exceeded, "
literal|"aborting oldest query"
argument_list|)
expr_stmt|;
name|ns_client_killoldestquery
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"no more recursive clients: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_killoldestquery
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|client
operator|->
name|mortal
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ns_client_replace
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"ns_client_replace() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_quota_detach
argument_list|(
operator|&
name|client
operator|->
name|recursionquota
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|ns_client_recursing
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the resolver. 	 */
name|REQUIRE
argument_list|(
name|nameservers
operator|==
name|NULL
operator|||
name|nameservers
operator|->
name|type
operator|==
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
else|else
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|timerset
operator|==
name|ISC_FALSE
condition|)
name|ns_client_settimeout
argument_list|(
name|client
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch
argument_list|(
name|client
operator|->
name|view
operator|->
name|resolver
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|qdomain
argument_list|,
name|nameservers
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|query
operator|.
name|fetchoptions
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|query_resume
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Record that we're waiting for an event.  A client which 		 * is shutting down will not be destroyed until all the 		 * events have been received. 		 */
block|}
else|else
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_RESTARTS
value|16
end_define

begin_define
define|#
directive|define
name|QUERY_ERROR
parameter_list|(
name|r
parameter_list|)
define|\
value|do { \ 	eresult = r; \ 	want_restart = ISC_FALSE; \ } while (0)
end_define

begin_comment
comment|/*  * Extract a network address from the RDATA of an A or AAAA  * record.  *  * Returns:  *	ISC_R_SUCCESS  *	ISC_R_NOTIMPLEMENTED	The rdata is not a known address type.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdata_tonetaddr
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_netaddr_t
modifier|*
name|netaddr
parameter_list|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
name|struct
name|in6_addr
name|in6a
decl_stmt|;
switch|switch
condition|(
name|rdata
operator|->
name|type
condition|)
block|{
case|case
name|dns_rdatatype_a
case|:
name|INSIST
argument_list|(
name|rdata
operator|->
name|length
operator|==
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ina
operator|.
name|s_addr
argument_list|,
name|rdata
operator|->
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin
argument_list|(
name|netaddr
argument_list|,
operator|&
name|ina
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
case|case
name|dns_rdatatype_aaaa
case|:
name|INSIST
argument_list|(
name|rdata
operator|->
name|length
operator|==
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|,
name|rdata
operator|->
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
name|netaddr
argument_list|,
operator|&
name|in6a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the sort order of 'rdata' in the topology-like  * ACL forming the second element in a 2-element top-level  * sortlist statement.  */
end_comment

begin_function
specifier|static
name|int
name|query_sortlist_order_2element
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
if|if
condition|(
name|rdata_tonetaddr
argument_list|(
name|rdata
argument_list|,
operator|&
name|netaddr
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|INT_MAX
operator|)
return|;
return|return
operator|(
name|ns_sortlist_addrorder2
argument_list|(
operator|&
name|netaddr
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the sort order of 'rdata' in the matching element  * of a 1-element top-level sortlist statement.  */
end_comment

begin_function
specifier|static
name|int
name|query_sortlist_order_1element
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
if|if
condition|(
name|rdata_tonetaddr
argument_list|(
name|rdata
argument_list|,
operator|&
name|netaddr
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|INT_MAX
operator|)
return|;
return|return
operator|(
name|ns_sortlist_addrorder1
argument_list|(
operator|&
name|netaddr
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the sortlist statement that applies to 'client' and set up  * the sortlist info in in client->message appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|setup_query_sortlist
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|dns_rdatasetorderfunc_t
name|order
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|order_arg
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ns_sortlist_setup
argument_list|(
name|client
operator|->
name|view
operator|->
name|sortlist
argument_list|,
operator|&
name|netaddr
argument_list|,
operator|&
name|order_arg
argument_list|)
condition|)
block|{
case|case
name|NS_SORTLISTTYPE_1ELEMENT
case|:
name|order
operator|=
name|query_sortlist_order_1element
expr_stmt|;
break|break;
case|case
name|NS_SORTLISTTYPE_2ELEMENT
case|:
name|order
operator|=
name|query_sortlist_order_2element
expr_stmt|;
break|break;
case|case
name|NS_SORTLISTTYPE_NONE
case|:
name|order
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|dns_message_setsortorder
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|order
argument_list|,
name|order_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addnoqnameproof
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|nsec
decl_stmt|,
modifier|*
name|nsecsig
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOMEMORY
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addnoqnameproof"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|=
name|NULL
expr_stmt|;
name|nsecsig
operator|=
name|NULL
expr_stmt|;
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|nsecsig
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|nsec
operator|==
name|NULL
operator|||
name|nsecsig
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_getnoqname
argument_list|(
name|rdataset
argument_list|,
name|fname
argument_list|,
name|nsec
argument_list|,
name|nsecsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|nsec
argument_list|,
operator|&
name|nsecsig
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|nsec
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecsig
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|nsecsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|answer_in_glue
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
decl_stmt|;
name|dns_section_t
name|section
init|=
name|DNS_SECTION_ADDITIONAL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|msg
operator|=
name|client
operator|->
name|message
expr_stmt|;
for|for
control|(
name|name
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|)
init|;
name|name
operator|!=
name|NULL
condition|;
name|name
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
condition|)
block|{
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|qtype
condition|)
break|break;
break|break;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|name
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|name
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_REQUIREDGLUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Do the bulk of query processing for the current query of 'client'.  * If 'event' is non-NULL, we are returning from recursion and 'qtype'  * is ignored.  Otherwise, 'qtype' is the query type.  */
end_comment

begin_function
specifier|static
name|void
name|query_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_fetchevent_t
modifier|*
name|event
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|zdb
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|zfname
decl_stmt|,
modifier|*
name|tname
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|trdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|zrdataset
decl_stmt|,
modifier|*
name|zsigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
decl_stmt|;
name|isc_boolean_t
name|want_restart
decl_stmt|,
name|authoritative
decl_stmt|,
name|is_zone
decl_stmt|,
name|need_wildcardproof
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|,
name|nlabels
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
name|int
name|order
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_t
name|wildcardname
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_rdata_cname_t
name|cname
decl_stmt|;
name|dns_rdata_dname_t
name|dname
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_boolean_t
name|empty_wild
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|noqname
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_find"
argument_list|)
expr_stmt|;
comment|/* 	 * One-time initialization. 	 * 	 * It's especially important to initialize anything that the cleanup 	 * code might cleanup. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|zdb
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_FALSE
expr_stmt|;
name|empty_wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We're returning from recursion.  Restore the query context 		 * and resume. 		 */
name|want_restart
operator|=
name|ISC_FALSE
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|qtype
operator|=
name|event
operator|->
name|qtype
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
name|db
operator|=
name|event
operator|->
name|db
expr_stmt|;
name|node
operator|=
name|event
operator|->
name|node
expr_stmt|;
name|rdataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
name|sigrdataset
operator|=
name|event
operator|->
name|sigrdataset
expr_stmt|;
comment|/* 		 * We'll need some resources... 		 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|tname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|tname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|event
operator|->
name|result
expr_stmt|;
goto|goto
name|resume
goto|;
block|}
comment|/* 	 * Not returning from recursion. 	 */
comment|/* 	 * If it's a SIG query, we'll iterate the node. 	 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
name|restart
label|:
name|CTRACE
argument_list|(
literal|"query_find: restart"
argument_list|)
expr_stmt|;
name|want_restart
operator|=
name|ISC_FALSE
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|checknames
operator|&&
operator|!
name|dns_rdata_checkowner
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|qtype
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|qtype
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"check-names failure %s/%s/%s"
argument_list|,
name|namebuf
argument_list|,
name|typename
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|QUERY_ERROR
argument_list|(
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * First we must find the right database. 	 */
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|qtype
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
name|options
operator||=
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|result
operator|=
name|query_getdb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|options
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|!
name|is_zone
operator|)
operator|&&
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ds
condition|)
block|{
comment|/* 		 * Look to see if we are authoritative for the 		 * child zone if the query type is DS. 		 */
name|dns_db_t
modifier|*
name|tdb
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|tzone
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|tversion
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|tresult
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_PARTIAL
argument_list|,
operator|&
name|tzone
argument_list|,
operator|&
name|tdb
argument_list|,
operator|&
name|tversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|options
operator|&=
operator|~
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|version
operator|=
name|tversion
expr_stmt|;
name|db
operator|=
name|tdb
expr_stmt|;
name|zone
operator|=
name|tzone
expr_stmt|;
name|is_zone
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|tdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|tzone
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_REFUSED
condition|)
name|QUERY_ERROR
argument_list|(
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
else|else
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|is_zone
condition|)
name|authoritative
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
operator|&&
name|client
operator|->
name|query
operator|.
name|restarts
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_zone
condition|)
block|{
name|dns_zone_attach
argument_list|(
name|zone
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|authzone
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|authdb
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|db_find
label|:
name|CTRACE
argument_list|(
literal|"query_find: db_find"
argument_list|)
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Now look for an answer in the database. 	 */
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|resume
label|:
name|CTRACE
argument_list|(
literal|"query_find: resume"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
comment|/* 		 * This case is handled in the main line below. 		 */
break|break;
case|case
name|DNS_R_GLUE
case|:
case|case
name|DNS_R_ZONECUT
case|:
comment|/* 		 * These cases are handled in the main line below. 		 */
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|ISC_R_NOTFOUND
case|:
comment|/* 		 * The cache doesn't even have the root NS.  Get them from 		 * the hints DB. 		 */
name|INSIST
argument_list|(
operator|!
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|hints
operator|==
name|NULL
condition|)
block|{
comment|/* We have no hints. */
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|hints
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_find
argument_list|(
name|db
argument_list|,
name|dns_rootname
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Nonsensical root hints may require cleanup. 			 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
comment|/* 			 * We don't have any root server hints, but 			 * we may have working forwarders, so try to 			 * recurse anyway. 			 */
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
else|else
block|{
comment|/* Unable to recurse. */
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
comment|/* Unable to give root server referral. */
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 		 * XXXRTH  We should trigger root server priming here. 		 */
comment|/* FALLTHROUGH */
case|case
name|DNS_R_DELEGATION
case|:
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|is_zone
condition|)
block|{
comment|/* 			 * Look to see if we are authoritative for the 			 * child zone if the query type is DS. 			 */
if|if
condition|(
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ds
condition|)
block|{
name|dns_db_t
modifier|*
name|tdb
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|tzone
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|tversion
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_PARTIAL
argument_list|,
operator|&
name|tzone
argument_list|,
operator|&
name|tdb
argument_list|,
operator|&
name|tversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|options
operator|&=
operator|~
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|version
operator|=
name|tversion
expr_stmt|;
name|db
operator|=
name|tdb
expr_stmt|;
name|zone
operator|=
name|tzone
expr_stmt|;
name|authoritative
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
if|if
condition|(
name|tdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|tdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|tzone
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We're authoritative for an ancestor of QNAME. 			 */
if|if
condition|(
operator|!
name|USECACHE
argument_list|(
name|client
argument_list|)
operator|||
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 				 * If we don't have a cache, this is the best 				 * answer. 				 * 				 * If the client is making a nonrecursive 				 * query we always give out the authoritative 				 * delegation.  This way even if we get 				 * junk in our cache, we won't fail in our 				 * role as the delegating authority if another 				 * nameserver asks us about a delegated 				 * subzone. 				 * 				 * We enable the retrieval of glue for this 				 * database by setting client->query.gluedb. 				 */
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|db
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * We must ensure NOADDITIONAL is off, 				 * because the generation of 				 * additional data is required in 				 * delegations. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
name|query_addds
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We might have a better answer or delegation 				 * in the cache.  We'll remember the current 				 * values of fname, rdataset, and sigrdataset. 				 * We'll then go looking for QNAME in the 				 * cache.  If we find something better, we'll 				 * use it instead. 				 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|zdb
operator|=
name|db
expr_stmt|;
name|zfname
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zfname
operator|!=
name|NULL
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
name|zfname
argument_list|)
condition|)
block|{
comment|/* 				 * We've already got a delegation from 				 * authoritative data, and it is better 				 * than what we found in the cache.  Use 				 * it instead of the cache delegation. 				 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|zfname
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * We've already done query_keepname() on 				 * zfname, so we must set dbuf to NULL to 				 * prevent query_addrrset() from trying to 				 * call query_keepname() again. 				 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|zrdataset
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|zsigrdataset
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * We don't clean up zdb here because we 				 * may still need it.  It will get cleaned 				 * up by the main cleanup code. 				 */
block|}
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 				 * Recurse! 				 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|type
argument_list|)
condition|)
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
else|else
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This is the best answer. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_CACHEGLUEOK
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|zdb
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * We must ensure NOADDITIONAL is off, 				 * because the generation of 				 * additional data is required in 				 * delegations. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_CACHEGLUEOK
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|query_addds
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_EMPTYNAME
case|:
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|DNS_R_NXRRSET
case|:
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * If we've got a NSEC record, we need to save the 			 * name now because we're going call query_addsoa() 			 * below, and it needs to use the name buffer. 			 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're not going to use fname, and need to release 			 * our hold on the name buffer so query_addsoa() 			 * may use it. 			 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add SOA. 		 */
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Add NSEC record if we found one. 		 */
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|query_addnxrrsetnsec
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_EMPTYWILD
case|:
name|empty_wild
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|DNS_R_NXDOMAIN
case|:
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * If we've got a NSEC record, we need to save the 			 * name now because we're going call query_addsoa() 			 * below, and it needs to use the name buffer. 			 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're not going to use fname, and need to release 			 * our hold on the name buffer so query_addsoa() 			 * may use it. 			 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add SOA.  If the query was for a SOA record force the 		 * ttl to zero so that it is possible for clients to find 		 * the containing zone of an arbitrary name with a stub 		 * resolver and not have it cached. 		 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_soa
condition|)
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Add NSEC record if we found one. 		 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Set message rcode. 		 */
if|if
condition|(
name|empty_wild
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_noerror
expr_stmt|;
else|else
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
case|case
name|DNS_R_NCACHENXRRSET
case|:
name|INSIST
argument_list|(
operator|!
name|is_zone
argument_list|)
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Set message rcode, if required. 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
comment|/* 		 * We don't call query_addrrset() because we don't need any 		 * of its extra features (and things would probably break!). 		 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|fname
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_CNAME
case|:
comment|/* 		 * Keep a copy of the rdataset.  We have to do this because 		 * query_addrrset may clear 'rdataset' (to prevent the 		 * cleanup code from cleaning it up). 		 */
name|trdataset
operator|=
name|rdataset
expr_stmt|;
comment|/* 		 * Add the CNAME to the answer section. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NOQNAME
operator|)
operator|!=
literal|0
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|noqname
operator|=
name|rdataset
expr_stmt|;
else|else
name|noqname
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|query_addnoqnameproof
argument_list|(
name|client
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
comment|/* 		 * We set the PARTIALANSWER attribute so that if anything goes 		 * wrong later on, we'll return what we've got so far. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_PARTIALANSWER
expr_stmt|;
comment|/* 		 * Reset qname to be the target name of the CNAME and restart 		 * the query. 		 */
name|tname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdataset_current
argument_list|(
name|trdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
name|query_maybeputqname
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|tname
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|addauth
goto|;
case|case
name|DNS_R_DNAME
case|:
comment|/* 		 * Compare the current qname to the found name.  We need 		 * to know how many labels and bits are in common because 		 * we're going to have to split qname later on. 		 */
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|namereln
operator|==
name|dns_namereln_subdomain
argument_list|)
expr_stmt|;
comment|/* 		 * Keep a copy of the rdataset.  We have to do this because 		 * query_addrrset may clear 'rdataset' (to prevent the 		 * cleanup code from cleaning it up). 		 */
name|trdataset
operator|=
name|rdataset
expr_stmt|;
comment|/* 		 * Add the DNAME to the answer section. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
comment|/* 		 * We set the PARTIALANSWER attribute so that if anything goes 		 * wrong later on, we'll return what we've got so far. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_PARTIALANSWER
expr_stmt|;
comment|/* 		 * Get the target name of the DNAME. 		 */
name|tname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdataset_current
argument_list|(
name|trdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|dname
operator|.
name|dname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
comment|/* 		 * Construct the new qname. 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|nlabels
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fname
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|prefix
argument_list|,
name|tname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
comment|/* 				 * RFC 2672, section 4.1, subsection 3c says 				 * we should return YXDOMAIN if the constructed 				 * name would be too long. 				 */
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_yxdomain
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
comment|/* 		 * Synthesize a CNAME for this DNAME. 		 * 		 * We want to synthesize a CNAME since if we don't 		 * then older software that doesn't understand DNAME 		 * will not chain like it should. 		 * 		 * We do not try to synthesize a signature because we hope 		 * that security aware servers will understand DNAME.  Also, 		 * even if we had an online key, making a signature 		 * on-the-fly is costly, and not really legitimate anyway 		 * since the synthesized CNAME is NOT in the zone. 		 */
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|query_addcnamelike
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|trdataset
operator|->
name|trust
argument_list|,
operator|&
name|tname
argument_list|,
name|dns_rdatatype_cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
comment|/* 		 * Switch to the new qname and restart. 		 */
name|query_maybeputqname
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|addauth
goto|;
default|default:
comment|/* 		 * Something has gone wrong. 		 */
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
block|{
comment|/* 		 * XXXRTH  Need to handle zonecuts with special case 		 * code. 		 */
name|n
operator|=
literal|0
expr_stmt|;
name|rdsiter
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Calling query_addrrset() with a non-NULL dbuf is going 		 * to either keep or release the name.  We don't want it to 		 * release fname, since we may have to call query_addrrset() 		 * more than once.  That means we have to call query_keepname() 		 * now, and pass a NULL dbuf to query_addrrset(). 		 * 		 * If we do a query_addrrset() below, we must set fname to 		 * NULL before leaving this block, otherwise we might try to 		 * cleanup fname even though we're using it! 		 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|tname
operator|=
name|fname
expr_stmt|;
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsiter
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|rdsiter
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qtype
operator|==
name|dns_rdatatype_any
operator|||
name|rdataset
operator|->
name|type
operator|==
name|qtype
operator|)
operator|&&
name|rdataset
operator|->
name|type
operator|!=
literal|0
condition|)
block|{
name|query_addrrset
argument_list|(
name|client
argument_list|,
name|fname
operator|!=
name|NULL
condition|?
operator|&
name|fname
else|:
operator|&
name|tname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|tname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * rdataset is non-NULL only in certain pathological 				 * cases involving DNAMEs. 				 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
comment|/* 				 * We're not interested in this rdataset. 				 */
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We didn't match any rdatasets. 			 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
comment|/* 				 * XXXRTH  If this is a secure zone and we 				 * didn't find any SIGs, we should generate 				 * an error unless we were searching for 				 * glue.  Ugh. 				 */
comment|/* 				 * We were searching for SIG records in 				 * a nonsecure zone.  Send a "no error, 				 * no data" response. 				 */
comment|/* 				 * Add SOA. 				 */
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Something went wrong. 				 */
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * This is the "normal" case -- an ordinary question to which 		 * we know the answer. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NOQNAME
operator|)
operator|!=
literal|0
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|noqname
operator|=
name|rdataset
expr_stmt|;
else|else
name|noqname
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|query_addnoqnameproof
argument_list|(
name|client
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
comment|/* 		 * We shouldn't ever fail to add 'rdataset' 		 * because it's already in the answer. 		 */
name|INSIST
argument_list|(
name|rdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|addauth
label|:
name|CTRACE
argument_list|(
literal|"query_find: addauth"
argument_list|)
expr_stmt|;
comment|/* 	 * Add NS records to the authority section (if we haven't already 	 * added them to the answer section). 	 */
if|if
condition|(
operator|!
name|want_restart
operator|&&
operator|!
name|NOAUTHORITY
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_zone
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|qtype
operator|==
name|dns_rdatatype_ns
operator|||
name|qtype
operator|==
name|dns_rdatatype_any
operator|)
operator|&&
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|query_addns
argument_list|(
name|client
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|!=
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|query_addbestns
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Add NSEC records to the authority section if they're needed for 	 * DNSSEC wildcard proofs. 	 */
if|if
condition|(
name|need_wildcardproof
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_find: cleanup"
argument_list|)
expr_stmt|;
comment|/* 	 * General cleanup. 	 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdb
operator|!=
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zsigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|zfname
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zdb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * AA bit. 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|restarts
operator|==
literal|0
operator|&&
operator|!
name|authoritative
condition|)
block|{
comment|/* 		 * We're not authoritative, so we must ensure the AA bit 		 * isn't set. 		 */
name|client
operator|->
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
block|}
comment|/* 	 * Restart the query? 	 */
if|if
condition|(
name|want_restart
operator|&&
name|client
operator|->
name|query
operator|.
name|restarts
operator|<
name|MAX_RESTARTS
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|restarts
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|eresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|(
operator|!
name|PARTIALANSWER
argument_list|(
name|client
argument_list|)
operator|||
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * If we don't have any answer to give the client, 		 * or if the client requested recursion and thus wanted 		 * the complete answer, send an error response. 		 */
name|query_error
argument_list|(
name|client
argument_list|,
name|eresult
argument_list|)
expr_stmt|;
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|RECURSING
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 		 * We are done.  Set up sortlist data for the message 		 * rendering code, make a final tweak to the AA bit if the 		 * auth-nxdomain config option says so, then render and 		 * send the response. 		 */
name|setup_query_sortlist
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a referral and the answer to the question 		 * is in the glue sort it to the start of the additional 		 * section. 		 */
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
operator|==
literal|0
operator|&&
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|&&
operator|(
name|qtype
operator|==
name|dns_rdatatype_a
operator|||
name|qtype
operator|==
name|dns_rdatatype_aaaa
operator|)
condition|)
name|answer_in_glue
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|&&
name|client
operator|->
name|view
operator|->
name|auth_nxdomain
operator|==
name|ISC_TRUE
condition|)
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
name|query_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_find: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_query
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_INFO
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_QUERIES
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|level
argument_list|,
literal|"query: %s %s %s %s%s%s"
argument_list|,
name|namebuf
argument_list|,
name|classname
argument_list|,
name|typename
argument_list|,
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
condition|?
literal|"+"
else|:
literal|"-"
argument_list|,
operator|(
name|client
operator|->
name|signer
operator|!=
name|NULL
operator|)
condition|?
literal|"S"
else|:
literal|""
argument_list|,
operator|(
name|client
operator|->
name|opt
operator|!=
name|NULL
operator|)
condition|?
literal|"E"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_query_start
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|client
operator|->
name|message
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|ns_client_t
modifier|*
name|qclient
decl_stmt|;
name|dns_rdatatype_t
name|qtype
decl_stmt|;
name|CTRACE
argument_list|(
literal|"ns_query_start"
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that appropriate cleanups occur. 	 */
name|client
operator|->
name|next
operator|=
name|query_next_callback
expr_stmt|;
comment|/* 	 * Behave as if we don't support DNSSEC if not enabled. 	 */
if|if
condition|(
operator|!
name|client
operator|->
name|view
operator|->
name|enablednssec
condition|)
block|{
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
name|client
operator|->
name|extflags
operator|&=
operator|~
name|DNS_MESSAGEEXTFLAG_DO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_RD
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_WANTRECURSION
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|extflags
operator|&
name|DNS_MESSAGEEXTFLAG_DO
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_WANTDNSSEC
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|minimalresponses
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
operator|(
name|NS_QUERYATTR_NOAUTHORITY
operator||
name|NS_QUERYATTR_NOADDITIONAL
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|view
operator|->
name|cachedb
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|client
operator|->
name|view
operator|->
name|additionalfromcache
operator|)
condition|)
block|{
comment|/* 		 * We don't have a cache.  Turn off cache support and 		 * recursion. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
operator|(
name|NS_QUERYATTR_RECURSIONOK
operator||
name|NS_QUERYATTR_CACHEOK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_RA
operator|)
operator|==
literal|0
operator|||
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_RD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the client isn't allowed to recurse (due to 		 * "recursion no", the allow-recursion ACL, or the 		 * lack of a resolver in this view), or if it 		 * doesn't want recursion, turn recursion off. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_RECURSIONOK
expr_stmt|;
block|}
comment|/* 	 * Get the question name. 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|origqname
operator|=
name|client
operator|->
name|query
operator|.
name|qname
expr_stmt|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * There's more than one QNAME in the question 			 * section. 			 */
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
block|}
else|else
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ns_g_server
operator|->
name|log_queries
condition|)
name|log_query
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Check for multiple question queries, since edns1 is dead. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|>
literal|1
condition|)
block|{
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for meta-queries like IXFR and AXFR. 	 */
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|qtype
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|dns_rdatatype_ismeta
argument_list|(
name|qtype
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|dns_rdatatype_any
case|:
break|break;
comment|/* Let query_find handle it. */
case|case
name|dns_rdatatype_ixfr
case|:
case|case
name|dns_rdatatype_axfr
case|:
name|ns_xfr_start
argument_list|(
name|client
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
case|case
name|dns_rdatatype_maila
case|:
case|case
name|dns_rdatatype_mailb
case|:
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_NOTIMP
argument_list|)
expr_stmt|;
return|return;
case|case
name|dns_rdatatype_tkey
case|:
name|result
operator|=
name|dns_tkey_processquery
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|ns_g_server
operator|->
name|tkeyctx
argument_list|,
name|client
operator|->
name|view
operator|->
name|dynamickeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|query_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
else|else
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* TSIG, etc. */
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If the client has requested that DNSSEC checking be disabled, 	 * allow lookups to return pending data and instruct the resolver 	 * to return data before validation has completed. 	 */
if|if
condition|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_CD
operator|||
name|qtype
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|dboptions
operator||=
name|DNS_DBFIND_PENDINGOK
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetchoptions
operator||=
name|DNS_FETCHOPT_NOVALIDATE
expr_stmt|;
block|}
comment|/* 	 * Allow glue NS records to be added to the authority section 	 * if the answer is secure. 	 */
if|if
condition|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_CD
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
comment|/* 	 * This is an ordinary query. 	 */
name|result
operator|=
name|dns_message_reply
argument_list|(
name|message
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|query_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Assume authoritative response until it is known to be 	 * otherwise. 	 */
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
comment|/* 	 * Set AD.  We must clear it if we add non-validated data to a 	 * response. 	 */
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|enablednssec
condition|)
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AD
expr_stmt|;
name|qclient
operator|=
name|NULL
expr_stmt|;
name|ns_client_attach
argument_list|(
name|client
argument_list|,
operator|&
name|qclient
argument_list|)
expr_stmt|;
name|query_find
argument_list|(
name|qclient
argument_list|,
name|NULL
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

