begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2013  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/hex.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/byaddr.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dlz.h>
end_include

begin_include
include|#
directive|include
file|<dns/dns64.h>
end_include

begin_include
include|#
directive|include
file|<dns/dnssec.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/ncache.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec3.h>
end_include

begin_include
include|#
directive|include
file|<dns/order.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/tkey.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<dns/zt.h>
end_include

begin_include
include|#
directive|include
file|<named/client.h>
end_include

begin_include
include|#
directive|include
file|<named/globals.h>
end_include

begin_include
include|#
directive|include
file|<named/log.h>
end_include

begin_include
include|#
directive|include
file|<named/server.h>
end_include

begin_include
include|#
directive|include
file|<named/sortlist.h>
end_include

begin_include
include|#
directive|include
file|<named/xfrout.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * It has been recommended that DNS64 be changed to return excluded  * AAAA addresses if DNS64 synthesis does not occur.  This minimises  * the impact on the lookup results.  While most DNS AAAA lookups are  * done to send IP packets to a host, not all of them are and filtering  * excluded addresses has a negative impact on those uses.  */
end_comment

begin_define
define|#
directive|define
name|dns64_bis_return_excluded_addresses
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*% Partial answer? */
end_comment

begin_define
define|#
directive|define
name|PARTIALANSWER
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_PARTIALANSWER) != 0)
end_define

begin_comment
comment|/*% Use Cache? */
end_comment

begin_define
define|#
directive|define
name|USECACHE
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_CACHEOK) != 0)
end_define

begin_comment
comment|/*% Recursion OK? */
end_comment

begin_define
define|#
directive|define
name|RECURSIONOK
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_RECURSIONOK) != 0)
end_define

begin_comment
comment|/*% Recursing? */
end_comment

begin_define
define|#
directive|define
name|RECURSING
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_RECURSING) != 0)
end_define

begin_comment
comment|/*% Cache glue ok? */
end_comment

begin_define
define|#
directive|define
name|CACHEGLUEOK
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_CACHEGLUEOK) != 0)
end_define

begin_comment
comment|/*% Want Recursion? */
end_comment

begin_define
define|#
directive|define
name|WANTRECURSION
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_WANTRECURSION) != 0)
end_define

begin_comment
comment|/*% Want DNSSEC? */
end_comment

begin_define
define|#
directive|define
name|WANTDNSSEC
parameter_list|(
name|c
parameter_list|)
value|(((c)->attributes& \ 				  NS_CLIENTATTR_WANTDNSSEC) != 0)
end_define

begin_comment
comment|/*% Want WANTAD? */
end_comment

begin_define
define|#
directive|define
name|WANTAD
parameter_list|(
name|c
parameter_list|)
value|(((c)->attributes& \ 				  NS_CLIENTATTR_WANTAD) != 0)
end_define

begin_comment
comment|/*% No authority? */
end_comment

begin_define
define|#
directive|define
name|NOAUTHORITY
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_NOAUTHORITY) != 0)
end_define

begin_comment
comment|/*% No additional? */
end_comment

begin_define
define|#
directive|define
name|NOADDITIONAL
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_NOADDITIONAL) != 0)
end_define

begin_comment
comment|/*% Secure? */
end_comment

begin_define
define|#
directive|define
name|SECURE
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_SECURE) != 0)
end_define

begin_comment
comment|/*% DNS64 A lookup? */
end_comment

begin_define
define|#
directive|define
name|DNS64
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_DNS64) != 0)
end_define

begin_define
define|#
directive|define
name|DNS64EXCLUDE
parameter_list|(
name|c
parameter_list|)
value|(((c)->query.attributes& \ 				  NS_QUERYATTR_DNS64EXCLUDE) != 0)
end_define

begin_comment
comment|/*% No QNAME Proof? */
end_comment

begin_define
define|#
directive|define
name|NOQNAME
parameter_list|(
name|r
parameter_list|)
value|(((r)->attributes& \ 				  DNS_RDATASETATTR_NOQNAME) != 0)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(ns_g_lctx, \ 				      NS_LOGCATEGORY_CLIENT, \ 				      NS_LOGMODULE_QUERY, \ 				      ISC_LOG_DEBUG(3), \ 				      "client %p: %s", client, (m))
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(ns_g_lctx, \ 				      NS_LOGCATEGORY_GENERAL, \ 				      NS_LOGMODULE_QUERY, \ 				      ISC_LOG_DEBUG(3), \ 				      "query %p: %s", query, (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)m)
end_define

begin_define
define|#
directive|define
name|QTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)m)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DNS_GETDB_NOEXACT
value|0x01U
end_define

begin_define
define|#
directive|define
name|DNS_GETDB_NOLOG
value|0x02U
end_define

begin_define
define|#
directive|define
name|DNS_GETDB_PARTIAL
value|0x04U
end_define

begin_define
define|#
directive|define
name|DNS_GETDB_IGNOREACL
value|0x08U
end_define

begin_define
define|#
directive|define
name|PENDINGOK
parameter_list|(
name|x
parameter_list|)
value|(((x)& DNS_DBFIND_PENDINGOK) != 0)
end_define

begin_typedef
typedef|typedef
struct|struct
name|client_additionalctx
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
block|}
name|client_additionalctx_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|isc_result_t
name|query_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_fetchevent_t
modifier|*
name|event
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|validate
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|query_findclosestnsec3
parameter_list|(
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|isc_boolean_t
name|exact
parameter_list|,
name|dns_name_t
modifier|*
name|found
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|log_queryerror
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpz_st_clear
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%  * Increment query statistics counters.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
name|dns_zone_t
modifier|*
name|zone
init|=
name|client
operator|->
name|query
operator|.
name|authzone
decl_stmt|;
name|isc_stats_t
modifier|*
name|zonestats
decl_stmt|;
ifdef|#
directive|ifdef
name|NEWSTATS
name|dns_rdatatype_t
name|qtype
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_stats_t
modifier|*
name|querystats
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|isc_stats_increment
argument_list|(
name|ns_g_server
operator|->
name|nsstats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|==
name|NULL
condition|)
return|return;
comment|/* Do regular response type stats */
name|zonestats
operator|=
name|dns_zone_getrequeststats
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonestats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|zonestats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEWSTATS
comment|/* Do query type statistics 	 * 	 * We only increment per-type if we're using the authoriative 	 * answer counter, preventing double-counting. 	 */
if|if
condition|(
name|counter
operator|==
name|dns_nsstatscounter_authans
condition|)
block|{
name|querystats
operator|=
name|dns_zone_getrcvquerystats
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|querystats
operator|!=
name|NULL
condition|)
block|{
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|qtype
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
name|dns_rdatatypestats_increment
argument_list|(
name|querystats
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|query_send
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_statscounter_t
name|counter
decl_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AA
operator|)
operator|==
literal|0
condition|)
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_nonauthans
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_authans
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
condition|)
block|{
name|dns_section_t
name|answer
init|=
name|DNS_SECTION_ANSWER
decl_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|message
operator|->
name|sections
index|[
name|answer
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|isreferral
condition|)
name|counter
operator|=
name|dns_nsstatscounter_referral
expr_stmt|;
else|else
name|counter
operator|=
name|dns_nsstatscounter_nxrrset
expr_stmt|;
block|}
else|else
name|counter
operator|=
name|dns_nsstatscounter_success
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
condition|)
name|counter
operator|=
name|dns_nsstatscounter_nxdomain
expr_stmt|;
else|else
comment|/* We end up here in case of YXDOMAIN, and maybe others */
name|counter
operator|=
name|dns_nsstatscounter_failure
expr_stmt|;
name|inc_stats
argument_list|(
name|client
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|ns_client_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_error
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|loglevel
init|=
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|DNS_R_SERVFAIL
case|:
name|loglevel
operator|=
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_servfail
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_R_FORMERR
case|:
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_formerr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_failure
argument_list|)
expr_stmt|;
break|break;
block|}
name|log_queryerror
argument_list|(
name|client
argument_list|,
name|result
argument_list|,
name|line
argument_list|,
name|loglevel
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_next
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_DUPLICATE
condition|)
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_duplicate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DROP
condition|)
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_dropped
argument_list|)
expr_stmt|;
else|else
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_failure
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_freefreeversions
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_boolean_t
name|everything
parameter_list|)
block|{
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|,
modifier|*
name|dbversion_next
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|dbversion_next
operator|,
name|i
operator|++
control|)
block|{
name|dbversion_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 		 * If we're not freeing everything, we keep the first three 		 * dbversions structures around. 		 */
if|if
condition|(
name|i
operator|>
literal|3
operator|||
name|everything
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|dbversion
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbversion
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_query_cancel
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|!=
name|NULL
condition|)
block|{
name|dns_resolver_cancelfetch
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_putrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
operator|*
name|rdatasetp
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_putrdataset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_putrdataset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_reset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_boolean_t
name|everything
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
modifier|*
name|dbuf_next
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|,
modifier|*
name|dbversion_next
decl_stmt|;
comment|/*% 	 * Reset the query state of a client to its default state. 	 */
comment|/* 	 * Cancel the fetch if it's running. 	 */
name|ns_query_cancel
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup any active versions. 	 */
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|dbversion_next
control|)
block|{
name|dbversion_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|dbversion
operator|->
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|dbversion
operator|->
name|db
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|authdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|authdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|authzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|authzone
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
argument_list|,
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|*
sizeof|sizeof
argument_list|(
name|isc_boolean_t
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|=
literal|0
expr_stmt|;
block|}
name|query_freefreeversions
argument_list|(
name|client
argument_list|,
name|everything
argument_list|)
expr_stmt|;
for|for
control|(
name|dbuf
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
init|;
name|dbuf
operator|!=
name|NULL
condition|;
name|dbuf
operator|=
name|dbuf_next
control|)
block|{
name|dbuf_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf_next
operator|!=
name|NULL
operator|||
name|everything
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|,
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|dbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|restarts
operator|>
literal|0
condition|)
block|{
comment|/* 		 * client->query.qname was dynamically allocated. 		 */
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|=
operator|(
name|NS_QUERYATTR_RECURSIONOK
operator||
name|NS_QUERYATTR_CACHEOK
operator||
name|NS_QUERYATTR_SECURE
operator|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|restarts
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|!=
name|NULL
condition|)
block|{
name|rpz_st_clear
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|everything
condition|)
block|{
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|query
operator|.
name|rpz_st
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
operator|->
name|query
operator|.
name|rpz_st
argument_list|)
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|client
operator|->
name|query
operator|.
name|origqname
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dboptions
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetchoptions
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_options
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|=
name|ISC_UINT32_MAX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_next_callback
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_query_free
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_newnamebuf
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_newnamebuf"
argument_list|)
expr_stmt|;
comment|/*% 	 * Allocate a name buffer. 	 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
operator|&
name|dbuf
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newnamebuf: isc_buffer_allocate failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|,
name|dbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newnamebuf: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_buffer_t
modifier|*
name|query_getnamebuf
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_getnamebuf"
argument_list|)
expr_stmt|;
comment|/*% 	 * Return a name buffer with space for a maximal name, allocating 	 * a new one if necessary. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_getnamebuf: query_newnamebuf failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|dbuf
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|255
condition|)
block|{
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_getnamebuf: query_newnamebuf failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbuf
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
literal|255
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_getnamebuf: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_keepname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_keepname"
argument_list|)
expr_stmt|;
comment|/*% 	 * 'name' is using space in 'dbuf', but 'dbuf' has not yet been 	 * adjusted to take account of that.  We do the adjustment. 	 */
name|REQUIRE
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|name
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|dbuf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_name_setbuffer
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_releasename
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
operator|*
name|namep
decl_stmt|;
comment|/*% 	 * 'name' is no longer needed.  Return it to our pool of temporary 	 * names.  If it is using a name buffer, relinquish its exclusive 	 * rights on the buffer. 	 */
name|CTRACE
argument_list|(
literal|"query_releasename"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_hasbuffer
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
block|}
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_releasename: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_name_t
modifier|*
name|query_newname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|isc_buffer_t
modifier|*
name|nbuf
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_NAMEBUFUSED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newname"
argument_list|)
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newname: dns_message_gettempname failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|isc_buffer_availableregion
argument_list|(
name|dbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
name|nbuf
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_setbuffer
argument_list|(
name|name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_NAMEBUFUSED
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newname: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rdataset_t
modifier|*
name|query_newrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_newrdataset"
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_newrdataset: "
literal|"dns_message_gettemprdataset failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_newrdataset: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_newdbversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dbversion
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbversion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|!=
name|NULL
condition|)
block|{
name|dbversion
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dbversion
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We only return ISC_R_NOMEMORY if we couldn't 			 * allocate anything. 			 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ns_dbversion_t
modifier|*
name|query_getdbversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_newdbversion
argument_list|(
name|client
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dbversion
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbversion
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_query_init
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|namebufs
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|client
operator|->
name|query
operator|.
name|freeversions
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|restarts
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|qname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authzone
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|=
literal|0
expr_stmt|;
name|query_reset
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|result
operator|=
name|query_newdbversion
argument_list|(
name|client
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|query_newnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|query_freefreeversions
argument_list|(
name|client
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ns_dbversion_t
modifier|*
name|query_findversion
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
comment|/*% 	 * We may already have done a query related to this 	 * database.  If so, we must be sure to make subsequent 	 * queries from the same version. 	 */
for|for
control|(
name|dbversion
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|)
init|;
name|dbversion
operator|!=
name|NULL
condition|;
name|dbversion
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbversion
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dbversion
operator|->
name|db
operator|==
name|db
condition|)
break|break;
block|}
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is a new zone for this query.  Add it to 		 * the active list. 		 */
name|dbversion
operator|=
name|query_getdbversion
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|dbversion
operator|->
name|version
argument_list|)
expr_stmt|;
name|dbversion
operator|->
name|acl_checked
operator|=
name|ISC_FALSE
expr_stmt|;
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|query
operator|.
name|activeversions
argument_list|,
name|dbversion
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dbversion
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_validatezonedb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_acl_t
modifier|*
name|queryacl
decl_stmt|,
modifier|*
name|queryonacl
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
name|REQUIRE
argument_list|(
name|zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * This limits our searching to the zone where the first name 	 * (the query target) was looked for.  This prevents following 	 * CNAMES or DNAMES into other zones and prevents returning 	 * additional data from other zones. 	 */
if|if
condition|(
operator|!
name|client
operator|->
name|view
operator|->
name|additionalfromauth
operator|&&
name|client
operator|->
name|query
operator|.
name|authdbset
operator|&&
name|db
operator|!=
name|client
operator|->
name|query
operator|.
name|authdb
condition|)
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
comment|/* 	 * Non recursive query to a static-stub zone is prohibited; its 	 * zone content is not public data, but a part of local configuration 	 * and should not be disclosed. 	 */
if|if
condition|(
name|dns_zone_gettype
argument_list|(
name|zone
argument_list|)
operator|==
name|dns_zone_staticstub
operator|&&
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
block|}
comment|/* 	 * If the zone has an ACL, we'll check it, otherwise 	 * we use the view's "allow-query" ACL.  Each ACL is only checked 	 * once per query. 	 * 	 * Also, get the database version to use. 	 */
comment|/* 	 * Get the current version of this database. 	 */
name|dbversion
operator|=
name|query_findversion
argument_list|(
name|client
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_GETDB_IGNOREACL
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|approved
goto|;
if|if
condition|(
name|dbversion
operator|->
name|acl_checked
condition|)
block|{
if|if
condition|(
operator|!
name|dbversion
operator|->
name|queryok
condition|)
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
goto|goto
name|approved
goto|;
block|}
name|queryacl
operator|=
name|dns_zone_getqueryacl
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryacl
operator|==
name|NULL
condition|)
block|{
name|queryacl
operator|=
name|client
operator|->
name|view
operator|->
name|queryacl
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOKVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * We've evaluated the view's queryacl already.  If 			 * NS_QUERYATTR_QUERYOK is set, then the client is 			 * allowed to make queries, otherwise the query should 			 * be refused. 			 */
name|dbversion
operator|->
name|acl_checked
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_QUERYOK
operator|)
operator|==
literal|0
condition|)
block|{
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
block|}
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|approved
goto|;
block|}
block|}
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|queryacl
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOLOG
operator|)
operator|==
literal|0
condition|)
block|{
name|char
name|msg
index|[
name|NS_CLIENT_ACLMSGSIZE
argument_list|(
literal|"query"
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s approved"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s denied"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|queryacl
operator|==
name|client
operator|->
name|view
operator|->
name|queryacl
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We were allowed by the default 			 * "allow-query" ACL.  Remember this so we 			 * don't have to check again. 			 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOK
expr_stmt|;
block|}
comment|/* 		 * We've now evaluated the view's query ACL, and 		 * the NS_QUERYATTR_QUERYOK attribute is now valid. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_QUERYOKVALID
expr_stmt|;
block|}
comment|/* If and only if we've gotten this far, check allow-query-on too */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|queryonacl
operator|=
name|dns_zone_getqueryonacl
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryonacl
operator|==
name|NULL
condition|)
name|queryonacl
operator|=
name|client
operator|->
name|view
operator|->
name|queryonacl
expr_stmt|;
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|queryonacl
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOLOG
operator|)
operator|==
literal|0
operator|&&
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"query-on denied"
argument_list|)
expr_stmt|;
block|}
name|dbversion
operator|->
name|acl_checked
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
block|}
name|dbversion
operator|->
name|queryok
operator|=
name|ISC_TRUE
expr_stmt|;
name|approved
label|:
comment|/* Transfer ownership, if necessary. */
if|if
condition|(
name|versionp
operator|!=
name|NULL
condition|)
operator|*
name|versionp
operator|=
name|dbversion
operator|->
name|version
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getzonedb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|ztoptions
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|partial
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/*% 	 * Find a zone database to answer the query. 	 */
name|ztoptions
operator|=
operator|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|)
condition|?
name|DNS_ZTFIND_NOEXACT
else|:
literal|0
expr_stmt|;
name|result
operator|=
name|dns_zt_find
argument_list|(
name|client
operator|->
name|view
operator|->
name|zonetable
argument_list|,
name|name
argument_list|,
name|ztoptions
argument_list|,
name|NULL
argument_list|,
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|partial
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|query_validatezonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|options
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* Transfer ownership. */
operator|*
name|zonep
operator|=
name|zone
expr_stmt|;
operator|*
name|dbp
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|partial
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_PARTIAL
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DNS_R_PARTIALMATCH
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpz_log_rewrite
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_boolean_t
name|disabled
parameter_list|,
name|dns_rpz_policy_t
name|policy
parameter_list|,
name|dns_rpz_type_t
name|type
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_name_t
modifier|*
name|rpz_qname
parameter_list|)
block|{
name|isc_stats_t
modifier|*
name|zonestats
decl_stmt|;
name|char
name|qname_buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|rpz_qname_buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
comment|/* 	 * Count enabled rewrites in the global counter. 	 * Count both enabled and disabled rewrites for each zone. 	 */
if|if
condition|(
operator|!
name|disabled
operator|&&
name|policy
operator|!=
name|DNS_RPZ_POLICY_PASSTHRU
condition|)
block|{
name|isc_stats_increment
argument_list|(
name|ns_g_server
operator|->
name|nsstats
argument_list|,
name|dns_nsstatscounter_rpz_rewrites
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
block|{
name|zonestats
operator|=
name|dns_zone_getrequeststats
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonestats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|zonestats
argument_list|,
name|dns_nsstatscounter_rpz_rewrites
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|DNS_RPZ_INFO_LEVEL
argument_list|)
condition|)
return|return;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qname_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|qname_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|rpz_qname
argument_list|,
name|rpz_qname_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpz_qname_buf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|DNS_RPZ_INFO_LEVEL
argument_list|,
literal|"%srpz %s %s rewrite %s via %s"
argument_list|,
name|disabled
condition|?
literal|"disabled "
else|:
literal|""
argument_list|,
name|dns_rpz_type2str
argument_list|(
name|type
argument_list|)
argument_list|,
name|dns_rpz_policy2str
argument_list|(
name|policy
argument_list|)
argument_list|,
name|qname_buf
argument_list|,
name|rpz_qname_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpz_log_fail
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|int
name|level
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|char
name|namebuf1
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf2
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
comment|/* 	 * bin/tests/system/rpz/tests.sh looks for "rpz.*failed". 	 */
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf1
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf1
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf2
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_QUERY_EERRORS
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|level
argument_list|,
literal|"rpz %s rewrite %s via %s %sfailed: %s"
argument_list|,
name|dns_rpz_type2str
argument_list|(
name|rpz_type
argument_list|)
argument_list|,
name|namebuf1
argument_list|,
name|namebuf2
argument_list|,
name|str
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a policy rewrite zone database.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_getdb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_name_t
modifier|*
name|rpz_qname
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|char
name|namebuf1
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|namebuf2
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|rpz_version
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|rpz_qname
argument_list|,
name|dns_rdatatype_any
argument_list|,
name|DNS_GETDB_IGNOREACL
argument_list|,
name|zonep
argument_list|,
name|dbp
argument_list|,
operator|&
name|rpz_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL2
argument_list|)
condition|)
block|{
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf1
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf1
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|rpz_qname
argument_list|,
name|namebuf2
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf2
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL2
argument_list|,
literal|"try rpz %s rewrite %s via %s"
argument_list|,
name|dns_rpz_type2str
argument_list|(
name|rpz_type
argument_list|)
argument_list|,
name|namebuf1
argument_list|,
name|namebuf2
argument_list|)
expr_stmt|;
block|}
operator|*
name|versionp
operator|=
name|rpz_version
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|rpz_qname
argument_list|,
literal|"query_getzonedb() "
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getcachedb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|check_acl
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/*% 	 * Find a cache database to answer the query. 	 * This may fail with DNS_R_REFUSED if the client 	 * is not allowed to use the cache. 	 */
if|if
condition|(
operator|!
name|USECACHE
argument_list|(
name|client
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_CACHEACLOKVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We've evaluated the view's cacheacl already.  If 		 * NS_QUERYATTR_CACHEACLOK is set, then the client is 		 * allowed to make queries, otherwise the query should 		 * be refused. 		 */
name|check_acl
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|query
operator|.
name|attributes
operator|&
name|NS_QUERYATTR_CACHEACLOK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|refuse
goto|;
block|}
else|else
block|{
comment|/* 		 * We haven't evaluated the view's queryacl yet. 		 */
name|check_acl
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|check_acl
condition|)
block|{
name|isc_boolean_t
name|log
init|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_GETDB_NOLOG
operator|)
operator|==
literal|0
argument_list|)
decl_stmt|;
name|char
name|msg
index|[
name|NS_CLIENT_ACLMSGSIZE
argument_list|(
literal|"query (cache)"
argument_list|)
index|]
decl_stmt|;
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|view
operator|->
name|cacheacl
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We were allowed by the "allow-query-cache" ACL. 			 * Remember this so we don't have to check again. 			 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_CACHEACLOK
expr_stmt|;
if|if
condition|(
name|log
operator|&&
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query (cache)"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s approved"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|log
condition|)
block|{
name|ns_client_aclmsg
argument_list|(
literal|"query (cache)"
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s denied"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We've now evaluated the view's query ACL, and 		 * the NS_QUERYATTR_CACHEACLOKVALID attribute is now valid. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_CACHEACLOKVALID
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|refuse
goto|;
block|}
comment|/* Approved. */
comment|/* Transfer ownership. */
operator|*
name|dbp
operator|=
name|db
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|refuse
label|:
name|result
operator|=
name|DNS_R_REFUSED
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_getdb
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
modifier|*
name|is_zonep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|namelabels
decl_stmt|;
name|unsigned
name|int
name|zonelabels
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|tdbp
decl_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tdbp
operator|=
name|NULL
expr_stmt|;
comment|/* Calculate how many labels are in name. */
name|namelabels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|zonelabels
operator|=
literal|0
expr_stmt|;
comment|/* Try to find name in bind's standard database. */
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|options
argument_list|,
operator|&
name|zone
argument_list|,
name|dbp
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
comment|/* See how many labels are in the zone's name.	  */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|zone
operator|!=
name|NULL
condition|)
name|zonelabels
operator|=
name|dns_name_countlabels
argument_list|(
name|dns_zone_getorigin
argument_list|(
name|zone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If # zone labels< # name labels, try to find an even better match 	 * Only try if a DLZ driver is loaded for this view 	 */
if|if
condition|(
name|zonelabels
operator|<
name|namelabels
operator|&&
name|client
operator|->
name|view
operator|->
name|dlzdatabase
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|dns_dlzfindzone
argument_list|(
name|client
operator|->
name|view
argument_list|,
name|name
argument_list|,
name|zonelabels
argument_list|,
operator|&
name|tdbp
argument_list|)
expr_stmt|;
comment|/* If we successful, we found a better match. */
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * If the previous search returned a zone, detach it. 			 */
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
comment|/* 			 * If the previous search returned a database, 			 * detach it. 			 */
if|if
condition|(
operator|*
name|dbp
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
comment|/* 			 * If the previous search returned a version, clear it. 			 */
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Get our database version. 			 */
name|dns_db_currentversion
argument_list|(
name|tdbp
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
comment|/* 			 * Be sure to return our database. 			 */
operator|*
name|dbp
operator|=
name|tdbp
expr_stmt|;
comment|/* 			 * We return a null zone, No stats for DLZ zones. 			 */
name|zone
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
comment|/* If successful, Transfer ownership of zone. */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|zonep
operator|=
name|zone
expr_stmt|;
comment|/* 		 * If neither attempt above succeeded, return the cache instead 		 */
operator|*
name|is_zonep
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|result
operator|=
name|query_getcachedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|dbp
argument_list|,
name|options
argument_list|)
expr_stmt|;
operator|*
name|is_zonep
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|query_isduplicate
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|mnamep
parameter_list|)
block|{
name|dns_section_t
name|section
decl_stmt|;
name|dns_name_t
modifier|*
name|mname
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_isduplicate"
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|DNS_SECTION_ANSWER
init|;
name|section
operator|<=
name|DNS_SECTION_ADDITIONAL
condition|;
name|section
operator|++
control|)
block|{
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|mname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * We've already got this RRset in the response. 			 */
name|CTRACE
argument_list|(
literal|"query_isduplicate: true: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
comment|/* 			 * The name exists, but the rdataset does not. 			 */
if|if
condition|(
name|section
operator|==
name|DNS_SECTION_ADDITIONAL
condition|)
break|break;
block|}
else|else
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXDOMAIN
argument_list|)
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mnamep
operator|!=
name|NULL
condition|)
operator|*
name|mnamep
operator|=
name|mname
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_isduplicate: false: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_addadditional
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
init|=
name|arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|trdataset
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|isc_boolean_t
name|added_something
decl_stmt|,
name|need_addname
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|qtype
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_rdatatype_isdnssec
argument_list|(
name|qtype
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|CTRACE
argument_list|(
literal|"query_addadditional"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|trdataset
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|added_something
operator|=
name|ISC_FALSE
expr_stmt|;
name|need_addname
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * We treat type A additional section processing as if it 	 * were "any address type" additional section processing. 	 * To avoid multiple lookups, we do an 'any' database 	 * lookup and iterate over the node. 	 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_a
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
comment|/* 	 * Get some resources. 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Look for a zone database that might contain authoritative 	 * additional data. 	 */
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|try_cache
goto|;
name|CTRACE
argument_list|(
literal|"query_addadditional: db_find"
argument_list|)
expr_stmt|;
comment|/* 	 * Since we are looking for authoritative data, we do not set 	 * the GLUEOK flag.  Glue will be looked for later, but not 	 * necessarily in the same database. 	 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
operator|!
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * No authoritative data was found.  The cache is our next best bet. 	 */
name|try_cache
label|:
name|result
operator|=
name|query_getcachedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
operator|&
name|db
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
comment|/* 		 * Most likely the client isn't allowed to query the cache. 		 */
goto|goto
name|try_glue
goto|;
comment|/* 	 * Attempt to validate glue. 	 */
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_GLUEOK
operator||
name|DNS_DBFIND_ADDITIONALOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_GLUE
operator|&&
name|validate
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
name|try_glue
label|:
comment|/* 	 * No cached data was found.  Glue is our last chance. 	 * RFC1035 sayeth: 	 * 	 *	NS records cause both the usual additional section 	 *	processing to locate a type A record, and, when used 	 *	in a referral, a special search of the zone in which 	 *	they reside for glue information. 	 * 	 * This is the "special search".  Note that we must search 	 * the zone where the NS record resides, not the zone it 	 * points to, and that we only do the search in the delegation 	 * case (identified by client->query.gluedb being set). 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|gluedb
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Don't poison caches using the bailiwick protection model. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|)
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_GLUEOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_ZONECUT
operator|||
name|result
operator|==
name|DNS_R_GLUE
operator|)
condition|)
goto|goto
name|cleanup
goto|;
name|found
label|:
comment|/* 	 * We have found a potential additional data rdataset, or 	 * at least a node to iterate over. 	 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an rdataset, add it to the additional data 	 * section. 	 */
name|mname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|&&
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|type
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|mname
operator|!=
name|fname
argument_list|)
expr_stmt|;
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|trdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Note: we only add SIGs if we've added the type they cover, 		 * so we do not need to check if the SIG rdataset is already 		 * in the response. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_a
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
name|isc_boolean_t
name|have_a
init|=
name|ISC_FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* 		 * We now go looking for A and AAAA records, along with 		 * their signatures. 		 * 		 * XXXRTH  This code could be more efficient. 		 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
if|if
condition|(
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|aaaa_lookup
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mname
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
name|have_a
operator|=
name|ISC_TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_a
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|fname
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|addname
goto|;
block|}
else|else
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
name|aaaa_lookup
label|:
if|if
condition|(
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|addname
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
goto|goto
name|addname
goto|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|mname
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * There's an A; check whether we're filtering AAAA 			 */
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
if|if
condition|(
name|have_a
operator|&&
operator|(
name|client
operator|->
name|filter_aaaa
operator|==
name|dns_v4_aaaa_break_dnssec
operator|||
operator|(
name|client
operator|->
name|filter_aaaa
operator|==
name|dns_v4_aaaa_filter
operator|&&
operator|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
operator|)
operator|)
operator|)
condition|)
goto|goto
name|addname
goto|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|fname
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|addname
label|:
name|CTRACE
argument_list|(
literal|"query_addadditional: addname"
argument_list|)
expr_stmt|;
comment|/* 	 * If we haven't added anything, then we're done. 	 */
if|if
condition|(
operator|!
name|added_something
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * We may have added our rdatasets to an existing name, if so, then 	 * need_addname will be ISC_FALSE.  Whether we used an existing name 	 * or a new one, we must set fname to NULL to prevent cleanup. 	 */
if|if
condition|(
name|need_addname
condition|)
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|fname
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In a few cases, we want to add additional data for additional 	 * data.  It's simpler to just deal with special cases here than 	 * to try to create a general purpose mechanism and allow the 	 * rdata implementations to do it themselves. 	 * 	 * This involves recursion, but the depth is limited.  The 	 * most complex case is adding a SRV rdataset, which involves 	 * recursing to add address records, which in turn can cause 	 * recursion to add KEYs. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_srv
operator|&&
name|trdataset
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're adding SRV records to the additional data 		 * section, it's helpful if we add the SRV additional data 		 * as well. 		 */
name|eresult
operator|=
name|dns_rdataset_additionaldata
argument_list|(
name|trdataset
argument_list|,
name|query_addadditional
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_addadditional: cleanup"
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addadditional: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_discardcache
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset_base
parameter_list|,
name|dns_rdatasetadditional_t
name|additionaltype
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
while|while
condition|(
operator|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fname
operator|->
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|versionp
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
operator|*
name|dbp
argument_list|,
name|versionp
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nodep
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zonep
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_putadditional
argument_list|(
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_iscachevalid
parameter_list|(
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_db_t
modifier|*
name|db0
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version_current
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db_current
init|=
name|db0
decl_stmt|;
if|if
condition|(
name|db_current
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_db_currentversion
argument_list|(
name|db_current
argument_list|,
operator|&
name|version_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_current
operator|!=
name|db
operator|||
name|version_current
operator|!=
name|version
condition|)
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
name|dns_db_closeversion
argument_list|(
name|db_current
argument_list|,
operator|&
name|version_current
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|db0
operator|==
name|NULL
operator|&&
name|db_current
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db_current
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_addadditional2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|client_additionalctx_t
modifier|*
name|additionalctx
init|=
name|arg
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset_base
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|cnode
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|cdb
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|mname0
decl_stmt|,
name|cfname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|crdataset
decl_stmt|,
modifier|*
name|crdataset_next
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|,
modifier|*
name|cversion
decl_stmt|;
name|isc_boolean_t
name|added_something
decl_stmt|,
name|need_addname
decl_stmt|,
name|needadditionalcache
decl_stmt|;
name|isc_boolean_t
name|need_sigrrset
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_rdatasetadditional_t
name|additionaltype
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
comment|/* 	 * If we don't have an additional cache call query_addadditional. 	 */
name|client
operator|=
name|additionalctx
operator|->
name|client
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|!=
name|dns_rdatatype_a
operator|||
name|client
operator|->
name|view
operator|->
name|acache
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This function is optimized for "address" types.  For other 		 * types, use a generic routine. 		 * XXX: ideally, this function should be generic enough. 		 */
return|return
operator|(
name|query_addadditional
argument_list|(
name|additionalctx
operator|->
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Initialization. 	 */
name|rdataset_base
operator|=
name|additionalctx
operator|->
name|rdataset
expr_stmt|;
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|cdb
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|cversion
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|cnode
operator|=
name|NULL
expr_stmt|;
name|added_something
operator|=
name|ISC_FALSE
expr_stmt|;
name|need_addname
operator|=
name|ISC_FALSE
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|needadditionalcache
operator|=
name|ISC_FALSE
expr_stmt|;
name|POST
argument_list|(
name|needadditionalcache
argument_list|)
expr_stmt|;
name|additionaltype
operator|=
name|dns_rdatasetadditional_fromauth
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|cfname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addadditional2"
argument_list|)
expr_stmt|;
comment|/* 	 * We treat type A additional section processing as if it 	 * were "any address type" additional section processing. 	 * To avoid multiple lookups, we do an 'any' database 	 * lookup and iterate over the node. 	 * XXXJT: this approach can cause a suboptimal result when the cache 	 * DB only has partial address types and the glue DB has remaining 	 * ones. 	 */
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
comment|/* 	 * Get some resources. 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|dns_name_setbuffer
argument_list|(
operator|&
name|cfname
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* share the buffer */
comment|/* Check additional cache */
name|result
operator|=
name|dns_rdataset_getadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
operator|&
name|cnode
argument_list|,
operator|&
name|cfname
argument_list|,
name|client
operator|->
name|message
argument_list|,
name|client
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|findauthdb
goto|;
if|if
condition|(
name|zone
operator|==
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addadditional2: auth zone not found"
argument_list|)
expr_stmt|;
goto|goto
name|try_cache
goto|;
block|}
comment|/* Is the cached DB up-to-date? */
name|result
operator|=
name|query_iscachevalid
argument_list|(
name|zone
argument_list|,
name|cdb
argument_list|,
name|NULL
argument_list|,
name|cversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addadditional2: old auth additional cache"
argument_list|)
expr_stmt|;
name|query_discardcache
argument_list|(
name|client
argument_list|,
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
operator|&
name|cnode
argument_list|,
operator|&
name|cfname
argument_list|)
expr_stmt|;
goto|goto
name|findauthdb
goto|;
block|}
if|if
condition|(
name|cnode
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We have a negative cache.  We don't have to check the zone 		 * ACL, since the result (not using this zone) would be same 		 * regardless of the result. 		 */
name|CTRACE
argument_list|(
literal|"query_addadditional2: negative auth additional cache"
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|cdb
argument_list|)
expr_stmt|;
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
goto|goto
name|try_cache
goto|;
block|}
name|result
operator|=
name|query_validatezonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|,
name|zone
argument_list|,
name|cdb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|query_discardcache
argument_list|(
name|client
argument_list|,
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
operator|&
name|cnode
argument_list|,
operator|&
name|cfname
argument_list|)
expr_stmt|;
goto|goto
name|try_cache
goto|;
block|}
comment|/* We've got an active cache. */
name|CTRACE
argument_list|(
literal|"query_addadditional2: auth additional cache"
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|db
operator|=
name|cdb
expr_stmt|;
name|node
operator|=
name|cnode
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|cfname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
goto|goto
name|foundcache
goto|;
comment|/* 	 * Look for a zone database that might contain authoritative 	 * additional data. 	 */
name|findauthdb
label|:
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* Cache the negative result */
operator|(
name|void
operator|)
name|dns_rdataset_setadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|try_cache
goto|;
block|}
name|CTRACE
argument_list|(
literal|"query_addadditional2: db_find"
argument_list|)
expr_stmt|;
comment|/* 	 * Since we are looking for authoritative data, we do not set 	 * the GLUEOK flag.  Glue will be looked for later, but not 	 * necessarily in the same database. 	 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|found
goto|;
comment|/* Cache the negative result */
operator|(
name|void
operator|)
name|dns_rdataset_setadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * No authoritative data was found.  The cache is our next best bet. 	 */
name|try_cache
label|:
name|additionaltype
operator|=
name|dns_rdatasetadditional_fromcache
expr_stmt|;
name|result
operator|=
name|query_getcachedb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
operator|&
name|db
argument_list|,
name|DNS_GETDB_NOLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
comment|/* 		 * Most likely the client isn't allowed to query the cache. 		 */
goto|goto
name|try_glue
goto|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_GLUEOK
operator||
name|DNS_DBFIND_ADDITIONALOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
name|try_glue
label|:
comment|/* 	 * No cached data was found.  Glue is our last chance. 	 * RFC1035 sayeth: 	 * 	 *	NS records cause both the usual additional section 	 *	processing to locate a type A record, and, when used 	 *	in a referral, a special search of the zone in which 	 *	they reside for glue information. 	 * 	 * This is the "special search".  Note that we must search 	 * the zone where the NS record resides, not the zone it 	 * points to, and that we only do the search in the delegation 	 * case (identified by client->query.gluedb being set). 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|gluedb
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Don't poison caches using the bailiwick protection model. 	 */
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|)
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Check additional cache */
name|additionaltype
operator|=
name|dns_rdatasetadditional_fromglue
expr_stmt|;
name|result
operator|=
name|dns_rdataset_getadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|NULL
argument_list|,
operator|&
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
operator|&
name|cnode
argument_list|,
operator|&
name|cfname
argument_list|,
name|client
operator|->
name|message
argument_list|,
name|client
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|findglue
goto|;
name|result
operator|=
name|query_iscachevalid
argument_list|(
name|zone
argument_list|,
name|cdb
argument_list|,
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|,
name|cversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addadditional2: old glue additional cache"
argument_list|)
expr_stmt|;
name|query_discardcache
argument_list|(
name|client
argument_list|,
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
operator|&
name|cnode
argument_list|,
operator|&
name|cfname
argument_list|)
expr_stmt|;
goto|goto
name|findglue
goto|;
block|}
if|if
condition|(
name|cnode
operator|==
name|NULL
condition|)
block|{
comment|/* We have a negative cache. */
name|CTRACE
argument_list|(
literal|"query_addadditional2: negative glue additional cache"
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|cdb
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Cache hit. */
name|CTRACE
argument_list|(
literal|"query_addadditional2: glue additional cache"
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|cdb
argument_list|,
operator|&
name|cversion
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|db
operator|=
name|cdb
expr_stmt|;
name|node
operator|=
name|cnode
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|cfname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
goto|goto
name|foundcache
goto|;
name|findglue
label|:
name|dns_db_attach
argument_list|(
name|client
operator|->
name|query
operator|.
name|gluedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_GLUEOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_ZONECUT
operator|||
name|result
operator|==
name|DNS_R_GLUE
operator|)
condition|)
block|{
comment|/* cache the negative result */
operator|(
name|void
operator|)
name|dns_rdataset_setadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|NULL
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|found
label|:
comment|/* 	 * We have found a DB node to iterate over from a DB. 	 * We are going to look for address RRsets (i.e., A and AAAA) in the DB 	 * node we've just found.  We'll then store the complete information 	 * in the additional data cache. 	 */
name|dns_name_clone
argument_list|(
name|fname
argument_list|,
operator|&
name|cfname
argument_list|)
expr_stmt|;
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|needadditionalcache
operator|=
name|ISC_TRUE
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromcache
operator|&&
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|aaaa_lookup
goto|;
comment|/* 	 * Find A RRset with sig RRset.  Even if we don't find a sig RRset 	 * for a client using DNSSEC, we'll continue the process to make a 	 * complete list to be cached.  However, we need to cancel the 	 * caching when something unexpected happens, in order to avoid 	 * caching incomplete information. 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't promote glue/pending from the cache to secure 	 * then drop it. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromcache
operator|&&
operator|(
name|DNS_TRUST_PENDING
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|||
name|DNS_TRUST_GLUE
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|)
operator|&&
operator|!
name|validate
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
goto|goto
name|setcache
goto|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* Remember the result as a cache */
name|ISC_LIST_APPEND
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
block|{
comment|/* do not cache incomplete information */
goto|goto
name|foundcache
goto|;
block|}
block|}
name|aaaa_lookup
label|:
if|if
condition|(
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromcache
operator|&&
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|foundcache
goto|;
comment|/* Find AAAA RRset with sig RRset */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't promote glue/pending from the cache to secure 	 * then drop it. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromcache
operator|&&
operator|(
name|DNS_TRUST_PENDING
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|||
name|DNS_TRUST_GLUE
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|)
operator|&&
operator|!
name|validate
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|setcache
label|:
comment|/* 	 * Set the new result in the cache if required.  We do not support 	 * caching additional data from a cache DB. 	 */
if|if
condition|(
name|needadditionalcache
operator|==
name|ISC_TRUE
operator|&&
operator|(
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromauth
operator|||
name|additionaltype
operator|==
name|dns_rdatasetadditional_fromglue
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dns_rdataset_setadditional
argument_list|(
name|rdataset_base
argument_list|,
name|additionaltype
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|view
operator|->
name|acache
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
operator|&
name|cfname
argument_list|)
expr_stmt|;
block|}
name|foundcache
label|:
name|need_sigrrset
operator|=
name|ISC_FALSE
expr_stmt|;
name|mname0
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|crdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cfname
operator|.
name|list
argument_list|)
init|;
name|crdataset
operator|!=
name|NULL
condition|;
name|crdataset
operator|=
name|crdataset_next
control|)
block|{
name|dns_name_t
modifier|*
name|mname
decl_stmt|;
name|crdataset_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|crdataset
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|||
name|crdataset
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
condition|)
block|{
if|if
condition|(
operator|!
name|query_isduplicate
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|crdataset
operator|->
name|type
argument_list|,
operator|&
name|mname
argument_list|)
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|fname
condition|)
block|{
if|if
condition|(
name|mname
operator|!=
name|NULL
condition|)
block|{
comment|/* 						 * A different type of this name is 						 * already stored in the additional 						 * section.  We'll reuse the name. 						 * Note that this should happen at most 						 * once.  Otherwise, fname->link could 						 * leak below. 						 */
name|INSIST
argument_list|(
name|mname0
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|mname
expr_stmt|;
name|mname0
operator|=
name|mname
expr_stmt|;
block|}
else|else
name|need_addname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
name|need_sigrrset
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|need_sigrrset
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|need_sigrrset
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|added_something
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* just in case */
name|need_sigrrset
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
name|CTRACE
argument_list|(
literal|"query_addadditional2: addname"
argument_list|)
expr_stmt|;
comment|/* 	 * If we haven't added anything, then we're done. 	 */
if|if
condition|(
operator|!
name|added_something
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * We may have added our rdatasets to an existing name, if so, then 	 * need_addname will be ISC_FALSE.  Whether we used an existing name 	 * or a new one, we must set fname to NULL to prevent cleanup. 	 */
if|if
condition|(
name|need_addname
condition|)
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|fname
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_addadditional2: cleanup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|crdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|cfname
operator|.
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|cfname
operator|.
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|crdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addadditional2: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|query_addrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|client_additionalctx_t
name|additionalctx
decl_stmt|;
comment|/* 	 * Add 'rdataset' and any pertinent additional data to 	 * 'fname', a name in the response message for 'client'. 	 */
name|CTRACE
argument_list|(
literal|"query_addrdataset"
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|order
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|dns_order_find
argument_list|(
name|client
operator|->
name|view
operator|->
name|order
argument_list|,
name|fname
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_LOADORDER
expr_stmt|;
if|if
condition|(
name|NOADDITIONAL
argument_list|(
name|client
argument_list|)
condition|)
return|return;
comment|/* 	 * Add additional data. 	 * 	 * We don't care if dns_rdataset_additionaldata() fails. 	 */
name|additionalctx
operator|.
name|client
operator|=
name|client
expr_stmt|;
name|additionalctx
operator|.
name|rdataset
operator|=
name|rdataset
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataset_additionaldata
argument_list|(
name|rdataset
argument_list|,
name|query_addadditional2
argument_list|,
operator|&
name|additionalctx
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addrdataset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_dns64
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdata_t
modifier|*
name|dns64_rdata
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|dns64_rdatalist
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|dns64_rdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|mrdataset
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_view_t
modifier|*
name|view
init|=
name|client
operator|->
name|view
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|dns_dns64_t
modifier|*
name|dns64
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|/*% 	 * To the current response for 'client', add the answer RRset 	 * '*rdatasetp' and an optional signature set '*sigrdatasetp', with 	 * owner name '*namep', to section 'section', unless they are 	 * already there.  Also add any pertinent additional data. 	 * 	 * If 'dbuf' is not NULL, then '*namep' is the name whose data is 	 * stored in 'dbuf'.  In this case, query_addrrset() guarantees that 	 * when it returns the name will either have been kept or released. 	 */
name|CTRACE
argument_list|(
literal|"query_dns64"
argument_list|)
expr_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
name|mrdataset
operator|=
name|NULL
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|dns64_rdata
operator|=
name|NULL
expr_stmt|;
name|dns64_rdataset
operator|=
name|NULL
expr_stmt|;
name|dns64_rdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|mrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * We've already got an RRset of the given name and type. 		 * There's nothing else to do; 		 */
name|CTRACE
argument_list|(
literal|"query_dns64: dns_message_findname succeeded: done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
comment|/* 		 * The name doesn't exist. 		 */
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_keepname
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
name|mname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXRRSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|&&
operator|(
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|||
name|section
operator|==
name|DNS_SECTION_AUTHORITY
operator|)
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
operator|&
name|buffer
argument_list|,
name|view
operator|->
name|dns64cnt
operator|*
literal|16
operator|*
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_rdataset_init
argument_list|(
name|dns64_rdataset
argument_list|)
expr_stmt|;
name|dns_rdatalist_init
argument_list|(
name|dns64_rdatalist
argument_list|)
expr_stmt|;
name|dns64_rdatalist
operator|->
name|rdclass
operator|=
name|dns_rdataclass_in
expr_stmt|;
name|dns64_rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_aaaa
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|!=
name|ISC_UINT32_MAX
condition|)
name|dns64_rdatalist
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|client
operator|->
name|query
operator|.
name|dns64_ttl
argument_list|)
expr_stmt|;
else|else
name|dns64_rdatalist
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
literal|600
argument_list|)
expr_stmt|;
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
name|flags
operator||=
name|DNS_DNS64_RECURSIVE
expr_stmt|;
comment|/* 	 * We use the signatures from the A lookup to set DNS_DNS64_DNSSEC 	 * as this provides a easy way to see if the answer was signed. 	 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|flags
operator||=
name|DNS_DNS64_DNSSEC
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
for|for
control|(
name|dns64
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|view
operator|->
name|dns64
argument_list|)
init|;
name|dns64
operator|!=
name|NULL
condition|;
name|dns64
operator|=
name|dns_dns64_next
argument_list|(
name|dns64
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc__buffer_availableregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
literal|16
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dns64_aaaafroma
argument_list|(
name|dns64
argument_list|,
operator|&
name|netaddr
argument_list|,
name|client
operator|->
name|signer
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
name|flags
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|isc_buffer_remainingregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_forward
argument_list|(
name|buffer
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_rdata_init
argument_list|(
name|dns64_rdata
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|dns64_rdata
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|dns64_rdatalist
operator|->
name|rdata
argument_list|,
name|dns64_rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns64_rdata
operator|=
name|NULL
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|dns64_rdatalist
operator|->
name|rdata
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdatalist_tordataset
argument_list|(
name|dns64_rdatalist
argument_list|,
name|dns64_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
name|dns64_rdataset
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|query_addrdataset
argument_list|(
name|client
argument_list|,
name|mname
argument_list|,
name|dns64_rdataset
argument_list|)
expr_stmt|;
name|dns64_rdataset
operator|=
name|NULL
expr_stmt|;
name|dns64_rdatalist
operator|=
name|NULL
expr_stmt|;
name|dns_message_takebuffer
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns64_rdata
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns64_rdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns64_rdatalist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|dns64_rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dns64_rdatalist
operator|->
name|rdata
argument_list|)
init|;
name|dns64_rdata
operator|!=
name|NULL
condition|;
name|dns64_rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dns64_rdatalist
operator|->
name|rdata
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|dns64_rdatalist
operator|->
name|rdata
argument_list|,
name|dns64_rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_puttemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdata
argument_list|)
expr_stmt|;
block|}
name|dns_message_puttemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns64_rdatalist
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_dns64: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_filter64
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdata_t
modifier|*
name|myrdata
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|myrdatalist
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|myrdataset
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_filter64"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|==
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
name|myrdata
operator|=
name|NULL
expr_stmt|;
name|myrdataset
operator|=
name|NULL
expr_stmt|;
name|myrdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|myrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * We've already got an RRset of the given name and type. 		 * There's nothing else to do; 		 */
name|CTRACE
argument_list|(
literal|"query_filter64: dns_message_findname succeeded: done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
name|mname
operator|=
name|name
expr_stmt|;
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXRRSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|&&
operator|(
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|||
name|section
operator|==
name|DNS_SECTION_AUTHORITY
operator|)
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
operator|&
name|buffer
argument_list|,
literal|16
operator|*
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_rdataset_init
argument_list|(
name|myrdataset
argument_list|)
expr_stmt|;
name|dns_rdatalist_init
argument_list|(
name|myrdatalist
argument_list|)
expr_stmt|;
name|myrdatalist
operator|->
name|rdclass
operator|=
name|dns_rdataclass_in
expr_stmt|;
name|myrdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_aaaa
expr_stmt|;
name|myrdatalist
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
index|[
name|i
operator|++
index|]
condition|)
continue|continue;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdata
operator|.
name|length
operator|==
literal|16
argument_list|)
expr_stmt|;
name|isc_buffer_putmem
argument_list|(
name|buffer
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_remainingregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_forward
argument_list|(
name|buffer
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_rdata_init
argument_list|(
name|myrdata
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|myrdata
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|myrdatalist
operator|->
name|rdata
argument_list|,
name|myrdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|myrdata
operator|=
name|NULL
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdatalist_tordataset
argument_list|(
name|myrdatalist
argument_list|,
name|myrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|mname
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_keepname
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|myrdataset
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|query_addrdataset
argument_list|(
name|client
argument_list|,
name|mname
argument_list|,
name|myrdataset
argument_list|)
expr_stmt|;
name|myrdataset
operator|=
name|NULL
expr_stmt|;
name|myrdatalist
operator|=
name|NULL
expr_stmt|;
name|dns_message_takebuffer
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|myrdata
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|myrdataset
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|myrdatalist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|myrdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|myrdatalist
operator|->
name|rdata
argument_list|)
init|;
name|myrdata
operator|!=
name|NULL
condition|;
name|myrdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|myrdatalist
operator|->
name|rdata
argument_list|)
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|myrdatalist
operator|->
name|rdata
argument_list|,
name|myrdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_puttemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdata
argument_list|)
expr_stmt|;
block|}
name|dns_message_puttemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|myrdatalist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_filter64: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addrrset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|mname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|mrdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/*% 	 * To the current response for 'client', add the answer RRset 	 * '*rdatasetp' and an optional signature set '*sigrdatasetp', with 	 * owner name '*namep', to section 'section', unless they are 	 * already there.  Also add any pertinent additional data. 	 * 	 * If 'dbuf' is not NULL, then '*namep' is the name whose data is 	 * stored in 'dbuf'.  In this case, query_addrrset() guarantees that 	 * when it returns the name will either have been kept or released. 	 */
name|CTRACE
argument_list|(
literal|"query_addrrset"
argument_list|)
expr_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
name|rdataset
operator|=
operator|*
name|rdatasetp
expr_stmt|;
if|if
condition|(
name|sigrdatasetp
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|=
operator|*
name|sigrdatasetp
expr_stmt|;
else|else
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|mname
operator|=
name|NULL
expr_stmt|;
name|mrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|,
operator|&
name|mname
argument_list|,
operator|&
name|mrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * We've already got an RRset of the given name and type. 		 * There's nothing else to do; 		 */
name|CTRACE
argument_list|(
literal|"query_addrrset: dns_message_findname succeeded: done"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
comment|/* 		 * The name doesn't exist. 		 */
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_keepname
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
name|mname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|DNS_R_NXRRSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
name|namep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|&&
operator|(
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|||
name|section
operator|==
name|DNS_SECTION_AUTHORITY
operator|)
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
comment|/* 	 * Note: we only add SIGs if we've added the type they cover, so 	 * we do not need to check if the SIG rdataset is already in the 	 * response. 	 */
name|query_addrdataset
argument_list|(
name|client
argument_list|,
name|mname
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
operator|*
name|rdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
block|{
comment|/* 		 * We have a signature.  Add it to the response. 		 */
name|ISC_LIST_APPEND
argument_list|(
name|mname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_addrrset: done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_addsoa
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|unsigned
name|int
name|override_ttl
parameter_list|,
name|isc_boolean_t
name|isassociated
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
init|=
name|NULL
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addsoa"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Don't add the SOA record for test which set "-T nosoa". 	 */
if|if
condition|(
name|ns_g_nosoa
operator|&&
operator|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
operator|!
name|isassociated
operator|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* 	 * Get resources and make 'name' be the database origin. 	 */
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Find the SOA. 	 */
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * This is bad.  We tried to get the SOA RR at the zone top 		 * and it didn't work! 		 */
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Extract the SOA MINIMUM. 		 */
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|override_ttl
operator|!=
name|ISC_UINT32_MAX
operator|&&
name|override_ttl
operator|<
name|rdataset
operator|->
name|ttl
condition|)
block|{
name|rdataset
operator|->
name|ttl
operator|=
name|override_ttl
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdataset
operator|->
name|ttl
operator|=
name|override_ttl
expr_stmt|;
block|}
comment|/* 		 * Add the SOA and its SIG to the response, with the 		 * TTLs adjusted per RFC2308 section 3. 		 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|>
name|soa
operator|.
name|minimum
condition|)
name|rdataset
operator|->
name|ttl
operator|=
name|soa
operator|.
name|minimum
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|sigrdataset
operator|->
name|ttl
operator|>
name|soa
operator|.
name|minimum
condition|)
name|sigrdataset
operator|->
name|ttl
operator|=
name|soa
operator|.
name|minimum
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|query_addns
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fixedname_t
name|foundname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|,
modifier|*
name|sigrdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
init|=
name|NULL
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialization. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Get resources and make 'name' be the database origin. 	 */
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: dns_message_gettempname failed: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: query_newrdataset failed"
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: query_newrdataset failed"
argument_list|)
expr_stmt|;
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Find the NS rdataset. 	 */
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTRACE
argument_list|(
literal|"query_addns: calling dns_db_find"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns: dns_db_find complete"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|CTRACE
argument_list|(
literal|"query_addns: "
literal|"dns_db_findrdataset or dns_db_find failed"
argument_list|)
expr_stmt|;
comment|/* 		 * This is bad.  We tried to get the NS rdataset at the zone 		 * top and it didn't work! 		 */
name|eresult
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_addns: cleanup"
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"query_addns: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_add_cname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|tname
parameter_list|,
name|dns_trust_t
name|trust
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_t
modifier|*
name|aname
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * We assume the name data referred to by tname won't go away. 	 */
name|aname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|qname
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
name|aname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rdata
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
name|dns_message_puttemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
name|dns_message_puttemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
name|dns_message_puttemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_cname
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|rdatalist
operator|->
name|rdclass
operator|=
name|client
operator|->
name|message
operator|->
name|rdclass
expr_stmt|;
name|rdatalist
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|tname
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|data
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|rdata
operator|->
name|length
operator|=
name|r
operator|.
name|length
expr_stmt|;
name|rdata
operator|->
name|rdclass
operator|=
name|client
operator|->
name|message
operator|->
name|rdclass
expr_stmt|;
name|rdata
operator|->
name|type
operator|=
name|dns_rdatatype_cname
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|trust
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|aname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|aname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the RRsets as secure.  Update the cache (db) to reflect the  * change in trust level.  */
end_comment

begin_function
specifier|static
name|void
name|mark_secure
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdata_rrsig_t
modifier|*
name|rrsig
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|dns_trust_secure
expr_stmt|;
name|sigrdataset
operator|->
name|trust
operator|=
name|dns_trust_secure
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Save the updated secure state.  Ignore failures. 	 */
name|result
operator|=
name|dns_db_findnodeext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dns_rdataset_trimttl
argument_list|(
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|rrsig
argument_list|,
name|now
argument_list|,
name|client
operator|->
name|view
operator|->
name|acceptexpired
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_db_addrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the secure key that corresponds to rrsig.  * Note: 'keyrdataset' maintains state between successive calls,  * there may be multiple keys with the same keyid.  * Return ISC_FALSE if we have exhausted all the possible keys.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|get_key
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdata_rrsig_t
modifier|*
name|rrsig
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyrdataset
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keyp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|secure
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|keyrdataset
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_db_findnodeext
argument_list|(
name|db
argument_list|,
operator|&
name|rrsig
operator|->
name|signer
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|keyrdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|keyrdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|keyrdataset
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|keyrdataset
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|keyrdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|keyrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_fromdns
argument_list|(
operator|&
name|rrsig
operator|->
name|signer
argument_list|,
name|rdata
operator|.
name|rdclass
argument_list|,
operator|&
name|b
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
name|keyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
if|if
condition|(
name|rrsig
operator|->
name|algorithm
operator|==
operator|(
name|dns_secalg_t
operator|)
name|dst_key_alg
argument_list|(
operator|*
name|keyp
argument_list|)
operator|&&
name|rrsig
operator|->
name|keyid
operator|==
operator|(
name|dns_keytag_t
operator|)
name|dst_key_id
argument_list|(
operator|*
name|keyp
argument_list|)
operator|&&
name|dst_key_iszonekey
argument_list|(
operator|*
name|keyp
argument_list|)
condition|)
block|{
name|secure
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|dst_key_free
argument_list|(
name|keyp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|secure
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|verify
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|isc_boolean_t
name|ignore
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|again
label|:
name|result
operator|=
name|dns_dnssec_verify3
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|key
argument_list|,
name|ignore
argument_list|,
name|client
operator|->
name|view
operator|->
name|maxbits
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
name|rdata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_SIGEXPIRED
operator|&&
name|client
operator|->
name|view
operator|->
name|acceptexpired
condition|)
block|{
name|ignore
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_FROMWILDCARD
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the rdataset if possible with available records.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|validate
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_rrsig_t
name|rrsig
decl_stmt|;
name|dst_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
name|keyrdataset
decl_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|sigrdataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|rrsig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|dns_resolver_algorithm_supported
argument_list|(
name|client
operator|->
name|view
operator|->
name|resolver
argument_list|,
name|name
argument_list|,
name|rrsig
operator|.
name|algorithm
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|rrsig
operator|.
name|signer
argument_list|)
condition|)
continue|continue;
name|dns_rdataset_init
argument_list|(
operator|&
name|keyrdataset
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|get_key
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
operator|&
name|rrsig
argument_list|,
operator|&
name|keyrdataset
argument_list|,
operator|&
name|key
argument_list|)
condition|)
break|break;
if|if
condition|(
name|verify
argument_list|(
name|key
argument_list|,
name|name
argument_list|,
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|,
name|client
argument_list|)
condition|)
block|{
name|dst_key_free
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keyrdataset
argument_list|)
expr_stmt|;
name|mark_secure
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|name
argument_list|,
operator|&
name|rrsig
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
name|dst_key_free
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|keyrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keyrdataset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addbestns
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|zdb
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|zfname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|zrdataset
decl_stmt|,
modifier|*
name|zsigrdataset
decl_stmt|;
name|isc_boolean_t
name|is_zone
decl_stmt|,
name|use_zone
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addbestns"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|zdb
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|use_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Find the right database. 	 */
name|result
operator|=
name|query_getdb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|db_find
label|:
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Get the RRSIGs if the client requested them or if we may 	 * need to validate answers from the cache. 	 */
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
operator|!
name|is_zone
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Now look for the zonecut. 	 */
if|if
condition|(
name|is_zone
condition|)
block|{
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_DELEGATION
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|USECACHE
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|zdb
operator|=
name|db
expr_stmt|;
name|zfname
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|dns_db_findzonecut
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|zfname
operator|!=
name|NULL
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
name|zfname
argument_list|)
condition|)
block|{
comment|/* 				 * We found a zonecut in the cache, but our 				 * zone delegation is better. 				 */
name|use_zone
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|&&
name|zfname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We didn't find anything in the cache, but we 			 * have a zone delegation, so use it. 			 */
name|use_zone
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|use_zone
condition|)
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|zfname
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * We've already done query_keepname() on 		 * zfname, so we must set dbuf to NULL to 		 * prevent query_addrrset() from trying to 		 * call query_keepname() again. 		 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|zrdataset
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|zsigrdataset
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Attempt to validate RRsets that are pending or that are glue. 	 */
if|if
condition|(
operator|(
name|DNS_TRUST_PENDING
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|||
operator|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|DNS_TRUST_PENDING
argument_list|(
name|sigrdataset
operator|->
name|trust
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|validate
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
operator|&&
operator|!
name|PENDINGOK
argument_list|(
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|DNS_TRUST_GLUE
argument_list|(
name|rdataset
operator|->
name|trust
argument_list|)
operator|||
operator|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|DNS_TRUST_GLUE
argument_list|(
name|sigrdataset
operator|->
name|trust
argument_list|)
operator|)
operator|)
operator|&&
operator|!
name|validate
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
operator|&&
name|SECURE
argument_list|(
name|client
argument_list|)
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * If the answer is secure only add NS records if they are secure		 * when the client may be looking for AD in the response. 	 */
if|if
condition|(
name|SECURE
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
name|WANTAD
argument_list|(
name|client
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|rdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|)
operator|||
operator|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|sigrdataset
operator|->
name|trust
operator|!=
name|dns_trust_secure
operator|)
operator|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * If the client doesn't want DNSSEC we can discard the sigrdataset 	 * now. 	 */
if|if
condition|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdb
operator|!=
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zsigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|zfname
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zdb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fixrdataset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|)
block|{
if|if
condition|(
operator|*
name|rdataset
operator|==
name|NULL
condition|)
operator|*
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|*
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|*
name|rdataset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fixfname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|fname
parameter_list|,
name|isc_buffer_t
modifier|*
modifier|*
name|dbuf
parameter_list|,
name|isc_buffer_t
modifier|*
name|nbuf
parameter_list|)
block|{
if|if
condition|(
operator|*
name|fname
operator|==
name|NULL
condition|)
block|{
operator|*
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dbuf
operator|==
name|NULL
condition|)
return|return;
operator|*
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
operator|*
name|dbuf
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|query_addds
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|rname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addds"
argument_list|)
expr_stmt|;
name|rname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Look for the DS record, which may or may not be present. 	 */
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ds
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
comment|/* 	 * If we didn't find it, look for an NSEC. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|addnsec3
goto|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
goto|goto
name|addnsec3
goto|;
comment|/* 	 * We've already added the NS record, so if the name's not there, 	 * we have other problems.  Use this name rather than calling 	 * query_addrrset(). 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|rname
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|rname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|ISC_LIST_APPEND
argument_list|(
name|rname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rname
operator|->
name|list
argument_list|,
name|sigrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
return|return;
name|addnsec3
label|:
if|if
condition|(
operator|!
name|dns_db_iszone
argument_list|(
name|db
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * Add the NSEC3 which proves the DS does not exist. 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|query_findclosestnsec3
argument_list|(
name|name
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_TRUE
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
comment|/* 	 * Did we find the closest provable encloser instead? 	 * If so add the nearest to the closest provable encloser. 	 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|=
name|dns_name_countlabels
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|-
name|count
argument_list|,
name|count
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
name|fixfname
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|fixrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|fixrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|query_findclosestnsec3
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addwildcardproof
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|ispositive
parameter_list|,
name|isc_boolean_t
name|nodata
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_fixedname_t
name|wfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|wname
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|unsigned
name|int
name|olabels
decl_stmt|,
name|nlabels
decl_stmt|,
name|labels
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_nsec_t
name|nsec
decl_stmt|;
name|isc_boolean_t
name|have_wname
decl_stmt|;
name|int
name|order
decl_stmt|;
name|dns_fixedname_t
name|cfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|cname
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addwildcardproof"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Get the NOQNAME proof then if !ispositive 	 * get the NOWILDCARD proof. 	 * 	 * DNS_DBFIND_NOWILD finds the NSEC records that covers the 	 * name ignoring any wildcard.  From the owner and next names 	 * of this record you can compute which wildcard (if it exists) 	 * will match by finding the longest common suffix of the 	 * owner name and next names with the qname and prefixing that 	 * with the wildcard label. 	 * 	 * e.g. 	 *   Given: 	 *	example SOA 	 *	example NSEC b.example 	 *	b.example A 	 *	b.example NSEC a.d.example 	 *	a.d.example A 	 *	a.d.example NSEC g.f.example 	 *	g.f.example A 	 *	g.f.example NSEC z.i.example 	 *	z.i.example A 	 *	z.i.example NSEC example 	 * 	 *   QNAME: 	 *   a.example -> example NSEC b.example 	 *	owner common example 	 *	next common example 	 *	wild *.example 	 *   d.b.example -> b.example NSEC a.d.example 	 *	owner common b.example 	 *	next common example 	 *	wild *.b.example 	 *   a.f.example -> a.d.example NSEC g.f.example 	 *	owner common example 	 *	next common f.example 	 *	wild *.f.example 	 *  j.example -> z.i.example NSEC example 	 *	owner common example 	 *	next common example 	 *	wild *.example 	 */
name|options
operator|=
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_NOWILD
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|wfixed
argument_list|)
expr_stmt|;
name|wname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|wfixed
argument_list|)
expr_stmt|;
name|again
label|:
name|have_wname
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 		 * No NSEC proof available, return NSEC3 proofs instead. 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|cfixed
argument_list|)
expr_stmt|;
name|cname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|cfixed
argument_list|)
expr_stmt|;
comment|/* 		 * Find the closest encloser. 		 */
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|cname
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Sanity check. 			 */
if|if
condition|(
name|labels
operator|==
literal|0U
condition|)
goto|goto
name|cleanup
goto|;
name|dns_name_split
argument_list|(
name|cname
argument_list|,
name|labels
argument_list|,
name|NULL
argument_list|,
name|cname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|cname
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add closest (provable) encloser NSEC3. 		 */
name|query_findclosestnsec3
argument_list|(
name|cname
argument_list|,
name|db
argument_list|,
name|NULL
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_TRUE
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|!
name|ispositive
condition|)
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
comment|/* 		 * Replace resources which were consumed by query_addrrset. 		 */
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Add no qname proof. 		 */
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|cname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|==
name|labels
condition|)
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|labels
argument_list|,
name|NULL
argument_list|,
name|wname
argument_list|)
expr_stmt|;
name|query_findclosestnsec3
argument_list|(
name|wname
argument_list|,
name|db
argument_list|,
name|NULL
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ispositive
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Replace resources which were consumed by query_addrrset. 		 */
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Add the no wildcard proof. 		 */
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|cname
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|query_findclosestnsec3
argument_list|(
name|wname
argument_list|,
name|db
argument_list|,
name|NULL
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|nodata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
if|if
condition|(
operator|!
name|ispositive
condition|)
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|olabels
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
operator|&
name|nsec
operator|.
name|next
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
comment|/* 			 * Check for a pathological condition created when 			 * serving some malformed signed zones and bail out. 			 */
if|if
condition|(
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|==
name|nlabels
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|olabels
operator|>
name|nlabels
condition|)
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|olabels
argument_list|,
name|NULL
argument_list|,
name|wname
argument_list|)
expr_stmt|;
else|else
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|nlabels
argument_list|,
name|NULL
argument_list|,
name|wname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|wname
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_wname
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|nsec
argument_list|)
expr_stmt|;
block|}
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_wname
condition|)
block|{
name|ispositive
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* prevent loop */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|wname
argument_list|)
condition|)
block|{
name|name
operator|=
name|wname
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addnxrrsetnsec
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|namep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|name
operator|=
operator|*
name|namep
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|==
literal|0
condition|)
block|{
name|query_addrrset
argument_list|(
name|client
argument_list|,
name|namep
argument_list|,
name|rdatasetp
argument_list|,
name|sigrdatasetp
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sigrdatasetp
operator|==
name|NULL
condition|)
return|return;
name|sigrdataset
operator|=
operator|*
name|sigrdatasetp
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
return|return;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|sig
operator|.
name|labels
operator|+
literal|1
operator|>=
name|labels
condition|)
return|return;
comment|/* XXX */
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
return|return;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
return|return;
name|dns_name_split
argument_list|(
name|name
argument_list|,
name|sig
operator|.
name|labels
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* This will succeed, since we've stripped labels. */
name|RUNTIME_CHECK
argument_list|(
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
name|rdatasetp
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_resume
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_fetchevent_t
modifier|*
name|devent
init|=
operator|(
name|dns_fetchevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|dns_fetch_t
modifier|*
name|fetch
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_boolean_t
name|fetch_canceled
decl_stmt|,
name|client_shuttingdown
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_logcategory_t
modifier|*
name|logcategory
init|=
name|NS_LOGCATEGORY_QUERY_EERRORS
decl_stmt|;
name|int
name|errorloglevel
decl_stmt|;
comment|/* 	 * Resume a query after recursion. 	 */
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_FETCHDONE
argument_list|)
expr_stmt|;
name|client
operator|=
name|devent
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|RECURSING
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This is the fetch we've been waiting for. 		 */
name|INSIST
argument_list|(
name|devent
operator|->
name|fetch
operator|==
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetch
operator|=
name|NULL
expr_stmt|;
name|fetch_canceled
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Update client->now. 		 */
name|isc_stdtime_get
argument_list|(
operator|&
name|client
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fetch completion event for a canceled fetch. 		 * Clean up and don't resume the find. 		 */
name|fetch_canceled
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|query
operator|.
name|fetchlock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_RECURSING
expr_stmt|;
name|fetch
operator|=
name|devent
operator|->
name|fetch
expr_stmt|;
name|devent
operator|->
name|fetch
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this client is shutting down, or this transaction 	 * has timed out, do not resume the find. 	 */
name|client_shuttingdown
operator|=
name|ns_client_shuttingdown
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_canceled
operator|||
name|client_shuttingdown
condition|)
block|{
if|if
condition|(
name|devent
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|devent
operator|->
name|db
argument_list|,
operator|&
name|devent
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|devent
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|devent
operator|->
name|db
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|devent
operator|->
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|devent
operator|->
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|devent
operator|->
name|sigrdataset
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetch_canceled
condition|)
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_SERVFAIL
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|else
name|query_next
argument_list|(
name|client
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
comment|/* 		 * This may destroy the client. 		 */
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|query_find
argument_list|(
name|client
argument_list|,
name|devent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_SERVFAIL
condition|)
name|errorloglevel
operator|=
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|errorloglevel
operator|=
name|ISC_LOG_DEBUG
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|errorloglevel
argument_list|)
condition|)
block|{
name|dns_resolver_logfetch
argument_list|(
name|fetch
argument_list|,
name|ns_g_lctx
argument_list|,
name|logcategory
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|errorloglevel
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dns_resolver_destroyfetch
argument_list|(
operator|&
name|fetch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|query_recurse
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|qdomain
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nameservers
parameter_list|,
name|isc_boolean_t
name|resuming
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|sigrdataset
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|peeraddr
decl_stmt|;
if|if
condition|(
operator|!
name|resuming
condition|)
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_recursion
argument_list|)
expr_stmt|;
comment|/* 	 * We are about to recurse, which means that this client will 	 * be unavailable for serving new requests for an indeterminate 	 * amount of time.  If this client is currently responsible 	 * for handling incoming queries, set up a new client 	 * object to handle them while we are waiting for a 	 * response.  There is no need to replace TCP clients 	 * because those have already been replaced when the 	 * connection was accepted (if allowed by the TCP quota). 	 */
if|if
condition|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_quota_attach
argument_list|(
operator|&
name|ns_g_server
operator|->
name|recursionquota
argument_list|,
operator|&
name|client
operator|->
name|recursionquota
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SOFTQUOTA
condition|)
block|{
specifier|static
name|isc_stdtime_t
name|last
init|=
literal|0
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|!=
name|last
condition|)
block|{
name|last
operator|=
name|now
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"recursive-clients soft limit "
literal|"exceeded (%d/%d/%d), "
literal|"aborting oldest query"
argument_list|,
name|client
operator|->
name|recursionquota
operator|->
name|used
argument_list|,
name|client
operator|->
name|recursionquota
operator|->
name|soft
argument_list|,
name|client
operator|->
name|recursionquota
operator|->
name|max
argument_list|)
expr_stmt|;
block|}
name|ns_client_killoldestquery
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
specifier|static
name|isc_stdtime_t
name|last
init|=
literal|0
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|!=
name|last
condition|)
block|{
name|last
operator|=
name|now
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"no more recursive clients "
literal|"(%d/%d/%d): %s"
argument_list|,
name|ns_g_server
operator|->
name|recursionquota
operator|.
name|used
argument_list|,
name|ns_g_server
operator|->
name|recursionquota
operator|.
name|soft
argument_list|,
name|ns_g_server
operator|->
name|recursionquota
operator|.
name|max
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ns_client_killoldestquery
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|!
name|client
operator|->
name|mortal
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ns_client_replace
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"ns_client_replace() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_quota_detach
argument_list|(
operator|&
name|client
operator|->
name|recursionquota
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|ns_client_recursing
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Invoke the resolver. 	 */
name|REQUIRE
argument_list|(
name|nameservers
operator|==
name|NULL
operator|||
name|nameservers
operator|->
name|type
operator|==
name|dns_rdatatype_ns
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|query
operator|.
name|fetch
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
else|else
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|timerset
operator|==
name|ISC_FALSE
condition|)
name|ns_client_settimeout
argument_list|(
name|client
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
name|peeraddr
operator|=
operator|&
name|client
operator|->
name|peeraddr
expr_stmt|;
else|else
name|peeraddr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_resolver_createfetch2
argument_list|(
name|client
operator|->
name|view
operator|->
name|resolver
argument_list|,
name|qname
argument_list|,
name|qtype
argument_list|,
name|qdomain
argument_list|,
name|nameservers
argument_list|,
name|NULL
argument_list|,
name|peeraddr
argument_list|,
name|client
operator|->
name|message
operator|->
name|id
argument_list|,
name|client
operator|->
name|query
operator|.
name|fetchoptions
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|query_resume
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|fetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Record that we're waiting for an event.  A client which 		 * is shutting down will not be destroyed until all the 		 * events have been received. 		 */
block|}
else|else
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rpz_clean
parameter_list|(
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|)
block|{
if|if
condition|(
name|nodep
operator|!=
name|NULL
operator|&&
operator|*
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdatasetp
operator|!=
name|NULL
operator|&&
operator|*
name|rdatasetp
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
operator|*
name|rdatasetp
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|*
name|rdatasetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpz_match_clear
parameter_list|(
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
block|{
name|rpz_clean
argument_list|(
operator|&
name|st
operator|->
name|m
operator|.
name|zone
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|db
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|node
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|rdataset
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|version
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|rpz_ready
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|rdatasetp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rpz_clean
argument_list|(
name|zonep
argument_list|,
name|dbp
argument_list|,
name|nodep
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdatasetp
operator|==
name|NULL
condition|)
block|{
operator|*
name|rdatasetp
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdatasetp
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpz_st_clear
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
init|=
name|client
operator|->
name|query
operator|.
name|rpz_st
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|rdataset
argument_list|)
expr_stmt|;
name|rpz_match_clear
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|rpz_clean
argument_list|(
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|r
operator|.
name|r_rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|r_rdataset
argument_list|)
expr_stmt|;
name|rpz_clean
argument_list|(
operator|&
name|st
operator|->
name|q
operator|.
name|zone
argument_list|,
operator|&
name|st
operator|->
name|q
operator|.
name|db
argument_list|,
operator|&
name|st
operator|->
name|q
operator|.
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|q
operator|.
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|st
operator|->
name|q
operator|.
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|q
operator|.
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|st
operator|->
name|q
operator|.
name|sigrdataset
argument_list|)
expr_stmt|;
name|st
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|type
operator|=
name|DNS_RPZ_TYPE_BAD
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_MISS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get NS, A, or AAAA rrset for response policy zone checks.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rrset_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|isc_boolean_t
name|resuming
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|isc_boolean_t
name|is_zone
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|st
operator|->
name|r
operator|.
name|r_type
operator|==
name|type
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|st
operator|->
name|r_name
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|*
name|rdatasetp
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|*
name|rdatasetp
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|state
operator|&=
operator|~
name|DNS_RPZ_RECURSING
expr_stmt|;
operator|*
name|dbp
operator|=
name|st
operator|->
name|r
operator|.
name|db
expr_stmt|;
name|st
operator|->
name|r
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|rdatasetp
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
operator|*
name|rdatasetp
operator|=
name|st
operator|->
name|r
operator|.
name|r_rdataset
expr_stmt|;
name|st
operator|->
name|r
operator|.
name|r_rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|st
operator|->
name|r
operator|.
name|r_result
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|name
argument_list|,
literal|"rpz_rrset_find(1) "
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|rpz_ready
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|dbp
operator|!=
name|NULL
condition|)
block|{
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|query_getdb
argument_list|(
name|client
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|zone
argument_list|,
name|dbp
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|name
argument_list|,
literal|"rpz_rrset_find(2) "
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
operator|*
name|dbp
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|DNS_DBFIND_GLUEOK
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|found
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
operator|&&
name|is_zone
operator|&&
name|USECACHE
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 		 * Try the cache if we're authoritative for an 		 * ancestor but not the domain itself. 		 */
name|rpz_clean
argument_list|(
name|NULL
argument_list|,
name|dbp
argument_list|,
operator|&
name|node
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
operator|*
name|dbp
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|found
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|rpz_clean
argument_list|(
name|NULL
argument_list|,
name|dbp
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
block|{
name|rpz_clean
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
comment|/* 		 * Recurse for NS rrset or A or AAAA rrset for an NS. 		 * Do not recurse for addresses for the query name. 		 */
if|if
condition|(
name|rpz_type
operator|==
name|DNS_RPZ_TYPE_IP
condition|)
block|{
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
block|}
else|else
block|{
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|st
operator|->
name|r_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|type
argument_list|,
name|st
operator|->
name|r_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_RECURSING
expr_stmt|;
name|result
operator|=
name|DNS_R_DELEGATION
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the IP address in an A or AAAA rdataset against  * the IP or NSIP response policy rules of a view.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rewrite_ip
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_rpz_zone_t
modifier|*
name|rpz
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|st
operator|->
name|m
operator|.
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
name|zone
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rpz
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|view
operator|->
name|rpz_zones
argument_list|)
init|;
name|rpz
operator|!=
name|NULL
condition|;
name|rpz
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rpz
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
name|rpz
operator|->
name|recursive_only
condition|)
continue|continue;
comment|/* 		 * Do not check policy zones that cannot replace a policy 		 * already known to match. 		 */
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|<
name|rpz
operator|->
name|num
condition|)
break|break;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|==
name|rpz
operator|->
name|num
operator|&&
name|st
operator|->
name|m
operator|.
name|type
operator|<
name|rpz_type
condition|)
continue|continue;
block|}
comment|/* 		 * Find the database for this policy zone to get its radix tree. 		 */
name|version
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|rpz_getdb
argument_list|(
name|client
argument_list|,
name|rpz_type
argument_list|,
operator|&
name|rpz
operator|->
name|origin
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|rpz_clean
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Look for a better (e.g. longer prefix) hit for an IP address 		 * in this rdataset in this radix tree than than the previous 		 * hit, if any.  Note the domain name and quality of the 		 * best hit. 		 */
name|dns_db_rpz_findips
argument_list|(
name|rpz
argument_list|,
name|rpz_type
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|rdataset
argument_list|,
name|st
argument_list|,
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|->
name|qname
argument_list|)
expr_stmt|;
name|rpz_clean
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an A or AAAA rdataset  * and check for IP or NSIP rewrite policy rules.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rewrite_rrset
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|isc_boolean_t
name|resuming
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|rpz_rrset_find
argument_list|(
name|client
argument_list|,
name|rpz_type
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|dbp
argument_list|,
name|version
argument_list|,
name|rdatasetp
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|DNS_R_GLUE
case|:
case|case
name|DNS_R_ZONECUT
case|:
name|result
operator|=
name|rpz_rewrite_ip
argument_list|(
name|client
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|rpz_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_R_EMPTYNAME
case|:
case|case
name|DNS_R_EMPTYWILD
case|:
case|case
name|DNS_R_NXDOMAIN
case|:
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
case|case
name|DNS_R_NXRRSET
case|:
case|case
name|DNS_R_NCACHENXRRSET
case|:
case|case
name|ISC_R_NOTFOUND
case|:
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
break|break;
case|case
name|DNS_R_DELEGATION
case|:
case|case
name|DNS_R_DUPLICATE
case|:
case|case
name|DNS_R_DROP
case|:
break|break;
case|case
name|DNS_R_CNAME
case|:
case|case
name|DNS_R_DNAME
case|:
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL1
argument_list|,
name|rpz_type
argument_list|,
name|name
argument_list|,
literal|"NS address rewrite rrset "
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_ERROR
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|name
argument_list|,
literal|"NS address rewrite rrset "
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for both A and AAAA rdatasets  * and check for IP or NSIP rewrite policy rules.  * Look only for addresses that will be in the ANSWER section  * when checking for IP rules.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rewrite_rrsets
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|isc_boolean_t
name|resuming
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_db_t
modifier|*
name|ipdb
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|ipdb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_DONE_IPv4
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rpz_type
operator|==
name|DNS_RPZ_TYPE_NSIP
operator|)
condition|?
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_NSIPv4
operator|)
else|:
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_IP
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|type
operator|==
name|dns_rdatatype_a
operator|)
condition|)
block|{
name|result
operator|=
name|rpz_rewrite_rrset
argument_list|(
name|client
argument_list|,
name|rpz_type
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|name
argument_list|,
operator|&
name|ipdb
argument_list|,
name|version
argument_list|,
name|rdatasetp
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_DONE_IPv4
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|(
operator|(
name|rpz_type
operator|==
name|DNS_RPZ_TYPE_NSIP
operator|)
condition|?
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_NSIPv6
operator|)
else|:
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_IP
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|type
operator|==
name|dns_rdatatype_any
operator|||
name|type
operator|==
name|dns_rdatatype_aaaa
operator|)
condition|)
block|{
name|result
operator|=
name|rpz_rewrite_rrset
argument_list|(
name|client
argument_list|,
name|rpz_type
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|name
argument_list|,
operator|&
name|ipdb
argument_list|,
name|version
argument_list|,
name|rdatasetp
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|ipdb
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the rrset from a response policy zone.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qnamef
parameter_list|,
name|dns_name_t
modifier|*
name|sname
parameter_list|,
name|dns_rpz_zone_t
modifier|*
name|rpz
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|,
name|dns_rpz_policy_t
modifier|*
name|policyp
parameter_list|)
block|{
name|dns_rpz_policy_t
name|policy
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|REQUIRE
argument_list|(
name|nodep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|rpz_ready
argument_list|(
name|client
argument_list|,
name|zonep
argument_list|,
name|dbp
argument_list|,
name|nodep
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|policyp
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Try to get either a CNAME or the type of record demanded by the 	 * request from the policy zone. 	 */
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|rpz_getdb
argument_list|(
name|client
argument_list|,
name|rpz_type
argument_list|,
name|qnamef
argument_list|,
name|zonep
argument_list|,
name|dbp
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|policyp
operator|=
name|DNS_RPZ_POLICY_MISS
expr_stmt|;
return|return
operator|(
name|DNS_R_NXDOMAIN
operator|)
return|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
operator|*
name|dbp
argument_list|,
name|qnamef
argument_list|,
operator|*
name|versionp
argument_list|,
name|dns_rdatatype_any
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|nodep
argument_list|,
name|found
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
decl_stmt|;
name|rdsiter
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
operator|*
name|dbp
argument_list|,
operator|*
name|nodep
argument_list|,
operator|*
name|versionp
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|qnamef
argument_list|,
literal|"allrdatasets() "
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|*
name|policyp
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsiter
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsiter
argument_list|)
control|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|rdsiter
argument_list|,
operator|*
name|rdatasetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rdatasetp
operator|)
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|||
operator|(
operator|*
name|rdatasetp
operator|)
operator|->
name|type
operator|==
name|qtype
condition|)
break|break;
name|dns_rdataset_disassociate
argument_list|(
operator|*
name|rdatasetp
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|qnamef
argument_list|,
literal|"rdatasetiter "
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|*
name|policyp
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
comment|/* 			 * Ask again to get the right DNS_R_DNAME/NXRRSET/... 			 * result if there is neither a CNAME nor target type. 			 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|*
name|rdatasetp
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|*
name|rdatasetp
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
condition|)
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
else|else
name|result
operator|=
name|dns_db_findext
argument_list|(
operator|*
name|dbp
argument_list|,
name|qnamef
argument_list|,
operator|*
name|versionp
argument_list|,
name|qtype
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|nodep
argument_list|,
name|found
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
if|if
condition|(
operator|(
operator|*
name|rdatasetp
operator|)
operator|->
name|type
operator|!=
name|dns_rdatatype_cname
condition|)
block|{
name|policy
operator|=
name|DNS_RPZ_POLICY_RECORD
expr_stmt|;
block|}
else|else
block|{
name|policy
operator|=
name|dns_rpz_decode_cname
argument_list|(
name|rpz
argument_list|,
operator|*
name|rdatasetp
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|policy
operator|==
name|DNS_RPZ_POLICY_RECORD
operator|||
name|policy
operator|==
name|DNS_RPZ_POLICY_WILDCNAME
operator|)
operator|&&
name|qtype
operator|!=
name|dns_rdatatype_cname
operator|&&
name|qtype
operator|!=
name|dns_rdatatype_any
condition|)
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
break|break;
case|case
name|DNS_R_NXRRSET
case|:
name|policy
operator|=
name|DNS_RPZ_POLICY_NODATA
expr_stmt|;
break|break;
case|case
name|DNS_R_DNAME
case|:
comment|/* 		 * DNAME policy RRs have very few if any uses that are not 		 * better served with simple wildcards.  Making the work would 		 * require complications to get the number of labels matched 		 * in the name or the found name to the main DNS_R_DNAME case 		 * in query_find(). 		 */
name|dns_rdataset_disassociate
argument_list|(
operator|*
name|rdatasetp
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
comment|/* 		 * Fall through to treat it as a miss. 		 */
case|case
name|DNS_R_NXDOMAIN
case|:
case|case
name|DNS_R_EMPTYNAME
case|:
comment|/* 		 * If we don't get a qname hit, 		 * see if it is worth looking for other types. 		 */
operator|(
name|void
operator|)
name|dns_db_rpz_enabled
argument_list|(
operator|*
name|dbp
argument_list|,
name|client
operator|->
name|query
operator|.
name|rpz_st
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dns_zone_detach
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_NXDOMAIN
expr_stmt|;
name|policy
operator|=
name|DNS_RPZ_POLICY_MISS
expr_stmt|;
break|break;
default|default:
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dns_zone_detach
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|qnamef
argument_list|,
literal|""
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
block|}
operator|*
name|policyp
operator|=
name|policy
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build and look for a QNAME or NSDNAME owner name in a response policy zone.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rewrite_name
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdatasetp
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|dns_rpz_zone_t
modifier|*
name|rpz
decl_stmt|;
name|dns_fixedname_t
name|prefixf
decl_stmt|,
name|rpz_qnamef
decl_stmt|;
name|dns_name_t
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|rpz_qname
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rpz_policy_t
name|policy
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rpz
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|view
operator|->
name|rpz_zones
argument_list|)
init|;
name|rpz
operator|!=
name|NULL
condition|;
name|rpz
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rpz
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
name|rpz
operator|->
name|recursive_only
condition|)
continue|continue;
comment|/* 		 * Do not check policy zones that cannot replace a policy 		 * already known to match. 		 */
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|<
name|rpz
operator|->
name|num
condition|)
break|break;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|==
name|rpz
operator|->
name|num
operator|&&
name|st
operator|->
name|m
operator|.
name|type
operator|<
name|rpz_type
condition|)
continue|continue;
block|}
comment|/* 		 * Construct the policy's owner name. 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|prefixf
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|prefixf
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|qname
argument_list|,
literal|1
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpz_type
operator|==
name|DNS_RPZ_TYPE_NSDNAME
condition|)
name|suffix
operator|=
operator|&
name|rpz
operator|->
name|nsdname
expr_stmt|;
else|else
name|suffix
operator|=
operator|&
name|rpz
operator|->
name|origin
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|rpz_qnamef
argument_list|)
expr_stmt|;
name|rpz_qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rpz_qnamef
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|prefix
argument_list|,
name|suffix
argument_list|,
name|rpz_qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
break|break;
name|INSIST
argument_list|(
name|result
operator|==
name|DNS_R_NAMETOOLONG
argument_list|)
expr_stmt|;
comment|/* 			 * Trim the name until it is not too long. 			 */
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|<
literal|2
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|rpz_type
argument_list|,
name|suffix
argument_list|,
literal|"concatentate() "
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|labels
operator|+
literal|1
operator|==
name|dns_name_countlabels
argument_list|(
name|qname
argument_list|)
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL1
argument_list|,
name|rpz_type
argument_list|,
name|suffix
argument_list|,
literal|"concatentate() "
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|dns_name_split
argument_list|(
name|prefix
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * See if the policy record exists and get its policy. 		 */
name|result
operator|=
name|rpz_find
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|rpz_qname
argument_list|,
name|qname
argument_list|,
name|rpz
argument_list|,
name|rpz_type
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|node
argument_list|,
name|rdatasetp
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|DNS_R_NXDOMAIN
case|:
break|break;
case|case
name|DNS_R_SERVFAIL
case|:
name|rpz_clean
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|node
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
return|return
operator|(
name|DNS_R_SERVFAIL
operator|)
return|;
default|default:
comment|/* 			 * We are dealing with names here. 			 * With more than one applicable policy, prefer 			 * the earliest configured policy, 			 * QNAME over IP over NSDNAME over NSIP, 			 * and the smallest name. 			 * Because of the testing above, 			 * we known st->m.rpz->num>= rpz->num  and either 			 * st->m.rpz->num> rpz->num or st->m.type>= rpz_type 			 */
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
operator|&&
name|rpz
operator|->
name|num
operator|==
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|&&
operator|(
name|st
operator|->
name|m
operator|.
name|type
operator|<
name|rpz_type
operator|||
operator|(
name|st
operator|->
name|m
operator|.
name|type
operator|==
name|rpz_type
operator|&&
literal|0
operator|>=
name|dns_name_compare
argument_list|(
name|rpz_qname
argument_list|,
name|st
operator|->
name|qname
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* 			 * This code would block a customer reported information 			 * leak of rpz rules by rewriting requests in the 			 * rpz-ip, rpz-nsip, rpz-nsdname,and rpz-passthru TLDs. 			 * Without this code, a bad guy could request 			 * 24.0.3.2.10.rpz-ip. to find the policy rule for 			 * 10.2.3.0/14.  It is an insignificant leak and this 			 * code is not worth its cost, because the bad guy 			 * could publish "evil.com A 10.2.3.4" and request 			 * evil.com to get the same information. 			 * Keep code with "#if 0" in case customer demand 			 * is irresistible. 			 * 			 * We have the less frequent case of a triggered 			 * policy.  Check that we have not trigger on one 			 * of the pretend RPZ TLDs. 			 * This test would make it impossible to rewrite 			 * names in TLDs that start with "rpz-" should 			 * ICANN ever allow such TLDs. 			 */
block|labels = dns_name_countlabels(qname); 			if (labels>= 2) { 				dns_label_t label;  				dns_name_getlabel(qname, labels-2,&label); 				if (label.length>= sizeof(DNS_RPZ_PREFIX)-1&& 				    strncasecmp((const char *)label.base+1, 						DNS_RPZ_PREFIX, 						sizeof(DNS_RPZ_PREFIX)-1) == 0) 					continue; 			}
endif|#
directive|endif
comment|/* 			 * Merely log DNS_RPZ_POLICY_DISABLED hits. 			 */
if|if
condition|(
name|rpz
operator|->
name|policy
operator|==
name|DNS_RPZ_POLICY_DISABLED
condition|)
block|{
name|rpz_log_rewrite
argument_list|(
name|client
argument_list|,
name|ISC_TRUE
argument_list|,
name|policy
argument_list|,
name|rpz_type
argument_list|,
name|zone
argument_list|,
name|rpz_qname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rpz_match_clear
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|rpz
operator|=
name|rpz
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|type
operator|=
name|rpz_type
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|prefix
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|dns_name_copy
argument_list|(
name|rpz_qname
argument_list|,
name|st
operator|->
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdatasetp
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
operator|*
name|rdatasetp
argument_list|)
condition|)
block|{
name|dns_rdataset_t
modifier|*
name|trdataset
decl_stmt|;
name|trdataset
operator|=
name|st
operator|->
name|m
operator|.
name|rdataset
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|rdataset
operator|=
operator|*
name|rdatasetp
expr_stmt|;
operator|*
name|rdatasetp
operator|=
name|trdataset
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|st
operator|->
name|m
operator|.
name|rdataset
operator|->
name|ttl
argument_list|,
name|rpz
operator|->
name|max_policy_ttl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|m
operator|.
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|DNS_RPZ_TTL_DEFAULT
argument_list|,
name|rpz
operator|->
name|max_policy_ttl
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|m
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|rpz_clean
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|node
argument_list|,
name|rdatasetp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpz_rewrite_ns_skip
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|nsname
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|level
argument_list|,
name|DNS_RPZ_TYPE_NSIP
argument_list|,
name|nsname
argument_list|,
name|str
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
name|st
operator|->
name|r
operator|.
name|label
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look for response policy zone QNAME, NSIP, and NSDNAME rewriting.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_rewrite
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|isc_result_t
name|qresult
parameter_list|,
name|isc_boolean_t
name|resuming
parameter_list|)
block|{
name|dns_rpz_st_t
modifier|*
name|st
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_fixedname_t
name|nsnamef
decl_stmt|;
name|dns_name_t
modifier|*
name|nsname
decl_stmt|;
name|isc_boolean_t
name|ck_ip
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
name|st
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|st
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|st
operator|->
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|->
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|type
operator|=
name|DNS_RPZ_TYPE_BAD
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_MISS
expr_stmt|;
name|memset
argument_list|(
operator|&
name|st
operator|->
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|st
operator|->
name|q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|st
operator|->
name|_qnamef
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|st
operator|->
name|_r_namef
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|st
operator|->
name|_fnamef
argument_list|)
expr_stmt|;
name|st
operator|->
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|st
operator|->
name|_qnamef
argument_list|)
expr_stmt|;
name|st
operator|->
name|r_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|st
operator|->
name|_r_namef
argument_list|)
expr_stmt|;
name|st
operator|->
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|st
operator|->
name|_fnamef
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|=
name|st
expr_stmt|;
block|}
comment|/* 	 * There is nothing to rewrite if the main query failed. 	 */
switch|switch
condition|(
name|qresult
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
case|case
name|DNS_R_GLUE
case|:
case|case
name|DNS_R_ZONECUT
case|:
name|ck_ip
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
case|case
name|DNS_R_EMPTYNAME
case|:
case|case
name|DNS_R_NXRRSET
case|:
case|case
name|DNS_R_NXDOMAIN
case|:
case|case
name|DNS_R_EMPTYWILD
case|:
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
case|case
name|DNS_R_NCACHENXRRSET
case|:
case|case
name|DNS_R_CNAME
case|:
case|case
name|DNS_R_DNAME
case|:
name|ck_ip
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|DNS_R_DELEGATION
case|:
case|case
name|ISC_R_NOTFOUND
case|:
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
case|case
name|ISC_R_FAILURE
case|:
case|case
name|ISC_R_TIMEDOUT
case|:
case|case
name|DNS_R_BROKENCHAIN
case|:
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL3
argument_list|,
name|DNS_RPZ_TYPE_QNAME
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
literal|"stop on qresult in rpz_rewrite() "
argument_list|,
name|qresult
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
default|default:
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL1
argument_list|,
name|DNS_RPZ_TYPE_QNAME
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
literal|"stop on unrecognized qresult in rpz_rewrite() "
argument_list|,
name|qresult
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_DONE_QNAME
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Check rules for the query name if this is the first time 		 * for the current qname, i.e. we've not been recursing. 		 * There is a first time for each name in a CNAME chain. 		 */
name|result
operator|=
name|rpz_rewrite_name
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|DNS_RPZ_TYPE_QNAME
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|st
operator|->
name|r
operator|.
name|label
operator|=
name|dns_name_countlabels
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
expr_stmt|;
name|st
operator|->
name|state
operator|&=
operator|~
operator|(
name|DNS_RPZ_DONE_QNAME_IP
operator||
name|DNS_RPZ_DONE_IPv4
operator|)
expr_stmt|;
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_DONE_QNAME
expr_stmt|;
block|}
comment|/* 	 * Check known IP addresses for the query name. 	 * Any recursion required for the query has already happened. 	 * Do not check addresses that will not be in the ANSWER section. 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_DONE_QNAME_IP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_IP
operator|)
operator|!=
literal|0
operator|&&
name|ck_ip
condition|)
block|{
name|result
operator|=
name|rpz_rewrite_rrsets
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_TYPE_IP
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
operator|&
name|rdataset
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|st
operator|->
name|state
operator|&=
operator|~
name|DNS_RPZ_DONE_IPv4
expr_stmt|;
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_DONE_QNAME_IP
expr_stmt|;
block|}
comment|/* 	 * Stop looking for rules if there are none of the other kinds. 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
operator|(
name|DNS_RPZ_HAVE_NSIPv4
operator||
name|DNS_RPZ_HAVE_NSIPv6
operator||
name|DNS_RPZ_HAVE_NSDNAME
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|nsnamef
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|nsnamef
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|st
operator|->
name|r
operator|.
name|label
operator|>
name|client
operator|->
name|view
operator|->
name|rpz_min_ns_labels
condition|)
block|{
comment|/* 		 * Get NS rrset for each domain in the current qname. 		 */
if|if
condition|(
name|st
operator|->
name|r
operator|.
name|label
operator|==
name|dns_name_countlabels
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
condition|)
block|{
name|nsname
operator|=
name|client
operator|->
name|query
operator|.
name|qname
expr_stmt|;
block|}
else|else
block|{
name|nsname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|nsnamef
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|st
operator|->
name|r
operator|.
name|label
argument_list|,
name|NULL
argument_list|,
name|nsname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
condition|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|rpz_rrset_find
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_TYPE_NSDNAME
argument_list|,
name|nsname
argument_list|,
name|dns_rdatatype_ns
argument_list|,
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_ERROR
condition|)
goto|goto
name|cleanup
goto|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|st
operator|->
name|state
operator|&=
operator|~
operator|(
name|DNS_RPZ_DONE_NSDNAME
operator||
name|DNS_RPZ_DONE_IPv4
operator|)
expr_stmt|;
break|break;
case|case
name|DNS_R_DELEGATION
case|:
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_EMPTYNAME
case|:
case|case
name|DNS_R_NXRRSET
case|:
case|case
name|DNS_R_EMPTYWILD
case|:
case|case
name|DNS_R_NXDOMAIN
case|:
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
case|case
name|DNS_R_NCACHENXRRSET
case|:
case|case
name|ISC_R_NOTFOUND
case|:
case|case
name|DNS_R_CNAME
case|:
case|case
name|DNS_R_DNAME
case|:
name|rpz_rewrite_ns_skip
argument_list|(
name|client
argument_list|,
name|nsname
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ISC_R_TIMEDOUT
case|:
case|case
name|DNS_R_BROKENCHAIN
case|:
case|case
name|ISC_R_FAILURE
case|:
name|rpz_rewrite_ns_skip
argument_list|(
name|client
argument_list|,
name|nsname
argument_list|,
name|result
argument_list|,
name|DNS_RPZ_DEBUG_LEVEL3
argument_list|,
literal|"NS db_find() "
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|rpz_rewrite_ns_skip
argument_list|(
name|client
argument_list|,
name|nsname
argument_list|,
name|result
argument_list|,
name|DNS_RPZ_INFO_LEVEL
argument_list|,
literal|"unrecognized NS db_find() "
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Check all NS names. 		 */
do|do
block|{
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|dns_rdata_t
name|nsrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|,
operator|&
name|nsrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|nsrdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|nsrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|rpz_log_fail
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|DNS_RPZ_TYPE_NSIP
argument_list|,
name|nsname
argument_list|,
literal|"rdata_tostruct() "
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|DNS_RPZ_POLICY_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 			 * Do nothing about "NS ." 			 */
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rootname
argument_list|)
condition|)
block|{
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Check this NS name if we did not handle it 			 * during a previous recursion. 			 */
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_DONE_NSDNAME
operator|)
operator|==
literal|0
operator|&&
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_HAVE_NSDNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|rpz_rewrite_name
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|DNS_RPZ_TYPE_NSDNAME
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_DONE_NSDNAME
expr_stmt|;
block|}
comment|/* 			 * Check all IP addresses for this NS name. 			 */
name|result
operator|=
name|rpz_rewrite_rrsets
argument_list|(
name|client
argument_list|,
name|DNS_RPZ_TYPE_NSIP
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|rdataset
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|st
operator|->
name|state
operator|&=
operator|~
operator|(
name|DNS_RPZ_DONE_NSDNAME
operator||
name|DNS_RPZ_DONE_IPv4
operator|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|dns_rdataset_disassociate
argument_list|(
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
name|st
operator|->
name|r
operator|.
name|label
operator|--
expr_stmt|;
block|}
comment|/* 	 * Use the best, if any, hit. 	 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
operator|&&
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_ERROR
operator|&&
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|policy
operator|!=
name|DNS_RPZ_POLICY_GIVEN
condition|)
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|policy
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_MISS
operator|||
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_PASSTHRU
operator|||
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_ERROR
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_PASSTHRU
operator|&&
name|result
operator|!=
name|DNS_R_DELEGATION
condition|)
name|rpz_log_rewrite
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|,
name|st
operator|->
name|m
operator|.
name|policy
argument_list|,
name|st
operator|->
name|m
operator|.
name|type
argument_list|,
name|st
operator|->
name|m
operator|.
name|zone
argument_list|,
name|st
operator|->
name|qname
argument_list|)
expr_stmt|;
name|rpz_match_clear
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|==
name|DNS_RPZ_POLICY_ERROR
condition|)
block|{
name|st
operator|->
name|m
operator|.
name|type
operator|=
name|DNS_RPZ_TYPE_BAD
expr_stmt|;
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|==
literal|0
condition|)
name|rpz_clean
argument_list|(
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|st
operator|->
name|r
operator|.
name|ns_rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See if response policy zone rewriting is allowed by a lack of interest  * by the client in DNSSEC or a lack of signatures.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|rpz_ck_dnssec
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_rdataset_t
name|trdataset
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|rpz_break_dnssec
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * sigrdataset == NULL if and only !WANTDNSSEC(client) 	 */
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * We are happy to rewrite nothing. 	 */
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Do not rewrite if there is any sign of signatures. 	 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * Look for a signature in a negative cache rdataset. 	 */
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NEGATIVE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_ncache_current
argument_list|(
name|rdataset
argument_list|,
name|found
argument_list|,
operator|&
name|trdataset
argument_list|)
expr_stmt|;
name|type
operator|=
name|trdataset
operator|.
name|type
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a CNAME to the query response, including translating foo.evil.com and  *	*.evil.com CNAME *.example.com  * to  *	foo.evil.com CNAME foo.evil.com.example.com  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rpz_add_cname
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|,
name|dns_name_t
modifier|*
name|cname
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|isc_buffer_t
modifier|*
name|dbuf
parameter_list|)
block|{
name|dns_fixedname_t
name|prefix
decl_stmt|,
name|suffix
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|>
literal|2
operator|&&
name|dns_name_iswildcard
argument_list|(
name|cname
argument_list|)
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|prefix
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
literal|1
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|suffix
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|cname
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|suffix
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|prefix
argument_list|)
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|suffix
argument_list|)
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NAMETOOLONG
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_yxdomain
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dns_name_copy
argument_list|(
name|cname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|query_add_cname
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|dns_trust_authanswer
argument_list|,
name|st
operator|->
name|m
operator|.
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rpz_log_rewrite
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|,
name|st
operator|->
name|m
operator|.
name|policy
argument_list|,
name|st
operator|->
name|m
operator|.
name|type
argument_list|,
name|st
operator|->
name|m
operator|.
name|zone
argument_list|,
name|st
operator|->
name|qname
argument_list|)
expr_stmt|;
name|ns_client_qnamereplace
argument_list|(
name|client
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off DNSSEC because the results of a 	 * response policy zone cannot verify. 	 */
name|client
operator|->
name|attributes
operator|&=
operator|~
operator|(
name|NS_CLIENTATTR_WANTDNSSEC
operator||
name|DNS_MESSAGEFLAG_AD
operator|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_RESTARTS
value|16
end_define

begin_define
define|#
directive|define
name|QUERY_ERROR
parameter_list|(
name|r
parameter_list|)
define|\
value|do { \ 	eresult = r; \ 	want_restart = ISC_FALSE; \ 	line = __LINE__; \ } while (0)
end_define

begin_define
define|#
directive|define
name|RECURSE_ERROR
parameter_list|(
name|r
parameter_list|)
define|\
value|do { \ 	if ((r) == DNS_R_DUPLICATE || (r) == DNS_R_DROP) \ 		QUERY_ERROR(r); \ 	else \ 		QUERY_ERROR(DNS_R_SERVFAIL); \ } while (0)
end_define

begin_comment
comment|/*  * Extract a network address from the RDATA of an A or AAAA  * record.  *  * Returns:  *	ISC_R_SUCCESS  *	ISC_R_NOTIMPLEMENTED	The rdata is not a known address type.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdata_tonetaddr
parameter_list|(
specifier|const
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_netaddr_t
modifier|*
name|netaddr
parameter_list|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
name|struct
name|in6_addr
name|in6a
decl_stmt|;
switch|switch
condition|(
name|rdata
operator|->
name|type
condition|)
block|{
case|case
name|dns_rdatatype_a
case|:
name|INSIST
argument_list|(
name|rdata
operator|->
name|length
operator|==
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ina
operator|.
name|s_addr
argument_list|,
name|rdata
operator|->
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin
argument_list|(
name|netaddr
argument_list|,
operator|&
name|ina
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
case|case
name|dns_rdatatype_aaaa
case|:
name|INSIST
argument_list|(
name|rdata
operator|->
name|length
operator|==
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|,
name|rdata
operator|->
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
name|netaddr
argument_list|,
operator|&
name|in6a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the sort order of 'rdata' in the topology-like  * ACL forming the second element in a 2-element top-level  * sortlist statement.  */
end_comment

begin_function
specifier|static
name|int
name|query_sortlist_order_2element
parameter_list|(
specifier|const
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
if|if
condition|(
name|rdata_tonetaddr
argument_list|(
name|rdata
argument_list|,
operator|&
name|netaddr
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|INT_MAX
operator|)
return|;
return|return
operator|(
name|ns_sortlist_addrorder2
argument_list|(
operator|&
name|netaddr
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the sort order of 'rdata' in the matching element  * of a 1-element top-level sortlist statement.  */
end_comment

begin_function
specifier|static
name|int
name|query_sortlist_order_1element
parameter_list|(
specifier|const
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
if|if
condition|(
name|rdata_tonetaddr
argument_list|(
name|rdata
argument_list|,
operator|&
name|netaddr
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|INT_MAX
operator|)
return|;
return|return
operator|(
name|ns_sortlist_addrorder1
argument_list|(
operator|&
name|netaddr
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the sortlist statement that applies to 'client' and set up  * the sortlist info in in client->message appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|setup_query_sortlist
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|dns_rdatasetorderfunc_t
name|order
init|=
name|NULL
decl_stmt|;
specifier|const
name|void
modifier|*
name|order_arg
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ns_sortlist_setup
argument_list|(
name|client
operator|->
name|view
operator|->
name|sortlist
argument_list|,
operator|&
name|netaddr
argument_list|,
operator|&
name|order_arg
argument_list|)
condition|)
block|{
case|case
name|NS_SORTLISTTYPE_1ELEMENT
case|:
name|order
operator|=
name|query_sortlist_order_1element
expr_stmt|;
break|break;
case|case
name|NS_SORTLISTTYPE_2ELEMENT
case|:
name|order
operator|=
name|query_sortlist_order_2element
expr_stmt|;
break|break;
case|case
name|NS_SORTLISTTYPE_NONE
case|:
name|order
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|dns_message_setsortorder
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|order
argument_list|,
name|order_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_addnoqnameproof
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|,
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|neg
decl_stmt|,
modifier|*
name|negsig
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOMEMORY
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_addnoqnameproof"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|neg
operator|=
name|NULL
expr_stmt|;
name|negsig
operator|=
name|NULL
expr_stmt|;
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|neg
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|negsig
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|neg
operator|==
name|NULL
operator|||
name|negsig
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_getnoqname
argument_list|(
name|rdataset
argument_list|,
name|fname
argument_list|,
name|neg
argument_list|,
name|negsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|neg
argument_list|,
operator|&
name|negsig
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_CLOSEST
operator|)
operator|==
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neg
operator|==
name|NULL
condition|)
name|neg
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|neg
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|negsig
operator|==
name|NULL
condition|)
name|negsig
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|negsig
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|negsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|neg
operator|==
name|NULL
operator|||
name|negsig
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_getclosest
argument_list|(
name|rdataset
argument_list|,
name|fname
argument_list|,
name|neg
argument_list|,
name|negsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|neg
argument_list|,
operator|&
name|negsig
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|neg
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
name|negsig
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|negsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|answer_in_glue
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
decl_stmt|;
name|dns_section_t
name|section
init|=
name|DNS_SECTION_ADDITIONAL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|msg
operator|=
name|client
operator|->
name|message
expr_stmt|;
for|for
control|(
name|name
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|)
init|;
name|name
operator|!=
name|NULL
condition|;
name|name
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|name
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
condition|)
block|{
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|qtype
condition|)
break|break;
break|break;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|msg
operator|->
name|sections
index|[
name|section
index|]
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|name
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|name
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_REQUIREDGLUE
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NS_NAME_INIT
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
define|\
value|{ \ 		DNS_NAME_MAGIC, \ 		A, sizeof(A), sizeof(B), \ 		DNS_NAMEATTR_READONLY | DNS_NAMEATTR_ABSOLUTE, \ 		B, NULL, { (void *)-1, (void *)-1}, \ 		{NULL, NULL} \ 	}
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr10_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|11
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr172_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|7
block|,
literal|15
block|,
literal|20
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr192_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|21
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr10
index|[]
init|=
literal|"\00210\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr16172
index|[]
init|=
literal|"\00216\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr17172
index|[]
init|=
literal|"\00217\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr18172
index|[]
init|=
literal|"\00218\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr19172
index|[]
init|=
literal|"\00219\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr20172
index|[]
init|=
literal|"\00220\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr21172
index|[]
init|=
literal|"\00221\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr22172
index|[]
init|=
literal|"\00222\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr23172
index|[]
init|=
literal|"\00223\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr24172
index|[]
init|=
literal|"\00224\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr25172
index|[]
init|=
literal|"\00225\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr26172
index|[]
init|=
literal|"\00226\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr27172
index|[]
init|=
literal|"\00227\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr28172
index|[]
init|=
literal|"\00228\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr29172
index|[]
init|=
literal|"\00229\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr30172
index|[]
init|=
literal|"\00230\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr31172
index|[]
init|=
literal|"\00231\003172\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|inaddr168192
index|[]
init|=
literal|"\003168\003192\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_name_t
name|rfc1918names
index|[]
init|=
block|{
name|NS_NAME_INIT
argument_list|(
name|inaddr10
argument_list|,
name|inaddr10_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr16172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr17172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr18172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr19172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr20172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr21172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr22172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr23172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr24172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr25172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr26172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr27172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr28172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr29172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr30172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
name|inaddr31172
argument_list|,
name|inaddr172_offsets
argument_list|)
block|,
name|NS_NAME_INIT
argument_list|(
argument|inaddr168192
argument_list|,
argument|inaddr192_offsets
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|prisoner_data
index|[]
init|=
literal|"\010prisoner\004iana\003org"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|hostmaster_data
index|[]
init|=
literal|"\012hostmaster\014root-servers\003org"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|prisoner_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|14
block|,
literal|18
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|hostmaster_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|11
block|,
literal|24
block|,
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_name_t
name|prisoner
init|=
name|NS_NAME_INIT
argument_list|(
name|prisoner_data
argument_list|,
name|prisoner_offsets
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_name_t
name|hostmaster
init|=
name|NS_NAME_INIT
argument_list|(
name|hostmaster_data
argument_list|,
name|hostmaster_offsets
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|warn_rfc1918
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdataset_t
name|found
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|rfc1918names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|rfc1918names
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
operator|&
name|rfc1918names
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|found
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_ncache_getrdataset
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rfc1918names
index|[
name|i
index|]
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|found
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|found
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|soa
operator|.
name|origin
argument_list|,
operator|&
name|prisoner
argument_list|)
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|soa
operator|.
name|contact
argument_list|,
operator|&
name|hostmaster
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|fname
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"RFC 1918 response from "
literal|"Internet for %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|found
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|query_findclosestnsec3
parameter_list|(
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|isc_boolean_t
name|exact
parameter_list|,
name|dns_name_t
modifier|*
name|found
parameter_list|)
block|{
name|unsigned
name|char
name|salt
index|[
literal|256
index|]
decl_stmt|;
name|size_t
name|salt_length
decl_stmt|;
name|isc_uint16_t
name|iterations
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|dboptions
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_hash_t
name|hash
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|int
name|order
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|dns_rdata_nsec3_t
name|nsec3
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|optout
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|salt_length
operator|=
sizeof|sizeof
argument_list|(
name|salt
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getnsec3parameters
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|hash
argument_list|,
name|NULL
argument_list|,
operator|&
name|iterations
argument_list|,
name|salt
argument_list|,
operator|&
name|salt_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|qname
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Map unknown algorithm to known value. 	 */
if|if
condition|(
name|hash
operator|==
name|DNS_NSEC3_UNKNOWNALG
condition|)
name|hash
operator|=
literal|1
expr_stmt|;
name|again
label|:
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_nsec3_hashname
argument_list|(
operator|&
name|fixed
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
name|hash
argument_list|,
name|iterations
argument_list|,
name|salt
argument_list|,
name|salt_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|dboptions
operator|=
name|client
operator|->
name|query
operator|.
name|dboptions
operator||
name|DNS_DBFIND_FORCENSEC3
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec3
argument_list|,
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NXDOMAIN
condition|)
block|{
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
return|return;
block|}
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|optout
operator|=
name|ISC_TF
argument_list|(
operator|(
name|nsec3
operator|.
name|flags
operator|&
name|DNS_NSEC3FLAG_OPTOUT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
name|optout
operator|&&
name|dns_name_fullcompare
argument_list|(
operator|&
name|name
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|count
argument_list|)
operator|==
name|dns_namereln_subdomain
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|count
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|name
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"looking for closest provable encloser"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|exact
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"expected a exact match NSEC3, got "
literal|"a covering record"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|exact
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"expected covering NSEC3, got an exact match"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
name|dns_name_copy
argument_list|(
operator|&
name|name
argument_list|,
name|found
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
end_ifdef

begin_function
specifier|static
name|isc_boolean_t
name|is_v4_client
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
operator|==
name|AF_INET
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|client
operator|->
name|peeraddr
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_uint32_t
name|dns64_ttl
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|ttl
init|=
name|ISC_UINT32_MAX
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_getoriginnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_soa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|.
name|ttl
argument_list|,
name|soa
operator|.
name|minimum
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|ttl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|dns64_aaaaok
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|dns_dns64_t
modifier|*
name|dns64
init|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|view
operator|->
name|dns64
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|isc_boolean_t
modifier|*
name|aaaaok
decl_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns64
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
name|flags
operator||=
name|DNS_DNS64_RECURSIVE
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|flags
operator||=
name|DNS_DNS64_DNSSEC
expr_stmt|;
name|count
operator|=
name|dns_rdataset_count
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|aaaaok
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_boolean_t
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_dns64_aaaaok
argument_list|(
name|dns64
argument_list|,
operator|&
name|netaddr
argument_list|,
name|client
operator|->
name|signer
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
name|flags
argument_list|,
name|rdataset
argument_list|,
name|aaaaok
argument_list|,
name|count
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aaaaok
operator|!=
name|NULL
operator|&&
operator|!
name|aaaaok
index|[
name|i
index|]
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|=
name|aaaaok
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaaoklen
operator|=
name|count
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|count
operator|&&
name|aaaaok
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|aaaaok
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_boolean_t
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|aaaaok
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|aaaaok
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_boolean_t
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for the name and type in the redirection zone.  If found update  * the arguments as appropriate.  Return ISC_TRUE if a update was  * performed.  *  * Only perform the update if the client is in the allow query acl and  * returning the update would not cause a DNSSEC validation failure.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|redirect
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_rdataset_t
name|trdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|ns_dbversion_t
modifier|*
name|dbversion
decl_stmt|;
name|CTRACE
argument_list|(
literal|"redirect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|redirect
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_db_iszone
argument_list|(
operator|*
name|dbp
argument_list|)
operator|&&
name|dns_db_issecure
argument_list|(
operator|*
name|dbp
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_secure
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|rdataset
operator|->
name|trust
operator|==
name|dns_trust_ultimate
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NEGATIVE
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_ncache_current
argument_list|(
name|rdataset
argument_list|,
name|found
argument_list|,
operator|&
name|trdataset
argument_list|)
expr_stmt|;
name|type
operator|=
name|trdataset
operator|.
name|type
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
block|}
name|result
operator|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|dns_zone_getqueryacl
argument_list|(
name|client
operator|->
name|view
operator|->
name|redirect
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_zone_getdb
argument_list|(
name|client
operator|->
name|view
operator|->
name|redirect
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|dbversion
operator|=
name|query_findversion
argument_list|(
name|client
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbversion
operator|==
name|NULL
condition|)
block|{
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* 	 * Lookup the requested data in the redirect zone. 	 */
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dbversion
operator|->
name|version
argument_list|,
name|qtype
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|found
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
operator|&
name|trdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|trdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|CTRACE
argument_list|(
literal|"redirect: found data: done"
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|found
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|trdataset
argument_list|)
condition|)
block|{
name|dns_rdataset_clone
argument_list|(
operator|&
name|trdataset
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|trdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nodep
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|dns_db_attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
operator|*
name|versionp
operator|=
name|dbversion
operator|->
name|version
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
operator|(
name|NS_QUERYATTR_NOAUTHORITY
operator||
name|NS_QUERYATTR_NOADDITIONAL
operator|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the bulk of query processing for the current query of 'client'.  * If 'event' is non-NULL, we are returning from recursion and 'qtype'  * is ignored.  Otherwise, 'qtype' is the query type.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|query_find
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_fetchevent_t
modifier|*
name|event
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|zdb
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|,
modifier|*
name|zfname
decl_stmt|,
modifier|*
name|tname
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|trdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|,
modifier|*
name|zrdataset
decl_stmt|,
modifier|*
name|zsigrdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdatasetp
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
decl_stmt|;
name|isc_boolean_t
name|want_restart
decl_stmt|,
name|authoritative
decl_stmt|,
name|is_zone
decl_stmt|,
name|need_wildcardproof
decl_stmt|;
name|isc_boolean_t
name|is_staticstub_zone
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|,
name|nlabels
decl_stmt|;
name|dns_namereln_t
name|namereln
decl_stmt|;
name|int
name|order
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dbuf
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|eresult
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_t
name|wildcardname
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|,
modifier|*
name|zversion
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
name|dns_rdata_cname_t
name|cname
decl_stmt|;
name|dns_rdata_dname_t
name|dname
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_boolean_t
name|empty_wild
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|noqname
decl_stmt|;
name|dns_rpz_st_t
modifier|*
name|rpz_st
decl_stmt|;
name|isc_boolean_t
name|resuming
decl_stmt|;
name|int
name|line
init|=
operator|-
literal|1
decl_stmt|;
name|isc_boolean_t
name|dns64_exclude
decl_stmt|,
name|dns64
decl_stmt|;
name|dns_clientinfomethods_t
name|cm
decl_stmt|;
name|dns_clientinfo_t
name|ci
decl_stmt|;
name|CTRACE
argument_list|(
literal|"query_find"
argument_list|)
expr_stmt|;
comment|/* 	 * One-time initialization. 	 * 	 * It's especially important to initialize anything that the cleanup 	 * code might cleanup. 	 */
name|eresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
name|zversion
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|zdb
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_FALSE
expr_stmt|;
name|empty_wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns64_exclude
operator|=
name|dns64
operator|=
name|ISC_FALSE
expr_stmt|;
name|options
operator|=
literal|0
expr_stmt|;
name|resuming
operator|=
name|ISC_FALSE
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|is_staticstub_zone
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_clientinfomethods_init
argument_list|(
operator|&
name|cm
argument_list|,
name|ns_client_sourceip
argument_list|)
expr_stmt|;
name|dns_clientinfo_init
argument_list|(
operator|&
name|ci
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We're returning from recursion.  Restore the query context 		 * and resume. 		 */
name|want_restart
operator|=
name|ISC_FALSE
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
operator|&&
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|is_zone
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
expr_stmt|;
name|authoritative
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|authoritative
expr_stmt|;
name|zone
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|zone
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|zone
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|node
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|db
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|rdataset
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|sigrdataset
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|qtype
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|qtype
expr_stmt|;
name|rpz_st
operator|->
name|r
operator|.
name|db
operator|=
name|event
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|event
operator|->
name|db
argument_list|,
operator|&
name|event
operator|->
name|node
argument_list|)
expr_stmt|;
name|rpz_st
operator|->
name|r
operator|.
name|r_type
operator|=
name|event
operator|->
name|qtype
expr_stmt|;
name|rpz_st
operator|->
name|r
operator|.
name|r_rdataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|event
operator|->
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
name|qtype
operator|=
name|event
operator|->
name|qtype
expr_stmt|;
name|db
operator|=
name|event
operator|->
name|db
expr_stmt|;
name|node
operator|=
name|event
operator|->
name|node
expr_stmt|;
name|rdataset
operator|=
name|event
operator|->
name|rdataset
expr_stmt|;
name|sigrdataset
operator|=
name|event
operator|->
name|sigrdataset
expr_stmt|;
block|}
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
if|if
condition|(
name|DNS64
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_DNS64
expr_stmt|;
name|dns64
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|DNS64EXCLUDE
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_DNS64EXCLUDE
expr_stmt|;
name|dns64_exclude
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 		 * We'll need some resources... 		 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
operator|&&
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|tname
operator|=
name|rpz_st
operator|->
name|fname
expr_stmt|;
block|}
else|else
block|{
name|tname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|event
operator|->
name|foundname
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_name_copy
argument_list|(
name|tname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
operator|&&
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|!=
literal|0
condition|)
block|{
name|rpz_st
operator|->
name|r
operator|.
name|r_result
operator|=
name|event
operator|->
name|result
expr_stmt|;
name|result
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|result
expr_stmt|;
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|event
operator|->
name|result
expr_stmt|;
block|}
name|resuming
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|resume
goto|;
block|}
comment|/* 	 * Not returning from recursion. 	 */
comment|/* 	 * If it's a SIG query, we'll iterate the node. 	 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
condition|)
name|type
operator|=
name|dns_rdatatype_any
expr_stmt|;
else|else
name|type
operator|=
name|qtype
expr_stmt|;
name|restart
label|:
name|CTRACE
argument_list|(
literal|"query_find: restart"
argument_list|)
expr_stmt|;
name|want_restart
operator|=
name|ISC_FALSE
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|checknames
operator|&&
operator|!
name|dns_rdata_checkowner
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|qtype
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|qtype
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"check-names failure %s/%s/%s"
argument_list|,
name|namebuf
argument_list|,
name|typename
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|QUERY_ERROR
argument_list|(
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * First we must find the right database. 	 */
name|options
operator|&=
name|DNS_GETDB_NOLOG
expr_stmt|;
comment|/* Preserve DNS_GETDB_NOLOG. */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|qtype
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
name|options
operator||=
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|result
operator|=
name|query_getdb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|options
argument_list|,
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|!
name|is_zone
operator|)
operator|&&
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ds
condition|)
block|{
comment|/* 		 * Look to see if we are authoritative for the 		 * child zone if the query type is DS. 		 */
name|dns_db_t
modifier|*
name|tdb
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|tzone
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|tversion
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|tresult
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_PARTIAL
argument_list|,
operator|&
name|tzone
argument_list|,
operator|&
name|tdb
argument_list|,
operator|&
name|tversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|options
operator|&=
operator|~
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|version
operator|=
name|tversion
expr_stmt|;
name|db
operator|=
name|tdb
expr_stmt|;
name|zone
operator|=
name|tzone
expr_stmt|;
name|is_zone
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|tdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|tzone
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_REFUSED
condition|)
block|{
if|if
condition|(
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_recurserej
argument_list|)
expr_stmt|;
block|}
else|else
name|inc_stats
argument_list|(
name|client
argument_list|,
name|dns_nsstatscounter_authrej
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PARTIALANSWER
argument_list|(
name|client
argument_list|)
condition|)
name|QUERY_ERROR
argument_list|(
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
block|}
else|else
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|is_staticstub_zone
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|is_zone
condition|)
block|{
name|authoritative
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
operator|&&
name|dns_zone_gettype
argument_list|(
name|zone
argument_list|)
operator|==
name|dns_zone_staticstub
condition|)
name|is_staticstub_zone
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|==
name|NULL
operator|&&
name|client
operator|->
name|query
operator|.
name|restarts
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_zone
condition|)
block|{
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * if is_zone = true, zone = NULL then this is 				 * a DLZ zone.  Don't attempt to attach zone. 				 */
name|dns_zone_attach
argument_list|(
name|zone
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|authzone
argument_list|)
expr_stmt|;
block|}
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|authdb
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|query
operator|.
name|authdbset
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|db_find
label|:
name|CTRACE
argument_list|(
literal|"query_find: db_find"
argument_list|)
expr_stmt|;
comment|/* 	 * We'll need some resources... 	 */
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
operator|!
name|is_zone
operator|||
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
operator|)
condition|)
block|{
name|sigrdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Now look for an answer in the database. 	 */
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|version
argument_list|,
name|type
argument_list|,
name|client
operator|->
name|query
operator|.
name|dboptions
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|resume
label|:
name|CTRACE
argument_list|(
literal|"query_find: resume"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|view
operator|->
name|rpz_zones
argument_list|)
operator|&&
operator|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|||
operator|!
name|client
operator|->
name|view
operator|->
name|rpz_recursive_only
operator|)
operator|&&
name|rpz_ck_dnssec
argument_list|(
name|client
argument_list|,
name|result
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
operator|&&
operator|!
name|RECURSING
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|==
name|NULL
operator|||
operator|(
name|client
operator|->
name|query
operator|.
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_REWRITTEN
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
block|{
name|isc_result_t
name|rresult
decl_stmt|;
name|rresult
operator|=
name|rpz_rewrite
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|result
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
switch|switch
condition|(
name|rresult
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
break|break;
case|case
name|DNS_R_DELEGATION
case|:
comment|/* 			 * recursing for NS names or addresses, 			 * so save the main query state 			 */
name|rpz_st
operator|->
name|q
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
operator|=
name|is_zone
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|authoritative
operator|=
name|authoritative
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|zone
operator|=
name|NULL
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|rdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|sigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|rpz_st
operator|->
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
goto|goto
name|cleanup
goto|;
default|default:
name|RECURSE_ERROR
argument_list|(
name|rresult
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
condition|)
name|rpz_st
operator|->
name|state
operator||=
name|DNS_RPZ_REWRITTEN
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
operator|&&
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_PASSTHRU
operator|&&
name|rpz_st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_ERROR
condition|)
block|{
if|if
condition|(
name|rpz_st
operator|->
name|m
operator|.
name|type
operator|==
name|DNS_RPZ_TYPE_QNAME
condition|)
block|{
name|result
operator|=
name|dns_name_copy
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|rpz_clean
argument_list|(
operator|&
name|zone
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|->
name|m
operator|.
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|rdataset
expr_stmt|;
name|rpz_st
operator|->
name|m
operator|.
name|rdataset
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|node
expr_stmt|;
name|rpz_st
operator|->
name|m
operator|.
name|node
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|db
expr_stmt|;
name|rpz_st
operator|->
name|m
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|version
expr_stmt|;
name|rpz_st
operator|->
name|m
operator|.
name|version
operator|=
name|NULL
expr_stmt|;
name|zone
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|zone
expr_stmt|;
name|rpz_st
operator|->
name|m
operator|.
name|zone
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|rpz_st
operator|->
name|m
operator|.
name|policy
condition|)
block|{
case|case
name|DNS_RPZ_POLICY_NXDOMAIN
case|:
name|result
operator|=
name|DNS_R_NXDOMAIN
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_NODATA
case|:
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_RECORD
case|:
name|result
operator|=
name|rpz_st
operator|->
name|m
operator|.
name|result
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_any
operator|&&
name|result
operator|!=
name|DNS_R_CNAME
condition|)
block|{
comment|/* 					 * We will add all of the rdatasets of 					 * the node by iterating, setting the 					 * TTL then. 					 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * We will add this rdataset. 					 */
name|rdataset
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|rpz_st
operator|->
name|m
operator|.
name|ttl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DNS_RPZ_POLICY_WILDCNAME
case|:
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|rpz_add_cname
argument_list|(
name|client
argument_list|,
name|rpz_st
argument_list|,
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DNS_RPZ_POLICY_CNAME
case|:
comment|/* 				 * Add overridding CNAME from a named.conf 				 * response-policy statement 				 */
name|result
operator|=
name|rpz_add_cname
argument_list|(
name|client
argument_list|,
name|rpz_st
argument_list|,
operator|&
name|rpz_st
operator|->
name|m
operator|.
name|rpz
operator|->
name|cname
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|cleanup
goto|;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Turn off DNSSEC because the results of a 			 * response policy zone cannot verify. 			 */
name|client
operator|->
name|attributes
operator|&=
operator|~
operator|(
name|NS_CLIENTATTR_WANTDNSSEC
operator||
name|DNS_MESSAGEFLAG_AD
operator|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
operator|=
name|is_zone
expr_stmt|;
name|is_zone
operator|=
name|ISC_TRUE
expr_stmt|;
name|rpz_log_rewrite
argument_list|(
name|client
argument_list|,
name|ISC_FALSE
argument_list|,
name|rpz_st
operator|->
name|m
operator|.
name|policy
argument_list|,
name|rpz_st
operator|->
name|m
operator|.
name|type
argument_list|,
name|zone
argument_list|,
name|rpz_st
operator|->
name|qname
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
comment|/* 		 * This case is handled in the main line below. 		 */
break|break;
case|case
name|DNS_R_GLUE
case|:
case|case
name|DNS_R_ZONECUT
case|:
comment|/* 		 * These cases are handled in the main line below. 		 */
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|ISC_R_NOTFOUND
case|:
comment|/* 		 * The cache doesn't even have the root NS.  Get them from 		 * the hints DB. 		 */
name|INSIST
argument_list|(
operator|!
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|hints
operator|==
name|NULL
condition|)
block|{
comment|/* We have no hints. */
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|hints
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findext
argument_list|(
name|db
argument_list|,
name|dns_rootname
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
operator|&
name|node
argument_list|,
name|fname
argument_list|,
operator|&
name|cm
argument_list|,
operator|&
name|ci
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Nonsensical root hints may require cleanup. 			 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
comment|/* 			 * We don't have any root server hints, but 			 * we may have working forwarders, so try to 			 * recurse anyway. 			 */
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
if|if
condition|(
name|dns64
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_DNS64
expr_stmt|;
if|if
condition|(
name|dns64_exclude
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_DNS64EXCLUDE
expr_stmt|;
block|}
else|else
name|RECURSE_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
comment|/* Unable to give root server referral. */
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 		 * XXXRTH  We should trigger root server priming here. 		 */
comment|/* FALLTHROUGH */
case|case
name|DNS_R_DELEGATION
case|:
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|is_zone
condition|)
block|{
comment|/* 			 * Look to see if we are authoritative for the 			 * child zone if the query type is DS. 			 */
if|if
condition|(
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|options
operator|&
name|DNS_GETDB_NOEXACT
operator|)
operator|!=
literal|0
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ds
condition|)
block|{
name|dns_db_t
modifier|*
name|tdb
init|=
name|NULL
decl_stmt|;
name|dns_zone_t
modifier|*
name|tzone
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|tversion
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|query_getzonedb
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|qtype
argument_list|,
name|DNS_GETDB_PARTIAL
argument_list|,
operator|&
name|tzone
argument_list|,
operator|&
name|tdb
argument_list|,
operator|&
name|tversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|options
operator|&=
operator|~
name|DNS_GETDB_NOEXACT
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
name|version
operator|=
name|tversion
expr_stmt|;
name|db
operator|=
name|tdb
expr_stmt|;
name|zone
operator|=
name|tzone
expr_stmt|;
name|authoritative
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
if|if
condition|(
name|tdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|tdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|tzone
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We're authoritative for an ancestor of QNAME. 			 */
if|if
condition|(
operator|!
name|USECACHE
argument_list|(
name|client
argument_list|)
operator|||
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * If we don't have a cache, this is the best 				 * answer. 				 * 				 * If the client is making a nonrecursive 				 * query we always give out the authoritative 				 * delegation.  This way even if we get 				 * junk in our cache, we won't fail in our 				 * role as the delegating authority if another 				 * nameserver asks us about a delegated 				 * subzone. 				 * 				 * We enable the retrieval of glue for this 				 * database by setting client->query.gluedb. 				 */
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|db
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * We must ensure NOADDITIONAL is off, 				 * because the generation of 				 * additional data is required in 				 * delegations. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|query_addds
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We might have a better answer or delegation 				 * in the cache.  We'll remember the current 				 * values of fname, rdataset, and sigrdataset. 				 * We'll then go looking for QNAME in the 				 * cache.  If we find something better, we'll 				 * use it instead. 				 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|zdb
operator|=
name|db
expr_stmt|;
name|zfname
operator|=
name|fname
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|zrdataset
operator|=
name|rdataset
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|zsigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|zversion
operator|=
name|version
expr_stmt|;
name|version
operator|=
name|NULL
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|client
operator|->
name|view
operator|->
name|cachedb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|is_zone
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zfname
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|fname
argument_list|,
name|zfname
argument_list|)
operator|||
operator|(
name|is_staticstub_zone
operator|&&
name|dns_name_equal
argument_list|(
name|fname
argument_list|,
name|zfname
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * In the following cases use "authoritative" 				 * data instead of the cache delegation: 				 * 1. We've already got a delegation from 				 *    authoritative data, and it is better 				 *    than what we found in the cache. 				 * 2. The query name matches the origin name 				 *    of a static-stub zone.  This needs to be 				 *    considered for the case where the NS of 				 *    the static-stub zone and the cached NS 				 *    are different.  We still need to contact 				 *    the nameservers configured in the 				 *    static-stub zone. 				 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|zfname
expr_stmt|;
name|zfname
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * We've already done query_keepname() on 				 * zfname, so we must set dbuf to NULL to 				 * prevent query_addrrset() from trying to 				 * call query_keepname() again. 				 */
name|dbuf
operator|=
name|NULL
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|zrdataset
expr_stmt|;
name|zrdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|zsigrdataset
expr_stmt|;
name|zsigrdataset
operator|=
name|NULL
expr_stmt|;
name|version
operator|=
name|zversion
expr_stmt|;
name|zversion
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * We don't clean up zdb here because we 				 * may still need it.  It will get cleaned 				 * up by the main cleanup code. 				 */
block|}
if|if
condition|(
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 				 * Recurse! 				 */
if|if
condition|(
name|dns_rdatatype_atparent
argument_list|(
name|type
argument_list|)
condition|)
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dns64
condition|)
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
if|if
condition|(
name|dns64
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_DNS64
expr_stmt|;
if|if
condition|(
name|dns64_exclude
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_DNS64EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_DUPLICATE
operator|||
name|result
operator|==
name|DNS_R_DROP
condition|)
name|QUERY_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
else|else
name|RECURSE_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * This is the best answer. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_CACHEGLUEOK
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|zdb
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|isreferral
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * We must ensure NOADDITIONAL is off, 				 * because the generation of 				 * additional data is required in 				 * delegations. 				 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|gluedb
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_CACHEGLUEOK
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|query_addds
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_EMPTYNAME
case|:
case|case
name|DNS_R_NXRRSET
case|:
name|iszone_nxrrset
label|:
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|dns64_bis_return_excluded_addresses
if|if
condition|(
name|dns64
condition|)
else|#
directive|else
if|if
condition|(
name|dns64
operator|&&
operator|!
name|dns64_exclude
condition|)
endif|#
directive|endif
block|{
comment|/* 			 * Restore the answers from the previous AAAA lookup. 			 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
expr_stmt|;
name|sigrdataset
operator|=
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|dns_name_copy
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns64
operator|=
name|ISC_FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|dns64_bis_return_excluded_addresses
comment|/* 			 * Resume the diverted processing of the AAAA response? 			 */
if|if
condition|(
name|dns64_excluded
condition|)
break|break;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|view
operator|->
name|dns64
argument_list|)
operator|&&
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|dns_rdataclass_in
operator|&&
name|qtype
operator|==
name|dns_rdatatype_aaaa
condition|)
block|{
comment|/* 			 * Look to see if there are A records for this 			 * name. 			 */
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|rdataset
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|sigrdataset
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|=
name|dns64_ttl
argument_list|(
name|db
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|qtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Arrange for RPZ rewriting of any A records. 				 */
if|if
condition|(
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_REWRITTEN
operator|)
operator|!=
literal|0
condition|)
name|is_zone
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
expr_stmt|;
name|rpz_st_clear
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|dns64
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
comment|/* 		 * Look for a NSEC3 record if we don't have a NSEC record. 		 */
name|nxrrset_rrsig
label|:
if|if
condition|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|==
literal|0
condition|)
block|{
name|dns_name_t
modifier|*
name|found
decl_stmt|;
name|dns_name_t
modifier|*
name|qname
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|found
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|qname
operator|=
name|client
operator|->
name|query
operator|.
name|qname
expr_stmt|;
name|query_findclosestnsec3
argument_list|(
name|qname
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_TRUE
argument_list|,
name|found
argument_list|)
expr_stmt|;
comment|/* 				 * Did we find the closest provable encloser 				 * instead? If so add the nearest to the 				 * closest provable encloser. 				 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|qname
argument_list|,
name|found
argument_list|)
operator|&&
operator|!
operator|(
name|ns_g_nonearest
operator|&&
name|qtype
operator|!=
name|dns_rdatatype_ds
operator|)
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|skip
decl_stmt|;
comment|/* 					 * Add the closest provable encloser. 					 */
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|count
operator|=
name|dns_name_countlabels
argument_list|(
name|found
argument_list|)
operator|+
literal|1
expr_stmt|;
name|skip
operator|=
name|dns_name_countlabels
argument_list|(
name|qname
argument_list|)
operator|-
name|count
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|qname
argument_list|,
name|skip
argument_list|,
name|count
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|fixfname
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|fixrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|fixrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 					 * 'nearest' doesn't exist so 					 * 'exist' is set to ISC_FALSE. 					 */
name|query_findclosestnsec3
argument_list|(
name|found
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|fname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * If we've got a NSEC record, we need to save the 			 * name now because we're going call query_addsoa() 			 * below, and it needs to use the name buffer. 			 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We're not going to use fname, and need to release 			 * our hold on the name buffer so query_addsoa() 			 * may use it. 			 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add SOA. 		 */
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|ISC_UINT32_MAX
argument_list|,
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Add NSEC record if we found one. 		 */
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|query_addnxrrsetnsec
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_EMPTYWILD
case|:
name|empty_wild
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|DNS_R_NXDOMAIN
case|:
name|INSIST
argument_list|(
name|is_zone
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty_wild
operator|&&
name|redirect
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|type
argument_list|)
condition|)
break|break;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
block|{
comment|/* 			 * If we've got a NSEC record, we need to save the 			 * name now because we're going call query_addsoa() 			 * below, and it needs to use the name buffer. 			 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We're not going to use fname, and need to release 			 * our hold on the name buffer so query_addsoa() 			 * may use it. 			 */
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add SOA.  If the query was for a SOA record force the 		 * ttl to zero so that it is possible for clients to find 		 * the containing zone of an arbitrary name with a stub 		 * resolver and not have it cached. 		 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_soa
operator|&&
name|zone
operator|!=
name|NULL
operator|&&
name|dns_zone_getzeronosoattl
argument_list|(
name|zone
argument_list|)
condition|)
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|ISC_UINT32_MAX
argument_list|,
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 			 * Add NSEC record if we found one. 			 */
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|rdataset
argument_list|)
condition|)
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set message rcode. 		 */
if|if
condition|(
name|empty_wild
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_noerror
expr_stmt|;
else|else
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_NCACHENXDOMAIN
case|:
if|if
condition|(
name|redirect
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|type
argument_list|)
condition|)
break|break;
case|case
name|DNS_R_NCACHENXRRSET
case|:
name|ncache_nxrrset
label|:
name|INSIST
argument_list|(
operator|!
name|is_zone
argument_list|)
expr_stmt|;
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Set message rcode, if required. 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_nxdomain
expr_stmt|;
comment|/* 		 * Look for RFC 1918 leakage from Internet. 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ptr
operator|&&
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|dns_rdataclass_in
operator|&&
name|dns_name_countlabels
argument_list|(
name|fname
argument_list|)
operator|==
literal|7
condition|)
name|warn_rfc1918
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|dns64_bis_return_excluded_addresses
if|if
condition|(
name|dns64
condition|)
else|#
directive|else
if|if
condition|(
name|dns64
operator|&&
operator|!
name|dns64_exclude
condition|)
endif|#
directive|endif
block|{
comment|/* 			 * Restore the answers from the previous AAAA lookup. 			 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
expr_stmt|;
name|sigrdataset
operator|=
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|dns_name_copy
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns64
operator|=
name|ISC_FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|dns64_bis_return_excluded_addresses
if|if
condition|(
name|dns64_excluded
condition|)
break|break;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NCACHENXRRSET
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|view
operator|->
name|dns64
argument_list|)
operator|&&
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|dns_rdataclass_in
operator|&&
name|qtype
operator|==
name|dns_rdatatype_aaaa
condition|)
block|{
comment|/* 			 * Look to see if there are A records for this 			 * name. 			 */
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|rdataset
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|sigrdataset
expr_stmt|;
comment|/* 			 * If the ttl is zero we need to workout if we have just 			 * decremented to zero or if there was no negative cache 			 * ttl in the answer. 			 */
if|if
condition|(
name|rdataset
operator|->
name|ttl
operator|!=
literal|0
condition|)
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
elseif|else
if|if
condition|(
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|=
literal|0
expr_stmt|;
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|qtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Arrange for RPZ rewriting of any A records. 				 */
if|if
condition|(
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_REWRITTEN
operator|)
operator|!=
literal|0
condition|)
name|is_zone
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
expr_stmt|;
name|rpz_st_clear
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|dns64
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
comment|/* 		 * We don't call query_addrrset() because we don't need any 		 * of its extra features (and things would probably break!). 		 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|fname
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DNS_R_CNAME
case|:
comment|/* 		 * Keep a copy of the rdataset.  We have to do this because 		 * query_addrrset may clear 'rdataset' (to prevent the 		 * cleanup code from cleaning it up). 		 */
name|trdataset
operator|=
name|rdataset
expr_stmt|;
comment|/* 		 * Add the CNAME to the answer section. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|NOQNAME
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|noqname
operator|=
name|rdataset
expr_stmt|;
else|else
name|noqname
operator|=
name|NULL
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|query_addnoqnameproof
argument_list|(
name|client
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
comment|/* 		 * We set the PARTIALANSWER attribute so that if anything goes 		 * wrong later on, we'll return what we've got so far. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_PARTIALANSWER
expr_stmt|;
comment|/* 		 * Reset qname to be the target name of the CNAME and restart 		 * the query. 		 */
name|tname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdataset_current
argument_list|(
name|trdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|client
operator|->
name|mctx
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdata_freestruct
argument_list|(
operator|&
name|cname
argument_list|)
expr_stmt|;
name|ns_client_qnamereplace
argument_list|(
name|client
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
condition|)
name|options
operator||=
name|DNS_GETDB_NOLOG
expr_stmt|;
goto|goto
name|addauth
goto|;
case|case
name|DNS_R_DNAME
case|:
comment|/* 		 * Compare the current qname to the found name.  We need 		 * to know how many labels and bits are in common because 		 * we're going to have to split qname later on. 		 */
name|namereln
operator|=
name|dns_name_fullcompare
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|nlabels
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|namereln
operator|==
name|dns_namereln_subdomain
argument_list|)
expr_stmt|;
comment|/* 		 * Keep a copy of the rdataset.  We have to do this because 		 * query_addrrset may clear 'rdataset' (to prevent the 		 * cleanup code from cleaning it up). 		 */
name|trdataset
operator|=
name|rdataset
expr_stmt|;
comment|/* 		 * Add the DNAME to the answer section. 		 */
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
comment|/* 		 * We set the PARTIALANSWER attribute so that if anything goes 		 * wrong later on, we'll return what we've got so far. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_PARTIALANSWER
expr_stmt|;
comment|/* 		 * Get the target name of the DNAME. 		 */
name|tname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|trdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_rdataset_current
argument_list|(
name|trdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|dname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_clone
argument_list|(
operator|&
name|dname
operator|.
name|dname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dname
argument_list|)
expr_stmt|;
comment|/* 		 * Construct the new qname consisting of 		 *<found name prefix>.<dname target> 		 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|nlabels
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|fname
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|query_getnamebuf
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|prefix
argument_list|,
name|tname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
comment|/* 		 * RFC2672, section 4.1, subsection 3c says 		 * we should return YXDOMAIN if the constructed 		 * name would be too long. 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_NAMETOOLONG
condition|)
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_yxdomain
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
comment|/* 		 * Synthesize a CNAME consisting of 		 *<old qname><dname ttl> CNAME<new qname> 		 *	    with<dname trust value> 		 * 		 * Synthesize a CNAME so old old clients that don't understand 		 * DNAME can chain. 		 * 		 * We do not try to synthesize a signature because we hope 		 * that security aware servers will understand DNAME.  Also, 		 * even if we had an online key, making a signature 		 * on-the-fly is costly, and not really legitimate anyway 		 * since the synthesized CNAME is NOT in the zone. 		 */
name|result
operator|=
name|query_add_cname
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|fname
argument_list|,
name|trdataset
operator|->
name|trust
argument_list|,
name|trdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 		 * Switch to the new qname and restart. 		 */
name|ns_client_qnamereplace
argument_list|(
name|client
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fname
operator|=
name|NULL
expr_stmt|;
name|want_restart
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
condition|)
name|options
operator||=
name|DNS_GETDB_NOLOG
expr_stmt|;
goto|goto
name|addauth
goto|;
default|default:
comment|/* 		 * Something has gone wrong. 		 */
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
name|fname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|wildcardname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|fname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_wildcardproof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|v4_aaaa
operator|!=
name|dns_v4_aaaa_ok
operator|&&
name|is_v4_client
argument_list|(
name|client
argument_list|)
operator|&&
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|view
operator|->
name|v4_aaaa_acl
argument_list|,
name|ISC_TRUE
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|client
operator|->
name|filter_aaaa
operator|=
name|client
operator|->
name|view
operator|->
name|v4_aaaa
expr_stmt|;
else|else
name|client
operator|->
name|filter_aaaa
operator|=
name|dns_v4_aaaa_ok
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
name|isc_boolean_t
name|have_aaaa
decl_stmt|,
name|have_a
decl_stmt|,
name|have_sig
decl_stmt|;
comment|/* 		 * The filter-aaaa-on-v4 option should 		 * suppress AAAAs for IPv4 clients if there is an A. 		 * If we are not authoritative, assume there is a A 		 * even in if it is not in our cache.  This assumption could 		 * be wrong but it is a good bet. 		 */
name|have_aaaa
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_a
operator|=
operator|!
name|authoritative
expr_stmt|;
name|have_sig
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * XXXRTH  Need to handle zonecuts with special case 		 * code. 		 */
name|n
operator|=
literal|0
expr_stmt|;
name|rdsiter
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
literal|0
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Calling query_addrrset() with a non-NULL dbuf is going 		 * to either keep or release the name.  We don't want it to 		 * release fname, since we may have to call query_addrrset() 		 * more than once.  That means we have to call query_keepname() 		 * now, and pass a NULL dbuf to query_addrrset(). 		 * 		 * If we do a query_addrrset() below, we must set fname to 		 * NULL before leaving this block, otherwise we might try to 		 * cleanup fname even though we're using it! 		 */
name|query_keepname
argument_list|(
name|client
argument_list|,
name|fname
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|tname
operator|=
name|fname
expr_stmt|;
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsiter
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdatasetiter_current
argument_list|(
name|rdsiter
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
comment|/* 			 * Notice the presence of A and AAAAs so 			 * that AAAAs can be hidden from IPv4 clients. 			 */
if|if
condition|(
name|client
operator|->
name|filter_aaaa
operator|!=
name|dns_v4_aaaa_ok
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
condition|)
name|have_aaaa
operator|=
name|ISC_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_a
condition|)
name|have_a
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|is_zone
operator|&&
name|qtype
operator|==
name|dns_rdatatype_any
operator|&&
operator|!
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
operator|&&
name|dns_rdatatype_isdnssec
argument_list|(
name|rdataset
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 				 * The zone is transitioning from insecure 				 * to secure. Hide the dnssec records from 				 * ANY queries. 				 */
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|qtype
operator|==
name|dns_rdatatype_any
operator|||
name|rdataset
operator|->
name|type
operator|==
name|qtype
operator|)
operator|&&
name|rdataset
operator|->
name|type
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
if|if
condition|(
name|dns_rdatatype_isdnssec
argument_list|(
name|rdataset
operator|->
name|type
argument_list|)
condition|)
name|have_sig
operator|=
name|ISC_TRUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NOQNAME
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|noqname
operator|=
name|rdataset
expr_stmt|;
else|else
name|noqname
operator|=
name|NULL
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|rpz_st
operator|->
name|m
operator|.
name|ttl
argument_list|)
expr_stmt|;
name|query_addrrset
argument_list|(
name|client
argument_list|,
name|fname
operator|!=
name|NULL
condition|?
operator|&
name|fname
else|:
operator|&
name|tname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|query_addnoqnameproof
argument_list|(
name|client
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|tname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * rdataset is non-NULL only in certain 				 * pathological cases involving DNAMEs. 				 */
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
break|break;
block|}
else|else
block|{
comment|/* 				 * We're not interested in this rdataset. 				 */
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsiter
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
comment|/* 		 * Filter AAAAs if there is an A and there is no signature 		 * or we are supposed to break DNSSEC. 		 */
if|if
condition|(
name|client
operator|->
name|filter_aaaa
operator|==
name|dns_v4_aaaa_break_dnssec
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_FILTER_AAAA
expr_stmt|;
elseif|else
if|if
condition|(
name|client
operator|->
name|filter_aaaa
operator|!=
name|dns_v4_aaaa_ok
operator|&&
name|have_aaaa
operator|&&
name|have_a
operator|&&
operator|(
operator|!
name|have_sig
operator|||
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|)
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_FILTER_AAAA
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|dns_message_puttempname
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No matching rdatasets found in cache. If we were 			 * searching for RRSIG/SIG, that's probably okay; 			 * otherwise this is an error condition. 			 */
if|if
condition|(
operator|(
name|qtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|qtype
operator|==
name|dns_rdatatype_sig
operator|)
operator|&&
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
if|if
condition|(
operator|!
name|is_zone
condition|)
block|{
name|authoritative
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
name|client
operator|->
name|attributes
operator|&=
operator|~
name|NS_CLIENTATTR_RA
expr_stmt|;
goto|goto
name|addauth
goto|;
block|}
if|if
condition|(
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"missing signature "
literal|"for %s"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
name|fname
operator|=
name|query_newname
argument_list|(
name|client
argument_list|,
name|dbuf
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
goto|goto
name|nxrrset_rrsig
goto|;
block|}
else|else
name|result
operator|=
name|DNS_R_SERVFAIL
expr_stmt|;
block|}
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
block|{
name|QUERY_ERROR
argument_list|(
name|DNS_R_SERVFAIL
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * This is the "normal" case -- an ordinary question to which 		 * we know the answer. 		 */
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
comment|/* 		 * Optionally hide AAAAs from IPv4 clients if there is an A. 		 * We add the AAAAs now, but might refuse to render them later 		 * after DNSSEC is figured out. 		 * This could be more efficient, but the whole idea is 		 * so fundamentally wrong, unavoidably inaccurate, and 		 * unneeded that it is best to keep it as short as possible. 		 */
if|if
condition|(
name|client
operator|->
name|filter_aaaa
operator|==
name|dns_v4_aaaa_break_dnssec
operator|||
operator|(
name|client
operator|->
name|filter_aaaa
operator|==
name|dns_v4_aaaa_filter
operator|&&
operator|(
operator|!
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
name|sigrdataset
operator|==
name|NULL
operator|||
operator|!
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_aaaa
condition|)
block|{
name|trdataset
operator|=
name|query_newrdataset
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_a
argument_list|,
literal|0
argument_list|,
name|client
operator|->
name|now
argument_list|,
name|trdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|trdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|trdataset
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|trdataset
argument_list|)
expr_stmt|;
comment|/* 				 * We have an AAAA but the A is not in our cache. 				 * Assume any result other than DNS_R_DELEGATION 				 * or ISC_R_NOTFOUND means there is no A and 				 * so AAAAs are ok. 				 * Assume there is no A if we can't recurse 				 * for this client, although that could be 				 * the wrong answer. What else can we do? 				 * Besides, that we have the AAAA and are using 				 * this mechanism suggests that we care more 				 * about As than AAAAs and would have cached 				 * the A if it existed. 				 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_FILTER_AAAA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|authoritative
operator|||
operator|!
name|RECURSIONOK
argument_list|(
name|client
argument_list|)
operator|||
operator|(
name|result
operator|!=
name|DNS_R_DELEGATION
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
operator|)
condition|)
block|{
name|client
operator|->
name|attributes
operator|&=
operator|~
name|NS_CLIENTATTR_FILTER_AAAA
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * This is an ugly kludge to recurse 					 * for the A and discard the result. 					 * 					 * Continue to add the AAAA now. 					 * We'll make a note to not render it 					 * if the recursion for the A succeeds. 					 */
name|result
operator|=
name|query_recurse
argument_list|(
name|client
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|resuming
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_FILTER_AAAA_RC
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_RECURSING
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_a
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_FILTER_AAAA_RC
operator|)
operator|!=
literal|0
condition|)
block|{
name|client
operator|->
name|attributes
operator|&=
operator|~
name|NS_CLIENTATTR_FILTER_AAAA_RC
expr_stmt|;
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_FILTER_AAAA
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|sigrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Check to see if the AAAA RRset has non-excluded addresses 		 * in it.  If not look for a A RRset. 		 */
name|INSIST
argument_list|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_aaaa
operator|&&
operator|!
name|dns64_exclude
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|view
operator|->
name|dns64
argument_list|)
operator|&&
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|dns_rdataclass_in
operator|&&
operator|!
name|dns64_aaaaok
argument_list|(
name|client
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
condition|)
block|{
comment|/* 			 * Look to see if there are A records for this 			 * name. 			 */
name|client
operator|->
name|query
operator|.
name|dns64_aaaa
operator|=
name|rdataset
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_sigaaaa
operator|=
name|sigrdataset
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|dns64_ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|qtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Arrange for RPZ rewriting of any A records. 				 */
if|if
condition|(
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_REWRITTEN
operator|)
operator|!=
literal|0
condition|)
name|is_zone
operator|=
name|rpz_st
operator|->
name|q
operator|.
name|is_zone
expr_stmt|;
name|rpz_st_clear
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|dns64_exclude
operator|=
name|dns64
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|db_find
goto|;
block|}
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|sigrdatasetp
operator|=
operator|&
name|sigrdataset
expr_stmt|;
else|else
name|sigrdatasetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NOQNAME
argument_list|(
name|rdataset
argument_list|)
operator|&&
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
condition|)
name|noqname
operator|=
name|rdataset
expr_stmt|;
else|else
name|noqname
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * BIND 8 priming queries need the additional section. 		 */
if|if
condition|(
name|is_zone
operator|&&
name|qtype
operator|==
name|dns_rdatatype_ns
operator|&&
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_NOADDITIONAL
expr_stmt|;
if|if
condition|(
name|dns64
condition|)
block|{
name|qtype
operator|=
name|type
operator|=
name|dns_rdatatype_aaaa
expr_stmt|;
name|result
operator|=
name|query_dns64
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
ifndef|#
directive|ifndef
name|dns64_bis_return_excluded_addresses
if|if
condition|(
name|dns64_exclude
condition|)
block|{
if|if
condition|(
operator|!
name|is_zone
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 					 * Add a fake SOA record. 					 */
operator|(
name|void
operator|)
name|query_addsoa
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
literal|600
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|is_zone
condition|)
goto|goto
name|iszone_nxrrset
goto|;
else|else
goto|goto
name|ncache_nxrrset
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|eresult
operator|=
name|result
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|dns64_aaaaok
operator|!=
name|NULL
condition|)
block|{
name|query_filter64
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
name|rdataset
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
else|else
name|query_addrrset
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|,
operator|&
name|rdataset
argument_list|,
name|sigrdatasetp
argument_list|,
name|dbuf
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|query_addnoqnameproof
argument_list|(
name|client
argument_list|,
name|noqname
argument_list|)
expr_stmt|;
comment|/* 		 * We shouldn't ever fail to add 'rdataset' 		 * because it's already in the answer. 		 */
name|INSIST
argument_list|(
name|rdataset
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|addauth
label|:
name|CTRACE
argument_list|(
literal|"query_find: addauth"
argument_list|)
expr_stmt|;
comment|/* 	 * Add NS records to the authority section (if we haven't already 	 * added them to the answer section). 	 */
if|if
condition|(
operator|!
name|want_restart
operator|&&
operator|!
name|NOAUTHORITY
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_zone
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|qtype
operator|==
name|dns_rdatatype_ns
operator|||
name|qtype
operator|==
name|dns_rdatatype_any
operator|)
operator|&&
name|dns_name_equal
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|dns_db_origin
argument_list|(
name|db
argument_list|)
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|query_addns
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qtype
operator|!=
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
name|query_addbestns
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Add NSEC records to the authority section if they're needed for 	 * DNSSEC wildcard proofs. 	 */
if|if
condition|(
name|need_wildcardproof
operator|&&
name|dns_db_issecure
argument_list|(
name|db
argument_list|)
condition|)
name|query_addwildcardproof
argument_list|(
name|client
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|wildcardname
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|CTRACE
argument_list|(
literal|"query_find: cleanup"
argument_list|)
expr_stmt|;
comment|/* 	 * General cleanup. 	 */
name|rpz_st
operator|=
name|client
operator|->
name|query
operator|.
name|rpz_st
expr_stmt|;
if|if
condition|(
name|rpz_st
operator|!=
name|NULL
operator|&&
operator|(
name|rpz_st
operator|->
name|state
operator|&
name|DNS_RPZ_RECURSING
operator|)
operator|==
literal|0
condition|)
block|{
name|rpz_match_clear
argument_list|(
name|rpz_st
argument_list|)
expr_stmt|;
name|rpz_st
operator|->
name|state
operator|&=
operator|~
name|DNS_RPZ_DONE_QNAME
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdb
operator|!=
name|NULL
condition|)
block|{
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zsigrdataset
operator|!=
name|NULL
condition|)
name|query_putrdataset
argument_list|(
name|client
argument_list|,
operator|&
name|zsigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfname
operator|!=
name|NULL
condition|)
name|query_releasename
argument_list|(
name|client
argument_list|,
operator|&
name|zfname
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|zdb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * AA bit. 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|restarts
operator|==
literal|0
operator|&&
operator|!
name|authoritative
condition|)
block|{
comment|/* 		 * We're not authoritative, so we must ensure the AA bit 		 * isn't set. 		 */
name|client
operator|->
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
block|}
comment|/* 	 * Restart the query? 	 */
if|if
condition|(
name|want_restart
operator|&&
name|client
operator|->
name|query
operator|.
name|restarts
operator|<
name|MAX_RESTARTS
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|restarts
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|eresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|(
operator|!
name|PARTIALANSWER
argument_list|(
name|client
argument_list|)
operator|||
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|eresult
operator|==
name|DNS_R_DUPLICATE
operator|||
name|eresult
operator|==
name|DNS_R_DROP
condition|)
block|{
comment|/* 			 * This was a duplicate query that we are 			 * recursing on.  Don't send a response now. 			 * The original query will still cause a response. 			 */
name|query_next
argument_list|(
name|client
argument_list|,
name|eresult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we don't have any answer to give the client, 			 * or if the client requested recursion and thus wanted 			 * the complete answer, send an error response. 			 */
name|INSIST
argument_list|(
name|line
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|query_error
argument_list|(
name|client
argument_list|,
name|eresult
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|RECURSING
argument_list|(
name|client
argument_list|)
condition|)
block|{
comment|/* 		 * We are done.  Set up sortlist data for the message 		 * rendering code, make a final tweak to the AA bit if the 		 * auth-nxdomain config option says so, then render and 		 * send the response. 		 */
name|setup_query_sortlist
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a referral and the answer to the question 		 * is in the glue sort it to the start of the additional 		 * section. 		 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|message
operator|->
name|sections
index|[
name|DNS_SECTION_ANSWER
index|]
argument_list|)
operator|&&
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|&&
operator|(
name|qtype
operator|==
name|dns_rdatatype_a
operator|||
name|qtype
operator|==
name|dns_rdatatype_aaaa
operator|)
condition|)
name|answer_in_glue
argument_list|(
name|client
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rcode
operator|==
name|dns_rcode_nxdomain
operator|&&
name|client
operator|->
name|view
operator|->
name|auth_nxdomain
operator|==
name|ISC_TRUE
condition|)
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
comment|/* 		 * If the response is somehow unexpected for the client and this 		 * is a result of recursion, return an error to the caller 		 * to indicate it may need to be logged. 		 */
if|if
condition|(
name|resuming
operator|&&
operator|(
name|ISC_LIST_EMPTY
argument_list|(
name|client
operator|->
name|message
operator|->
name|sections
index|[
name|DNS_SECTION_ANSWER
index|]
argument_list|)
operator|||
name|client
operator|->
name|message
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|)
condition|)
name|eresult
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|query_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ns_client_detach
argument_list|(
operator|&
name|client
argument_list|)
expr_stmt|;
block|}
name|CTRACE
argument_list|(
literal|"query_find: done"
argument_list|)
expr_stmt|;
return|return
operator|(
name|eresult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_query
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|extflags
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|char
name|onbuf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_INFO
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|client
operator|->
name|destaddr
argument_list|,
name|onbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|onbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_QUERIES
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|level
argument_list|,
literal|"query: %s %s %s %s%s%s%s%s%s (%s)"
argument_list|,
name|namebuf
argument_list|,
name|classname
argument_list|,
name|typename
argument_list|,
name|WANTRECURSION
argument_list|(
name|client
argument_list|)
condition|?
literal|"+"
else|:
literal|"-"
argument_list|,
operator|(
name|client
operator|->
name|signer
operator|!=
name|NULL
operator|)
condition|?
literal|"S"
else|:
literal|""
argument_list|,
operator|(
name|client
operator|->
name|opt
operator|!=
name|NULL
operator|)
condition|?
literal|"E"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"T"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|extflags
operator|&
name|DNS_MESSAGEEXTFLAG_DO
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"D"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_CD
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"C"
else|:
literal|""
argument_list|,
name|onbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|log_queryerror
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|namep
decl_stmt|,
modifier|*
name|typep
decl_stmt|,
modifier|*
name|classp
decl_stmt|,
modifier|*
name|sep1
decl_stmt|,
modifier|*
name|sep2
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|namep
operator|=
name|typep
operator|=
name|classp
operator|=
name|sep1
operator|=
name|sep2
operator|=
literal|""
expr_stmt|;
comment|/* 	 * Query errors can happen for various reasons.  In some cases we cannot 	 * even assume the query contains a valid question section, so we should 	 * expect exceptional cases. 	 */
if|if
condition|(
name|client
operator|->
name|query
operator|.
name|origqname
operator|!=
name|NULL
condition|)
block|{
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|origqname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|namep
operator|=
name|namebuf
expr_stmt|;
name|sep1
operator|=
literal|" for "
expr_stmt|;
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|origqname
operator|->
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|dns_rdataclass_format
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|classp
operator|=
name|classname
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
name|typep
operator|=
name|typename
expr_stmt|;
name|sep2
operator|=
literal|"/"
expr_stmt|;
block|}
block|}
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_QUERY_EERRORS
argument_list|,
name|NS_LOGMODULE_QUERY
argument_list|,
name|level
argument_list|,
literal|"query failed (%s)%s%s%s%s%s%s at %s:%d"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|,
name|sep1
argument_list|,
name|namep
argument_list|,
name|sep2
argument_list|,
name|classp
argument_list|,
name|sep2
argument_list|,
name|typep
argument_list|,
name|__FILE__
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_query_start
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_message_t
modifier|*
name|message
init|=
name|client
operator|->
name|message
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|ns_client_t
modifier|*
name|qclient
decl_stmt|;
name|dns_rdatatype_t
name|qtype
decl_stmt|;
name|unsigned
name|int
name|saved_extflags
init|=
name|client
operator|->
name|extflags
decl_stmt|;
name|unsigned
name|int
name|saved_flags
init|=
name|client
operator|->
name|message
operator|->
name|flags
decl_stmt|;
name|CTRACE
argument_list|(
literal|"ns_query_start"
argument_list|)
expr_stmt|;
comment|/* 	 * Test only. 	 */
if|if
condition|(
name|ns_g_clienttest
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
name|RUNTIME_CHECK
argument_list|(
name|ns_client_replace
argument_list|(
name|client
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that appropriate cleanups occur. 	 */
name|client
operator|->
name|next
operator|=
name|query_next_callback
expr_stmt|;
comment|/* 	 * Behave as if we don't support DNSSEC if not enabled. 	 */
if|if
condition|(
operator|!
name|client
operator|->
name|view
operator|->
name|enablednssec
condition|)
block|{
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
name|client
operator|->
name|extflags
operator|&=
operator|~
name|DNS_MESSAGEEXTFLAG_DO
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|opt
operator|!=
name|NULL
condition|)
name|client
operator|->
name|opt
operator|->
name|ttl
operator|&=
operator|~
name|DNS_MESSAGEEXTFLAG_DO
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_RD
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
name|NS_QUERYATTR_WANTRECURSION
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|extflags
operator|&
name|DNS_MESSAGEEXTFLAG_DO
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_WANTDNSSEC
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|minimalresponses
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
operator|(
name|NS_QUERYATTR_NOAUTHORITY
operator||
name|NS_QUERYATTR_NOADDITIONAL
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|view
operator|->
name|cachedb
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|client
operator|->
name|view
operator|->
name|additionalfromcache
operator|)
condition|)
block|{
comment|/* 		 * We don't have a cache.  Turn off cache support and 		 * recursion. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
operator|(
name|NS_QUERYATTR_RECURSIONOK
operator||
name|NS_QUERYATTR_CACHEOK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_RA
operator|)
operator|==
literal|0
operator|||
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_RD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the client isn't allowed to recurse (due to 		 * "recursion no", the allow-recursion ACL, or the 		 * lack of a resolver in this view), or if it 		 * doesn't want recursion, turn recursion off. 		 */
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_RECURSIONOK
expr_stmt|;
block|}
comment|/* 	 * Get the question name. 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_message_currentname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|client
operator|->
name|query
operator|.
name|qname
argument_list|)
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|origqname
operator|=
name|client
operator|->
name|query
operator|.
name|qname
expr_stmt|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * There's more than one QNAME in the question 			 * section. 			 */
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ns_g_server
operator|->
name|log_queries
condition|)
name|log_query
argument_list|(
name|client
argument_list|,
name|saved_flags
argument_list|,
name|saved_extflags
argument_list|)
expr_stmt|;
comment|/* 	 * Check for multiple question queries, since edns1 is dead. 	 */
if|if
condition|(
name|message
operator|->
name|counts
index|[
name|DNS_SECTION_QUESTION
index|]
operator|>
literal|1
condition|)
block|{
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for meta-queries like IXFR and AXFR. 	 */
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|qtype
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
name|dns_rdatatypestats_increment
argument_list|(
name|ns_g_server
operator|->
name|rcvquerystats
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdatatype_ismeta
argument_list|(
name|qtype
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|dns_rdatatype_any
case|:
break|break;
comment|/* Let query_find handle it. */
case|case
name|dns_rdatatype_ixfr
case|:
case|case
name|dns_rdatatype_axfr
case|:
name|ns_xfr_start
argument_list|(
name|client
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
case|case
name|dns_rdatatype_maila
case|:
case|case
name|dns_rdatatype_mailb
case|:
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_NOTIMP
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
case|case
name|dns_rdatatype_tkey
case|:
name|result
operator|=
name|dns_tkey_processquery
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|ns_g_server
operator|->
name|tkeyctx
argument_list|,
name|client
operator|->
name|view
operator|->
name|dynamickeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|query_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
else|else
name|query_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* TSIG, etc. */
name|query_error
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Turn on minimal response for DNSKEY and DS queries. 	 */
if|if
condition|(
name|qtype
operator|==
name|dns_rdatatype_dnskey
operator|||
name|qtype
operator|==
name|dns_rdatatype_ds
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
operator|(
name|NS_QUERYATTR_NOAUTHORITY
operator||
name|NS_QUERYATTR_NOADDITIONAL
operator|)
expr_stmt|;
comment|/* 	 * Turn on minimal responses for EDNS/UDP bufsize 512 queries. 	 */
if|if
condition|(
name|client
operator|->
name|opt
operator|!=
name|NULL
operator|&&
name|client
operator|->
name|udpsize
operator|<=
literal|512U
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator||=
operator|(
name|NS_QUERYATTR_NOAUTHORITY
operator||
name|NS_QUERYATTR_NOADDITIONAL
operator|)
expr_stmt|;
comment|/* 	 * If the client has requested that DNSSEC checking be disabled, 	 * allow lookups to return pending data and instruct the resolver 	 * to return data before validation has completed. 	 * 	 * We don't need to set DNS_DBFIND_PENDINGOK when validation is 	 * disabled as there will be no pending data. 	 */
if|if
condition|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_CD
operator|||
name|qtype
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
name|client
operator|->
name|query
operator|.
name|dboptions
operator||=
name|DNS_DBFIND_PENDINGOK
expr_stmt|;
name|client
operator|->
name|query
operator|.
name|fetchoptions
operator||=
name|DNS_FETCHOPT_NOVALIDATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|client
operator|->
name|view
operator|->
name|enablevalidation
condition|)
name|client
operator|->
name|query
operator|.
name|fetchoptions
operator||=
name|DNS_FETCHOPT_NOVALIDATE
expr_stmt|;
comment|/* 	 * Allow glue NS records to be added to the authority section 	 * if the answer is secure. 	 */
if|if
condition|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_CD
condition|)
name|client
operator|->
name|query
operator|.
name|attributes
operator|&=
operator|~
name|NS_QUERYATTR_SECURE
expr_stmt|;
comment|/* 	 * Set NS_CLIENTATTR_WANTDNSSEC if the client has set AD in the query. 	 * This allows AD to be returned on queries without DO set. 	 */
if|if
condition|(
operator|(
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_AD
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_WANTAD
expr_stmt|;
comment|/* 	 * This is an ordinary query. 	 */
name|result
operator|=
name|dns_message_reply
argument_list|(
name|message
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|query_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Assume authoritative response until it is known to be 	 * otherwise. 	 * 	 * If "-T noaa" has been set on the command line don't set 	 * AA on authoritative answers. 	 */
if|if
condition|(
operator|!
name|ns_g_noaa
condition|)
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
comment|/* 	 * Set AD.  We must clear it if we add non-validated data to a 	 * response. 	 */
if|if
condition|(
name|WANTDNSSEC
argument_list|(
name|client
argument_list|)
operator|||
name|WANTAD
argument_list|(
name|client
argument_list|)
condition|)
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AD
expr_stmt|;
name|qclient
operator|=
name|NULL
expr_stmt|;
name|ns_client_attach
argument_list|(
name|client
argument_list|,
operator|&
name|qclient
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|query_find
argument_list|(
name|qclient
argument_list|,
name|NULL
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

