begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2002  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: os.c,v 1.46.2.4.8.19 2004/10/07 02:34:20 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* dev_t FreeBSD 2.1 */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_comment
comment|/* Required for initgroups() on IRIX. */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TZSET
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<named/main.h>
end_include

begin_include
include|#
directive|include
file|<named/os.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pidfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devnullfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_FACILITY
end_ifndef

begin_define
define|#
directive|define
name|ISC_FACILITY
value|LOG_DAEMON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If there's no<linux/capability.h>, we don't care about<sys/prctl.h>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_LINUX_CAPABILITY_H
end_ifndef

begin_undef
undef|#
directive|undef
name|HAVE_SYS_PRCTL_H
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Linux defines:  *	(T) HAVE_LINUXTHREADS  *	(C) HAVE_LINUX_CAPABILITY_H  *	(P) HAVE_SYS_PRCTL_H  * The possible cases are:  *	none:	setuid() normally  *	T:	no setuid()  *	C:	setuid() normally, drop caps (keep CAP_SETUID)  *	T+C:	no setuid(), drop caps (don't keep CAP_SETUID)  *	T+C+P:	setuid() early, drop caps (keep CAP_SETUID)  *	C+P:	setuid() normally, drop caps (keep CAP_SETUID)  *	P:	not possible  *	T+P:	not possible  *  * if (C)  *	caps = BIND_SERVICE + CHROOT + SETGID  *	if ((T&& C&& P) || !T)  *		caps += SETUID  *	endif  *	capset(caps)  * endif  * if (T&& C&& P&& -u)  *	setuid()  * else if (T&& -u)  *	fail  * --> start threads  * if (!T&& -u)  *	setuid()  * if (C&& (P || !-u))  *	caps = BIND_SERVICE  *	capset(caps)  * endif  *  * It will be nice when Linux threads work properly with setuid().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
end_ifdef

begin_decl_stmt
specifier|static
name|pid_t
name|mainpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|runas_pw
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|done_setuid
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dfd
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_CAPABILITY_H
end_ifdef

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|non_root
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|non_root_caps
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We define _LINUX_FS_H to prevent it from being included.  We don't need  * anything from it, and the files it includes cause warnings with 2.2  * kernels, and compilation failures (due to conflicts between<linux/string.h>  * and<string.h>) on 2.3 kernels.  */
end_comment

begin_define
define|#
directive|define
name|_LINUX_FS_H
end_define

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_comment
comment|/* Required for syscall(). */
end_comment

begin_include
include|#
directive|include
file|<linux/capability.h>
end_include

begin_comment
comment|/* Required for _LINUX_CAPABILITY_VERSION. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PRCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/prctl.h>
end_include

begin_comment
comment|/* Required for prctl(). */
end_comment

begin_comment
comment|/*  * If the value of PR_SET_KEEPCAPS is not in<sys/prctl.h>, define it  * here.  This allows setuid() to work on systems running a new enough  * kernel but with /usr/include/linux pointing to "standard" kernel  * headers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PR_SET_KEEPCAPS
end_ifndef

begin_define
define|#
directive|define
name|PR_SET_KEEPCAPS
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_PRCTL_H */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_capset
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__NR_capset
end_ifndef

begin_include
include|#
directive|include
file|<asm/unistd.h>
end_include

begin_comment
comment|/* Slackware 4.0 needs this. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYS_capset
value|__NR_capset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|linux_setcaps
parameter_list|(
name|unsigned
name|int
name|caps
parameter_list|)
block|{
name|struct
name|__user_cap_header_struct
name|caphead
decl_stmt|;
name|struct
name|__user_cap_data_struct
name|cap
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|getuid
argument_list|()
operator|!=
literal|0
operator|&&
operator|!
name|non_root_caps
operator|)
operator|||
name|non_root
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|caphead
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|caphead
argument_list|)
argument_list|)
expr_stmt|;
name|caphead
operator|.
name|version
operator|=
name|_LINUX_CAPABILITY_VERSION
expr_stmt|;
name|caphead
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cap
argument_list|)
argument_list|)
expr_stmt|;
name|cap
operator|.
name|effective
operator|=
name|caps
expr_stmt|;
name|cap
operator|.
name|permitted
operator|=
name|caps
expr_stmt|;
name|cap
operator|.
name|inheritable
operator|=
name|caps
expr_stmt|;
if|if
condition|(
name|syscall
argument_list|(
name|SYS_capset
argument_list|,
operator|&
name|caphead
argument_list|,
operator|&
name|cap
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"capset failed: %s:"
literal|" please ensure that the capset kernel"
literal|" module is loaded.  see insmod(8)"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|linux_initialprivs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|caps
decl_stmt|;
comment|/* 	 * We don't need most privileges, so we drop them right away. 	 * Later on linux_minprivs() will be called, which will drop our 	 * capabilities to the minimum needed to run the server. 	 */
name|caps
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We need to be able to bind() to privileged ports, notably port 53! 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_NET_BIND_SERVICE
operator|)
expr_stmt|;
comment|/* 	 * We need chroot() initially too. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_SYS_CHROOT
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_PRCTL_H
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_LINUXTHREADS
argument_list|)
comment|/* 	 * We can setuid() only if either the kernel supports keeping 	 * capabilities after setuid() (which we don't know until we've 	 * tried) or we're not using threads.  If either of these is 	 * true, we want the setuid capability. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_SETUID
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Since we call initgroups, we need this. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_SETGID
operator|)
expr_stmt|;
comment|/* 	 * Without this, we run into problems reading a configuration file 	 * owned by a non-root user and non-world-readable on startup. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_DAC_READ_SEARCH
operator|)
expr_stmt|;
comment|/* 	 * XXX  We might want to add CAP_SYS_RESOURCE, though it's not 	 *      clear it would work right given the way linuxthreads work. 	 * XXXDCL But since we need to be able to set the maximum number 	 * of files, the stack size, data size, and core dump size to 	 * support named.conf options, this is now being added to test. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_SYS_RESOURCE
operator|)
expr_stmt|;
name|linux_setcaps
argument_list|(
name|caps
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_minprivs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|caps
decl_stmt|;
comment|/* 	 * Drop all privileges except the ability to bind() to privileged 	 * ports. 	 * 	 * It's important that we drop CAP_SYS_CHROOT.  If we didn't, it 	 * chroot() could be used to escape from the chrooted area. 	 */
name|caps
operator|=
literal|0
expr_stmt|;
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_NET_BIND_SERVICE
operator|)
expr_stmt|;
comment|/* 	 * XXX  We might want to add CAP_SYS_RESOURCE, though it's not 	 *      clear it would work right given the way linuxthreads work. 	 * XXXDCL But since we need to be able to set the maximum number 	 * of files, the stack size, data size, and core dump size to 	 * support named.conf options, this is now being added to test. 	 */
name|caps
operator||=
operator|(
literal|1
operator|<<
name|CAP_SYS_RESOURCE
operator|)
expr_stmt|;
name|linux_setcaps
argument_list|(
name|caps
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_PRCTL_H
end_ifdef

begin_function
specifier|static
name|void
name|linux_keepcaps
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
comment|/* 	 * Ask the kernel to allow us to keep our capabilities after we 	 * setuid(). 	 */
if|if
condition|(
name|prctl
argument_list|(
name|PR_SET_KEEPCAPS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINVAL
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"prctl() failed: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|non_root_caps
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
name|non_root
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINUX_CAPABILITY_H */
end_comment

begin_function
specifier|static
name|void
name|setup_syslog
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|int
name|options
decl_stmt|;
name|options
operator|=
name|LOG_PID
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_NDELAY
name|options
operator||=
name|LOG_NDELAY
expr_stmt|;
endif|#
directive|endif
name|openlog
argument_list|(
name|isc_file_basename
argument_list|(
name|progname
argument_list|)
argument_list|,
name|options
argument_list|,
name|ISC_FACILITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_os_init
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|)
block|{
name|setup_syslog
argument_list|(
name|progname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LINUX_CAPABILITY_H
name|linux_initialprivs
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
name|mainpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ns_os_daemonize
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|dfd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"pipe(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"fork(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* 		 * Wait for the child to finish loading for the first time. 		 * This would be so much simpler if fork() worked once we 	         * were multi-threaded. 		 */
operator|(
name|void
operator|)
name|close
argument_list|(
name|dfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
do|do
block|{
name|char
name|buf
decl_stmt|;
name|n
operator|=
name|read
argument_list|(
name|dfd
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|dfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * We're the child. 	 */
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
name|mainpid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"setsid(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try to set stdin, stdout, and stderr to /dev/null, but press 	 * on even if it fails. 	 * 	 * XXXMLG The close() calls here are unneeded on all but NetBSD, but 	 * are harmless to include everywhere.  dup2() is supposed to close 	 * the FD if it is in use, but unproven-pthreads-0.16 is broken 	 * and will end up closing the wrong FD.  This will be fixed eventually, 	 * and these calls will be removed. 	 */
if|if
condition|(
name|devnullfd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|devnullfd
operator|!=
name|STDIN_FILENO
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|devnullfd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devnullfd
operator|!=
name|STDOUT_FILENO
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|devnullfd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devnullfd
operator|!=
name|STDERR_FILENO
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|STDERR_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|devnullfd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_os_started
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
init|=
literal|0
decl_stmt|;
comment|/* 	 * Signal to the parent that we stated successfully. 	 */
if|if
condition|(
name|dfd
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|dfd
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|write
argument_list|(
name|dfd
index|[
literal|1
index|]
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dfd
index|[
literal|0
index|]
operator|=
name|dfd
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ns_os_opendevnull
parameter_list|(
name|void
parameter_list|)
block|{
name|devnullfd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_os_closedevnull
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|devnullfd
operator|!=
name|STDIN_FILENO
operator|&&
name|devnullfd
operator|!=
name|STDOUT_FILENO
operator|&&
name|devnullfd
operator|!=
name|STDERR_FILENO
condition|)
block|{
name|close
argument_list|(
name|devnullfd
argument_list|)
expr_stmt|;
name|devnullfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|all_digits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
operator|*
name|s
operator|)
operator|&
literal|0xff
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_os_chroot
parameter_list|(
specifier|const
name|char
modifier|*
name|root
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chroot
argument_list|(
name|root
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"chroot(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"chdir(/): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_os_inituserinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|username
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|username
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|all_digits
argument_list|(
name|username
argument_list|)
condition|)
name|runas_pw
operator|=
name|getpwuid
argument_list|(
operator|(
name|uid_t
operator|)
name|atoi
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|runas_pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|runas_pw
operator|==
name|NULL
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"user '%s' unknown"
argument_list|,
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|initgroups
argument_list|(
name|runas_pw
operator|->
name|pw_name
argument_list|,
name|runas_pw
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"initgroups(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_os_changeuser
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|runas_pw
operator|==
name|NULL
operator|||
name|done_setuid
condition|)
return|return;
name|done_setuid
operator|=
name|ISC_TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
ifdef|#
directive|ifdef
name|HAVE_LINUX_CAPABILITY_H
if|if
condition|(
operator|!
name|non_root_caps
condition|)
name|ns_main_earlyfatal
argument_list|(
literal|"-u with Linux threads not supported: "
literal|"requires kernel support for "
literal|"prctl(PR_SET_KEEPCAPS)"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ns_main_earlyfatal
argument_list|(
literal|"-u with Linux threads not supported: "
literal|"no capabilities support or capabilities "
literal|"disabled at build time"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|setgid
argument_list|(
name|runas_pw
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"setgid(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|runas_pw
operator|->
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_main_earlyfatal
argument_list|(
literal|"setuid(): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_CAPABILITY_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_LINUXTHREADS
argument_list|)
name|linux_minprivs
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ns_os_minprivs
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYS_PRCTL_H
name|linux_keepcaps
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
name|ns_os_changeuser
argument_list|()
expr_stmt|;
comment|/* Call setuid() before threads are started */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LINUX_CAPABILITY_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LINUXTHREADS
argument_list|)
name|linux_minprivs
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|safe_open
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|isc_boolean_t
name|append
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|append
condition|)
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_APPEND
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_pidfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pidfile
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
name|pidfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_os_writepidfile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|isc_boolean_t
name|first_time
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|lockfile
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|report
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* 	 * The caller must ensure any required synchronization. 	 */
name|report
operator|=
name|first_time
condition|?
name|ns_main_earlyfatal
else|:
name|ns_main_earlywarning
expr_stmt|;
name|cleanup_pidfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|pidfile
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidfile
operator|==
name|NULL
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|report
call|)
argument_list|(
literal|"couldn't malloc '%s': %s"
argument_list|,
name|filename
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is safe. */
name|strcpy
argument_list|(
name|pidfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|safe_open
argument_list|(
name|filename
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|report
call|)
argument_list|(
literal|"couldn't open pid file '%s': %s"
argument_list|,
name|filename
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|pidfile
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|lockfile
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfile
operator|==
name|NULL
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|report
call|)
argument_list|(
literal|"could not fdopen() pid file '%s': %s"
argument_list|,
name|filename
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|cleanup_pidfile
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
name|pid
operator|=
name|mainpid
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fprintf
argument_list|(
name|lockfile
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|report
call|)
argument_list|(
literal|"fprintf() to pid file '%s' failed"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
name|cleanup_pidfile
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|lockfile
argument_list|)
operator|==
name|EOF
condition|)
block|{
call|(
modifier|*
name|report
call|)
argument_list|(
literal|"fflush() to pid file '%s' failed"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
name|cleanup_pidfile
argument_list|()
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_os_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|closelog
argument_list|()
expr_stmt|;
name|cleanup_pidfile
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_os_gethostname
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|gethostname
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
name|ISC_R_SUCCESS
else|:
name|ISC_R_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|next_token
parameter_list|(
name|char
modifier|*
modifier|*
name|stringp
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|res
decl_stmt|;
do|do
block|{
name|res
operator|=
name|strsep
argument_list|(
name|stringp
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|res
operator|==
literal|'\0'
condition|)
do|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_os_shutdownmsg
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|isc_buffer_t
modifier|*
name|text
parameter_list|)
block|{
name|char
modifier|*
name|input
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|input
operator|=
name|command
expr_stmt|;
comment|/* Skip the command name. */
name|ptr
operator|=
name|next_token
argument_list|(
operator|&
name|input
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
name|ptr
operator|=
name|next_token
argument_list|(
operator|&
name|input
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
argument_list|,
literal|"-p"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|HAVE_LINUXTHREADS
name|pid
operator|=
name|mainpid
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|isc_buffer_used
argument_list|(
name|text
argument_list|)
argument_list|,
name|isc_buffer_availablelength
argument_list|(
name|text
argument_list|)
argument_list|,
literal|"pid: %ld"
argument_list|,
operator|(
name|long
operator|)
name|pid
argument_list|)
expr_stmt|;
comment|/* Only send a message if it is complete. */
if|if
condition|(
name|n
operator|<
name|isc_buffer_availablelength
argument_list|(
name|text
argument_list|)
condition|)
name|isc_buffer_add
argument_list|(
name|text
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_os_tzset
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_TZSET
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

