begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2014  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/dlz_dlopen.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<named/globals.h>
end_include

begin_include
include|#
directive|include
file|<dlz/dlz_dlopen_driver.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_DLZ_DLOPEN
end_ifdef

begin_decl_stmt
specifier|static
name|dns_sdlzimplementation_t
modifier|*
name|dlz_dlopen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|dlopen_data
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|char
modifier|*
name|dl_path
decl_stmt|;
name|char
modifier|*
name|dlzname
decl_stmt|;
name|void
modifier|*
name|dl_handle
decl_stmt|;
name|void
modifier|*
name|dbdata
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|int
name|version
decl_stmt|;
name|isc_boolean_t
name|in_configure
decl_stmt|;
name|dlz_dlopen_version_t
modifier|*
name|dlz_version
decl_stmt|;
name|dlz_dlopen_create_t
modifier|*
name|dlz_create
decl_stmt|;
name|dlz_dlopen_findzonedb_t
modifier|*
name|dlz_findzonedb
decl_stmt|;
name|dlz_dlopen_lookup_t
modifier|*
name|dlz_lookup
decl_stmt|;
name|dlz_dlopen_authority_t
modifier|*
name|dlz_authority
decl_stmt|;
name|dlz_dlopen_allnodes_t
modifier|*
name|dlz_allnodes
decl_stmt|;
name|dlz_dlopen_allowzonexfr_t
modifier|*
name|dlz_allowzonexfr
decl_stmt|;
name|dlz_dlopen_newversion_t
modifier|*
name|dlz_newversion
decl_stmt|;
name|dlz_dlopen_closeversion_t
modifier|*
name|dlz_closeversion
decl_stmt|;
name|dlz_dlopen_configure_t
modifier|*
name|dlz_configure
decl_stmt|;
name|dlz_dlopen_ssumatch_t
modifier|*
name|dlz_ssumatch
decl_stmt|;
name|dlz_dlopen_addrdataset_t
modifier|*
name|dlz_addrdataset
decl_stmt|;
name|dlz_dlopen_subrdataset_t
modifier|*
name|dlz_subrdataset
decl_stmt|;
name|dlz_dlopen_delrdataset_t
modifier|*
name|dlz_delrdataset
decl_stmt|;
name|dlz_dlopen_destroy_t
modifier|*
name|dlz_destroy
decl_stmt|;
block|}
name|dlopen_data_t
typedef|;
end_typedef

begin_comment
comment|/* Modules can choose whether they are lock-safe or not. */
end_comment

begin_define
define|#
directive|define
name|MAYBE_LOCK
parameter_list|(
name|cd
parameter_list|)
define|\
value|do { \ 		if ((cd->flags& DNS_SDLZFLAG_THREADSAFE) == 0&& \ 		    cd->in_configure == ISC_FALSE) \ 			LOCK(&cd->lock); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MAYBE_UNLOCK
parameter_list|(
name|cd
parameter_list|)
define|\
value|do { \ 		if ((cd->flags& DNS_SDLZFLAG_THREADSAFE) == 0&& \ 		    cd->in_configure == ISC_FALSE) \ 			UNLOCK(&cd->lock); \ 	} while (0)
end_define

begin_comment
comment|/*  * Log a message at the given level.  */
end_comment

begin_function
specifier|static
name|void
name|dlopen_log
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|isc_log_vwrite
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_DLZ
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
name|level
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SDLZ methods  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_allnodes
parameter_list|(
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|dns_sdlzallnodes_t
modifier|*
name|allnodes
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_allnodes
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
block|}
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_allnodes
argument_list|(
name|zone
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|allnodes
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_allowzonexfr
parameter_list|(
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|client
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_allowzonexfr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
block|}
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_allowzonexfr
argument_list|(
name|cd
operator|->
name|dbdata
argument_list|,
name|name
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_authority
parameter_list|(
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|dns_sdlzlookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_authority
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_authority
argument_list|(
name|zone
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_findzonedb
parameter_list|(
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_findzonedb
argument_list|(
name|cd
operator|->
name|dbdata
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|dns_sdlzlookup_t
modifier|*
name|lookup
parameter_list|,
name|dns_clientinfomethods_t
modifier|*
name|methods
parameter_list|,
name|dns_clientinfo_t
modifier|*
name|clientinfo
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_lookup
argument_list|(
name|zone
argument_list|,
name|name
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|lookup
argument_list|,
name|methods
argument_list|,
name|clientinfo
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load a symbol from the library  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dl_load_symbol
parameter_list|(
name|dlopen_data_t
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|symbol
parameter_list|,
name|isc_boolean_t
name|mandatory
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dlsym
argument_list|(
name|cd
operator|->
name|dl_handle
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|&&
name|mandatory
condition|)
block|{
name|dlopen_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"dlz_dlopen: library '%s' is missing "
literal|"required symbol '%s'"
argument_list|,
name|cd
operator|->
name|dl_path
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called at startup for each dlopen zone in named.conf  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_create
parameter_list|(
specifier|const
name|char
modifier|*
name|dlzname
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
modifier|*
name|dbdata
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|int
name|dlopen_flags
init|=
literal|0
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|dlopen_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"dlz_dlopen driver for '%s' needs a path to "
literal|"the shared library"
argument_list|,
name|dlzname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|result
operator|=
name|isc_mem_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|cd
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|==
name|NULL
condition|)
block|{
name|isc_mem_destroy
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|cd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|cd
operator|->
name|dl_path
operator|=
name|isc_mem_strdup
argument_list|(
name|cd
operator|->
name|mctx
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dl_path
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|cd
operator|->
name|dlzname
operator|=
name|isc_mem_strdup
argument_list|(
name|cd
operator|->
name|mctx
argument_list|,
name|dlzname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlzname
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Initialize the lock */
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|cd
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failed
goto|;
comment|/* Open the library */
name|dlopen_flags
operator|=
name|RTLD_NOW
operator||
name|RTLD_GLOBAL
expr_stmt|;
ifdef|#
directive|ifdef
name|RTLD_DEEPBIND
comment|/* 	 * If RTLD_DEEPBIND is available then use it. This can avoid 	 * issues with a module using a different version of a system 	 * library than one that bind9 uses. For example, bind9 may link 	 * to MIT kerberos, but the module may use Heimdal. If we don't 	 * use RTLD_DEEPBIND then we could end up with Heimdal functions 	 * calling MIT functions, which leads to bizarre results (usually 	 * a segfault). 	 */
name|dlopen_flags
operator||=
name|RTLD_DEEPBIND
expr_stmt|;
endif|#
directive|endif
name|cd
operator|->
name|dl_handle
operator|=
name|dlopen
argument_list|(
name|cd
operator|->
name|dl_path
argument_list|,
name|dlopen_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dl_handle
operator|==
name|NULL
condition|)
block|{
name|dlopen_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"dlz_dlopen failed to open library '%s' - %s"
argument_list|,
name|cd
operator|->
name|dl_path
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Find the symbols */
name|cd
operator|->
name|dlz_version
operator|=
operator|(
name|dlz_dlopen_version_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_version"
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_create
operator|=
operator|(
name|dlz_dlopen_create_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_create"
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_lookup
operator|=
operator|(
name|dlz_dlopen_lookup_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_lookup"
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_findzonedb
operator|=
operator|(
name|dlz_dlopen_findzonedb_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_findzonedb"
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_create
operator|==
name|NULL
operator|||
name|cd
operator|->
name|dlz_lookup
operator|==
name|NULL
operator|||
name|cd
operator|->
name|dlz_findzonedb
operator|==
name|NULL
condition|)
block|{
comment|/* We're missing a required symbol */
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|cd
operator|->
name|dlz_allowzonexfr
operator|=
operator|(
name|dlz_dlopen_allowzonexfr_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_allowzonexfr"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_allnodes
operator|=
operator|(
name|dlz_dlopen_allnodes_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_allnodes"
argument_list|,
name|ISC_TF
argument_list|(
name|cd
operator|->
name|dlz_allowzonexfr
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_authority
operator|=
operator|(
name|dlz_dlopen_authority_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_authority"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_newversion
operator|=
operator|(
name|dlz_dlopen_newversion_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_newversion"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_closeversion
operator|=
operator|(
name|dlz_dlopen_closeversion_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_closeversion"
argument_list|,
name|ISC_TF
argument_list|(
name|cd
operator|->
name|dlz_newversion
operator|!=
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_configure
operator|=
operator|(
name|dlz_dlopen_configure_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_configure"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_ssumatch
operator|=
operator|(
name|dlz_dlopen_ssumatch_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_ssumatch"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_addrdataset
operator|=
operator|(
name|dlz_dlopen_addrdataset_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_addrdataset"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_subrdataset
operator|=
operator|(
name|dlz_dlopen_subrdataset_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_subrdataset"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_delrdataset
operator|=
operator|(
name|dlz_dlopen_delrdataset_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_delrdataset"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_destroy
operator|=
operator|(
name|dlz_dlopen_destroy_t
operator|*
operator|)
name|dl_load_symbol
argument_list|(
name|cd
argument_list|,
literal|"dlz_destroy"
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* Check the version of the API is the same */
name|cd
operator|->
name|version
operator|=
name|cd
operator|->
name|dlz_version
argument_list|(
operator|&
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|version
operator|!=
name|DLZ_DLOPEN_VERSION
condition|)
block|{
name|dlopen_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"dlz_dlopen: incorrect version %d "
literal|"should be %d in '%s'"
argument_list|,
name|cd
operator|->
name|version
argument_list|,
name|DLZ_DLOPEN_VERSION
argument_list|,
name|cd
operator|->
name|dl_path
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Call the library's create function. Note that this is an 	 * extended version of dlz create, with the addition of 	 * named function pointers for helper functions that the 	 * driver will need. This avoids the need for the backend to 	 * link the BIND9 libraries 	 */
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_create
argument_list|(
name|dlzname
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
operator|&
name|cd
operator|->
name|dbdata
argument_list|,
literal|"log"
argument_list|,
name|dlopen_log
argument_list|,
literal|"putrr"
argument_list|,
name|dns_sdlz_putrr
argument_list|,
literal|"putnamedrr"
argument_list|,
name|dns_sdlz_putnamedrr
argument_list|,
literal|"writeable_zone"
argument_list|,
name|dns_dlz_writeablezone
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failed
goto|;
operator|*
name|dbdata
operator|=
name|cd
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failed
label|:
name|dlopen_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"dlz_dlopen of '%s' failed"
argument_list|,
name|dlzname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dl_path
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|cd
operator|->
name|dl_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlzname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|cd
operator|->
name|dlzname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlopen_flags
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|isc_mutex_destroy
argument_list|(
operator|&
name|cd
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DLCLOSE
if|if
condition|(
name|cd
operator|->
name|dl_handle
condition|)
name|dlclose
argument_list|(
name|cd
operator|->
name|dl_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_destroy
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when bind is shutting down  */
end_comment

begin_function
specifier|static
name|void
name|dlopen_dlz_destroy
parameter_list|(
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_destroy
condition|)
block|{
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_destroy
argument_list|(
name|cd
operator|->
name|dbdata
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cd
operator|->
name|dl_path
condition|)
name|isc_mem_free
argument_list|(
name|cd
operator|->
name|mctx
argument_list|,
name|cd
operator|->
name|dl_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlzname
condition|)
name|isc_mem_free
argument_list|(
name|cd
operator|->
name|mctx
argument_list|,
name|cd
operator|->
name|dlzname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DLCLOSE
if|if
condition|(
name|cd
operator|->
name|dl_handle
condition|)
name|dlclose
argument_list|(
name|cd
operator|->
name|dl_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|isc_mutex_destroy
argument_list|(
operator|&
name|cd
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|cd
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cd
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_destroy
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to start a transaction  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_newversion
parameter_list|(
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|void
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_newversion
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_newversion
argument_list|(
name|zone
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to end a transaction  */
end_comment

begin_function
specifier|static
name|void
name|dlopen_dlz_closeversion
parameter_list|(
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
name|isc_boolean_t
name|commit
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|void
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_newversion
operator|==
name|NULL
condition|)
block|{
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlz_closeversion
argument_list|(
name|zone
argument_list|,
name|commit
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called on startup to configure any writeable zones  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_configure
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_configure
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|in_configure
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_configure
argument_list|(
name|view
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|)
expr_stmt|;
name|cd
operator|->
name|in_configure
operator|=
name|ISC_FALSE
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for authority to change a name  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|dlopen_dlz_ssumatch
parameter_list|(
specifier|const
name|char
modifier|*
name|signer
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|tcpaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|isc_uint32_t
name|keydatalen
parameter_list|,
name|unsigned
name|char
modifier|*
name|keydata
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_boolean_t
name|ret
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_ssumatch
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cd
operator|->
name|dlz_ssumatch
argument_list|(
name|signer
argument_list|,
name|name
argument_list|,
name|tcpaddr
argument_list|,
name|type
argument_list|,
name|key
argument_list|,
name|keydatalen
argument_list|,
name|keydata
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an rdataset  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_addrdataset
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|rdatastr
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|void
modifier|*
name|version
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_addrdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_addrdataset
argument_list|(
name|name
argument_list|,
name|rdatastr
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Subtract an rdataset  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_subrdataset
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|rdatastr
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|void
modifier|*
name|version
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_subrdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_subrdataset
argument_list|(
name|name
argument_list|,
name|rdatastr
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   delete a rdataset  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dlopen_dlz_delrdataset
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|void
modifier|*
name|dbdata
parameter_list|,
name|void
modifier|*
name|version
parameter_list|)
block|{
name|dlopen_data_t
modifier|*
name|cd
init|=
operator|(
name|dlopen_data_t
operator|*
operator|)
name|dbdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|dlz_delrdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|MAYBE_LOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|result
operator|=
name|cd
operator|->
name|dlz_delrdataset
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|cd
operator|->
name|dbdata
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|MAYBE_UNLOCK
argument_list|(
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_sdlzmethods_t
name|dlz_dlopen_methods
init|=
block|{
name|dlopen_dlz_create
block|,
name|dlopen_dlz_destroy
block|,
name|dlopen_dlz_findzonedb
block|,
name|dlopen_dlz_lookup
block|,
name|dlopen_dlz_authority
block|,
name|dlopen_dlz_allnodes
block|,
name|dlopen_dlz_allowzonexfr
block|,
name|dlopen_dlz_newversion
block|,
name|dlopen_dlz_closeversion
block|,
name|dlopen_dlz_configure
block|,
name|dlopen_dlz_ssumatch
block|,
name|dlopen_dlz_addrdataset
block|,
name|dlopen_dlz_subrdataset
block|,
name|dlopen_dlz_delrdataset
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Register driver with BIND  */
end_comment

begin_function
name|isc_result_t
name|dlz_dlopen_init
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ISC_DLZ_DLOPEN
name|UNUSED
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
else|#
directive|else
name|isc_result_t
name|result
decl_stmt|;
name|dlopen_log
argument_list|(
literal|2
argument_list|,
literal|"Registering DLZ_dlopen driver"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_sdlzregister
argument_list|(
literal|"dlopen"
argument_list|,
operator|&
name|dlz_dlopen_methods
argument_list|,
name|NULL
argument_list|,
name|DNS_SDLZFLAG_RELATIVEOWNER
operator||
name|DNS_SDLZFLAG_THREADSAFE
argument_list|,
name|mctx
argument_list|,
operator|&
name|dlz_dlopen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"dns_sdlzregister() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Unregister the driver  */
end_comment

begin_function
name|void
name|dlz_dlopen_clear
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_DLZ_DLOPEN
name|dlopen_log
argument_list|(
literal|2
argument_list|,
literal|"Unregistering DLZ_dlopen driver"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlz_dlopen
operator|!=
name|NULL
condition|)
name|dns_sdlzunregister
argument_list|(
operator|&
name|dlz_dlopen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

