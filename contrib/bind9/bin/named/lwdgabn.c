begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000, 2001  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: lwdgabn.c,v 1.13.12.5 2006/03/02 00:37:20 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_comment
comment|/* Required for HP/UX (and others?) */
end_comment

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/adb.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<named/types.h>
end_include

begin_include
include|#
directive|include
file|<named/lwaddr.h>
end_include

begin_include
include|#
directive|include
file|<named/lwdclient.h>
end_include

begin_include
include|#
directive|include
file|<named/lwresd.h>
end_include

begin_include
include|#
directive|include
file|<named/lwsearch.h>
end_include

begin_include
include|#
directive|include
file|<named/sortlist.h>
end_include

begin_define
define|#
directive|define
name|NEED_V4
parameter_list|(
name|c
parameter_list|)
value|((((c)->find_wanted& LWRES_ADDRTYPE_V4) != 0) \&& ((c)->v4find == NULL))
end_define

begin_define
define|#
directive|define
name|NEED_V6
parameter_list|(
name|c
parameter_list|)
value|((((c)->find_wanted& LWRES_ADDRTYPE_V6) != 0) \&& ((c)->v6find == NULL))
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|start_find
parameter_list|(
name|ns_lwdclient_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restart_find
parameter_list|(
name|ns_lwdclient_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_gabn
parameter_list|(
name|ns_lwdclient_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Destroy any finds.  This can be used to "start over from scratch" and  * should only be called when events are _not_ being generated by the finds.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_gabn
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"cleaning up client %p"
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|v6find
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|v6find
operator|==
name|client
operator|->
name|v4find
condition|)
name|client
operator|->
name|v6find
operator|=
name|NULL
expr_stmt|;
else|else
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|v6find
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|v4find
operator|!=
name|NULL
condition|)
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|v4find
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_addresses
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|,
name|dns_adbfind_t
modifier|*
name|find
parameter_list|,
name|unsigned
name|int
name|at
parameter_list|)
block|{
name|dns_adbaddrinfo_t
modifier|*
name|ai
decl_stmt|;
name|lwres_addr_t
modifier|*
name|addr
decl_stmt|;
name|int
name|af
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|at
operator|==
name|DNS_ADBFIND_INET
condition|)
name|af
operator|=
name|AF_INET
expr_stmt|;
else|else
name|af
operator|=
name|AF_INET6
expr_stmt|;
name|ai
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|find
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ai
operator|!=
name|NULL
operator|&&
name|client
operator|->
name|gabn
operator|.
name|naddrs
operator|<
name|LWRES_MAX_ADDRS
condition|)
block|{
name|sa
operator|=
operator|&
name|ai
operator|->
name|sockaddr
operator|.
name|type
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|af
condition|)
goto|goto
name|next
goto|;
name|addr
operator|=
operator|&
name|client
operator|->
name|addrs
index|[
name|client
operator|->
name|gabn
operator|.
name|naddrs
index|]
expr_stmt|;
name|result
operator|=
name|lwaddr_lwresaddr_fromsockaddr
argument_list|(
name|addr
argument_list|,
operator|&
name|ai
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|next
goto|;
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"adding address %p, family %d, length %d"
argument_list|,
name|addr
operator|->
name|address
argument_list|,
name|addr
operator|->
name|family
argument_list|,
name|addr
operator|->
name|length
argument_list|)
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|naddrs
operator|++
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|LWRES_LINK_LINKED
argument_list|(
name|addr
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|LWRES_LIST_APPEND
argument_list|(
name|client
operator|->
name|gabn
operator|.
name|addrs
argument_list|,
name|addr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|next
label|:
name|ai
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ai
argument_list|,
name|publink
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_netaddr_t
name|address
decl_stmt|;
name|int
name|rank
decl_stmt|;
block|}
name|rankedaddress
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|addr_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|av
parameter_list|,
specifier|const
name|void
modifier|*
name|bv
parameter_list|)
block|{
specifier|const
name|rankedaddress
modifier|*
name|a
init|=
operator|(
specifier|const
name|rankedaddress
operator|*
operator|)
name|av
decl_stmt|;
specifier|const
name|rankedaddress
modifier|*
name|b
init|=
operator|(
specifier|const
name|rankedaddress
operator|*
operator|)
name|bv
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|rank
operator|-
name|b
operator|->
name|rank
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_addresses
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|unsigned
name|int
name|naddrs
decl_stmt|;
name|rankedaddress
modifier|*
name|addrs
decl_stmt|;
name|isc_netaddr_t
name|remote
decl_stmt|;
name|dns_addressorderfunc_t
name|order
decl_stmt|;
specifier|const
name|void
modifier|*
name|arg
decl_stmt|;
name|ns_lwresd_t
modifier|*
name|lwresd
init|=
name|client
operator|->
name|clientmgr
operator|->
name|listener
operator|->
name|manager
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|naddrs
operator|=
name|client
operator|->
name|gabn
operator|.
name|naddrs
expr_stmt|;
if|if
condition|(
name|naddrs
operator|<=
literal|1
operator|||
name|lwresd
operator|->
name|view
operator|->
name|sortlist
operator|==
name|NULL
condition|)
return|return;
name|addrs
operator|=
name|isc_mem_get
argument_list|(
name|lwresd
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|rankedaddress
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
operator|==
name|NULL
condition|)
return|return;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|remote
argument_list|,
operator|&
name|client
operator|->
name|address
argument_list|)
expr_stmt|;
name|ns_sortlist_byaddrsetup
argument_list|(
name|lwresd
operator|->
name|view
operator|->
name|sortlist
argument_list|,
operator|&
name|remote
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|lwresd
operator|->
name|mctx
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|rankedaddress
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|lwaddr_netaddr_fromlwresaddr
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|address
argument_list|,
operator|&
name|client
operator|->
name|addrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|addrs
index|[
name|i
index|]
operator|.
name|rank
operator|=
call|(
modifier|*
name|order
call|)
argument_list|(
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|addrs
argument_list|,
name|naddrs
argument_list|,
sizeof|sizeof
argument_list|(
name|rankedaddress
argument_list|)
argument_list|,
name|addr_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|lwaddr_lwresaddr_fromnetaddr
argument_list|(
operator|&
name|client
operator|->
name|addrs
index|[
name|i
index|]
argument_list|,
operator|&
name|addrs
index|[
name|i
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|lwresd
operator|->
name|mctx
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|rankedaddress
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generate_reply
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|lwres
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|lwres_buffer_t
name|lwb
decl_stmt|;
name|ns_lwdclientmgr_t
modifier|*
name|cm
decl_stmt|;
name|cm
operator|=
name|client
operator|->
name|clientmgr
expr_stmt|;
name|lwb
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"generating gabn reply for client %p"
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * We must make certain the client->find is not still active. 	 * If it is either the v4 or v6 answer, just set it to NULL and 	 * let the cleanup code destroy it.  Otherwise, destroy it now. 	 */
if|if
condition|(
name|client
operator|->
name|find
operator|==
name|client
operator|->
name|v4find
operator|||
name|client
operator|->
name|find
operator|==
name|client
operator|->
name|v6find
condition|)
name|client
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|client
operator|->
name|find
operator|!=
name|NULL
condition|)
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
comment|/* 	 * perhaps there are some here? 	 */
if|if
condition|(
name|NEED_V6
argument_list|(
name|client
argument_list|)
operator|&&
name|client
operator|->
name|v4find
operator|!=
name|NULL
condition|)
name|client
operator|->
name|v6find
operator|=
name|client
operator|->
name|v4find
expr_stmt|;
comment|/* 	 * Run through the finds we have and wire them up to the gabn 	 * structure. 	 */
name|LWRES_LIST_INIT
argument_list|(
name|client
operator|->
name|gabn
operator|.
name|addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|v4find
operator|!=
name|NULL
condition|)
name|setup_addresses
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|v4find
argument_list|,
name|DNS_ADBFIND_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|v6find
operator|!=
name|NULL
condition|)
name|setup_addresses
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|v6find
argument_list|,
name|DNS_ADBFIND_INET6
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no addresses, try the next element in the search 	 * path, if there are any more.  Otherwise, fall through into 	 * the error handling code below. 	 */
if|if
condition|(
name|client
operator|->
name|gabn
operator|.
name|naddrs
operator|==
literal|0
condition|)
block|{
do|do
block|{
name|result
operator|=
name|ns_lwsearchctx_next
argument_list|(
operator|&
name|client
operator|->
name|searchctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|start_find
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return;
block|}
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
block|}
comment|/* 	 * Render the packet. 	 */
name|client
operator|->
name|pkt
operator|.
name|recvlength
operator|=
name|LWRES_RECVLENGTH
expr_stmt|;
name|client
operator|->
name|pkt
operator|.
name|authtype
operator|=
literal|0
expr_stmt|;
comment|/* XXXMLG */
name|client
operator|->
name|pkt
operator|.
name|authlength
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If there are no addresses, return failure. 	 */
if|if
condition|(
name|client
operator|->
name|gabn
operator|.
name|naddrs
operator|!=
literal|0
condition|)
name|client
operator|->
name|pkt
operator|.
name|result
operator|=
name|LWRES_R_SUCCESS
expr_stmt|;
else|else
name|client
operator|->
name|pkt
operator|.
name|result
operator|=
name|LWRES_R_NOTFOUND
expr_stmt|;
name|sort_addresses
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|lwres
operator|=
name|lwres_gabnresponse_render
argument_list|(
name|cm
operator|->
name|lwctx
argument_list|,
operator|&
name|client
operator|->
name|gabn
argument_list|,
operator|&
name|client
operator|->
name|pkt
argument_list|,
operator|&
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwres
operator|!=
name|LWRES_R_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|r
operator|.
name|base
operator|=
name|lwb
operator|.
name|base
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|lwb
operator|.
name|used
expr_stmt|;
name|client
operator|->
name|sendbuf
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|client
operator|->
name|sendlength
operator|=
name|r
operator|.
name|length
expr_stmt|;
name|result
operator|=
name|ns_lwdclient_sendreply
argument_list|(
name|client
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|NS_LWDCLIENT_SETSEND
argument_list|(
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * All done! 	 */
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|.
name|base
operator|!=
name|NULL
condition|)
name|lwres_context_freemem
argument_list|(
name|client
operator|->
name|clientmgr
operator|->
name|lwctx
argument_list|,
name|lwb
operator|.
name|base
argument_list|,
name|lwb
operator|.
name|length
argument_list|)
expr_stmt|;
name|ns_lwdclient_errorpktsend
argument_list|(
name|client
argument_list|,
name|LWRES_R_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the current real name, move it to an alias slot (if any are  * open) then put this new name in as the real name for the target.  *  * Return success if it can be rendered, otherwise failure.  Note that  * not having enough alias slots open is NOT a failure.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|add_alias
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint16_t
name|naliases
decl_stmt|;
name|b
operator|=
name|client
operator|->
name|recv_buffer
expr_stmt|;
comment|/* 	 * Render the new name to the buffer. 	 */
name|result
operator|=
name|dns_name_totext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|target_name
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|client
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Are there any open slots? 	 */
name|naliases
operator|=
name|client
operator|->
name|gabn
operator|.
name|naliases
expr_stmt|;
if|if
condition|(
name|naliases
operator|<
name|LWRES_MAX_ALIASES
condition|)
block|{
name|client
operator|->
name|gabn
operator|.
name|aliases
index|[
name|naliases
index|]
operator|=
name|client
operator|->
name|gabn
operator|.
name|realname
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|aliaslen
index|[
name|naliases
index|]
operator|=
name|client
operator|->
name|gabn
operator|.
name|realnamelen
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|naliases
operator|++
expr_stmt|;
block|}
comment|/* 	 * Save this name away as the current real name. 	 */
name|client
operator|->
name|gabn
operator|.
name|realname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|b
operator|.
name|base
operator|)
operator|+
name|b
operator|.
name|used
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|realnamelen
operator|=
name|client
operator|->
name|recv_buffer
operator|.
name|used
operator|-
name|b
operator|.
name|used
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|store_realname
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|tname
decl_stmt|;
name|b
operator|=
name|client
operator|->
name|recv_buffer
expr_stmt|;
name|tname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|target_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|ns_lwsearchctx_current
argument_list|(
operator|&
name|client
operator|->
name|searchctx
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Render the new name to the buffer. 	 */
name|result
operator|=
name|dns_name_totext
argument_list|(
name|tname
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|client
operator|->
name|recv_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Save this name away as the current real name. 	 */
name|client
operator|->
name|gabn
operator|.
name|realname
operator|=
operator|(
name|char
operator|*
operator|)
name|b
operator|.
name|base
operator|+
name|b
operator|.
name|used
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|realnamelen
operator|=
name|client
operator|->
name|recv_buffer
operator|.
name|used
operator|-
name|b
operator|.
name|used
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_gabn_finddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|ns_lwdclient_t
modifier|*
name|client
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|isc_eventtype_t
name|evtype
decl_stmt|;
name|isc_boolean_t
name|claimed
decl_stmt|;
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"find done for task %p, client %p"
argument_list|,
name|task
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|evtype
operator|=
name|ev
operator|->
name|ev_type
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
comment|/* 	 * No more info to be had?  If so, we have all the good stuff 	 * right now, so we can render things. 	 */
name|claimed
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|evtype
operator|==
name|DNS_EVENT_ADBNOMOREADDRESSES
condition|)
block|{
if|if
condition|(
name|NEED_V4
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client
operator|->
name|v4find
operator|=
name|client
operator|->
name|find
expr_stmt|;
name|claimed
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|NEED_V6
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client
operator|->
name|v6find
operator|=
name|client
operator|->
name|find
expr_stmt|;
name|claimed
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|find
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|claimed
condition|)
name|client
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
else|else
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
block|}
name|generate_reply
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We probably don't need this find anymore.  We're either going to 	 * reissue it, or an error occurred.  Either way, we're done with 	 * it. 	 */
if|if
condition|(
operator|(
name|client
operator|->
name|find
operator|!=
name|client
operator|->
name|v4find
operator|)
operator|&&
operator|(
name|client
operator|->
name|find
operator|!=
name|client
operator|->
name|v6find
operator|)
condition|)
block|{
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|client
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * We have some new information we can gather.  Run off and fetch 	 * it. 	 */
if|if
condition|(
name|evtype
operator|==
name|DNS_EVENT_ADBMOREADDRESSES
condition|)
block|{
name|restart_find
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * An error or other strangeness happened.  Drop this query. 	 */
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ns_lwdclient_errorpktsend
argument_list|(
name|client
argument_list|,
name|LWRES_R_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_find
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|claimed
decl_stmt|;
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"starting find for client %p"
argument_list|,
name|client
argument_list|)
expr_stmt|;
comment|/* 	 * Issue a find for the name contained in the request.  We won't 	 * set the bit that says "anything is good enough" -- we want it 	 * all. 	 */
name|options
operator|=
literal|0
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_WANTEVENT
expr_stmt|;
name|options
operator||=
name|DNS_ADBFIND_RETURNLAME
expr_stmt|;
comment|/* 	 * Set the bits up here to mark that we want this address family 	 * and that we do not currently have a find pending.  We will 	 * set that bit again below if it turns out we will get an event. 	 */
if|if
condition|(
name|NEED_V4
argument_list|(
name|client
argument_list|)
condition|)
name|options
operator||=
name|DNS_ADBFIND_INET
expr_stmt|;
if|if
condition|(
name|NEED_V6
argument_list|(
name|client
argument_list|)
condition|)
name|options
operator||=
name|DNS_ADBFIND_INET6
expr_stmt|;
name|find_again
label|:
name|INSIST
argument_list|(
name|client
operator|->
name|find
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_adb_createfind
argument_list|(
name|client
operator|->
name|clientmgr
operator|->
name|view
operator|->
name|adb
argument_list|,
name|client
operator|->
name|clientmgr
operator|->
name|task
argument_list|,
name|process_gabn_finddone
argument_list|,
name|client
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|target_name
argument_list|)
argument_list|,
name|dns_rootname
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|target_name
argument_list|)
argument_list|,
name|client
operator|->
name|clientmgr
operator|->
name|view
operator|->
name|dstport
argument_list|,
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
comment|/* 	 * Did we get an alias?  If so, save it and re-issue the query. 	 */
if|if
condition|(
name|result
operator|==
name|DNS_R_ALIAS
condition|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"found alias, restarting query"
argument_list|)
expr_stmt|;
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|add_alias
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"out of buffer space adding alias"
argument_list|)
expr_stmt|;
name|ns_lwdclient_errorpktsend
argument_list|(
name|client
argument_list|,
name|LWRES_R_FAILURE
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|find_again
goto|;
block|}
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"find returned %d (%s)"
argument_list|,
name|result
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Did we get an error? 	 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|find
operator|!=
name|NULL
condition|)
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
name|cleanup_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|ns_lwdclient_errorpktsend
argument_list|(
name|client
argument_list|,
name|LWRES_R_FAILURE
argument_list|)
expr_stmt|;
return|return;
block|}
name|claimed
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Did we get our answer to V4 addresses? 	 */
if|if
condition|(
name|NEED_V4
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
operator|(
name|client
operator|->
name|find
operator|->
name|query_pending
operator|&
name|DNS_ADBFIND_INET
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"client %p ipv4 satisfied by find %p"
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
name|claimed
operator|=
name|ISC_TRUE
expr_stmt|;
name|client
operator|->
name|v4find
operator|=
name|client
operator|->
name|find
expr_stmt|;
block|}
comment|/* 	 * Did we get our answer to V6 addresses? 	 */
if|if
condition|(
name|NEED_V6
argument_list|(
name|client
argument_list|)
operator|&&
operator|(
operator|(
name|client
operator|->
name|find
operator|->
name|query_pending
operator|&
name|DNS_ADBFIND_INET6
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"client %p ipv6 satisfied by find %p"
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
name|claimed
operator|=
name|ISC_TRUE
expr_stmt|;
name|client
operator|->
name|v6find
operator|=
name|client
operator|->
name|find
expr_stmt|;
block|}
comment|/* 	 * If we're going to get an event, set our internal pending flag 	 * and return.  When we get an event back we'll do the right 	 * thing, basically by calling this function again, perhaps with a 	 * new target name. 	 * 	 * If we have both v4 and v6, and we are still getting an event, 	 * we have a programming error, so die hard. 	 */
if|if
condition|(
operator|(
name|client
operator|->
name|find
operator|->
name|options
operator|&
name|DNS_ADBFIND_WANTEVENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"event will be sent"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|v4find
operator|==
name|NULL
operator|||
name|client
operator|->
name|v6find
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"no event will be sent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|claimed
condition|)
name|client
operator|->
name|find
operator|=
name|NULL
expr_stmt|;
else|else
name|dns_adb_destroyfind
argument_list|(
operator|&
name|client
operator|->
name|find
argument_list|)
expr_stmt|;
comment|/* 	 * We seem to have everything we asked for, or at least we are 	 * able to respond with things we've learned. 	 */
name|generate_reply
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|start_find
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Initialize the real name and alias arrays in the reply we're 	 * going to build up. 	 */
name|init_gabn
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|=
name|store_realname
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|restart_find
argument_list|(
name|client
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_gabn
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Initialize the real name and alias arrays in the reply we're 	 * going to build up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LWRES_MAX_ALIASES
condition|;
name|i
operator|++
control|)
block|{
name|client
operator|->
name|aliases
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|aliaslen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LWRES_MAX_ADDRS
condition|;
name|i
operator|++
control|)
block|{
name|client
operator|->
name|addrs
index|[
name|i
index|]
operator|.
name|family
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|addrs
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|client
operator|->
name|addrs
index|[
name|i
index|]
operator|.
name|address
argument_list|,
literal|0
argument_list|,
name|LWRES_ADDR_MAXLEN
argument_list|)
expr_stmt|;
name|LWRES_LINK_INIT
argument_list|(
operator|&
name|client
operator|->
name|addrs
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|gabn
operator|.
name|naliases
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|naddrs
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|realname
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|aliases
operator|=
name|client
operator|->
name|aliases
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|realnamelen
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|aliaslen
operator|=
name|client
operator|->
name|aliaslen
expr_stmt|;
name|LWRES_LIST_INIT
argument_list|(
name|client
operator|->
name|gabn
operator|.
name|addrs
argument_list|)
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|gabn
operator|.
name|baselen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up the internal buffer to point to the receive region. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|client
operator|->
name|recv_buffer
argument_list|,
name|client
operator|->
name|buffer
argument_list|,
name|LWRES_RECVLENGTH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When we are called, we can be assured that:  *  *	client->sockaddr contains the address we need to reply to,  *  *	client->pkt contains the packet header data,  *  *	the packet "checks out" overall -- any MD5 hashes or crypto  *	bits have been verified,  *  *	"b" points to the remaining data after the packet header  *	was parsed off.  *  *	We are in a the RECVDONE state.  *  * From this state we will enter the SEND state if we happen to have  * everything we need or we need to return an error packet, or to the  * FINDWAIT state if we need to look things up.  */
end_comment

begin_function
name|void
name|ns_lwdclient_processgabn
parameter_list|(
name|ns_lwdclient_t
modifier|*
name|client
parameter_list|,
name|lwres_buffer_t
modifier|*
name|b
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|lwres_gabnrequest_t
modifier|*
name|req
decl_stmt|;
name|ns_lwdclientmgr_t
modifier|*
name|cm
decl_stmt|;
name|isc_buffer_t
name|namebuf
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_LWDCLIENT_ISRECVDONE
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|cm
operator|=
name|client
operator|->
name|clientmgr
expr_stmt|;
name|req
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|lwres_gabnrequest_parse
argument_list|(
name|client
operator|->
name|clientmgr
operator|->
name|lwctx
argument_list|,
name|b
argument_list|,
operator|&
name|client
operator|->
name|pkt
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|LWRES_R_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|req
operator|->
name|name
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|isc_buffer_init
argument_list|(
operator|&
name|namebuf
argument_list|,
name|req
operator|->
name|name
argument_list|,
name|req
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|namebuf
argument_list|,
name|req
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|client
operator|->
name|target_name
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|client
operator|->
name|query_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|query_name
argument_list|)
argument_list|,
operator|&
name|namebuf
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|out
goto|;
name|ns_lwsearchctx_init
argument_list|(
operator|&
name|client
operator|->
name|searchctx
argument_list|,
name|cm
operator|->
name|listener
operator|->
name|manager
operator|->
name|search
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|client
operator|->
name|query_name
argument_list|)
argument_list|,
name|cm
operator|->
name|listener
operator|->
name|manager
operator|->
name|ndots
argument_list|)
expr_stmt|;
name|ns_lwsearchctx_first
argument_list|(
operator|&
name|client
operator|->
name|searchctx
argument_list|)
expr_stmt|;
name|client
operator|->
name|find_wanted
operator|=
name|req
operator|->
name|addrtypes
expr_stmt|;
name|ns_lwdclient_log
argument_list|(
literal|50
argument_list|,
literal|"client %p looking for addrtypes %08x"
argument_list|,
name|client
argument_list|,
name|client
operator|->
name|find_wanted
argument_list|)
expr_stmt|;
comment|/* 	 * We no longer need to keep this around. 	 */
name|lwres_gabnrequest_free
argument_list|(
name|client
operator|->
name|clientmgr
operator|->
name|lwctx
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Start the find. 	 */
name|result
operator|=
name|start_find
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|out
goto|;
return|return;
comment|/* 	 * We're screwed.  Return an error packet to our caller. 	 */
name|out
label|:
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
name|lwres_gabnrequest_free
argument_list|(
name|client
operator|->
name|clientmgr
operator|->
name|lwctx
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
name|ns_lwdclient_errorpktsend
argument_list|(
name|client
argument_list|,
name|LWRES_R_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

