begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: client.c,v 1.176.2.13.4.26 2005/07/27 02:53:14 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/formatcheck.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/resolver.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<named/interfacemgr.h>
end_include

begin_include
include|#
directive|include
file|<named/log.h>
end_include

begin_include
include|#
directive|include
file|<named/notify.h>
end_include

begin_include
include|#
directive|include
file|<named/server.h>
end_include

begin_include
include|#
directive|include
file|<named/update.h>
end_include

begin_comment
comment|/***  *** Client  ***/
end_comment

begin_comment
comment|/*  * Important note!  *  * All client state changes, other than that from idle to listening, occur  * as a result of events.  This guarantees serialization and avoids the  * need for locking.  *  * If a routine is ever created that allows someone other than the client's  * task to change the client, then the client will have to be locked.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENT_TRACE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NS_CLIENT_TRACE
end_ifdef

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|ns_client_log(client, \ 				      NS_LOGCATEGORY_CLIENT, \ 				      NS_LOGMODULE_CLIENT, \ 				      ISC_LOG_DEBUG(3), \ 				      "%s", (m))
end_define

begin_define
define|#
directive|define
name|MTRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(ns_g_lctx, \ 				      NS_LOGCATEGORY_GENERAL, \ 				      NS_LOGMODULE_CLIENT, \ 				      ISC_LOG_DEBUG(3), \ 				      "clientmgr @%p: %s", manager, (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)(m))
end_define

begin_define
define|#
directive|define
name|MTRACE
parameter_list|(
name|m
parameter_list|)
value|((void)(m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TCP_CLIENT
parameter_list|(
name|c
parameter_list|)
value|(((c)->attributes& NS_CLIENTATTR_TCP) != 0)
end_define

begin_define
define|#
directive|define
name|TCP_BUFFER_SIZE
value|(65535 + 2)
end_define

begin_define
define|#
directive|define
name|SEND_BUFFER_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|RECV_BUFFER_SIZE
value|4096
end_define

begin_struct
struct|struct
name|ns_clientmgr
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_taskmgr_t
modifier|*
name|taskmgr
decl_stmt|;
name|isc_timermgr_t
modifier|*
name|timermgr
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by lock. */
name|isc_boolean_t
name|exiting
decl_stmt|;
name|client_list_t
name|active
decl_stmt|;
comment|/* Active clients */
name|client_list_t
name|recursing
decl_stmt|;
comment|/* Recursing clients */
name|client_list_t
name|inactive
decl_stmt|;
comment|/* To be recycled */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MANAGER_MAGIC
value|ISC_MAGIC('N', 'S', 'C', 'm')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, MANAGER_MAGIC)
end_define

begin_comment
comment|/*  * Client object states.  Ordering is significant: higher-numbered  * states are generally "more active", meaning that the client can  * have more dynamically allocated data, outstanding events, etc.  * In the list below, any such properties listed for state N  * also apply to any state> N.  *  * To force the client into a less active state, set client->newstate  * to that state and call exit_check().  This will cause any  * activities defined for higher-numbered states to be aborted.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_FREED
value|0
end_define

begin_comment
comment|/*  * The client object no longer exists.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_INACTIVE
value|1
end_define

begin_comment
comment|/*  * The client object exists and has a task and timer.  * Its "query" struct and sendbuf are initialized.  * It is on the client manager's list of inactive clients.  * It has a message and OPT, both in the reset state.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_READY
value|2
end_define

begin_comment
comment|/*  * The client object is either a TCP or a UDP one, and  * it is associated with a network interface.  It is on the  * client manager's list of active clients.  *  * If it is a TCP client object, it has a TCP listener socket  * and an outstanding TCP listen request.  *  * If it is a UDP client object, it has a UDP listener socket  * and an outstanding UDP receive request.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_READING
value|3
end_define

begin_comment
comment|/*  * The client object is a TCP client object that has received  * a connection.  It has a tcpsocket, tcpmsg, TCP quota, and an  * outstanding TCP read request.  This state is not used for  * UDP client objects.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_WORKING
value|4
end_define

begin_comment
comment|/*  * The client object has received a request and is working  * on it.  It has a view, and it may have any of a non-reset OPT,  * recursion quota, and an outstanding write request.  */
end_comment

begin_define
define|#
directive|define
name|NS_CLIENTSTATE_MAX
value|9
end_define

begin_comment
comment|/*  * Sentinel value used to indicate "no state".  When client->newstate  * has this value, we are not attempting to exit the current state.  * Must be greater than any valid state.  */
end_comment

begin_function_decl
specifier|static
name|void
name|client_read
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|client_accept
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|client_udprecv
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clientmgr_destroy
parameter_list|(
name|ns_clientmgr_t
modifier|*
name|manager
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|exit_check
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ns_client_endrequest
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ns_client_checkactive
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|client_start
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|client_request
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ns_client_dumpmessage
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ns_client_recursing
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|client
operator|->
name|list
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|manager
operator|->
name|recursing
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
operator|&
name|client
operator|->
name|manager
operator|->
name|recursing
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_killoldestquery
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|oldest
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|oldest
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|client
operator|->
name|manager
operator|->
name|recursing
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldest
operator|!=
name|NULL
condition|)
block|{
name|ns_query_cancel
argument_list|(
name|oldest
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|oldest
operator|->
name|list
argument_list|,
name|oldest
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|manager
operator|->
name|active
argument_list|,
name|oldest
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|oldest
operator|->
name|list
operator|=
operator|&
name|client
operator|->
name|manager
operator|->
name|active
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_settimeout
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|seconds
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|seconds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|client
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
name|NULL
argument_list|,
operator|&
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|client
operator|->
name|timerset
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"setting timeout: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Continue anyway. */
block|}
block|}
end_function

begin_comment
comment|/*  * Check for a deactivation or shutdown request and take appropriate  * action.  Returns ISC_TRUE if either is in progress; in this case  * the caller must no longer use the client object as it may have been  * freed.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|exit_check
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|ns_clientmgr_t
modifier|*
name|locked_manager
init|=
name|NULL
decl_stmt|;
name|ns_clientmgr_t
modifier|*
name|destroy_manager
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|state
operator|<=
name|client
operator|->
name|newstate
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* Business as usual. */
name|INSIST
argument_list|(
name|client
operator|->
name|newstate
operator|<
name|NS_CLIENTSTATE_WORKING
argument_list|)
expr_stmt|;
comment|/* 	 * We need to detach from the view early when shutting down 	 * the server to break the following vicious circle: 	 * 	 *  - The resolver will not shut down until the view refcount is zero 	 *  - The view refcount does not go to zero until all clients detach 	 *  - The client does not detach from the view until references is zero 	 *  - references does not go to zero until the resolver has shut down 	 * 	 * Keep the view attached until any outstanding updates complete. 	 */
if|if
condition|(
name|client
operator|->
name|nupdates
operator|==
literal|0
operator|&&
name|client
operator|->
name|newstate
operator|==
name|NS_CLIENTSTATE_FREED
operator|&&
name|client
operator|->
name|view
operator|!=
name|NULL
condition|)
name|dns_view_detach
argument_list|(
operator|&
name|client
operator|->
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_WORKING
condition|)
block|{
name|INSIST
argument_list|(
name|client
operator|->
name|newstate
operator|<=
name|NS_CLIENTSTATE_READING
argument_list|)
expr_stmt|;
comment|/* 		 * Let the update processing complete. 		 */
if|if
condition|(
name|client
operator|->
name|nupdates
operator|>
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 		 * We are trying to abort request processing. 		 */
if|if
condition|(
name|client
operator|->
name|nsends
operator|>
literal|0
condition|)
block|{
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
name|socket
operator|=
name|client
operator|->
name|tcpsocket
expr_stmt|;
else|else
name|socket
operator|=
name|client
operator|->
name|udpsocket
expr_stmt|;
name|isc_socket_cancel
argument_list|(
name|socket
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_SEND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|client
operator|->
name|nsends
operator|==
literal|0
operator|&&
name|client
operator|->
name|nrecvs
operator|==
literal|0
operator|&&
name|client
operator|->
name|references
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Still waiting for I/O cancel completion. 			 * or lingering references. 			 */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* 		 * I/O cancel is complete.  Burn down all state 		 * related to the current request. 		 */
name|ns_client_endrequest
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_READING
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_CLIENTSTATE_READING
operator|==
name|client
operator|->
name|newstate
condition|)
block|{
name|client_read
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_MAX
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* We're done. */
block|}
block|}
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_READING
condition|)
block|{
comment|/* 		 * We are trying to abort the current TCP connection, 		 * if any. 		 */
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|newstate
operator|<=
name|NS_CLIENTSTATE_READY
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|nreads
operator|>
literal|0
condition|)
name|dns_tcpmsg_cancelread
argument_list|(
operator|&
name|client
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
operator|->
name|nreads
operator|==
literal|0
condition|)
block|{
comment|/* Still waiting for read cancel completion. */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
name|client
operator|->
name|tcpmsg_valid
condition|)
block|{
name|dns_tcpmsg_invalidate
argument_list|(
operator|&
name|client
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|client
operator|->
name|tcpmsg_valid
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|tcpsocket
operator|!=
name|NULL
condition|)
block|{
name|CTRACE
argument_list|(
literal|"closetcp"
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|client
operator|->
name|tcpsocket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|tcpquota
operator|!=
name|NULL
condition|)
name|isc_quota_detach
argument_list|(
operator|&
name|client
operator|->
name|tcpquota
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|timerset
condition|)
block|{
operator|(
name|void
operator|)
name|isc_timer_reset
argument_list|(
name|client
operator|->
name|timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|client
operator|->
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|client
operator|->
name|peeraddr_valid
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_READY
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Now the client is ready to accept a new TCP connection 		 * or UDP request, but we may have enough clients doing 		 * that already.  Check whether this client needs to remain 		 * active and force it to go inactive if not. 		 */
name|ns_client_checkactive
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_CLIENTSTATE_READY
operator|==
name|client
operator|->
name|newstate
condition|)
block|{
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client_accept
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
name|client_udprecv
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_MAX
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_READY
condition|)
block|{
name|INSIST
argument_list|(
name|client
operator|->
name|newstate
operator|<=
name|NS_CLIENTSTATE_INACTIVE
argument_list|)
expr_stmt|;
comment|/* 		 * We are trying to enter the inactive state. 		 */
if|if
condition|(
name|client
operator|->
name|naccepts
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|client
operator|->
name|tcplistener
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_ACCEPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|client
operator|->
name|naccepts
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Still waiting for accept cancel completion. */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* Accept cancel is complete. */
if|if
condition|(
name|client
operator|->
name|nrecvs
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|client
operator|->
name|udpsocket
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|client
operator|->
name|nrecvs
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Still waiting for recv cancel completion. */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* Recv cancel is complete. */
if|if
condition|(
name|client
operator|->
name|nctls
operator|>
literal|0
condition|)
block|{
comment|/* Still waiting for control event to be delivered */
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* Deactivate the client. */
if|if
condition|(
name|client
operator|->
name|interface
condition|)
name|ns_interface_detach
argument_list|(
operator|&
name|client
operator|->
name|interface
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|naccepts
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|tcplistener
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|client
operator|->
name|tcplistener
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|udpsocket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|client
operator|->
name|udpsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|dispatch
operator|!=
name|NULL
condition|)
name|dns_dispatch_detach
argument_list|(
operator|&
name|client
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|client
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|mortal
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * Put the client on the inactive list.  If we are aiming for 		 * the "freed" state, it will be removed from the inactive 		 * list shortly, and we need to keep the manager locked until 		 * that has been done, lest the manager decide to reactivate 		 * the dying client inbetween. 		 */
name|locked_manager
operator|=
name|client
operator|->
name|manager
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|client
operator|->
name|list
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|client
operator|->
name|manager
operator|->
name|inactive
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
operator|&
name|client
operator|->
name|manager
operator|->
name|inactive
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_INACTIVE
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|client
operator|->
name|newstate
condition|)
block|{
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_MAX
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
if|if
condition|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_INACTIVE
condition|)
block|{
name|INSIST
argument_list|(
name|client
operator|->
name|newstate
operator|==
name|NS_CLIENTSTATE_FREED
argument_list|)
expr_stmt|;
comment|/* 		 * We are trying to free the client. 		 * 		 * When "shuttingdown" is true, either the task has received 		 * its shutdown event or no shutdown event has ever been 		 * set up.  Thus, we have no outstanding shutdown 		 * event at this point. 		 */
name|REQUIRE
argument_list|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_INACTIVE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ns_query_free
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|recvbuf
argument_list|,
name|RECV_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|client
operator|->
name|sendevent
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|client
operator|->
name|recvevent
argument_list|)
expr_stmt|;
name|isc_timer_detach
argument_list|(
operator|&
name|client
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|tcpbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|tcpbuf
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|opt
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|dns_rdataset_isassociated
argument_list|(
name|client
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|client
operator|->
name|opt
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|client
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
name|dns_message_destroy
argument_list|(
operator|&
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|manager
operator|!=
name|NULL
condition|)
block|{
name|ns_clientmgr_t
modifier|*
name|manager
init|=
name|client
operator|->
name|manager
decl_stmt|;
if|if
condition|(
name|locked_manager
operator|==
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|locked_manager
operator|=
name|manager
expr_stmt|;
block|}
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|client
operator|->
name|list
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|exiting
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|active
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
condition|)
name|destroy_manager
operator|=
name|manager
expr_stmt|;
block|}
comment|/* 		 * Detaching the task must be done after unlinking from 		 * the manager's lists because the manager accesses 		 * client->task. 		 */
if|if
condition|(
name|client
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"free"
argument_list|)
expr_stmt|;
name|client
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|unlock
label|:
if|if
condition|(
name|locked_manager
operator|!=
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|locked_manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|locked_manager
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Only now is it safe to destroy the client manager (if needed), 	 * because we have accessed its lock for the last time. 	 */
if|if
condition|(
name|destroy_manager
operator|!=
name|NULL
condition|)
name|clientmgr_destroy
argument_list|(
name|destroy_manager
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The client's task has received the client's control event  * as part of the startup process.  */
end_comment

begin_function
specifier|static
name|void
name|client_start
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
init|=
operator|(
name|ns_client_t
operator|*
operator|)
name|event
operator|->
name|ev_arg
decl_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nctls
operator|==
literal|1
argument_list|)
expr_stmt|;
name|client
operator|->
name|nctls
operator|--
expr_stmt|;
if|if
condition|(
name|exit_check
argument_list|(
name|client
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|client_accept
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|client_udprecv
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The client's task has received a shutdown event.  */
end_comment

begin_function
specifier|static
name|void
name|client_shutdown
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TASKEVENT_SHUTDOWN
argument_list|)
expr_stmt|;
name|client
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|shutdown
operator|!=
name|NULL
condition|)
block|{
call|(
name|client
operator|->
name|shutdown
call|)
argument_list|(
name|client
operator|->
name|shutdown_arg
argument_list|,
name|ISC_R_SHUTTINGDOWN
argument_list|)
expr_stmt|;
name|client
operator|->
name|shutdown
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|shutdown_arg
operator|=
name|NULL
expr_stmt|;
block|}
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_FREED
expr_stmt|;
operator|(
name|void
operator|)
name|exit_check
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_client_endrequest
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|INSIST
argument_list|(
name|client
operator|->
name|naccepts
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nreads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nsends
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nrecvs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nupdates
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_WORKING
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"endrequest"
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
call|(
name|client
operator|->
name|next
call|)
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|view
operator|!=
name|NULL
condition|)
name|dns_view_detach
argument_list|(
operator|&
name|client
operator|->
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|opt
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|dns_rdataset_isassociated
argument_list|(
name|client
operator|->
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|client
operator|->
name|opt
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|client
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|udpsize
operator|=
literal|512
expr_stmt|;
name|client
operator|->
name|extflags
operator|=
literal|0
expr_stmt|;
name|dns_message_reset
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|recursionquota
operator|!=
name|NULL
condition|)
name|isc_quota_detach
argument_list|(
operator|&
name|client
operator|->
name|recursionquota
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all client attributes that are specific to 	 * the request; that's all except the TCP flag. 	 */
name|client
operator|->
name|attributes
operator|&=
name|NS_CLIENTATTR_TCP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_client_checkactive
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
if|if
condition|(
name|client
operator|->
name|mortal
condition|)
block|{
comment|/* 		 * This client object should normally go inactive 		 * at this point, but if we have fewer active client 		 * objects than  desired due to earlier quota exhaustion, 		 * keep it active to make up for the shortage. 		 */
name|isc_boolean_t
name|need_another_client
init|=
name|ISC_FALSE
decl_stmt|;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|interface
operator|->
name|ntcpcurrent
operator|<
name|client
operator|->
name|interface
operator|->
name|ntcptarget
condition|)
name|need_another_client
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The UDP client quota is enforced by making 			 * requests fail rather than by not listening 			 * for new ones.  Therefore, there is always a 			 * full set of UDP clients listening. 			 */
block|}
if|if
condition|(
operator|!
name|need_another_client
condition|)
block|{
comment|/* 			 * We don't need this client object.  Recycle it. 			 */
if|if
condition|(
name|client
operator|->
name|newstate
operator|>=
name|NS_CLIENTSTATE_INACTIVE
condition|)
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_INACTIVE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_client_next
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|int
name|newstate
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_WORKING
operator|||
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_READING
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"request failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * An error processing a TCP request may have left 	 * the connection out of sync.  To be safe, we always 	 * sever the connection when result != ISC_R_SUCCESS. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
name|newstate
operator|=
name|NS_CLIENTSTATE_READING
expr_stmt|;
else|else
name|newstate
operator|=
name|NS_CLIENTSTATE_READY
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|newstate
operator|>
name|newstate
condition|)
name|client
operator|->
name|newstate
operator|=
name|newstate
expr_stmt|;
operator|(
name|void
operator|)
name|exit_check
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|REQUIRE
argument_list|(
name|sevent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sevent
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_SENDDONE
argument_list|)
expr_stmt|;
name|client
operator|=
name|sevent
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sevent
operator|==
name|client
operator|->
name|sendevent
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"senddone"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"error sending response: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nsends
operator|>
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|nsends
operator|--
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|tcpbuf
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|tcpbuf
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|client
operator|->
name|tcpbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exit_check
argument_list|(
name|client
argument_list|)
condition|)
return|return;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We only want to fail with ISC_R_NOSPACE when called from  * ns_client_sendraw() and not when called from ns_client_send(),  * tcpbuffer is NULL when called from ns_client_sendraw() and  * length != 0.  tcpbuffer != NULL when called from ns_client_send()  * and length == 0.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|client_allocsendbuf
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|isc_buffer_t
modifier|*
name|tcpbuffer
parameter_list|,
name|isc_uint32_t
name|length
parameter_list|,
name|unsigned
name|char
modifier|*
name|sendbuf
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|isc_uint32_t
name|bufsize
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|datap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|tcpbuffer
operator|==
name|NULL
operator|&&
name|length
operator|!=
literal|0
operator|)
operator|||
operator|(
name|tcpbuffer
operator|!=
name|NULL
operator|&&
name|length
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|client
operator|->
name|tcpbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|+
literal|2
operator|>
name|TCP_BUFFER_SIZE
condition|)
block|{
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|client
operator|->
name|tcpbuf
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|tcpbuf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|data
operator|=
name|client
operator|->
name|tcpbuf
expr_stmt|;
if|if
condition|(
name|tcpbuffer
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_init
argument_list|(
name|tcpbuffer
argument_list|,
name|data
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
name|buffer
argument_list|,
name|data
operator|+
literal|2
argument_list|,
name|TCP_BUFFER_SIZE
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_init
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|length
operator|<=
literal|0xffff
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
name|buffer
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|data
operator|=
name|sendbuf
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|udpsize
operator|<
name|SEND_BUFFER_SIZE
condition|)
name|bufsize
operator|=
name|client
operator|->
name|udpsize
expr_stmt|;
else|else
name|bufsize
operator|=
name|SEND_BUFFER_SIZE
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|bufsize
condition|)
block|{
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|isc_buffer_init
argument_list|(
name|buffer
argument_list|,
name|data
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
operator|*
name|datap
operator|=
name|data
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|done
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|client_sendpkg
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_sockaddr_t
modifier|*
name|address
decl_stmt|;
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|int
name|match
decl_stmt|;
name|unsigned
name|int
name|sockflags
init|=
name|ISC_SOCKFLAG_IMMEDIATE
decl_stmt|;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|socket
operator|=
name|client
operator|->
name|tcpsocket
expr_stmt|;
name|address
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|socket
operator|=
name|client
operator|->
name|udpsocket
expr_stmt|;
name|address
operator|=
operator|&
name|client
operator|->
name|peeraddr
expr_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_server
operator|->
name|blackholeacl
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|ns_g_server
operator|->
name|blackholeacl
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
return|return
operator|(
name|DNS_R_BLACKHOLED
operator|)
return|;
name|sockflags
operator||=
name|ISC_SOCKFLAG_NORETRY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_PKTINFO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_MULTICAST
operator|)
operator|==
literal|0
condition|)
name|pktinfo
operator|=
operator|&
name|client
operator|->
name|pktinfo
expr_stmt|;
else|else
name|pktinfo
operator|=
name|NULL
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_sendto2
argument_list|(
name|socket
argument_list|,
operator|&
name|r
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
name|client
operator|->
name|sendevent
argument_list|,
name|sockflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_INPROGRESS
condition|)
block|{
name|client
operator|->
name|nsends
operator|++
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|client_senddone
argument_list|(
name|client
operator|->
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|)
name|client
operator|->
name|sendevent
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_client_sendraw
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_message_t
modifier|*
name|message
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_region_t
modifier|*
name|mr
decl_stmt|;
name|unsigned
name|char
name|sendbuf
index|[
name|SEND_BUFFER_SIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"sendraw"
argument_list|)
expr_stmt|;
name|mr
operator|=
name|dns_message_getrawmessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_UNEXPECTEDEND
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|client_allocsendbuf
argument_list|(
name|client
argument_list|,
operator|&
name|buffer
argument_list|,
name|NULL
argument_list|,
name|mr
operator|->
name|length
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Copy message to buffer and fixup id. 	 */
name|isc_buffer_availableregion
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_copyregion
argument_list|(
operator|&
name|buffer
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|(
name|client
operator|->
name|message
operator|->
name|id
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|r
operator|.
name|base
index|[
literal|1
index|]
operator|=
name|client
operator|->
name|message
operator|->
name|id
operator|&
literal|0xff
expr_stmt|;
name|result
operator|=
name|client_sendpkg
argument_list|(
name|client
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return;
name|done
label|:
if|if
condition|(
name|client
operator|->
name|tcpbuf
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|tcpbuf
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|client
operator|->
name|tcpbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_send
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_buffer_t
name|tcpbuffer
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_compress_t
name|cctx
decl_stmt|;
name|isc_boolean_t
name|cleanup_cctx
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|char
name|sendbuf
index|[
name|SEND_BUFFER_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|dnssec_opts
decl_stmt|;
name|unsigned
name|int
name|preferred_glue
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"send"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_RA
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_RA
expr_stmt|;
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_WANTDNSSEC
operator|)
operator|!=
literal|0
condition|)
name|dnssec_opts
operator|=
literal|0
expr_stmt|;
else|else
name|dnssec_opts
operator|=
name|DNS_MESSAGERENDER_OMITDNSSEC
expr_stmt|;
name|preferred_glue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|preferred_glue
operator|==
name|dns_rdatatype_a
condition|)
name|preferred_glue
operator|=
name|DNS_MESSAGERENDER_PREFER_A
expr_stmt|;
elseif|else
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|preferred_glue
operator|==
name|dns_rdatatype_aaaa
condition|)
name|preferred_glue
operator|=
name|DNS_MESSAGERENDER_PREFER_AAAA
expr_stmt|;
block|}
comment|/* 	 * XXXRTH  The following doesn't deal with TCP buffer resizing. 	 */
name|result
operator|=
name|client_allocsendbuf
argument_list|(
name|client
argument_list|,
operator|&
name|buffer
argument_list|,
operator|&
name|tcpbuffer
argument_list|,
literal|0
argument_list|,
name|sendbuf
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|result
operator|=
name|dns_compress_init
argument_list|(
operator|&
name|cctx
argument_list|,
operator|-
literal|1
argument_list|,
name|client
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|cleanup_cctx
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dns_message_renderbegin
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|cctx
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|client
operator|->
name|opt
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_message_setopt
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|client
operator|->
name|opt
argument_list|)
expr_stmt|;
comment|/* 		 * XXXRTH dns_message_setopt() should probably do this... 		 */
name|client
operator|->
name|opt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
block|}
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_TC
expr_stmt|;
goto|goto
name|renderend
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
name|DNS_MESSAGERENDER_PARTIAL
operator||
name|dnssec_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_TC
expr_stmt|;
goto|goto
name|renderend
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
name|DNS_MESSAGERENDER_PARTIAL
operator||
name|dnssec_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|client
operator|->
name|message
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_TC
expr_stmt|;
goto|goto
name|renderend
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|,
name|preferred_glue
operator||
name|dnssec_opts
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_NOSPACE
condition|)
goto|goto
name|done
goto|;
name|renderend
label|:
name|result
operator|=
name|dns_message_renderend
argument_list|(
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|cleanup_cctx
condition|)
block|{
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|cleanup_cctx
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|isc_buffer_usedregion
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|tcpbuffer
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|client_sendpkg
argument_list|(
name|client
argument_list|,
operator|&
name|tcpbuffer
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|client_sendpkg
argument_list|(
name|client
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return;
name|done
label|:
if|if
condition|(
name|client
operator|->
name|tcpbuf
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|tcpbuf
argument_list|,
name|TCP_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|client
operator|->
name|tcpbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cleanup_cctx
condition|)
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_error
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|dns_rcode_t
name|rcode
decl_stmt|;
name|dns_message_t
modifier|*
name|message
decl_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
name|message
operator|=
name|client
operator|->
name|message
expr_stmt|;
name|rcode
operator|=
name|dns_result_torcode
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* 	 * Message may be an in-progress reply that we had trouble 	 * with, in which case QR will be set.  We need to clear QR before 	 * calling dns_message_reply() to avoid triggering an assertion. 	 */
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_QR
expr_stmt|;
comment|/* 	 * AA and AD shouldn't be set. 	 */
name|message
operator|->
name|flags
operator|&=
operator|~
operator|(
name|DNS_MESSAGEFLAG_AA
operator||
name|DNS_MESSAGEFLAG_AD
operator|)
expr_stmt|;
name|result
operator|=
name|dns_message_reply
argument_list|(
name|message
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * It could be that we've got a query with a good header, 		 * but a bad question section, so we try again with 		 * want_question_section set to ISC_FALSE. 		 */
name|result
operator|=
name|dns_message_reply
argument_list|(
name|message
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|message
operator|->
name|rcode
operator|=
name|rcode
expr_stmt|;
comment|/* 	 * FORMERR loop avoidance:  If we sent a FORMERR message 	 * with the same ID to the same client less than two 	 * seconds ago, assume that we are in an infinite error  	 * packet dialog with a server for some protocol whose  	 * error responses look enough like DNS queries to 	 * elicit a FORMERR response.  Drop a packet to break 	 * the loop. 	 */
if|if
condition|(
name|rcode
operator|==
name|dns_rcode_formerr
condition|)
block|{
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|client
operator|->
name|peeraddr
argument_list|,
operator|&
name|client
operator|->
name|formerrcache
operator|.
name|addr
argument_list|)
operator|&&
name|message
operator|->
name|id
operator|==
name|client
operator|->
name|formerrcache
operator|.
name|id
operator|&&
name|client
operator|->
name|requesttime
operator|-
name|client
operator|->
name|formerrcache
operator|.
name|time
operator|<
literal|2
condition|)
block|{
comment|/* Drop packet. */
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"possible error packet loop, "
literal|"FORMERR dropped"
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return;
block|}
name|client
operator|->
name|formerrcache
operator|.
name|addr
operator|=
name|client
operator|->
name|peeraddr
expr_stmt|;
name|client
operator|->
name|formerrcache
operator|.
name|time
operator|=
name|client
operator|->
name|requesttime
expr_stmt|;
name|client
operator|->
name|formerrcache
operator|.
name|id
operator|=
name|message
operator|->
name|id
expr_stmt|;
block|}
name|ns_client_send
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|client_addopt
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|dns_resolver_t
modifier|*
name|resolver
decl_stmt|;
name|isc_uint16_t
name|udpsize
decl_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|opt
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXXRTH free old. */
name|rdatalist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_opt
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set the maximum UDP buffer size. 	 */
name|view
operator|=
name|client
operator|->
name|view
expr_stmt|;
name|resolver
operator|=
operator|(
name|view
operator|!=
name|NULL
operator|)
condition|?
name|view
operator|->
name|resolver
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|resolver
operator|!=
name|NULL
condition|)
name|udpsize
operator|=
name|dns_resolver_getudpsize
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
else|else
name|udpsize
operator|=
name|ns_g_udpsize
expr_stmt|;
name|rdatalist
operator|->
name|rdclass
operator|=
name|udpsize
expr_stmt|;
comment|/* 	 * Set EXTENDED-RCODE, VERSION and Z to 0. 	 */
name|rdatalist
operator|->
name|ttl
operator|=
operator|(
name|client
operator|->
name|extflags
operator|&
name|DNS_MESSAGEEXTFLAG_REPLYPRESERVE
operator|)
expr_stmt|;
comment|/* 	 * No ENDS options in the default case. 	 */
name|rdata
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|rdata
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|rdata
operator|->
name|rdclass
operator|=
name|rdatalist
operator|->
name|rdclass
expr_stmt|;
name|rdata
operator|->
name|type
operator|=
name|rdatalist
operator|->
name|type
expr_stmt|;
name|rdata
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|client
operator|->
name|opt
operator|=
name|rdataset
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|allowed
parameter_list|(
name|isc_netaddr_t
modifier|*
name|addr
parameter_list|,
name|dns_name_t
modifier|*
name|signer
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
name|int
name|match
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|result
operator|=
name|dns_acl_match
argument_list|(
name|addr
argument_list|,
name|signer
argument_list|,
name|acl
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an incoming request event from the socket (UDP case)  * or tcpmsg (TCP case).  */
end_comment

begin_function
specifier|static
name|void
name|client_request
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sevent
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|sigresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_buffer_t
name|tbuffer
decl_stmt|;
name|dns_view_t
modifier|*
name|view
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|opt
decl_stmt|;
name|isc_boolean_t
name|ra
decl_stmt|;
comment|/* Recursion available. */
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|isc_netaddr_t
name|destaddr
decl_stmt|;
name|int
name|match
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|isc_boolean_t
name|notimp
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|state
operator|==
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|?
name|NS_CLIENTSTATE_READING
else|:
name|NS_CLIENTSTATE_READY
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_RECVDONE
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|REQUIRE
argument_list|(
name|sevent
operator|==
name|client
operator|->
name|recvevent
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|tbuffer
argument_list|,
name|sevent
operator|->
name|region
operator|.
name|base
argument_list|,
name|sevent
operator|->
name|n
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|tbuffer
argument_list|,
name|sevent
operator|->
name|n
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|tbuffer
expr_stmt|;
name|result
operator|=
name|sevent
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|peeraddr
operator|=
name|sevent
operator|->
name|address
expr_stmt|;
name|client
operator|->
name|peeraddr_valid
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sevent
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_PKTINFO
operator|)
operator|!=
literal|0
condition|)
block|{
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_PKTINFO
expr_stmt|;
name|client
operator|->
name|pktinfo
operator|=
name|sevent
operator|->
name|pktinfo
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sevent
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_MULTICAST
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_MULTICAST
expr_stmt|;
name|client
operator|->
name|nrecvs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_TCPMSG
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_sender
operator|==
operator|&
name|client
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|&
name|client
operator|->
name|tcpmsg
operator|.
name|buffer
expr_stmt|;
name|result
operator|=
name|client
operator|->
name|tcpmsg
operator|.
name|result
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nreads
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * client->peeraddr was set when the connection was accepted. 		 */
name|client
operator|->
name|nreads
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|exit_check
argument_list|(
name|client
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
name|client
operator|->
name|state
operator|=
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_WORKING
expr_stmt|;
name|isc_task_getcurrenttime
argument_list|(
name|task
argument_list|,
operator|&
name|client
operator|->
name|requesttime
argument_list|)
expr_stmt|;
name|client
operator|->
name|now
operator|=
name|client
operator|->
name|requesttime
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|result
operator|!=
name|ISC_R_CANCELED
condition|)
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"UDP client handler shutting "
literal|"down due to fatal receive "
literal|"error: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_shutdown
argument_list|(
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
block|}
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s request"
argument_list|,
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|?
literal|"TCP"
else|:
literal|"UDP"
argument_list|)
expr_stmt|;
comment|/* 	 * Check the blackhole ACL for UDP only, since TCP is done in 	 * client_newconn. 	 */
if|if
condition|(
operator|!
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
if|if
condition|(
name|ns_g_server
operator|->
name|blackholeacl
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|ns_g_server
operator|->
name|blackholeacl
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"blackholed UDP datagram"
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Silently drop multicast requests for the present. 	 * XXXMPA look at when/if mDNS spec stabilizes. 	 */
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_MULTICAST
operator|)
operator|!=
literal|0
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"dropping multicast request"
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_peekheader
argument_list|(
name|buffer
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * There isn't enough header to determine whether 		 * this was a request or a response.  Drop it. 		 */
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * The client object handles requests, not responses. 	 * If this is a UDP response, forward it to the dispatcher. 	 * If it's a TCP response, discard it here. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|CTRACE
argument_list|(
literal|"unexpected response"
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|dns_dispatch_importrecv
argument_list|(
name|client
operator|->
name|dispatch
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * It's a request.  Parse it. 	 */
name|result
operator|=
name|dns_message_parse
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Parsing the request failed.  Send a response 		 * (typically FORMERR or SERVFAIL). 		 */
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
switch|switch
condition|(
name|client
operator|->
name|message
operator|->
name|opcode
condition|)
block|{
case|case
name|dns_opcode_query
case|:
case|case
name|dns_opcode_update
case|:
case|case
name|dns_opcode_notify
case|:
name|notimp
operator|=
name|ISC_FALSE
expr_stmt|;
break|break;
case|case
name|dns_opcode_iquery
case|:
default|default:
name|notimp
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|client
operator|->
name|message
operator|->
name|rcode
operator|=
name|dns_rcode_noerror
expr_stmt|;
comment|/* RFC1123 section 6.1.3.2 */
if|if
condition|(
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_MULTICAST
operator|)
operator|!=
literal|0
condition|)
name|client
operator|->
name|message
operator|->
name|flags
operator|&=
operator|~
name|DNS_MESSAGEFLAG_RD
expr_stmt|;
comment|/* 	 * Deal with EDNS. 	 */
name|opt
operator|=
name|dns_message_getopt
argument_list|(
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|version
decl_stmt|;
comment|/* 		 * Set the client's UDP buffer size. 		 */
name|client
operator|->
name|udpsize
operator|=
name|opt
operator|->
name|rdclass
expr_stmt|;
comment|/* 		 * If the requested UDP buffer size is less than 512, 		 * ignore it and use 512. 		 */
if|if
condition|(
name|client
operator|->
name|udpsize
operator|<
literal|512
condition|)
name|client
operator|->
name|udpsize
operator|=
literal|512
expr_stmt|;
comment|/* 		 * Get the flags out of the OPT record. 		 */
name|client
operator|->
name|extflags
operator|=
call|(
name|isc_uint16_t
call|)
argument_list|(
name|opt
operator|->
name|ttl
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* 		 * Create an OPT for our reply. 		 */
name|result
operator|=
name|client_addopt
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 		 * Do we understand this version of ENDS? 		 * 		 * XXXRTH need library support for this! 		 */
name|version
operator|=
operator|(
name|opt
operator|->
name|ttl
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0
condition|)
block|{
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|DNS_R_BADVERS
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
literal|0
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"message class could not be determined"
argument_list|)
expr_stmt|;
name|ns_client_dumpmessage
argument_list|(
name|client
argument_list|,
literal|"message class could not be determined"
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|notimp
condition|?
name|DNS_R_NOTIMP
else|:
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Determine the destination address.  If the receiving interface is 	 * bound to a specific address, we simply use it regardless of the 	 * address family.  All IPv4 queries should fall into this case. 	 * Otherwise, if this is a TCP query, get the address from the 	 * receiving socket (this needs a system call and can be heavy). 	 * For IPv6 UDP queries, we get this from the pktinfo structure (if 	 * supported). 	 * If all the attempts fail (this can happen due to memory shortage, 	 * etc), we regard this as an error for safety.  	 */
if|if
condition|(
operator|(
name|client
operator|->
name|interface
operator|->
name|flags
operator|&
name|NS_INTERFACEFLAG_ANYADDR
operator|)
operator|==
literal|0
condition|)
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|destaddr
argument_list|,
operator|&
name|client
operator|->
name|interface
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|)
block|{
name|isc_sockaddr_t
name|destsockaddr
decl_stmt|;
name|result
operator|=
name|isc_socket_getsockname
argument_list|(
name|client
operator|->
name|tcpsocket
argument_list|,
operator|&
name|destsockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|destaddr
argument_list|,
operator|&
name|destsockaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|client
operator|->
name|interface
operator|->
name|addr
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_PKTINFO
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_uint32_t
name|zone
init|=
literal|0
decl_stmt|;
comment|/* 			 * XXXJT technically, we should convert the receiving 			 * interface ID to a proper scope zone ID.  However, 			 * due to the fact there is no standard API for this, 			 * we only handle link-local addresses and use the 			 * interface index as link ID.  Despite the assumption, 			 * it should cover most typical cases. 			 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|client
operator|->
name|pktinfo
operator|.
name|ipi6_addr
argument_list|)
condition|)
name|zone
operator|=
operator|(
name|isc_uint32_t
operator|)
name|client
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
operator|&
name|destaddr
argument_list|,
operator|&
name|client
operator|->
name|pktinfo
operator|.
name|ipi6_addr
argument_list|)
expr_stmt|;
name|isc_netaddr_setzone
argument_list|(
operator|&
name|destaddr
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed to get request's "
literal|"destination: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Find a view that matches the client's source address. 	 */
for|for
control|(
name|view
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|ns_g_server
operator|->
name|viewlist
argument_list|)
init|;
name|view
operator|!=
name|NULL
condition|;
name|view
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|view
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|view
operator|->
name|rdclass
operator|||
name|client
operator|->
name|message
operator|->
name|rdclass
operator|==
name|dns_rdataclass_any
condition|)
block|{
name|dns_name_t
modifier|*
name|tsig
init|=
name|NULL
decl_stmt|;
name|sigresult
operator|=
name|dns_message_rechecksig
argument_list|(
name|client
operator|->
name|message
argument_list|,
name|view
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigresult
operator|==
name|ISC_R_SUCCESS
condition|)
name|tsig
operator|=
name|client
operator|->
name|message
operator|->
name|tsigname
expr_stmt|;
if|if
condition|(
name|allowed
argument_list|(
operator|&
name|netaddr
argument_list|,
name|tsig
argument_list|,
name|view
operator|->
name|matchclients
argument_list|)
operator|&&
name|allowed
argument_list|(
operator|&
name|destaddr
argument_list|,
name|tsig
argument_list|,
name|view
operator|->
name|matchdestinations
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|client
operator|->
name|message
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_RD
operator|)
operator|==
literal|0
operator|&&
name|view
operator|->
name|matchrecursiveonly
operator|)
condition|)
block|{
name|dns_view_attach
argument_list|(
name|view
argument_list|,
operator|&
name|client
operator|->
name|view
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|view
operator|==
name|NULL
condition|)
block|{
name|char
name|classname
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
comment|/* 		 * Do a dummy TSIG verification attempt so that the 		 * response will have a TSIG if the query did, as 		 * required by RFC2845. 		 */
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_region_t
modifier|*
name|r
decl_stmt|;
name|dns_message_resetsig
argument_list|(
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
name|r
operator|=
name|dns_message_getrawmessage
argument_list|(
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|r
operator|->
name|base
argument_list|,
name|r
operator|->
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|r
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_tsig_verify
argument_list|(
operator|&
name|b
argument_list|,
name|client
operator|->
name|message
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|classname
argument_list|,
sizeof|sizeof
argument_list|(
name|classname
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no matching view in class '%s'"
argument_list|,
name|classname
argument_list|)
expr_stmt|;
name|ns_client_dumpmessage
argument_list|(
name|client
argument_list|,
literal|"no matching view in class"
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|notimp
condition|?
name|DNS_R_NOTIMP
else|:
name|DNS_R_REFUSED
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|5
argument_list|)
argument_list|,
literal|"using view '%s'"
argument_list|,
name|view
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Check for a signature.  We log bad signatures regardless of 	 * whether they ultimately cause the request to be rejected or 	 * not.  We do not log the lack of a signature unless we are 	 * debugging. 	 */
name|client
operator|->
name|signer
operator|=
name|NULL
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|client
operator|->
name|signername
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_signer
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|client
operator|->
name|signername
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"request has valid signature"
argument_list|)
expr_stmt|;
name|client
operator|->
name|signer
operator|=
operator|&
name|client
operator|->
name|signername
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"request is not signed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NOIDENTITY
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"request is signed by a nonauthoritative key"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|tsigrcode
index|[
literal|64
index|]
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|tsigrcode
argument_list|,
sizeof|sizeof
argument_list|(
name|tsigrcode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_tsigrcode_totext
argument_list|(
name|client
operator|->
name|message
operator|->
name|tsigstatus
argument_list|,
operator|&
name|b
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|tsigrcode
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* There is a signature, but it is bad. */
if|if
condition|(
name|dns_message_gettsig
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"request has invalid signature: "
literal|"TSIG %s: %s (%s)"
argument_list|,
name|namebuf
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|,
name|tsigrcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"request has invalid signature: %s (%s)"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|,
name|tsigrcode
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Accept update messages signed by unknown keys so that 		 * update forwarding works transparently through slaves 		 * that don't have all the same keys as the master. 		 */
if|if
condition|(
operator|!
operator|(
name|client
operator|->
name|message
operator|->
name|tsigstatus
operator|==
name|dns_tsigerror_badkey
operator|&&
name|client
operator|->
name|message
operator|->
name|opcode
operator|==
name|dns_opcode_update
operator|)
condition|)
block|{
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|sigresult
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
comment|/* 	 * Decide whether recursive service is available to this client. 	 * We do this here rather than in the query code so that we can 	 * set the RA bit correctly on all kinds of responses, not just 	 * responses to ordinary queries. 	 */
name|ra
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|->
name|resolver
operator|!=
name|NULL
operator|&&
name|client
operator|->
name|view
operator|->
name|recursion
operator|==
name|ISC_TRUE
operator|&&
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|client
operator|->
name|view
operator|->
name|recursionacl
argument_list|,
name|ISC_TRUE
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|ra
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ra
operator|==
name|ISC_TRUE
condition|)
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_RA
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
name|ra
condition|?
literal|"recursion available"
else|:
literal|"recursion not available"
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch the request. 	 */
switch|switch
condition|(
name|client
operator|->
name|message
operator|->
name|opcode
condition|)
block|{
case|case
name|dns_opcode_query
case|:
name|CTRACE
argument_list|(
literal|"query"
argument_list|)
expr_stmt|;
name|ns_query_start
argument_list|(
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_opcode_update
case|:
name|CTRACE
argument_list|(
literal|"update"
argument_list|)
expr_stmt|;
name|ns_client_settimeout
argument_list|(
name|client
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ns_update_start
argument_list|(
name|client
argument_list|,
name|sigresult
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_opcode_notify
case|:
name|CTRACE
argument_list|(
literal|"notify"
argument_list|)
expr_stmt|;
name|ns_client_settimeout
argument_list|(
name|client
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ns_notify_start
argument_list|(
name|client
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_opcode_iquery
case|:
name|CTRACE
argument_list|(
literal|"iquery"
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|DNS_R_NOTIMP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CTRACE
argument_list|(
literal|"unknown opcode"
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|DNS_R_NOTIMP
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|client_timeout
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_LIFE
operator|||
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_IDLE
argument_list|)
expr_stmt|;
name|client
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|==
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|timer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|CTRACE
argument_list|(
literal|"timeout"
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|shutdown
operator|!=
name|NULL
condition|)
block|{
call|(
name|client
operator|->
name|shutdown
call|)
argument_list|(
name|client
operator|->
name|shutdown_arg
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
name|client
operator|->
name|shutdown
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|shutdown_arg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|->
name|newstate
operator|>
name|NS_CLIENTSTATE_READY
condition|)
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_READY
expr_stmt|;
operator|(
name|void
operator|)
name|exit_check
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|client_create
parameter_list|(
name|ns_clientmgr_t
modifier|*
name|manager
parameter_list|,
name|ns_client_t
modifier|*
modifier|*
name|clientp
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Caller must be holding the manager lock. 	 * 	 * Note: creating a client does not add the client to the 	 * manager's client list or set the client's manager pointer. 	 * The caller is responsible for that. 	 */
name|REQUIRE
argument_list|(
name|clientp
operator|!=
name|NULL
operator|&&
operator|*
name|clientp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|client
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|manager
operator|->
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_client
goto|;
name|isc_task_setname
argument_list|(
name|client
operator|->
name|task
argument_list|,
literal|"client"
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|client
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|manager
operator|->
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|client_timeout
argument_list|,
name|client
argument_list|,
operator|&
name|client
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_task
goto|;
name|client
operator|->
name|timerset
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|message
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_timer
goto|;
comment|/* XXXRTH  Hardwired constants */
name|client
operator|->
name|sendevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|client
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|client_senddone
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_socketevent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|sendevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_message
goto|;
block|}
name|client
operator|->
name|recvbuf
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|RECV_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|recvbuf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_sendevent
goto|;
block|}
name|client
operator|->
name|recvevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|client
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|client_request
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_socketevent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|recvevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_recvbuf
goto|;
block|}
name|client
operator|->
name|magic
operator|=
name|NS_CLIENT_MAGIC
expr_stmt|;
name|client
operator|->
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|client
operator|->
name|manager
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_INACTIVE
expr_stmt|;
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_MAX
expr_stmt|;
name|client
operator|->
name|naccepts
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|nreads
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|nsends
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|nrecvs
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|nupdates
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|nctls
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|view
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|dispatch
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|udpsocket
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|tcplistener
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|tcpsocket
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|tcpmsg_valid
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|tcpbuf
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|opt
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|udpsize
operator|=
literal|512
expr_stmt|;
name|client
operator|->
name|extflags
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|shutdown
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|shutdown_arg
operator|=
name|NULL
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|client
operator|->
name|signername
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|mortal
operator|=
name|ISC_FALSE
expr_stmt|;
name|client
operator|->
name|tcpquota
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|recursionquota
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|interface
operator|=
name|NULL
expr_stmt|;
name|client
operator|->
name|peeraddr_valid
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|client
operator|->
name|ctlevent
argument_list|,
sizeof|sizeof
argument_list|(
name|client
operator|->
name|ctlevent
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NS_EVENT_CLIENTCONTROL
argument_list|,
name|client_start
argument_list|,
name|client
argument_list|,
name|client
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize FORMERR cache to sentinel value that will not match 	 * any actual FORMERR response. 	 */
name|isc_sockaddr_any
argument_list|(
operator|&
name|client
operator|->
name|formerrcache
operator|.
name|addr
argument_list|)
expr_stmt|;
name|client
operator|->
name|formerrcache
operator|.
name|time
operator|=
literal|0
expr_stmt|;
name|client
operator|->
name|formerrcache
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We call the init routines for the various kinds of client here, 	 * after we have created an otherwise valid client, because some 	 * of them call routines that REQUIRE(NS_CLIENT_VALID(client)). 	 */
name|result
operator|=
name|ns_query_init
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_recvevent
goto|;
name|result
operator|=
name|isc_task_onshutdown
argument_list|(
name|client
operator|->
name|task
argument_list|,
name|client_shutdown
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_query
goto|;
name|CTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
operator|*
name|clientp
operator|=
name|client
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_query
label|:
name|ns_query_free
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|cleanup_recvevent
label|:
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|client
operator|->
name|recvevent
argument_list|)
expr_stmt|;
name|cleanup_recvbuf
label|:
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|recvbuf
argument_list|,
name|RECV_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|cleanup_sendevent
label|:
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|client
operator|->
name|sendevent
argument_list|)
expr_stmt|;
name|client
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|cleanup_message
label|:
name|dns_message_destroy
argument_list|(
operator|&
name|client
operator|->
name|message
argument_list|)
expr_stmt|;
name|cleanup_timer
label|:
name|isc_timer_detach
argument_list|(
operator|&
name|client
operator|->
name|timer
argument_list|)
expr_stmt|;
name|cleanup_task
label|:
name|isc_task_detach
argument_list|(
operator|&
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
name|cleanup_client
label|:
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|client
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|client
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_read
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_tcpmsg_readmessage
argument_list|(
operator|&
name|client
operator|->
name|tcpmsg
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|client_request
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Set a timeout to limit the amount of time we will wait 	 * for a request on this TCP connection. 	 */
name|ns_client_settimeout
argument_list|(
name|client
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_READING
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nreads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|client
operator|->
name|nreads
operator|++
expr_stmt|;
return|return;
name|fail
label|:
name|ns_client_next
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_newconn
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|nevent
init|=
operator|(
name|isc_socket_newconnev_t
operator|*
operator|)
name|event
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_NEWCONN
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|client
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|client
operator|->
name|task
operator|==
name|task
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|state
operator|==
name|NS_CLIENTSTATE_READY
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|naccepts
operator|==
literal|1
argument_list|)
expr_stmt|;
name|client
operator|->
name|naccepts
operator|--
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|interface
operator|->
name|ntcpcurrent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|interface
operator|->
name|ntcpcurrent
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * We must take ownership of the new socket before the exit 	 * check to make sure it gets destroyed if we decide to exit. 	 */
if|if
condition|(
name|nevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|client
operator|->
name|tcpsocket
operator|=
name|nevent
operator|->
name|newsocket
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_READING
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_socket_getpeername
argument_list|(
name|client
operator|->
name|tcpsocket
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
name|client
operator|->
name|peeraddr_valid
operator|=
name|ISC_TRUE
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"new TCP connection"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXXRTH  What should we do?  We're trying to accept but 		 *         it didn't work.  If we just give up, then TCP 		 *	   service may eventually stop. 		 * 		 *	   For now, we just go idle. 		 * 		 *	   Going idle is probably the right thing if the 		 *	   I/O was canceled. 		 */
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"accept failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|nevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_check
argument_list|(
name|client
argument_list|)
condition|)
goto|goto
name|freeevent
goto|;
if|if
condition|(
name|nevent
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|int
name|match
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_g_server
operator|->
name|blackholeacl
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|ns_g_server
operator|->
name|blackholeacl
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"blackholed connection attempt"
argument_list|)
expr_stmt|;
name|client
operator|->
name|newstate
operator|=
name|NS_CLIENTSTATE_READY
expr_stmt|;
operator|(
name|void
operator|)
name|exit_check
argument_list|(
name|client
argument_list|)
expr_stmt|;
goto|goto
name|freeevent
goto|;
block|}
name|INSIST
argument_list|(
name|client
operator|->
name|tcpmsg_valid
operator|==
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_tcpmsg_init
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|client
operator|->
name|tcpsocket
argument_list|,
operator|&
name|client
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|client
operator|->
name|tcpmsg_valid
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Let a new client take our place immediately, before 		 * we wait for a request packet.  If we don't, 		 * telnetting to port 53 (once per CPU) will 		 * deny service to legititmate TCP clients. 		 */
name|result
operator|=
name|isc_quota_attach
argument_list|(
operator|&
name|ns_g_server
operator|->
name|tcpquota
argument_list|,
operator|&
name|client
operator|->
name|tcpquota
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ns_client_replace
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"no more TCP clients: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|client_read
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
name|freeevent
label|:
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_accept
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_accept
argument_list|(
name|client
operator|->
name|tcplistener
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|client_newconn
argument_list|,
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_socket_accept() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXXRTH  What should we do?  We're trying to accept but 		 *         it didn't work.  If we just give up, then TCP 		 *	   service may eventually stop. 		 * 		 *	   For now, we just go idle. 		 */
return|return;
block|}
name|INSIST
argument_list|(
name|client
operator|->
name|naccepts
operator|==
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|naccepts
operator|++
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
name|client
operator|->
name|interface
operator|->
name|ntcpcurrent
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|client
operator|->
name|interface
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|client_udprecv
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|CTRACE
argument_list|(
literal|"udprecv"
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|client
operator|->
name|recvbuf
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|RECV_BUFFER_SIZE
expr_stmt|;
name|result
operator|=
name|isc_socket_recv2
argument_list|(
name|client
operator|->
name|udpsocket
argument_list|,
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|client
operator|->
name|task
argument_list|,
name|client
operator|->
name|recvevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_socket_recv2() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * This cannot happen in the current implementation, since 		 * isc_socket_recv2() cannot fail if flags == 0. 		 * 		 * If this does fail, we just go idle. 		 */
return|return;
block|}
name|INSIST
argument_list|(
name|client
operator|->
name|nrecvs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|nrecvs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_attach
parameter_list|(
name|ns_client_t
modifier|*
name|source
parameter_list|,
name|ns_client_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|NS_CLIENT_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|ns_client_log
argument_list|(
name|source
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"ns_client_attach: ref = %d"
argument_list|,
name|source
operator|->
name|references
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_detach
parameter_list|(
name|ns_client_t
modifier|*
modifier|*
name|clientp
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
init|=
operator|*
name|clientp
decl_stmt|;
name|client
operator|->
name|references
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|references
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|clientp
operator|=
name|NULL
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_CLIENT
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"ns_client_detach: ref = %d"
argument_list|,
name|client
operator|->
name|references
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit_check
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|ns_client_shuttingdown
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
return|return
operator|(
name|ISC_TF
argument_list|(
name|client
operator|->
name|newstate
operator|==
name|NS_CLIENTSTATE_FREED
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_client_replace
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CTRACE
argument_list|(
literal|"replace"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ns_clientmgr_createclients
argument_list|(
name|client
operator|->
name|manager
argument_list|,
literal|1
argument_list|,
name|client
operator|->
name|interface
argument_list|,
operator|(
name|TCP_CLIENT
argument_list|(
name|client
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * The responsibility for listening for new requests is hereby 	 * transferred to the new client.  Therefore, the old client 	 * should refrain from listening for any more requests. 	 */
name|client
operator|->
name|mortal
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  *** Client Manager  ***/
end_comment

begin_function
specifier|static
name|void
name|clientmgr_destroy
parameter_list|(
name|ns_clientmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|active
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
argument_list|)
expr_stmt|;
name|MTRACE
argument_list|(
literal|"clientmgr_destroy"
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_clientmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|ns_clientmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|ns_clientmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_manager
goto|;
name|manager
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|manager
operator|->
name|taskmgr
operator|=
name|taskmgr
expr_stmt|;
name|manager
operator|->
name|timermgr
operator|=
name|timermgr
expr_stmt|;
name|manager
operator|->
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|active
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
name|MANAGER_MAGIC
expr_stmt|;
name|MTRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_manager
label|:
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_clientmgr_destroy
parameter_list|(
name|ns_clientmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|ns_clientmgr_t
modifier|*
name|manager
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|isc_boolean_t
name|need_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|MTRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|client
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
init|;
name|client
operator|!=
name|NULL
condition|;
name|client
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|client
argument_list|,
name|link
argument_list|)
control|)
name|isc_task_shutdown
argument_list|(
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
for|for
control|(
name|client
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|manager
operator|->
name|active
argument_list|)
init|;
name|client
operator|!=
name|NULL
condition|;
name|client
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|client
argument_list|,
name|link
argument_list|)
control|)
name|isc_task_shutdown
argument_list|(
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
for|for
control|(
name|client
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
init|;
name|client
operator|!=
name|NULL
condition|;
name|client
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|client
argument_list|,
name|link
argument_list|)
control|)
name|isc_task_shutdown
argument_list|(
name|client
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|active
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
condition|)
name|need_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
name|clientmgr_destroy
argument_list|(
name|manager
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_clientmgr_createclients
parameter_list|(
name|ns_clientmgr_t
modifier|*
name|manager
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|,
name|ns_interface_t
modifier|*
name|ifp
parameter_list|,
name|isc_boolean_t
name|tcp
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MTRACE
argument_list|(
literal|"createclients"
argument_list|)
expr_stmt|;
comment|/* 	 * We MUST lock the manager lock for the entire client creation 	 * process.  If we didn't do this, then a client could get a 	 * shutdown event and disappear out from under us. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|isc_event_t
modifier|*
name|ev
decl_stmt|;
comment|/* 		 * Allocate a client.  First try to get a recycled one; 		 * if that fails, make a new one. 		 */
name|client
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|manager
operator|->
name|inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|!=
name|NULL
condition|)
block|{
name|MTRACE
argument_list|(
literal|"recycle"
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|manager
operator|->
name|inactive
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|MTRACE
argument_list|(
literal|"create new"
argument_list|)
expr_stmt|;
name|result
operator|=
name|client_create
argument_list|(
name|manager
argument_list|,
operator|&
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
name|ns_interface_attach
argument_list|(
name|ifp
argument_list|,
operator|&
name|client
operator|->
name|interface
argument_list|)
expr_stmt|;
name|client
operator|->
name|state
operator|=
name|NS_CLIENTSTATE_READY
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|recursionquota
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcp
condition|)
block|{
name|client
operator|->
name|attributes
operator||=
name|NS_CLIENTATTR_TCP
expr_stmt|;
name|isc_socket_attach
argument_list|(
name|ifp
operator|->
name|tcpsocket
argument_list|,
operator|&
name|client
operator|->
name|tcplistener
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|dns_dispatch_attach
argument_list|(
name|ifp
operator|->
name|udpdispatch
argument_list|,
operator|&
name|client
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|sock
operator|=
name|dns_dispatch_getsocket
argument_list|(
name|client
operator|->
name|dispatch
argument_list|)
expr_stmt|;
name|isc_socket_attach
argument_list|(
name|sock
argument_list|,
operator|&
name|client
operator|->
name|udpsocket
argument_list|)
expr_stmt|;
block|}
name|client
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|active
argument_list|,
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|client
operator|->
name|list
operator|=
operator|&
name|manager
operator|->
name|active
expr_stmt|;
name|INSIST
argument_list|(
name|client
operator|->
name|nctls
operator|==
literal|0
argument_list|)
expr_stmt|;
name|client
operator|->
name|nctls
operator|++
expr_stmt|;
name|ev
operator|=
operator|&
name|client
operator|->
name|ctlevent
expr_stmt|;
name|isc_task_send
argument_list|(
name|client
operator|->
name|task
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We managed to create at least one client, so we 		 * declare victory. 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_sockaddr_t
modifier|*
name|ns_client_getsockaddr
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|)
block|{
return|return
operator|(
operator|&
name|client
operator|->
name|peeraddr
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_client_checkaclsilent
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|,
name|isc_boolean_t
name|default_allow
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|match
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|default_allow
condition|)
goto|goto
name|allow
goto|;
else|else
goto|goto
name|deny
goto|;
block|}
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|client
operator|->
name|signer
argument_list|,
name|acl
argument_list|,
operator|&
name|ns_g_server
operator|->
name|aclenv
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deny
goto|;
comment|/* Internal error, already logged. */
if|if
condition|(
name|match
operator|>
literal|0
condition|)
goto|goto
name|allow
goto|;
goto|goto
name|deny
goto|;
comment|/* Negative match or no match. */
name|allow
label|:
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|deny
label|:
return|return
operator|(
name|DNS_R_REFUSED
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|ns_client_checkacl
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|,
name|dns_acl_t
modifier|*
name|acl
parameter_list|,
name|isc_boolean_t
name|default_allow
parameter_list|,
name|int
name|log_level
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ns_client_checkaclsilent
argument_list|(
name|client
argument_list|,
name|acl
argument_list|,
name|default_allow
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s approved"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
else|else
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_SECURITY
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|log_level
argument_list|,
literal|"%s denied"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_client_name
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|char
modifier|*
name|peerbuf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|client
operator|->
name|peeraddr_valid
condition|)
name|isc_sockaddr_format
argument_list|(
operator|&
name|client
operator|->
name|peeraddr
argument_list|,
name|peerbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|peerbuf
argument_list|,
name|len
argument_list|,
literal|"@%p"
argument_list|,
name|client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_logv
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ns_client_name
argument_list|(
name|client
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|client
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_bind"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|client
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_default"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
name|client
operator|->
name|view
operator|->
name|name
expr_stmt|;
name|sep
operator|=
literal|": view "
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|ns_g_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"client %s%s%s: %s"
argument_list|,
name|peerbuf
argument_list|,
name|sep
argument_list|,
name|name
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_log
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ns_client_logv
argument_list|(
name|client
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_aclmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|typebuf
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|typebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s '%s/%s/%s'"
argument_list|,
name|msg
argument_list|,
name|namebuf
argument_list|,
name|typebuf
argument_list|,
name|classbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ns_client_dumpmessage
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|isc_buffer_t
name|buffer
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
literal|1024
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Note that these are multiline debug messages.  We want a newline 	 * to appear in the log after each message. 	 */
do|do
block|{
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
break|break;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_totext
argument_list|(
name|client
operator|->
name|message
argument_list|,
operator|&
name|dns_master_style_debug
argument_list|,
literal|0
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|NS_LOGCATEGORY_UNMATCHED
argument_list|,
name|NS_LOGMODULE_CLIENT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"%s\n%.*s"
argument_list|,
name|reason
argument_list|,
operator|(
name|int
operator|)
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buffer
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
do|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|client
operator|->
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_client_dumprecursing
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|ns_clientmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|client
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|manager
operator|->
name|recursing
argument_list|)
expr_stmt|;
while|while
condition|(
name|client
operator|!=
name|NULL
condition|)
block|{
name|ns_client_name
argument_list|(
name|client
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|view
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|client
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_bind"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|client
operator|->
name|view
operator|->
name|name
argument_list|,
literal|"_default"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|name
operator|=
name|client
operator|->
name|view
operator|->
name|name
expr_stmt|;
name|sep
operator|=
literal|": view "
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
block|}
name|dns_name_format
argument_list|(
name|client
operator|->
name|query
operator|.
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; client %s%s%s: '%s' requesttime %d\n"
argument_list|,
name|peerbuf
argument_list|,
name|sep
argument_list|,
name|name
argument_list|,
name|namebuf
argument_list|,
name|client
operator|->
name|requesttime
argument_list|)
expr_stmt|;
name|client
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|client
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

