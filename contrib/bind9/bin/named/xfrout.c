begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: xfrout.c,v 1.101.2.5.2.12 2005/10/14 02:13:05 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/formatcheck.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/journal.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/peer.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/soa.h>
end_include

begin_include
include|#
directive|include
file|<dns/timer.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<dns/zt.h>
end_include

begin_include
include|#
directive|include
file|<named/client.h>
end_include

begin_include
include|#
directive|include
file|<named/log.h>
end_include

begin_include
include|#
directive|include
file|<named/server.h>
end_include

begin_include
include|#
directive|include
file|<named/xfrout.h>
end_include

begin_comment
comment|/*  * Outgoing AXFR and IXFR.  */
end_comment

begin_comment
comment|/*  * TODO:  *  - IXFR over UDP  */
end_comment

begin_define
define|#
directive|define
name|XFROUT_COMMON_LOGARGS
define|\
value|ns_g_lctx, DNS_LOGCATEGORY_XFER_OUT, NS_LOGMODULE_XFER_OUT
end_define

begin_define
define|#
directive|define
name|XFROUT_PROTOCOL_LOGARGS
define|\
value|XFROUT_COMMON_LOGARGS, ISC_LOG_INFO
end_define

begin_define
define|#
directive|define
name|XFROUT_DEBUG_LOGARGS
parameter_list|(
name|n
parameter_list|)
define|\
value|XFROUT_COMMON_LOGARGS, ISC_LOG_DEBUG(n)
end_define

begin_define
define|#
directive|define
name|XFROUT_RR_LOGARGS
define|\
value|XFROUT_COMMON_LOGARGS, XFROUT_RR_LOGLEVEL
end_define

begin_define
define|#
directive|define
name|XFROUT_RR_LOGLEVEL
value|ISC_LOG_DEBUG(8)
end_define

begin_comment
comment|/*  * Fail unconditionally and log as a client error.  * The test against ISC_R_SUCCESS is there to keep the Solaris compiler  * from complaining about "end-of-loop code not reached".  */
end_comment

begin_define
define|#
directive|define
name|FAILC
parameter_list|(
name|code
parameter_list|,
name|msg
parameter_list|)
define|\
value|do {							\ 		result = (code);				\ 		ns_client_log(client, DNS_LOGCATEGORY_XFER_OUT, \ 			   NS_LOGMODULE_XFER_OUT, ISC_LOG_INFO, \ 			   "bad zone transfer request: %s (%s)", \ 		      	   msg, isc_result_totext(code));	\ 		if (result != ISC_R_SUCCESS) goto failure;	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|FAILQ
parameter_list|(
name|code
parameter_list|,
name|msg
parameter_list|,
name|question
parameter_list|,
name|rdclass
parameter_list|)
define|\
value|do {							\ 		char _buf1[DNS_NAME_FORMATSIZE];		\ 		char _buf2[DNS_RDATACLASS_FORMATSIZE]; 		\ 		result = (code);				\ 		dns_name_format(question, _buf1, sizeof(_buf1));  \ 		dns_rdataclass_format(rdclass, _buf2, sizeof(_buf2)); \ 		ns_client_log(client, DNS_LOGCATEGORY_XFER_OUT, \ 			   NS_LOGMODULE_XFER_OUT, ISC_LOG_INFO, \ 			   "bad zone transfer request: '%s/%s': %s (%s)", \ 		      	   _buf1, _buf2, msg, isc_result_totext(code));	\ 		if (result != ISC_R_SUCCESS) goto failure;	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op); 					\ 		if (result != ISC_R_SUCCESS) goto failure; 	\ 	} while (0)
end_define

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * A db_rr_iterator_t is an iterator that iterates over an entire database,  * returning one RR at a time, in some arbitrary order.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|db_rr_iterator
name|db_rr_iterator_t
typedef|;
end_typedef

begin_struct
struct|struct
name|db_rr_iterator
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbit
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdatasetit
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|isc_result_t
name|db_rr_iterator_init
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|db_rr_iterator_first
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|db_rr_iterator_next
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_rr_iterator_current
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_rr_iterator_destroy
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|isc_result_t
name|db_rr_iterator_init
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|it
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|it
operator|->
name|dbit
operator|=
name|NULL
expr_stmt|;
name|it
operator|->
name|ver
operator|=
name|ver
expr_stmt|;
name|it
operator|->
name|now
operator|=
name|now
expr_stmt|;
name|it
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|it
operator|->
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|it
operator|->
name|dbit
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|it
operator|->
name|rdatasetit
operator|=
name|NULL
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|it
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|it
operator|->
name|fixedname
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|db_rr_iterator_first
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
block|{
name|it
operator|->
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|it
operator|->
name|dbit
argument_list|)
expr_stmt|;
comment|/* 	 * The top node may be empty when out of zone glue exists. 	 * Walk the tree to find the first node with data. 	 */
while|while
condition|(
name|it
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|it
operator|->
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|it
operator|->
name|dbit
argument_list|,
operator|&
name|it
operator|->
name|node
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|it
operator|->
name|fixedname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|it
operator|->
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|it
operator|->
name|db
argument_list|,
name|it
operator|->
name|node
argument_list|,
name|it
operator|->
name|ver
argument_list|,
name|it
operator|->
name|now
argument_list|,
operator|&
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|it
operator|->
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * This node is empty. Try next node. 			 */
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|it
operator|->
name|db
argument_list|,
operator|&
name|it
operator|->
name|node
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|it
operator|->
name|dbit
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dns_rdatasetiter_current
argument_list|(
name|it
operator|->
name|rdatasetit
argument_list|,
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|db_rr_iterator_next
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
block|{
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|INSIST
argument_list|(
name|it
operator|->
name|dbit
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|it
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|it
operator|->
name|rdatasetit
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
comment|/* 		 * The while loop body is executed more than once 		 * only when an empty dbnode needs to be skipped. 		 */
while|while
condition|(
name|it
operator|->
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|it
operator|->
name|db
argument_list|,
operator|&
name|it
operator|->
name|node
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|it
operator|->
name|dbit
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
comment|/* We are at the end of the entire database. */
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|it
operator|->
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|it
operator|->
name|dbit
argument_list|,
operator|&
name|it
operator|->
name|node
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|it
operator|->
name|fixedname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|it
operator|->
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|it
operator|->
name|db
argument_list|,
name|it
operator|->
name|node
argument_list|,
name|it
operator|->
name|ver
argument_list|,
name|it
operator|->
name|now
argument_list|,
operator|&
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|it
operator|->
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
name|dns_rdatasetiter_current
argument_list|(
name|it
operator|->
name|rdatasetit
argument_list|,
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
name|it
operator|->
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
return|return
operator|(
name|it
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_rr_iterator_pause
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|dns_dbiterator_pause
argument_list|(
name|it
operator|->
name|dbit
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_rr_iterator_destroy
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|rdatasetit
operator|!=
name|NULL
condition|)
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|it
operator|->
name|rdatasetit
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|it
operator|->
name|db
argument_list|,
operator|&
name|it
operator|->
name|node
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|it
operator|->
name|dbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_rr_iterator_current
parameter_list|(
name|db_rr_iterator_t
modifier|*
name|it
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
operator|*
name|name
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|it
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|it
operator|->
name|fixedname
argument_list|)
expr_stmt|;
operator|*
name|ttl
operator|=
name|it
operator|->
name|rdataset
operator|.
name|ttl
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|it
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|it
operator|->
name|rdataset
argument_list|,
operator|&
name|it
operator|->
name|rdata
argument_list|)
expr_stmt|;
operator|*
name|rdata
operator|=
operator|&
name|it
operator|->
name|rdata
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/* Log an RR (for debugging) */
end_comment

begin_function
specifier|static
name|void
name|log_rr
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_uint32_t
name|ttl
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|char
name|mem
index|[
literal|2000
index|]
decl_stmt|;
name|dns_rdatalist_t
name|rdl
decl_stmt|;
name|dns_rdataset_t
name|rds
decl_stmt|;
name|dns_rdata_t
name|rd
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|rdl
operator|.
name|type
operator|=
name|rdata
operator|->
name|type
expr_stmt|;
name|rdl
operator|.
name|rdclass
operator|=
name|rdata
operator|->
name|rdclass
expr_stmt|;
name|rdl
operator|.
name|ttl
operator|=
name|ttl
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdl
operator|.
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|rdl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rds
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rd
argument_list|)
expr_stmt|;
name|dns_rdata_clone
argument_list|(
name|rdata
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdl
operator|.
name|rdata
argument_list|,
operator|&
name|rd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
operator|&
name|rdl
argument_list|,
operator|&
name|rds
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|mem
argument_list|,
sizeof|sizeof
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_totext
argument_list|(
operator|&
name|rds
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * We could use xfrout_log(), but that would produce 	 * very long lines with a repetitive prefix. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Get rid of final newline. 		 */
name|INSIST
argument_list|(
name|buf
operator|.
name|used
operator|>=
literal|1
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|base
operator|)
index|[
name|buf
operator|.
name|used
operator|-
literal|1
index|]
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|used
operator|--
expr_stmt|;
name|isc_log_write
argument_list|(
name|XFROUT_RR_LOGARGS
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|isc_buffer_base
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_log_write
argument_list|(
name|XFROUT_RR_LOGARGS
argument_list|,
literal|"<RR too large to print>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * An 'rrstream_t' is a polymorphic iterator that returns  * a stream of resource records.  There are multiple implementations,  * e.g. for generating AXFR and IXFR records streams.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|rrstream_methods
name|rrstream_methods_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rrstream
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|rrstream_methods_t
modifier|*
name|methods
decl_stmt|;
block|}
name|rrstream_t
typedef|;
end_typedef

begin_struct
struct|struct
name|rrstream_methods
block|{
name|isc_result_t
function_decl|(
modifier|*
name|first
function_decl|)
parameter_list|(
name|rrstream_t
modifier|*
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|next
function_decl|)
parameter_list|(
name|rrstream_t
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|current
function_decl|)
parameter_list|(
name|rrstream_t
modifier|*
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
parameter_list|,
name|isc_uint32_t
modifier|*
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pause
function_decl|)
parameter_list|(
name|rrstream_t
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|destroy
function_decl|)
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|rrstream_noop_pause
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * An 'ixfr_rrstream_t' is an 'rrstream_t' that returns  * an IXFR-like RR stream from a journal file.  *  * The SOA at the beginning of each sequence of additions  * or deletions are included in the stream, but the extra  * SOAs at the beginning and end of the entire transfer are  * not included.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ixfr_rrstream
block|{
name|rrstream_t
name|common
decl_stmt|;
name|dns_journal_t
modifier|*
name|journal
decl_stmt|;
block|}
name|ixfr_rrstream_t
typedef|;
end_typedef

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|ixfr_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|ixfr_rrstream_methods
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Returns: anything dns_journal_open() or dns_journal_iter_init()  * may return.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|ixfr_rrstream_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|journal_filename
parameter_list|,
name|isc_uint32_t
name|begin_serial
parameter_list|,
name|isc_uint32_t
name|end_serial
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|ixfr_rrstream_t
modifier|*
name|s
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|sp
operator|!=
name|NULL
operator|&&
operator|*
name|sp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|s
operator|->
name|common
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|s
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|ixfr_rrstream_methods
expr_stmt|;
name|s
operator|->
name|journal
operator|=
name|NULL
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_open
argument_list|(
name|mctx
argument_list|,
name|journal_filename
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|s
operator|->
name|journal
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_iter_init
argument_list|(
name|s
operator|->
name|journal
argument_list|,
name|begin_serial
argument_list|,
name|end_serial
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
operator|(
name|rrstream_t
operator|*
operator|)
name|s
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
name|ixfr_rrstream_destroy
argument_list|(
operator|(
name|rrstream_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|ixfr_rrstream_first
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|ixfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|ixfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
return|return
operator|(
name|dns_journal_first_rr
argument_list|(
name|s
operator|->
name|journal
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|ixfr_rrstream_next
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|ixfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|ixfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
return|return
operator|(
name|dns_journal_next_rr
argument_list|(
name|s
operator|->
name|journal
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixfr_rrstream_current
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|ixfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|ixfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|dns_journal_current_rr
argument_list|(
name|s
operator|->
name|journal
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixfr_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|ixfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|ixfr_rrstream_t
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|journal
operator|!=
literal|0
condition|)
name|dns_journal_destroy
argument_list|(
operator|&
name|s
operator|->
name|journal
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|s
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|ixfr_rrstream_methods
init|=
block|{
name|ixfr_rrstream_first
block|,
name|ixfr_rrstream_next
block|,
name|ixfr_rrstream_current
block|,
name|rrstream_noop_pause
block|,
name|ixfr_rrstream_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * An 'axfr_rrstream_t' is an 'rrstream_t' that returns  * an AXFR-like RR stream from a database.  *  * The SOAs at the beginning and end of the transfer are  * not included in the stream.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|axfr_rrstream
block|{
name|rrstream_t
name|common
decl_stmt|;
name|db_rr_iterator_t
name|it
decl_stmt|;
name|isc_boolean_t
name|it_valid
decl_stmt|;
block|}
name|axfr_rrstream_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|axfr_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|axfr_rrstream_methods
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|axfr_rrstream_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|sp
operator|!=
name|NULL
operator|&&
operator|*
name|sp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|s
operator|->
name|common
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|s
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|axfr_rrstream_methods
expr_stmt|;
name|s
operator|->
name|it_valid
operator|=
name|ISC_FALSE
expr_stmt|;
name|CHECK
argument_list|(
name|db_rr_iterator_init
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|it_valid
operator|=
name|ISC_TRUE
expr_stmt|;
operator|*
name|sp
operator|=
operator|(
name|rrstream_t
operator|*
operator|)
name|s
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
name|axfr_rrstream_destroy
argument_list|(
operator|(
name|rrstream_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|axfr_rrstream_first
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|axfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|db_rr_iterator_first
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* Skip SOA records. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dns_name_t
modifier|*
name|name_dummy
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|ttl_dummy
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|db_rr_iterator_current
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|,
operator|&
name|name_dummy
argument_list|,
operator|&
name|ttl_dummy
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|!=
name|dns_rdatatype_soa
condition|)
break|break;
name|result
operator|=
name|db_rr_iterator_next
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|axfr_rrstream_next
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|axfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* Skip SOA records. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dns_name_t
modifier|*
name|name_dummy
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|ttl_dummy
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|db_rr_iterator_next
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|db_rr_iterator_current
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|,
operator|&
name|name_dummy
argument_list|,
operator|&
name|ttl_dummy
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|!=
name|dns_rdatatype_soa
condition|)
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|axfr_rrstream_current
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|axfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|db_rr_iterator_current
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|axfr_rrstream_pause
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|axfr_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|db_rr_iterator_pause
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|axfr_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|axfr_rrstream_t
modifier|*
name|s
init|=
operator|(
name|axfr_rrstream_t
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|it_valid
condition|)
name|db_rr_iterator_destroy
argument_list|(
operator|&
name|s
operator|->
name|it
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|s
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|axfr_rrstream_methods
init|=
block|{
name|axfr_rrstream_first
block|,
name|axfr_rrstream_next
block|,
name|axfr_rrstream_current
block|,
name|axfr_rrstream_pause
block|,
name|axfr_rrstream_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * An 'soa_rrstream_t' is a degenerate 'rrstream_t' that returns  * a single SOA record.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|soa_rrstream
block|{
name|rrstream_t
name|common
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|soa_tuple
decl_stmt|;
block|}
name|soa_rrstream_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|soa_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|soa_rrstream_methods
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|soa_rrstream_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|soa_rrstream_t
modifier|*
name|s
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|sp
operator|!=
name|NULL
operator|&&
operator|*
name|sp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|s
operator|->
name|common
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|s
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|soa_rrstream_methods
expr_stmt|;
name|s
operator|->
name|soa_tuple
operator|=
name|NULL
expr_stmt|;
name|CHECK
argument_list|(
name|dns_db_createsoatuple
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|mctx
argument_list|,
name|DNS_DIFFOP_EXISTS
argument_list|,
operator|&
name|s
operator|->
name|soa_tuple
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
operator|(
name|rrstream_t
operator|*
operator|)
name|s
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
name|soa_rrstream_destroy
argument_list|(
operator|(
name|rrstream_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|soa_rrstream_first
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|soa_rrstream_next
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|soa_rrstream_current
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|soa_rrstream_t
modifier|*
name|s
init|=
operator|(
name|soa_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
operator|*
name|name
operator|=
operator|&
name|s
operator|->
name|soa_tuple
operator|->
name|name
expr_stmt|;
operator|*
name|ttl
operator|=
name|s
operator|->
name|soa_tuple
operator|->
name|ttl
expr_stmt|;
operator|*
name|rdata
operator|=
operator|&
name|s
operator|->
name|soa_tuple
operator|->
name|rdata
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soa_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|soa_rrstream_t
modifier|*
name|s
init|=
operator|(
name|soa_rrstream_t
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|soa_tuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|s
operator|->
name|soa_tuple
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|s
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|soa_rrstream_methods
init|=
block|{
name|soa_rrstream_first
block|,
name|soa_rrstream_next
block|,
name|soa_rrstream_current
block|,
name|rrstream_noop_pause
block|,
name|soa_rrstream_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * A 'compound_rrstream_t' objects owns a soa_rrstream  * and another rrstream, the "data stream".  It returns  * a concatenated stream consisting of the soa_rrstream, then  * the data stream, then the soa_rrstream again.  *  * The component streams are owned by the compound_rrstream_t  * and are destroyed with it.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|compound_rrstream
block|{
name|rrstream_t
name|common
decl_stmt|;
name|rrstream_t
modifier|*
name|components
index|[
literal|3
index|]
decl_stmt|;
name|int
name|state
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
block|}
name|compound_rrstream_t
typedef|;
end_typedef

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|compound_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|compound_rrstream_next
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|compound_rrstream_methods
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Requires:  *	soa_stream != NULL&& *soa_stream != NULL  *	data_stream != NULL&& *data_stream != NULL  *	sp != NULL&& *sp == NULL  *  * Ensures:  *	*soa_stream == NULL  *	*data_stream == NULL  *	*sp points to a valid compound_rrstream_t  *	The soa and data streams will be destroyed  *	when the compound_rrstream_t is destroyed.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|compound_rrstream_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|soa_stream
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|data_stream
parameter_list|,
name|rrstream_t
modifier|*
modifier|*
name|sp
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
decl_stmt|;
name|INSIST
argument_list|(
name|sp
operator|!=
name|NULL
operator|&&
operator|*
name|sp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|s
operator|->
name|common
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|s
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|compound_rrstream_methods
expr_stmt|;
name|s
operator|->
name|components
index|[
literal|0
index|]
operator|=
operator|*
name|soa_stream
expr_stmt|;
name|s
operator|->
name|components
index|[
literal|1
index|]
operator|=
operator|*
name|data_stream
expr_stmt|;
name|s
operator|->
name|components
index|[
literal|2
index|]
operator|=
operator|*
name|soa_stream
expr_stmt|;
name|s
operator|->
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
operator|*
name|soa_stream
operator|=
name|NULL
expr_stmt|;
operator|*
name|data_stream
operator|=
name|NULL
expr_stmt|;
operator|*
name|sp
operator|=
operator|(
name|rrstream_t
operator|*
operator|)
name|s
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|compound_rrstream_first
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
init|=
operator|(
name|compound_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|s
operator|->
name|state
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|rrstream_t
modifier|*
name|curstream
init|=
name|s
operator|->
name|components
index|[
name|s
operator|->
name|state
index|]
decl_stmt|;
name|s
operator|->
name|result
operator|=
name|curstream
operator|->
name|methods
operator|->
name|first
argument_list|(
name|curstream
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|->
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
name|s
operator|->
name|state
operator|<
literal|2
condition|)
do|;
return|return
operator|(
name|s
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|compound_rrstream_next
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
init|=
operator|(
name|compound_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|rrstream_t
modifier|*
name|curstream
init|=
name|s
operator|->
name|components
index|[
name|s
operator|->
name|state
index|]
decl_stmt|;
name|s
operator|->
name|result
operator|=
name|curstream
operator|->
name|methods
operator|->
name|next
argument_list|(
name|curstream
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
comment|/* 		 * Make sure locks held by the current stream 		 * are released before we switch streams. 		 */
name|curstream
operator|->
name|methods
operator|->
name|pause
argument_list|(
name|curstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
literal|2
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|s
operator|->
name|state
operator|++
expr_stmt|;
name|curstream
operator|=
name|s
operator|->
name|components
index|[
name|s
operator|->
name|state
index|]
expr_stmt|;
name|s
operator|->
name|result
operator|=
name|curstream
operator|->
name|methods
operator|->
name|first
argument_list|(
name|curstream
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compound_rrstream_current
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
init|=
operator|(
name|compound_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|rrstream_t
modifier|*
name|curstream
decl_stmt|;
name|INSIST
argument_list|(
literal|0
operator|<=
name|s
operator|->
name|state
operator|&&
name|s
operator|->
name|state
operator|<
literal|3
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|s
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|curstream
operator|=
name|s
operator|->
name|components
index|[
name|s
operator|->
name|state
index|]
expr_stmt|;
name|curstream
operator|->
name|methods
operator|->
name|current
argument_list|(
name|curstream
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compound_rrstream_pause
parameter_list|(
name|rrstream_t
modifier|*
name|rs
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
init|=
operator|(
name|compound_rrstream_t
operator|*
operator|)
name|rs
decl_stmt|;
name|rrstream_t
modifier|*
name|curstream
decl_stmt|;
name|INSIST
argument_list|(
literal|0
operator|<=
name|s
operator|->
name|state
operator|&&
name|s
operator|->
name|state
operator|<
literal|3
argument_list|)
expr_stmt|;
name|curstream
operator|=
name|s
operator|->
name|components
index|[
name|s
operator|->
name|state
index|]
expr_stmt|;
name|curstream
operator|->
name|methods
operator|->
name|pause
argument_list|(
name|curstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compound_rrstream_destroy
parameter_list|(
name|rrstream_t
modifier|*
modifier|*
name|rsp
parameter_list|)
block|{
name|compound_rrstream_t
modifier|*
name|s
init|=
operator|(
name|compound_rrstream_t
operator|*
operator|)
operator|*
name|rsp
decl_stmt|;
name|s
operator|->
name|components
index|[
literal|0
index|]
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|s
operator|->
name|components
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|components
index|[
literal|1
index|]
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|s
operator|->
name|components
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|components
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Copy of components[0]. */
name|isc_mem_put
argument_list|(
name|s
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|rrstream_methods_t
name|compound_rrstream_methods
init|=
block|{
name|compound_rrstream_first
block|,
name|compound_rrstream_next
block|,
name|compound_rrstream_current
block|,
name|compound_rrstream_pause
block|,
name|compound_rrstream_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * An 'xfrout_ctx_t' contains the state of an outgoing AXFR or IXFR  * in progress.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|ns_client_t
modifier|*
name|client
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
comment|/* ID of request */
name|dns_name_t
modifier|*
name|qname
decl_stmt|;
comment|/* Question name of request */
name|dns_rdatatype_t
name|qtype
decl_stmt|;
comment|/* dns_rdatatype_{a,i}xfr */
name|dns_rdataclass_t
name|qclass
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
decl_stmt|;
name|isc_quota_t
modifier|*
name|quota
decl_stmt|;
name|rrstream_t
modifier|*
name|stream
decl_stmt|;
comment|/* The XFR RR stream */
name|isc_boolean_t
name|end_of_stream
decl_stmt|;
comment|/* EOS has been reached */
name|isc_buffer_t
name|buf
decl_stmt|;
comment|/* Buffer for message owner 						   names and rdatas */
name|isc_buffer_t
name|txlenbuf
decl_stmt|;
comment|/* Transmit length buffer */
name|isc_buffer_t
name|txbuf
decl_stmt|;
comment|/* Transmit message buffer */
name|void
modifier|*
name|txmem
decl_stmt|;
name|unsigned
name|int
name|txmemlen
decl_stmt|;
name|unsigned
name|int
name|nmsg
decl_stmt|;
comment|/* Number of messages sent */
name|dns_tsigkey_t
modifier|*
name|tsigkey
decl_stmt|;
comment|/* Key used to create TSIG */
name|isc_buffer_t
modifier|*
name|lasttsig
decl_stmt|;
comment|/* the last TSIG */
name|isc_boolean_t
name|many_answers
decl_stmt|;
name|int
name|sends
decl_stmt|;
comment|/* Send in progress */
name|isc_boolean_t
name|shuttingdown
decl_stmt|;
specifier|const
name|char
modifier|*
name|mnemonic
decl_stmt|;
comment|/* Style of transfer */
block|}
name|xfrout_ctx_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|isc_result_t
name|xfrout_ctx_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_rdataclass_t
name|qclass
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_quota_t
modifier|*
name|quota
parameter_list|,
name|rrstream_t
modifier|*
name|stream
parameter_list|,
name|dns_tsigkey_t
modifier|*
name|tsigkey
parameter_list|,
name|isc_buffer_t
modifier|*
name|lasttsig
parameter_list|,
name|unsigned
name|int
name|maxtime
parameter_list|,
name|unsigned
name|int
name|idletime
parameter_list|,
name|isc_boolean_t
name|many_answers
parameter_list|,
name|xfrout_ctx_t
modifier|*
modifier|*
name|xfrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sendstream
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_fail
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_maybe_destroy
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_ctx_destroy
parameter_list|(
name|xfrout_ctx_t
modifier|*
modifier|*
name|xfrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_client_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xfrout_log1
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|zonename
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|5
operator|,
function_decl|6
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|xfrout_log
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**************************************************************************/
end_comment

begin_function
name|void
name|ns_xfr_start
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_rdatatype_t
name|reqtype
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|question_name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|question_rdataset
decl_stmt|;
name|dns_zone_t
modifier|*
name|zone
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|dns_rdataclass_t
name|question_class
decl_stmt|;
name|rrstream_t
modifier|*
name|soa_stream
init|=
name|NULL
decl_stmt|;
name|rrstream_t
modifier|*
name|data_stream
init|=
name|NULL
decl_stmt|;
name|rrstream_t
modifier|*
name|stream
init|=
name|NULL
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|current_soa_tuple
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|soa_name
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|soa_rdataset
decl_stmt|;
name|dns_rdata_t
name|soa_rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_boolean_t
name|have_soa
init|=
name|ISC_FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|mnemonic
init|=
name|NULL
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|client
operator|->
name|mctx
decl_stmt|;
name|dns_message_t
modifier|*
name|request
init|=
name|client
operator|->
name|message
decl_stmt|;
name|xfrout_ctx_t
modifier|*
name|xfr
init|=
name|NULL
decl_stmt|;
name|isc_quota_t
modifier|*
name|quota
init|=
name|NULL
decl_stmt|;
name|dns_transfer_format_t
name|format
init|=
name|client
operator|->
name|view
operator|->
name|transfer_format
decl_stmt|;
name|isc_netaddr_t
name|na
decl_stmt|;
name|dns_peer_t
modifier|*
name|peer
init|=
name|NULL
decl_stmt|;
name|isc_buffer_t
modifier|*
name|tsigbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|journalfile
decl_stmt|;
name|char
name|msg
index|[
name|NS_CLIENT_ACLMSGSIZE
argument_list|(
literal|"zone transfer"
argument_list|)
index|]
decl_stmt|;
name|char
name|keyname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|isc_boolean_t
name|is_poll
init|=
name|ISC_FALSE
decl_stmt|;
switch|switch
condition|(
name|reqtype
condition|)
block|{
case|case
name|dns_rdatatype_axfr
case|:
name|mnemonic
operator|=
literal|"AXFR"
expr_stmt|;
break|break;
case|case
name|dns_rdatatype_ixfr
case|:
name|mnemonic
operator|=
literal|"IXFR"
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_XFER_OUT
argument_list|,
name|NS_LOGMODULE_XFER_OUT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"%s request"
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
comment|/* 	 * Apply quota. 	 */
name|result
operator|=
name|isc_quota_attach
argument_list|(
operator|&
name|ns_g_server
operator|->
name|xfroutquota
argument_list|,
operator|&
name|quota
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|XFROUT_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"%s request denied: %s"
argument_list|,
name|mnemonic
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
comment|/* 	 * Interpret the question section. 	 */
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 	 * The question section must contain exactly one question, and 	 * it must be for AXFR/IXFR as appropriate. 	 */
name|question_name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
operator|&
name|question_name
argument_list|)
expr_stmt|;
name|question_rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|question_name
operator|->
name|list
argument_list|)
expr_stmt|;
name|question_class
operator|=
name|question_rdataset
operator|->
name|rdclass
expr_stmt|;
name|INSIST
argument_list|(
name|question_rdataset
operator|->
name|type
operator|==
name|reqtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_NEXT
argument_list|(
name|question_rdataset
argument_list|,
name|link
argument_list|)
operator|!=
name|NULL
condition|)
name|FAILC
argument_list|(
name|DNS_R_FORMERR
argument_list|,
literal|"multiple questions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
name|FAILC
argument_list|(
name|DNS_R_FORMERR
argument_list|,
literal|"multiple questions"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_zt_find
argument_list|(
name|client
operator|->
name|view
operator|->
name|zonetable
argument_list|,
name|question_name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|FAILQ
argument_list|(
name|DNS_R_NOTAUTH
argument_list|,
literal|"non-authoritative zone"
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dns_zone_gettype
argument_list|(
name|zone
argument_list|)
condition|)
block|{
case|case
name|dns_zone_master
case|:
case|case
name|dns_zone_slave
case|:
break|break;
comment|/* Master and slave zones are OK for transfer. */
default|default:
name|FAILQ
argument_list|(
name|DNS_R_NOTAUTH
argument_list|,
literal|"non-authoritative zone"
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|dns_zone_getdb
argument_list|(
name|zone
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
expr_stmt|;
name|xfrout_log1
argument_list|(
name|client
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"%s question section OK"
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
comment|/* 	 * Check the authority section.  Look for a SOA record with 	 * the same name and class as the question. 	 */
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
control|)
block|{
name|soa_name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|request
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|soa_name
argument_list|)
expr_stmt|;
comment|/* 		 * Ignore data whose owner name is not the zone apex. 		 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|soa_name
argument_list|,
name|question_name
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|soa_rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|soa_name
operator|->
name|list
argument_list|)
init|;
name|soa_rdataset
operator|!=
name|NULL
condition|;
name|soa_rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|soa_rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
comment|/* 			 * Ignore non-SOA data. 			 */
if|if
condition|(
name|soa_rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_soa
condition|)
continue|continue;
if|if
condition|(
name|soa_rdataset
operator|->
name|rdclass
operator|!=
name|question_class
condition|)
continue|continue;
name|CHECK
argument_list|(
name|dns_rdataset_first
argument_list|(
name|soa_rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|soa_rdataset
argument_list|,
operator|&
name|soa_rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|soa_rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|FAILC
argument_list|(
name|DNS_R_FORMERR
argument_list|,
literal|"IXFR authority section "
literal|"has multiple SOAs"
argument_list|)
expr_stmt|;
name|have_soa
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|got_soa
goto|;
block|}
block|}
name|got_soa
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|xfrout_log1
argument_list|(
name|client
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|6
argument_list|)
argument_list|,
literal|"%s authority section OK"
argument_list|,
name|mnemonic
argument_list|)
expr_stmt|;
comment|/* 	 * Decide whether to allow this transfer. 	 */
name|ns_client_aclmsg
argument_list|(
literal|"zone transfer"
argument_list|,
name|question_name
argument_list|,
name|reqtype
argument_list|,
name|client
operator|->
name|view
operator|->
name|rdclass
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ns_client_checkacl
argument_list|(
name|client
argument_list|,
name|msg
argument_list|,
name|dns_zone_getxfracl
argument_list|(
name|zone
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_LOG_ERROR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * AXFR over UDP is not possible. 	 */
if|if
condition|(
name|reqtype
operator|==
name|dns_rdatatype_axfr
operator|&&
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
name|FAILC
argument_list|(
name|DNS_R_FORMERR
argument_list|,
literal|"attempted AXFR over UDP"
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the requesting server in the peer table. 	 */
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
operator|&
name|client
operator|->
name|peeraddr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_peerlist_peerbyaddr
argument_list|(
name|client
operator|->
name|view
operator|->
name|peers
argument_list|,
operator|&
name|na
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
comment|/* 	 * Decide on the transfer format (one-answer or many-answers). 	 */
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_peer_gettransferformat
argument_list|(
name|peer
argument_list|,
operator|&
name|format
argument_list|)
expr_stmt|;
comment|/* 	 * Get a dynamically allocated copy of the current SOA. 	 */
name|CHECK
argument_list|(
name|dns_db_createsoatuple
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|mctx
argument_list|,
name|DNS_DIFFOP_EXISTS
argument_list|,
operator|&
name|current_soa_tuple
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqtype
operator|==
name|dns_rdatatype_ixfr
condition|)
block|{
name|isc_uint32_t
name|begin_serial
decl_stmt|,
name|current_serial
decl_stmt|;
name|isc_boolean_t
name|provide_ixfr
decl_stmt|;
comment|/* 		 * Outgoing IXFR may have been disabled for this peer 		 * or globally. 		 */
name|provide_ixfr
operator|=
name|client
operator|->
name|view
operator|->
name|provideixfr
expr_stmt|;
if|if
condition|(
name|peer
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dns_peer_getprovideixfr
argument_list|(
name|peer
argument_list|,
operator|&
name|provide_ixfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|provide_ixfr
operator|==
name|ISC_FALSE
condition|)
goto|goto
name|axfr_fallback
goto|;
if|if
condition|(
operator|!
name|have_soa
condition|)
name|FAILC
argument_list|(
name|DNS_R_FORMERR
argument_list|,
literal|"IXFR request missing SOA"
argument_list|)
expr_stmt|;
name|begin_serial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|soa_rdata
argument_list|)
expr_stmt|;
name|current_serial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|current_soa_tuple
operator|->
name|rdata
argument_list|)
expr_stmt|;
comment|/* 		 * RFC1995 says "If an IXFR query with the same or 		 * newer version number than that of the server 		 * is received, it is replied to with a single SOA 		 * record of the server's current version, just as 		 * in AXFR".  The claim about AXFR is incorrect, 		 * but other than that, we do as the RFC says. 		 * 		 * Sending a single SOA record is also how we refuse 		 * IXFR over UDP (currently, we always do). 		 */
if|if
condition|(
name|DNS_SERIAL_GE
argument_list|(
name|begin_serial
argument_list|,
name|current_serial
argument_list|)
operator|||
operator|(
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|soa_rrstream_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|is_poll
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|have_stream
goto|;
block|}
name|journalfile
operator|=
name|dns_zone_getjournal
argument_list|(
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|journalfile
operator|!=
name|NULL
condition|)
name|result
operator|=
name|ixfr_rrstream_create
argument_list|(
name|mctx
argument_list|,
name|journalfile
argument_list|,
name|begin_serial
argument_list|,
name|current_serial
argument_list|,
operator|&
name|data_stream
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|||
name|result
operator|==
name|ISC_R_RANGE
condition|)
block|{
name|xfrout_log1
argument_list|(
name|client
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|4
argument_list|)
argument_list|,
literal|"IXFR version not in journal, "
literal|"falling back to AXFR"
argument_list|)
expr_stmt|;
name|mnemonic
operator|=
literal|"AXFR-style IXFR"
expr_stmt|;
goto|goto
name|axfr_fallback
goto|;
block|}
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|axfr_fallback
label|:
name|CHECK
argument_list|(
name|axfr_rrstream_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|data_stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Bracket the the data stream with SOAs. 	 */
name|CHECK
argument_list|(
name|soa_rrstream_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|soa_stream
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|compound_rrstream_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|soa_stream
argument_list|,
operator|&
name|data_stream
argument_list|,
operator|&
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|soa_stream
operator|=
name|NULL
expr_stmt|;
name|data_stream
operator|=
name|NULL
expr_stmt|;
name|have_stream
label|:
name|CHECK
argument_list|(
name|dns_message_getquerytsig
argument_list|(
name|request
argument_list|,
name|mctx
argument_list|,
operator|&
name|tsigbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create the xfrout context object.  This transfers the ownership 	 * of "stream", "db", "ver", and "quota" to the xfrout context object. 	 */
name|CHECK
argument_list|(
name|xfrout_ctx_create
argument_list|(
name|mctx
argument_list|,
name|client
argument_list|,
name|request
operator|->
name|id
argument_list|,
name|question_name
argument_list|,
name|reqtype
argument_list|,
name|question_class
argument_list|,
name|db
argument_list|,
name|ver
argument_list|,
name|quota
argument_list|,
name|stream
argument_list|,
name|dns_message_gettsigkey
argument_list|(
name|request
argument_list|)
argument_list|,
name|tsigbuf
argument_list|,
name|dns_zone_getmaxxfrout
argument_list|(
name|zone
argument_list|)
argument_list|,
name|dns_zone_getidleout
argument_list|(
name|zone
argument_list|)
argument_list|,
operator|(
name|format
operator|==
name|dns_many_answers
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
argument_list|,
operator|&
name|xfr
argument_list|)
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|mnemonic
operator|=
name|mnemonic
expr_stmt|;
name|stream
operator|=
name|NULL
expr_stmt|;
name|quota
operator|=
name|NULL
expr_stmt|;
name|CHECK
argument_list|(
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|first
argument_list|(
name|xfr
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|tsigkey
operator|!=
name|NULL
condition|)
block|{
name|dns_name_format
argument_list|(
operator|&
name|xfr
operator|->
name|tsigkey
operator|->
name|name
argument_list|,
name|keyname
argument_list|,
sizeof|sizeof
argument_list|(
name|keyname
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|is_poll
condition|)
name|xfrout_log1
argument_list|(
name|client
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"IXFR poll up to date%s%s"
argument_list|,
operator|(
name|xfr
operator|->
name|tsigkey
operator|!=
name|NULL
operator|)
condition|?
literal|": TSIG "
else|:
literal|""
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
else|else
name|xfrout_log1
argument_list|(
name|client
argument_list|,
name|question_name
argument_list|,
name|question_class
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s started%s%s"
argument_list|,
name|mnemonic
argument_list|,
operator|(
name|xfr
operator|->
name|tsigkey
operator|!=
name|NULL
operator|)
condition|?
literal|": TSIG "
else|:
literal|""
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
comment|/* 	 * Hand the context over to sendstream().  Set xfr to NULL; 	 * sendstream() is responsible for either passing the 	 * context on to a later event handler or destroying it. 	 */
name|sendstream
argument_list|(
name|xfr
argument_list|)
expr_stmt|;
name|xfr
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|quota
operator|!=
name|NULL
condition|)
name|isc_quota_detach
argument_list|(
operator|&
name|quota
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_soa_tuple
operator|!=
name|NULL
condition|)
name|dns_difftuple_free
argument_list|(
operator|&
name|current_soa_tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|NULL
condition|)
name|stream
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa_stream
operator|!=
name|NULL
condition|)
name|soa_stream
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|soa_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_stream
operator|!=
name|NULL
condition|)
name|data_stream
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|data_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|zone
argument_list|)
expr_stmt|;
comment|/* XXX kludge */
if|if
condition|(
name|xfr
operator|!=
name|NULL
condition|)
block|{
name|xfrout_fail
argument_list|(
name|xfr
argument_list|,
name|result
argument_list|,
literal|"setting up zone transfer"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_XFER_OUT
argument_list|,
name|NS_LOGMODULE_XFER_OUT
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"zone transfer setup failed"
argument_list|)
expr_stmt|;
name|ns_client_error
argument_list|(
name|client
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|xfrout_ctx_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_rdataclass_t
name|qclass
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_quota_t
modifier|*
name|quota
parameter_list|,
name|rrstream_t
modifier|*
name|stream
parameter_list|,
name|dns_tsigkey_t
modifier|*
name|tsigkey
parameter_list|,
name|isc_buffer_t
modifier|*
name|lasttsig
parameter_list|,
name|unsigned
name|int
name|maxtime
parameter_list|,
name|unsigned
name|int
name|idletime
parameter_list|,
name|isc_boolean_t
name|many_answers
parameter_list|,
name|xfrout_ctx_t
modifier|*
modifier|*
name|xfrp
parameter_list|)
block|{
name|xfrout_ctx_t
modifier|*
name|xfr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|INSIST
argument_list|(
name|xfrp
operator|!=
name|NULL
operator|&&
operator|*
name|xfrp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|xfr
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xfr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|xfr
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|xfr
operator|->
name|client
operator|=
name|NULL
expr_stmt|;
name|ns_client_attach
argument_list|(
name|client
argument_list|,
operator|&
name|xfr
operator|->
name|client
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|xfr
operator|->
name|qname
operator|=
name|qname
expr_stmt|;
name|xfr
operator|->
name|qtype
operator|=
name|qtype
expr_stmt|;
name|xfr
operator|->
name|qclass
operator|=
name|qclass
expr_stmt|;
name|xfr
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|ver
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|xfr
operator|->
name|db
argument_list|)
expr_stmt|;
name|dns_db_attachversion
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|xfr
operator|->
name|ver
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|end_of_stream
operator|=
name|ISC_FALSE
expr_stmt|;
name|xfr
operator|->
name|tsigkey
operator|=
name|tsigkey
expr_stmt|;
name|xfr
operator|->
name|lasttsig
operator|=
name|lasttsig
expr_stmt|;
name|xfr
operator|->
name|txmem
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|txmemlen
operator|=
literal|0
expr_stmt|;
name|xfr
operator|->
name|nmsg
operator|=
literal|0
expr_stmt|;
name|xfr
operator|->
name|many_answers
operator|=
name|many_answers
operator|,
name|xfr
operator|->
name|sends
operator|=
literal|0
expr_stmt|;
name|xfr
operator|->
name|shuttingdown
operator|=
name|ISC_FALSE
expr_stmt|;
name|xfr
operator|->
name|mnemonic
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|buf
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|buf
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|xfr
operator|->
name|txmem
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|txmemlen
operator|=
literal|0
expr_stmt|;
name|xfr
operator|->
name|stream
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|quota
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Allocate a temporary buffer for the uncompressed response 	 * message data.  The size should be no more than 65535 bytes 	 * so that the compressed data will fit in a TCP message, 	 * and no less than 65535 bytes so that an almost maximum-sized 	 * RR will fit.  Note that although 65535-byte RRs are allowed 	 * in principle, they cannot be zone-transferred (at least not 	 * if uncompressible), because the message and RR headers would 	 * push the size of the TCP message over the 65536 byte limit. 	 */
name|len
operator|=
literal|65535
expr_stmt|;
name|mem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
name|mem
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate another temporary buffer for the compressed 	 * response message and its TCP length prefix. 	 */
name|len
operator|=
literal|2
operator|+
literal|65535
expr_stmt|;
name|mem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|xfr
operator|->
name|txlenbuf
argument_list|,
name|mem
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|xfr
operator|->
name|txbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mem
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|txmem
operator|=
name|mem
expr_stmt|;
name|xfr
operator|->
name|txmemlen
operator|=
name|len
expr_stmt|;
name|CHECK
argument_list|(
name|dns_timer_setidle
argument_list|(
name|xfr
operator|->
name|client
operator|->
name|timer
argument_list|,
name|maxtime
argument_list|,
name|idletime
argument_list|,
name|ISC_FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Register a shutdown callback with the client, so that we 	 * can stop the transfer immediately when the client task 	 * gets a shutdown event. 	 */
name|xfr
operator|->
name|client
operator|->
name|shutdown
operator|=
name|xfrout_client_shutdown
expr_stmt|;
name|xfr
operator|->
name|client
operator|->
name|shutdown_arg
operator|=
name|xfr
expr_stmt|;
comment|/* 	 * These MUST be after the last "goto failure;" / CHECK to 	 * prevent a double free by the caller. 	 */
name|xfr
operator|->
name|quota
operator|=
name|quota
expr_stmt|;
name|xfr
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
operator|*
name|xfrp
operator|=
name|xfr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
name|xfrout_ctx_destroy
argument_list|(
operator|&
name|xfr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Arrange to send as much as we can of "stream" without blocking.  *  * Requires:  *	The stream iterator is initialized and points at an RR,  *      or possiby at the end of the stream (that is, the  *      _first method of the iterator has been called).  */
end_comment

begin_function
specifier|static
name|void
name|sendstream
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|)
block|{
name|dns_message_t
modifier|*
name|tcpmsg
init|=
name|NULL
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
comment|/* Client message if UDP, tcpmsg if TCP */
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|used
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|qrdataset
decl_stmt|;
name|dns_name_t
modifier|*
name|msgname
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
modifier|*
name|msgrdata
init|=
name|NULL
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|msgrdl
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|msgrds
init|=
name|NULL
decl_stmt|;
name|dns_compress_t
name|cctx
decl_stmt|;
name|isc_boolean_t
name|cleanup_cctx
init|=
name|ISC_FALSE
decl_stmt|;
name|int
name|n_rrs
decl_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|)
expr_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|xfr
operator|->
name|txlenbuf
argument_list|)
expr_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|xfr
operator|->
name|txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xfr
operator|->
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * In the UDP case, we put the response data directly into 		 * the client message. 		 */
name|msg
operator|=
name|xfr
operator|->
name|client
operator|->
name|message
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_reply
argument_list|(
name|msg
argument_list|,
name|ISC_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * TCP. Build a response dns_message_t, temporarily storing 		 * the raw, uncompressed owner names and RR data contiguously 		 * in xfr->buf.  We know that if the uncompressed data fits 		 * in xfr->buf, the compressed data will surely fit in a TCP 		 * message. 		 */
name|CHECK
argument_list|(
name|dns_message_create
argument_list|(
name|xfr
operator|->
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|tcpmsg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|tcpmsg
expr_stmt|;
name|msg
operator|->
name|id
operator|=
name|xfr
operator|->
name|id
expr_stmt|;
name|msg
operator|->
name|rcode
operator|=
name|dns_rcode_noerror
expr_stmt|;
name|msg
operator|->
name|flags
operator|=
name|DNS_MESSAGEFLAG_QR
operator||
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
if|if
condition|(
operator|(
name|xfr
operator|->
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_RA
operator|)
operator|!=
literal|0
condition|)
name|msg
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_RA
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_settsigkey
argument_list|(
name|msg
argument_list|,
name|xfr
operator|->
name|tsigkey
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_setquerytsig
argument_list|(
name|msg
argument_list|,
name|xfr
operator|->
name|lasttsig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|lasttsig
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|xfr
operator|->
name|lasttsig
argument_list|)
expr_stmt|;
comment|/* 		 * Include a question section in the first message only. 		 * BIND 8.2.1 will not recognize an IXFR if it does not 		 * have a question section. 		 */
if|if
condition|(
name|xfr
operator|->
name|nmsg
operator|==
literal|0
condition|)
block|{
name|dns_name_t
modifier|*
name|qname
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
comment|/* 			 * Reserve space for the 12-byte message header 			 * and 4 bytes of question. 			 */
name|isc_buffer_add
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
literal|12
operator|+
literal|4
argument_list|)
expr_stmt|;
name|qrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|qrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_rdataset_init
argument_list|(
name|qrdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|qrdataset
argument_list|,
name|xfr
operator|->
name|client
operator|->
name|message
operator|->
name|rdclass
argument_list|,
name|xfr
operator|->
name|qtype
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|msg
argument_list|,
operator|&
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_name_init
argument_list|(
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
name|xfr
operator|->
name|qname
operator|->
name|length
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|xfr
operator|->
name|qname
operator|->
name|length
expr_stmt|;
name|isc_buffer_putmem
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
name|xfr
operator|->
name|qname
operator|->
name|ndata
argument_list|,
name|xfr
operator|->
name|qname
operator|->
name|length
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
name|qname
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|qname
operator|->
name|list
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qname
operator|->
name|list
argument_list|,
name|qrdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|msg
argument_list|,
name|qname
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
block|}
else|else
name|msg
operator|->
name|tcp_continuation
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Try to fit in as many RRs as possible, unless "one-answer" 	 * format has been requested. 	 */
for|for
control|(
name|n_rrs
operator|=
literal|0
init|;
condition|;
name|n_rrs
operator|++
control|)
block|{
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|msgname
operator|=
name|NULL
expr_stmt|;
name|msgrdata
operator|=
name|NULL
expr_stmt|;
name|msgrdl
operator|=
name|NULL
expr_stmt|;
name|msgrds
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|current
argument_list|(
name|xfr
operator|->
name|stream
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|size
operator|=
name|name
operator|->
name|length
operator|+
literal|10
operator|+
name|rdata
operator|->
name|length
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|r
operator|.
name|length
condition|)
block|{
comment|/* 			 * RR would not fit.  If there are other RRs in the 			 * buffer, send them now and leave this RR to the 			 * next message.  If this RR overflows the buffer 			 * all by itself, fail. 			 * 			 * In theory some RRs might fit in a TCP message 			 * when compressed even if they do not fit when 			 * uncompressed, but surely we don't want 			 * to send such monstrosities to an unsuspecting 			 * slave. 			 */
if|if
condition|(
name|n_rrs
operator|==
literal|0
condition|)
block|{
name|xfrout_log
argument_list|(
name|xfr
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"RR too large for zone transfer "
literal|"(%d bytes)"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* XXX DNS_R_RRTOOLARGE? */
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|ns_g_lctx
argument_list|,
name|XFROUT_RR_LOGLEVEL
argument_list|)
condition|)
name|log_rr
argument_list|(
name|name
argument_list|,
name|rdata
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* XXX */
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|msg
argument_list|,
operator|&
name|msgname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_name_init
argument_list|(
name|msgname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|name
operator|->
name|length
expr_stmt|;
name|isc_buffer_putmem
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
name|name
operator|->
name|ndata
argument_list|,
name|name
operator|->
name|length
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
name|msgname
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* Reserve space for RR header. */
name|isc_buffer_add
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|rdata
operator|->
name|length
expr_stmt|;
name|isc_buffer_putmem
argument_list|(
operator|&
name|xfr
operator|->
name|buf
argument_list|,
name|rdata
operator|->
name|data
argument_list|,
name|rdata
operator|->
name|length
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
name|msgrdata
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|msgrdata
argument_list|,
name|rdata
operator|->
name|rdclass
argument_list|,
name|rdata
operator|->
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|msgrdl
operator|->
name|type
operator|=
name|rdata
operator|->
name|type
expr_stmt|;
name|msgrdl
operator|->
name|rdclass
operator|=
name|rdata
operator|->
name|rdclass
expr_stmt|;
name|msgrdl
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|msgrdl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|msgrdl
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|msgrdl
operator|->
name|rdata
argument_list|,
name|msgrdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrds
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_rdataset_init
argument_list|(
name|msgrds
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatalist_tordataset
argument_list|(
name|msgrdl
argument_list|,
name|msgrds
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|msgname
operator|->
name|list
argument_list|,
name|msgrds
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|msg
argument_list|,
name|msgname
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|msgname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|next
argument_list|(
name|xfr
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
block|{
name|xfr
operator|->
name|end_of_stream
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfr
operator|->
name|many_answers
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|xfr
operator|->
name|client
operator|->
name|attributes
operator|&
name|NS_CLIENTATTR_TCP
operator|)
operator|!=
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|dns_compress_init
argument_list|(
operator|&
name|cctx
argument_list|,
operator|-
literal|1
argument_list|,
name|xfr
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_cctx
operator|=
name|ISC_TRUE
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_renderbegin
argument_list|(
name|msg
argument_list|,
operator|&
name|cctx
argument_list|,
operator|&
name|xfr
operator|->
name|txbuf
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_rendersection
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_rendersection
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_message_renderend
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
name|cleanup_cctx
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|xfr
operator|->
name|txbuf
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|xfr
operator|->
name|txlenbuf
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|used
operator|.
name|length
argument_list|)
expr_stmt|;
name|region
operator|.
name|base
operator|=
name|xfr
operator|->
name|txlenbuf
operator|.
name|base
expr_stmt|;
name|region
operator|.
name|length
operator|=
literal|2
operator|+
name|used
operator|.
name|length
expr_stmt|;
name|xfrout_log
argument_list|(
name|xfr
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|8
argument_list|)
argument_list|,
literal|"sending TCP message of %d bytes"
argument_list|,
name|used
operator|.
name|length
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|isc_socket_send
argument_list|(
name|xfr
operator|->
name|client
operator|->
name|tcpsocket
argument_list|,
comment|/* XXX */
operator|&
name|region
argument_list|,
name|xfr
operator|->
name|client
operator|->
name|task
argument_list|,
name|xfrout_senddone
argument_list|,
name|xfr
argument_list|)
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|sends
operator|++
expr_stmt|;
block|}
else|else
block|{
name|xfrout_log
argument_list|(
name|xfr
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|8
argument_list|)
argument_list|,
literal|"sending IXFR UDP response"
argument_list|)
expr_stmt|;
name|ns_client_send
argument_list|(
name|xfr
operator|->
name|client
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|pause
argument_list|(
name|xfr
operator|->
name|stream
argument_list|)
expr_stmt|;
name|xfrout_ctx_destroy
argument_list|(
operator|&
name|xfr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Advance lasttsig to be the last TSIG generated */
name|CHECK
argument_list|(
name|dns_message_getquerytsig
argument_list|(
name|msg
argument_list|,
name|xfr
operator|->
name|mctx
argument_list|,
operator|&
name|xfr
operator|->
name|lasttsig
argument_list|)
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|nmsg
operator|++
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|msgname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msgrds
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|msgrds
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|msgrds
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgrdl
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|msgrdl
operator|->
name|rdata
argument_list|,
name|msgrdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_puttemprdatalist
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrdl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgrdata
operator|!=
name|NULL
condition|)
name|dns_message_puttemprdata
argument_list|(
name|msg
argument_list|,
operator|&
name|msgrdata
argument_list|)
expr_stmt|;
name|dns_message_puttempname
argument_list|(
name|msg
argument_list|,
operator|&
name|msgname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcpmsg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|tcpmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_cctx
condition|)
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure to release any locks held by database 	 * iterators before returning from the event handler. 	 */
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|pause
argument_list|(
name|xfr
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return;
name|xfrout_fail
argument_list|(
name|xfr
argument_list|,
name|result
argument_list|,
literal|"sending zone data"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfrout_ctx_destroy
parameter_list|(
name|xfrout_ctx_t
modifier|*
modifier|*
name|xfrp
parameter_list|)
block|{
name|xfrout_ctx_t
modifier|*
name|xfr
init|=
operator|*
name|xfrp
decl_stmt|;
name|INSIST
argument_list|(
name|xfr
operator|->
name|sends
operator|==
literal|0
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|client
operator|->
name|shutdown
operator|=
name|NULL
expr_stmt|;
name|xfr
operator|->
name|client
operator|->
name|shutdown_arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|stream
operator|!=
name|NULL
condition|)
name|xfr
operator|->
name|stream
operator|->
name|methods
operator|->
name|destroy
argument_list|(
operator|&
name|xfr
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|buf
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|xfr
operator|->
name|mctx
argument_list|,
name|xfr
operator|->
name|buf
operator|.
name|base
argument_list|,
name|xfr
operator|->
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|txmem
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|xfr
operator|->
name|mctx
argument_list|,
name|xfr
operator|->
name|txmem
argument_list|,
name|xfr
operator|->
name|txmemlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|lasttsig
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|xfr
operator|->
name|lasttsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|quota
operator|!=
name|NULL
condition|)
name|isc_quota_detach
argument_list|(
operator|&
name|xfr
operator|->
name|quota
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|xfr
operator|->
name|db
argument_list|,
operator|&
name|xfr
operator|->
name|ver
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|xfr
operator|->
name|db
argument_list|)
expr_stmt|;
name|ns_client_detach
argument_list|(
operator|&
name|xfr
operator|->
name|client
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|xfr
operator|->
name|mctx
argument_list|,
name|xfr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xfr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|xfrp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfrout_senddone
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|xfrout_ctx_t
modifier|*
name|xfr
init|=
operator|(
name|xfrout_ctx_t
operator|*
operator|)
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_result_t
name|evresult
init|=
name|sev
operator|->
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_SENDDONE
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|xfr
operator|->
name|sends
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|xfr
operator|->
name|sends
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_timer_touch
argument_list|(
name|xfr
operator|->
name|client
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|shuttingdown
operator|==
name|ISC_TRUE
condition|)
block|{
name|xfrout_maybe_destroy
argument_list|(
name|xfr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|xfrout_fail
argument_list|(
name|xfr
argument_list|,
name|evresult
argument_list|,
literal|"send"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xfr
operator|->
name|end_of_stream
operator|==
name|ISC_FALSE
condition|)
block|{
name|sendstream
argument_list|(
name|xfr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* End of zone transfer stream. */
name|xfrout_log
argument_list|(
name|xfr
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"%s ended"
argument_list|,
name|xfr
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
name|ns_client_next
argument_list|(
name|xfr
operator|->
name|client
argument_list|,
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|xfrout_ctx_destroy
argument_list|(
operator|&
name|xfr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xfrout_fail
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|xfr
operator|->
name|shuttingdown
operator|=
name|ISC_TRUE
expr_stmt|;
name|xfrout_log
argument_list|(
name|xfr
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: %s"
argument_list|,
name|msg
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|xfrout_maybe_destroy
argument_list|(
name|xfr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xfrout_maybe_destroy
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|)
block|{
name|INSIST
argument_list|(
name|xfr
operator|->
name|shuttingdown
operator|==
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfr
operator|->
name|sends
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If we are currently sending, cancel it and wait for 		 * cancel event before destroying the context. 		 */
name|isc_socket_cancel
argument_list|(
name|xfr
operator|->
name|client
operator|->
name|tcpsocket
argument_list|,
name|xfr
operator|->
name|client
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_SEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_client_next
argument_list|(
name|xfr
operator|->
name|client
argument_list|,
name|ISC_R_CANCELED
argument_list|)
expr_stmt|;
name|xfrout_ctx_destroy
argument_list|(
operator|&
name|xfr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xfrout_client_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|xfrout_ctx_t
modifier|*
name|xfr
init|=
operator|(
name|xfrout_ctx_t
operator|*
operator|)
name|arg
decl_stmt|;
name|xfrout_fail
argument_list|(
name|xfr
argument_list|,
name|result
argument_list|,
literal|"aborted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log outgoing zone transfer messages in a format like  *<client>: transfer of<zone>:<message>  */
end_comment

begin_function_decl
specifier|static
name|void
name|xfrout_logv
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|zonename
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|5
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|xfrout_logv
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|zonename
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classbuf
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|zonename
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|rdclass
argument_list|,
name|classbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|classbuf
argument_list|)
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ns_client_log
argument_list|(
name|client
argument_list|,
name|DNS_LOGCATEGORY_XFER_OUT
argument_list|,
name|NS_LOGMODULE_XFER_OUT
argument_list|,
name|level
argument_list|,
literal|"transfer of '%s/%s': %s"
argument_list|,
name|namebuf
argument_list|,
name|classbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logging function for use when a xfrout_ctx_t has not yet been created.  */
end_comment

begin_function
specifier|static
name|void
name|xfrout_log1
parameter_list|(
name|ns_client_t
modifier|*
name|client
parameter_list|,
name|dns_name_t
modifier|*
name|zonename
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xfrout_logv
argument_list|(
name|client
argument_list|,
name|zonename
argument_list|,
name|rdclass
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logging function for use when there is a xfrout_ctx_t.  */
end_comment

begin_function
specifier|static
name|void
name|xfrout_log
parameter_list|(
name|xfrout_ctx_t
modifier|*
name|xfr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xfrout_logv
argument_list|(
name|xfr
operator|->
name|client
argument_list|,
name|xfr
operator|->
name|qname
argument_list|,
name|xfr
operator|->
name|qclass
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

