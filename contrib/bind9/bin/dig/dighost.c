begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: dighost.c,v 1.221.2.19.2.36 2006/12/07 01:26:33 marka Exp $ */
end_comment

begin_comment
comment|/*  * Notice to programmers:  Do not use this code as an example of how to  * use the ISC library to perform DNS lookups.  Dig and Host both operate  * on the request level, since they allow fine-tuning of output and are  * intended as debugging tools.  As a result, they perform many of the  * functions which could be better handled using the dns_resolver  * functions in most applications.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<dns/byaddr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
end_ifdef

begin_include
include|#
directive|include
file|<dns/dnssec.h>
end_include

begin_include
include|#
directive|include
file|<dns/ds.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_include
include|#
directive|include
file|<dst/dst.h>
end_include

begin_include
include|#
directive|include
file|<isc/app.h>
end_include

begin_include
include|#
directive|include
file|<isc/base64.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/lang.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
end_ifdef

begin_include
include|#
directive|include
file|<isc/netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/types.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<lwres/lwres.h>
end_include

begin_include
include|#
directive|include
file|<lwres/net.h>
end_include

begin_include
include|#
directive|include
file|<bind9/getaddresses.h>
end_include

begin_include
include|#
directive|include
file|<dig/dig.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NS_INADDRSZ
argument_list|)
end_if

begin_define
define|#
directive|define
name|NS_INADDRSZ
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NS_IN6ADDRSZ
argument_list|)
end_if

begin_define
define|#
directive|define
name|NS_IN6ADDRSZ
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|lwres_context_t
modifier|*
name|lwctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|lwres_conf_t
modifier|*
name|lwconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dig_lookuplist_t
name|lookup_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dig_serverlist_t
name|server_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dig_searchlistlist_t
name|search_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|have_ipv4
init|=
name|ISC_FALSE
decl_stmt|,
name|have_ipv6
init|=
name|ISC_FALSE
decl_stmt|,
name|specified_source
init|=
name|ISC_FALSE
decl_stmt|,
name|free_now
init|=
name|ISC_FALSE
decl_stmt|,
name|cancel_now
init|=
name|ISC_FALSE
decl_stmt|,
name|usesearch
init|=
name|ISC_FALSE
decl_stmt|,
name|qr
init|=
name|ISC_FALSE
decl_stmt|,
name|is_dst_up
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|in_port_t
name|port
init|=
literal|53
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|timeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_mem_t
modifier|*
name|mctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_taskmgr_t
modifier|*
name|taskmgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_task_t
modifier|*
name|global_task
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_timermgr_t
modifier|*
name|timermgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_socketmgr_t
modifier|*
name|socketmgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_sockaddr_t
name|bind_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_sockaddr_t
name|bind_any
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sendcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recvcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sockcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndots
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lookup_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Exit Codes:  *   0   Everything went well, including things like NXDOMAIN  *   1   Usage error  *   7   Got too many RR's or Names  *   8   Couldn't open batch file  *   9   No reply from server  *   10  Internal error  */
end_comment

begin_decl_stmt
name|int
name|exitcode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fatalexit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|keynametext
index|[
name|MXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|keyfile
index|[
name|MXNAME
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|keysecret
index|[
name|MXNAME
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_buffer_t
modifier|*
name|namebuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_tsigkey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|validated
init|=
name|ISC_TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_entropy_t
modifier|*
name|entp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_mempool_t
modifier|*
name|commctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|debugging
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|memdebugging
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_mutex_t
name|lookup_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dig_lookup_t
modifier|*
name|current_lookup
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
end_ifdef

begin_function_decl
name|isc_result_t
name|get_trusted_key
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dns_rdataset_t
modifier|*
name|sigchase_scanname
parameter_list|(
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_boolean_t
modifier|*
name|lookedup
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dns_rdataset_t
modifier|*
name|chase_scanname_section
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|int
name|section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|advanced_rrsearch
parameter_list|(
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_boolean_t
modifier|*
name|lookedup
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|sigchase_verify_sig_key
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dst_key_t
modifier|*
name|dnsseckey
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|sigchase_verify_sig
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyrdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|sigchase_verify_ds
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyrdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|dsrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigchase
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_rdata
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_rdataset
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dup_name
parameter_list|(
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_name
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_database
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_database_section
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|int
name|section
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dns_rdataset_t
modifier|*
name|search_type
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|contains_trusted_key
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_type
parameter_list|(
name|dns_rdatatype_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|prove_nx_domain
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|prove_nx_type
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsec
parameter_list|,
name|dns_rdataclass_t
name|class
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|prove_nx
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataclass_t
name|class
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nameFromString
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|dns_name_t
modifier|*
name|p_ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|inf_name
parameter_list|(
name|dns_name_t
modifier|*
name|name1
parameter_list|,
name|dns_name_t
modifier|*
name|name2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|opentmpkey
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|tempp
parameter_list|,
name|FILE
modifier|*
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|removetmpkey
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clean_trustedkey
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_trustedkey
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|DIG_SIGCHASE_BU
end_if

begin_function_decl
name|isc_result_t
name|getneededrr
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigchase_bottom_up
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigchase_bu
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DIG_SIGCHASE_TD
end_if

begin_function_decl
name|isc_result_t
name|initialization
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|prepare_lookup
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|grandfather_pb_test
parameter_list|(
name|dns_name_t
modifier|*
name|zone_name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|child_of_zone
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|zone_name
parameter_list|,
name|dns_name_t
modifier|*
name|child_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigchase_td
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|trustedkey
index|[
name|MXNAME
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_rdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_sigrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_dsrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_sigdsrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_keyrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_sigkeyrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_rdataset_t
modifier|*
name|chase_nsrdataset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_name_t
name|chase_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the query name */
end_comment

begin_if
if|#
directive|if
name|DIG_SIGCHASE_TD
end_if

begin_comment
comment|/*  * the current name is the parent name when we follow delegation  */
end_comment

begin_decl_stmt
name|dns_name_t
name|chase_current_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the child name is used for delegation (NS DS responses in AUTHORITY section)  */
end_comment

begin_decl_stmt
name|dns_name_t
name|chase_authority_name
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DIG_SIGCHASE_BU
end_if

begin_decl_stmt
name|dns_name_t
name|chase_signame
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|isc_boolean_t
name|chase_siglookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_keylookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_sigkeylookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_dslookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_sigdslookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DIG_SIGCHASE_TD
end_if

begin_decl_stmt
name|isc_boolean_t
name|chase_nslookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_lookedup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|delegation_follow
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|grandfather_pb
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|have_response
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|have_delegation_ns
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dns_message_t
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|isc_boolean_t
name|dsvalidating
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|chase_name_dup
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_macro
name|ISC_LIST
argument_list|(
argument|dig_message_t
argument_list|)
end_macro

begin_expr_stmt
name|chase_message_list
expr_stmt|;
end_expr_stmt

begin_macro
name|ISC_LIST
argument_list|(
argument|dig_message_t
argument_list|)
end_macro

begin_expr_stmt
name|chase_message_list2
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MAX_TRUSTED_KEY
value|5
end_define

begin_typedef
typedef|typedef
struct|struct
name|struct_trusted_key_list
block|{
name|dst_key_t
modifier|*
name|key
index|[
name|MAX_TRUSTED_KEY
index|]
decl_stmt|;
name|int
name|nb_tk
decl_stmt|;
block|}
name|struct_tk_list
typedef|;
end_typedef

begin_decl_stmt
name|struct_tk_list
name|tk_list
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DIG_MAX_ADDRESSES
value|20
end_define

begin_comment
comment|/*  * Apply and clear locks at the event level in global task.  * Can I get rid of these using shutdown events?  XXX  */
end_comment

begin_define
define|#
directive|define
name|LOCK_LOOKUP
value|{\ 	debug("lock_lookup %s:%d", __FILE__, __LINE__);\ 	check_result(isc_mutex_lock((&lookup_lock)), "isc_mutex_lock");\ 	debug("success");\ }
end_define

begin_define
define|#
directive|define
name|UNLOCK_LOOKUP
value|{\ 	debug("unlock_lookup %s:%d", __FILE__, __LINE__);\ 	check_result(isc_mutex_unlock((&lookup_lock)),\ 		     "isc_mutex_unlock");\ }
end_define

begin_function_decl
specifier|static
name|void
name|cancel_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recv_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_udp
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|connect_timeout
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|launch_next_query
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|,
name|isc_boolean_t
name|include_question
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|mem_alloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|isc_mem_get
argument_list|(
name|arg
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|isc_mem_put
argument_list|(
name|arg
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|next_token
parameter_list|(
name|char
modifier|*
modifier|*
name|stringp
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|res
decl_stmt|;
do|do
block|{
name|res
operator|=
name|strsep
argument_list|(
name|stringp
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|res
operator|==
literal|'\0'
condition|)
do|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_dots
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|i
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hex_dump
parameter_list|(
name|isc_buffer_t
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d bytes\n"
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|r
operator|.
name|length
condition|;
name|len
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|r
operator|.
name|base
index|[
name|len
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|16
operator|==
literal|15
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|%
literal|16
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append 'len' bytes of 'text' at '*p', failing with  * ISC_R_NOSPACE if that would advance p past 'end'.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|append
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
name|end
operator|-
operator|*
name|p
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
operator|*
name|p
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|reverse_octets
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
name|char
modifier|*
name|dot
init|=
name|strchr
argument_list|(
name|in
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|reverse_octets
argument_list|(
name|dot
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|append
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|len
operator|=
name|dot
operator|-
name|in
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|append
argument_list|(
name|in
argument_list|,
name|len
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|get_reverse
parameter_list|(
name|char
modifier|*
name|reverse
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|isc_boolean_t
name|ip6_int
parameter_list|,
name|isc_boolean_t
name|strict
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_netaddr_t
name|addr
decl_stmt|;
name|addr
operator|.
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|r
operator|=
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|value
argument_list|,
operator|&
name|addr
operator|.
name|type
operator|.
name|in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
comment|/* This is a valid IPv6 address. */
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|options
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ip6_int
condition|)
name|options
operator||=
name|DNS_BYADDROPT_IPV6INT
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_byaddr_createptrname2
argument_list|(
operator|&
name|addr
argument_list|,
name|options
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|reverse
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Not a valid IPv6 address.  Assume IPv4. 		 * If 'strict' is not set, construct the 		 * in-addr.arpa name by blindly reversing 		 * octets whether or not they look like integers, 		 * so that this can be used for RFC2317 names 		 * and such. 		 */
name|char
modifier|*
name|p
init|=
name|reverse
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|reverse
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|strict
operator|&&
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|value
argument_list|,
operator|&
name|addr
operator|.
name|type
operator|.
name|in
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|DNS_R_BADDOTTEDQUAD
operator|)
return|;
name|result
operator|=
name|reverse_octets
argument_list|(
name|value
argument_list|,
operator|&
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* Append .in-addr.arpa. and a terminating NUL. */
name|result
operator|=
name|append
argument_list|(
literal|".in-addr.arpa."
argument_list|,
literal|15
argument_list|,
operator|&
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|<
literal|10
condition|)
name|exitcode
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|fatalexit
operator|!=
literal|0
condition|)
name|exitcode
operator|=
name|fatalexit
expr_stmt|;
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|check_result
parameter_list|(
name|isc_result_t
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|msg
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a server structure, which is part of the lookup structure.  * This is little more than a linked list of servers to query in hopes  * of finding the answer the user is looking for  */
end_comment

begin_function
name|dig_server_t
modifier|*
name|make_server
parameter_list|(
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|char
modifier|*
name|userarg
parameter_list|)
block|{
name|dig_server_t
modifier|*
name|srv
decl_stmt|;
name|REQUIRE
argument_list|(
name|servname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"make_server(%s)"
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|srv
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dig_server
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srv
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|srv
operator|->
name|servername
argument_list|,
name|servname
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|srv
operator|->
name|userarg
argument_list|,
name|userarg
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|srv
operator|->
name|servername
index|[
name|MXNAME
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|srv
operator|->
name|userarg
index|[
name|MXNAME
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|srv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addr2af
parameter_list|(
name|int
name|lwresaddrtype
parameter_list|)
block|{
name|int
name|af
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|lwresaddrtype
condition|)
block|{
case|case
name|LWRES_ADDRTYPE_V4
case|:
name|af
operator|=
name|AF_INET
expr_stmt|;
break|break;
case|case
name|LWRES_ADDRTYPE_V6
case|:
name|af
operator|=
name|AF_INET6
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|af
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a copy of the server list from the lwres configuration structure.  * The dest list must have already had ISC_LIST_INIT applied.  */
end_comment

begin_function
specifier|static
name|void
name|copy_server_list
parameter_list|(
name|lwres_conf_t
modifier|*
name|confdata
parameter_list|,
name|dig_serverlist_t
modifier|*
name|dest
parameter_list|)
block|{
name|dig_server_t
modifier|*
name|newsrv
decl_stmt|;
name|char
name|tmp
index|[
sizeof|sizeof
argument_list|(
literal|"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"
argument_list|)
index|]
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debug
argument_list|(
literal|"copy_server_list()"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|confdata
operator|->
name|nsnext
condition|;
name|i
operator|++
control|)
block|{
name|af
operator|=
name|addr2af
argument_list|(
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|family
argument_list|)
expr_stmt|;
name|lwres_net_ntop
argument_list|(
name|af
argument_list|,
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|address
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|newsrv
operator|=
name|make_server
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|newsrv
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
operator|*
name|dest
argument_list|,
name|newsrv
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|flush_server_list
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_server_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|ps
decl_stmt|;
name|debug
argument_list|(
literal|"flush_server_list()"
argument_list|)
expr_stmt|;
name|s
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|server_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|ps
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|server_list
argument_list|,
name|ps
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_nameserver
parameter_list|(
name|char
modifier|*
name|opt
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_sockaddr_t
name|sockaddrs
index|[
name|DIG_MAX_ADDRESSES
index|]
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|dig_server_t
modifier|*
name|srv
decl_stmt|;
name|char
name|tmp
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|NULL
condition|)
return|return;
name|result
operator|=
name|bind9_getaddresses
argument_list|(
name|opt
argument_list|,
literal|0
argument_list|,
name|sockaddrs
argument_list|,
name|DIG_MAX_ADDRESSES
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"couldn't get address for '%s': %s"
argument_list|,
name|opt
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|flush_server_list
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|sockaddrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|netaddr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|srv
operator|=
name|make_server
argument_list|(
name|tmp
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|srv
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure"
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|server_list
argument_list|,
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_nameserver
parameter_list|(
name|lwres_conf_t
modifier|*
name|confdata
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|af
parameter_list|)
block|{
name|int
name|i
init|=
name|confdata
operator|->
name|nsnext
decl_stmt|;
if|if
condition|(
name|confdata
operator|->
name|nsnext
operator|>=
name|LWRES_CONFMAXNAMESERVERS
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|family
operator|=
name|LWRES_ADDRTYPE_V4
expr_stmt|;
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|length
operator|=
name|NS_INADDRSZ
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|family
operator|=
name|LWRES_ADDRTYPE_V6
expr_stmt|;
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|length
operator|=
name|NS_IN6ADDRSZ
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|lwres_net_pton
argument_list|(
name|af
argument_list|,
name|addr
argument_list|,
operator|&
name|confdata
operator|->
name|nameservers
index|[
name|i
index|]
operator|.
name|address
argument_list|)
operator|==
literal|1
condition|)
block|{
name|confdata
operator|->
name|nsnext
operator|++
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a cloned server list.  The dest list must have already had  * ISC_LIST_INIT applied.  */
end_comment

begin_function
name|void
name|clone_server_list
parameter_list|(
name|dig_serverlist_t
name|src
parameter_list|,
name|dig_serverlist_t
modifier|*
name|dest
parameter_list|)
block|{
name|dig_server_t
modifier|*
name|srv
decl_stmt|,
modifier|*
name|newsrv
decl_stmt|;
name|debug
argument_list|(
literal|"clone_server_list()"
argument_list|)
expr_stmt|;
name|srv
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|src
argument_list|)
expr_stmt|;
while|while
condition|(
name|srv
operator|!=
name|NULL
condition|)
block|{
name|newsrv
operator|=
name|make_server
argument_list|(
name|srv
operator|->
name|servername
argument_list|,
name|srv
operator|->
name|userarg
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|newsrv
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
operator|*
name|dest
argument_list|,
name|newsrv
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|srv
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create an empty lookup structure, which holds all the information needed  * to get an answer to a user's question.  This structure contains two  * linked lists: the server list (servers to query) and the query list  * (outstanding queries which have been made to the listed servers).  */
end_comment

begin_function
name|dig_lookup_t
modifier|*
name|make_empty_lookup
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|looknew
decl_stmt|;
name|debug
argument_list|(
literal|"make_empty_lookup()"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|looknew
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dig_lookup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|looknew
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|looknew
operator|->
name|pending
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|textname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|looknew
operator|->
name|cmdline
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|looknew
operator|->
name|rdtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
name|looknew
operator|->
name|qrdtype
operator|=
name|dns_rdatatype_a
expr_stmt|;
name|looknew
operator|->
name|rdclass
operator|=
name|dns_rdataclass_in
expr_stmt|;
name|looknew
operator|->
name|rdtypeset
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|rdclassset
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|sendspace
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|sendmsg
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|oname
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|timer
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|xfr_q
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|current_query
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|doing_xfr
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|ixfr_serial
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|trace
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|identify
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|identify_previous_line
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|ignore
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|servfail_stops
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|besteffort
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|dnssec
operator|=
name|ISC_FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|looknew
operator|->
name|sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
name|looknew
operator|->
name|do_topdown
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|trace_root_sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|rdtype_sigchaseset
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|rdtype_sigchase
operator|=
name|dns_rdatatype_any
expr_stmt|;
name|looknew
operator|->
name|qrdtype_sigchase
operator|=
name|dns_rdatatype_any
expr_stmt|;
name|looknew
operator|->
name|rdclass_sigchase
operator|=
name|dns_rdataclass_in
expr_stmt|;
name|looknew
operator|->
name|rdclass_sigchaseset
operator|=
name|ISC_FALSE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|looknew
operator|->
name|udpsize
operator|=
literal|0
expr_stmt|;
name|looknew
operator|->
name|recurse
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|aaonly
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|adflag
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|cdflag
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|ns_search_only
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|tsigctx
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|querysig
operator|=
name|NULL
expr_stmt|;
name|looknew
operator|->
name|retries
operator|=
name|tries
expr_stmt|;
name|looknew
operator|->
name|nsfound
operator|=
literal|0
expr_stmt|;
name|looknew
operator|->
name|tcp_mode
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|ip6_int
operator|=
name|ISC_FALSE
expr_stmt|;
name|looknew
operator|->
name|comments
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|stats
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|section_question
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|section_answer
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|section_authority
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|section_additional
operator|=
name|ISC_TRUE
expr_stmt|;
name|looknew
operator|->
name|new_search
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|looknew
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|looknew
operator|->
name|q
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|looknew
operator|->
name|my_server_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|looknew
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clone a lookup, perhaps copying the server list.  This does not clone  * the query list, since it will be regenerated by the setup_lookup()  * function, nor does it queue up the new lookup for processing.  * Caution: If you don't clone the servers, you MUST clone the server  * list seperately from somewhere else, or construct it by hand.  */
end_comment

begin_function
name|dig_lookup_t
modifier|*
name|clone_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookold
parameter_list|,
name|isc_boolean_t
name|servers
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|looknew
decl_stmt|;
name|debug
argument_list|(
literal|"clone_lookup()"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|looknew
operator|=
name|make_empty_lookup
argument_list|()
expr_stmt|;
name|INSIST
argument_list|(
name|looknew
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|looknew
operator|->
name|textname
argument_list|,
name|lookold
operator|->
name|textname
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
name|strncpy
argument_list|(
name|looknew
operator|->
name|textnamesigchase
argument_list|,
name|lookold
operator|->
name|textnamesigchase
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
name|looknew
operator|->
name|cmdline
argument_list|,
name|lookold
operator|->
name|cmdline
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|looknew
operator|->
name|textname
index|[
name|MXNAME
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|looknew
operator|->
name|rdtype
operator|=
name|lookold
operator|->
name|rdtype
expr_stmt|;
name|looknew
operator|->
name|qrdtype
operator|=
name|lookold
operator|->
name|qrdtype
expr_stmt|;
name|looknew
operator|->
name|rdclass
operator|=
name|lookold
operator|->
name|rdclass
expr_stmt|;
name|looknew
operator|->
name|rdtypeset
operator|=
name|lookold
operator|->
name|rdtypeset
expr_stmt|;
name|looknew
operator|->
name|rdclassset
operator|=
name|lookold
operator|->
name|rdclassset
expr_stmt|;
name|looknew
operator|->
name|doing_xfr
operator|=
name|lookold
operator|->
name|doing_xfr
expr_stmt|;
name|looknew
operator|->
name|ixfr_serial
operator|=
name|lookold
operator|->
name|ixfr_serial
expr_stmt|;
name|looknew
operator|->
name|trace
operator|=
name|lookold
operator|->
name|trace
expr_stmt|;
name|looknew
operator|->
name|trace_root
operator|=
name|lookold
operator|->
name|trace_root
expr_stmt|;
name|looknew
operator|->
name|identify
operator|=
name|lookold
operator|->
name|identify
expr_stmt|;
name|looknew
operator|->
name|identify_previous_line
operator|=
name|lookold
operator|->
name|identify_previous_line
expr_stmt|;
name|looknew
operator|->
name|ignore
operator|=
name|lookold
operator|->
name|ignore
expr_stmt|;
name|looknew
operator|->
name|servfail_stops
operator|=
name|lookold
operator|->
name|servfail_stops
expr_stmt|;
name|looknew
operator|->
name|besteffort
operator|=
name|lookold
operator|->
name|besteffort
expr_stmt|;
name|looknew
operator|->
name|dnssec
operator|=
name|lookold
operator|->
name|dnssec
expr_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|looknew
operator|->
name|sigchase
operator|=
name|lookold
operator|->
name|sigchase
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
name|looknew
operator|->
name|do_topdown
operator|=
name|lookold
operator|->
name|do_topdown
expr_stmt|;
name|looknew
operator|->
name|trace_root_sigchase
operator|=
name|lookold
operator|->
name|trace_root_sigchase
expr_stmt|;
name|looknew
operator|->
name|rdtype_sigchaseset
operator|=
name|lookold
operator|->
name|rdtype_sigchaseset
expr_stmt|;
name|looknew
operator|->
name|rdtype_sigchase
operator|=
name|lookold
operator|->
name|rdtype_sigchase
expr_stmt|;
name|looknew
operator|->
name|qrdtype_sigchase
operator|=
name|lookold
operator|->
name|qrdtype_sigchase
expr_stmt|;
name|looknew
operator|->
name|rdclass_sigchase
operator|=
name|lookold
operator|->
name|rdclass_sigchase
expr_stmt|;
name|looknew
operator|->
name|rdclass_sigchaseset
operator|=
name|lookold
operator|->
name|rdclass_sigchaseset
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|looknew
operator|->
name|udpsize
operator|=
name|lookold
operator|->
name|udpsize
expr_stmt|;
name|looknew
operator|->
name|recurse
operator|=
name|lookold
operator|->
name|recurse
expr_stmt|;
name|looknew
operator|->
name|aaonly
operator|=
name|lookold
operator|->
name|aaonly
expr_stmt|;
name|looknew
operator|->
name|adflag
operator|=
name|lookold
operator|->
name|adflag
expr_stmt|;
name|looknew
operator|->
name|cdflag
operator|=
name|lookold
operator|->
name|cdflag
expr_stmt|;
name|looknew
operator|->
name|ns_search_only
operator|=
name|lookold
operator|->
name|ns_search_only
expr_stmt|;
name|looknew
operator|->
name|tcp_mode
operator|=
name|lookold
operator|->
name|tcp_mode
expr_stmt|;
name|looknew
operator|->
name|comments
operator|=
name|lookold
operator|->
name|comments
expr_stmt|;
name|looknew
operator|->
name|stats
operator|=
name|lookold
operator|->
name|stats
expr_stmt|;
name|looknew
operator|->
name|section_question
operator|=
name|lookold
operator|->
name|section_question
expr_stmt|;
name|looknew
operator|->
name|section_answer
operator|=
name|lookold
operator|->
name|section_answer
expr_stmt|;
name|looknew
operator|->
name|section_authority
operator|=
name|lookold
operator|->
name|section_authority
expr_stmt|;
name|looknew
operator|->
name|section_additional
operator|=
name|lookold
operator|->
name|section_additional
expr_stmt|;
name|looknew
operator|->
name|retries
operator|=
name|lookold
operator|->
name|retries
expr_stmt|;
name|looknew
operator|->
name|tsigctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|servers
condition|)
name|clone_server_list
argument_list|(
name|lookold
operator|->
name|my_server_list
argument_list|,
operator|&
name|looknew
operator|->
name|my_server_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|looknew
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Requeue a lookup for further processing, perhaps copying the server  * list.  The new lookup structure is returned to the caller, and is  * queued for processing.  If servers are not cloned in the requeue, they  * must be added before allowing the current event to complete, since the  * completion of the event may result in the next entry on the lookup  * queue getting run.  */
end_comment

begin_function
name|dig_lookup_t
modifier|*
name|requeue_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookold
parameter_list|,
name|isc_boolean_t
name|servers
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|looknew
decl_stmt|;
name|debug
argument_list|(
literal|"requeue_lookup()"
argument_list|)
expr_stmt|;
name|lookup_counter
operator|++
expr_stmt|;
if|if
condition|(
name|lookup_counter
operator|>
name|LOOKUP_LIMIT
condition|)
name|fatal
argument_list|(
literal|"too many lookups"
argument_list|)
expr_stmt|;
name|looknew
operator|=
name|clone_lookup
argument_list|(
name|lookold
argument_list|,
name|servers
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|looknew
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"before insertion, init@%p -> %p, new@%p -> %p"
argument_list|,
name|lookold
argument_list|,
name|lookold
operator|->
name|link
operator|.
name|next
argument_list|,
name|looknew
argument_list|,
name|looknew
operator|->
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|lookup_list
argument_list|,
name|looknew
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"after insertion, init -> %p, new = %p, new -> %p"
argument_list|,
name|lookold
argument_list|,
name|looknew
argument_list|,
name|looknew
operator|->
name|link
operator|.
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|looknew
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_text_key
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|keyname
decl_stmt|;
name|isc_buffer_t
name|secretbuf
decl_stmt|;
name|int
name|secretsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|secretstore
decl_stmt|;
name|debug
argument_list|(
literal|"setup_text_key()"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|namebuf
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|keyname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_name_init"
argument_list|)
expr_stmt|;
name|isc_buffer_putstr
argument_list|(
name|namebuf
argument_list|,
name|keynametext
argument_list|)
expr_stmt|;
name|secretsize
operator|=
name|strlen
argument_list|(
name|keysecret
argument_list|)
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
name|secretstore
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|secretstore
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|secretbuf
argument_list|,
name|secretstore
argument_list|,
name|secretsize
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_base64_decodestring
argument_list|(
name|keysecret
argument_list|,
operator|&
name|secretbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|secretsize
operator|=
name|isc_buffer_usedlength
argument_list|(
operator|&
name|secretbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
operator|&
name|keyname
argument_list|,
name|namebuf
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dns_tsigkey_create
argument_list|(
operator|&
name|keyname
argument_list|,
name|dns_tsig_hmacmd5_name
argument_list|,
name|secretstore
argument_list|,
name|secretsize
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|printf
argument_list|(
literal|";; Couldn't create key %s: %s\n"
argument_list|,
name|keynametext
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|secretstore
argument_list|)
expr_stmt|;
name|dns_name_invalidate
argument_list|(
operator|&
name|keyname
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|namebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_file_key
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
name|debug
argument_list|(
literal|"setup_file_key()"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_fromnamedfile
argument_list|(
name|keyfile
argument_list|,
name|DST_TYPE_PRIVATE
operator||
name|DST_TYPE_KEY
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't read key from %s: %s\n"
argument_list|,
name|keyfile
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|result
operator|=
name|dns_tsigkey_createfromkey
argument_list|(
name|dst_key_name
argument_list|(
name|dstkey
argument_list|)
argument_list|,
name|dns_tsig_hmacmd5_name
argument_list|,
name|dstkey
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; Couldn't create key %s: %s\n"
argument_list|,
name|keynametext
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|dstkey
operator|=
name|NULL
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dstkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dig_searchlist_t
modifier|*
name|make_searchlist_entry
parameter_list|(
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|dig_searchlist_t
modifier|*
name|search
decl_stmt|;
name|search
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|search
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|search
operator|->
name|origin
argument_list|,
name|domain
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|search
operator|->
name|origin
index|[
name|MXNAME
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|search
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|search
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_search_list
parameter_list|(
name|lwres_conf_t
modifier|*
name|confdata
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dig_searchlist_t
modifier|*
name|search
decl_stmt|;
name|debug
argument_list|(
literal|"create_search_list()"
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|search_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|confdata
operator|->
name|searchnxt
condition|;
name|i
operator|++
control|)
block|{
name|search
operator|=
name|make_searchlist_entry
argument_list|(
name|confdata
operator|->
name|search
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|search_list
argument_list|,
name|search
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup the system as a whole, reading key information and resolv.conf  * settings.  */
end_comment

begin_function
name|void
name|setup_system
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_searchlist_t
modifier|*
name|domain
init|=
name|NULL
decl_stmt|;
name|lwres_result_t
name|lwresult
decl_stmt|;
name|debug
argument_list|(
literal|"setup_system()"
argument_list|)
expr_stmt|;
name|lwresult
operator|=
name|lwres_context_create
argument_list|(
operator|&
name|lwctx
argument_list|,
name|mctx
argument_list|,
name|mem_alloc
argument_list|,
name|mem_free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwresult
operator|!=
name|LWRES_R_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"lwres_context_create failed"
argument_list|)
expr_stmt|;
name|lwresult
operator|=
name|lwres_conf_parse
argument_list|(
name|lwctx
argument_list|,
name|RESOLV_CONF
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwresult
operator|!=
name|LWRES_R_SUCCESS
operator|&&
name|lwresult
operator|!=
name|LWRES_R_NOTFOUND
condition|)
name|fatal
argument_list|(
literal|"parse of %s failed"
argument_list|,
name|RESOLV_CONF
argument_list|)
expr_stmt|;
name|lwconf
operator|=
name|lwres_conf_get
argument_list|(
name|lwctx
argument_list|)
expr_stmt|;
comment|/* Make the search list */
if|if
condition|(
name|lwconf
operator|->
name|searchnxt
operator|>
literal|0
condition|)
name|create_search_list
argument_list|(
name|lwconf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* No search list. Use the domain name if any */
if|if
condition|(
name|lwconf
operator|->
name|domainname
operator|!=
name|NULL
condition|)
block|{
name|domain
operator|=
name|make_searchlist_entry
argument_list|(
name|lwconf
operator|->
name|domainname
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|search_list
argument_list|,
name|domain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|domain
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ndots
operator|==
operator|-
literal|1
condition|)
block|{
name|ndots
operator|=
name|lwconf
operator|->
name|ndots
expr_stmt|;
name|debug
argument_list|(
literal|"ndots is %d."
argument_list|,
name|ndots
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't find a nameserver fall back to localhost */
if|if
condition|(
name|lwconf
operator|->
name|nsnext
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|have_ipv4
condition|)
block|{
name|lwresult
operator|=
name|add_nameserver
argument_list|(
name|lwconf
argument_list|,
literal|"127.0.0.1"
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"add_nameserver failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_ipv6
condition|)
block|{
name|lwresult
operator|=
name|add_nameserver
argument_list|(
name|lwconf
argument_list|,
literal|"::1"
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"add_nameserver failed"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|server_list
argument_list|)
condition|)
name|copy_server_list
argument_list|(
name|lwconf
argument_list|,
operator|&
name|server_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfile
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|setup_file_key
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|keysecret
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|setup_text_key
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
comment|/* Setup the list of messages for +sigchase */
name|ISC_LIST_INIT
argument_list|(
name|chase_message_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|chase_message_list2
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|chase_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
name|dns_name_init
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DIG_SIGCHASE_BU
name|dns_name_init
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|clear_searchlist
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_searchlist_t
modifier|*
name|search
decl_stmt|;
while|while
condition|(
operator|(
name|search
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|search_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|search_list
argument_list|,
name|search
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|search
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Override the search list derived from resolv.conf by 'domain'.  */
end_comment

begin_function
name|void
name|set_search_domain
parameter_list|(
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|dig_searchlist_t
modifier|*
name|search
decl_stmt|;
name|clear_searchlist
argument_list|()
expr_stmt|;
name|search
operator|=
name|make_searchlist_entry
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|search_list
argument_list|,
name|search
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the ISC and DNS libraries for use by the system.  */
end_comment

begin_function
name|void
name|setup_libs
parameter_list|(
name|void
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"setup_libs()"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_net_probeipv4
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_ipv4
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_net_probeipv6
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|have_ipv6
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|have_ipv6
operator|&&
operator|!
name|have_ipv4
condition|)
name|fatal
argument_list|(
literal|"can't find either v4 or v6 networking"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mem_create
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_mem_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_taskmgr_create
argument_list|(
name|mctx
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|taskmgr
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_taskmgr_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|global_task
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_task_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timermgr_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|timermgr
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_timermgr_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socketmgr_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|socketmgr
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socketmgr_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_entropy_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|entp
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_entropy_create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_lib_init
argument_list|(
name|mctx
argument_list|,
name|entp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dst_lib_init"
argument_list|)
expr_stmt|;
name|is_dst_up
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_mempool_create
argument_list|(
name|mctx
argument_list|,
name|COMMSIZE
argument_list|,
operator|&
name|commctx
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_mempool_create"
argument_list|)
expr_stmt|;
name|isc_mempool_setname
argument_list|(
name|commctx
argument_list|,
literal|"COMMPOOL"
argument_list|)
expr_stmt|;
comment|/* 	 * 6 and 2 set as reasonable parameters for 3 or 4 nameserver 	 * systems. 	 */
name|isc_mempool_setfreemax
argument_list|(
name|commctx
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|isc_mempool_setfillcount
argument_list|(
name|commctx
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|lookup_lock
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_mutex_init"
argument_list|)
expr_stmt|;
name|dns_result_register
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add EDNS0 option record to a message.  Currently, the only supported  * options are UDP buffer size and the DO bit.  */
end_comment

begin_function
specifier|static
name|void
name|add_opt
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|isc_uint16_t
name|udpsize
parameter_list|,
name|isc_boolean_t
name|dnssec
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"add_opt()"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdataset"
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|msg
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdatalist"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|msg
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdata"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"setting udp size of %d"
argument_list|,
name|udpsize
argument_list|)
expr_stmt|;
name|rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_opt
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|rdatalist
operator|->
name|rdclass
operator|=
name|udpsize
expr_stmt|;
name|rdatalist
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dnssec
condition|)
name|rdatalist
operator|->
name|ttl
operator|=
name|DNS_MESSAGEEXTFLAG_DO
expr_stmt|;
name|rdata
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|rdata
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_setopt
argument_list|(
name|msg
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_setopt"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a question section to a message, asking for the specified name,  * type, and class.  */
end_comment

begin_function
specifier|static
name|void
name|add_question
parameter_list|(
name|dns_message_t
modifier|*
name|message
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|dns_rdatatype_t
name|rdtype
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"add_question()"
argument_list|)
expr_stmt|;
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|message
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdataset()"
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_makequestion
argument_list|(
name|rdataset
argument_list|,
name|rdclass
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|name
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if we're done with all the queued lookups, which is true iff  * all sockets, sends, and recvs are accounted for (counters == 0),  * and the lookup list is empty.  * If we are done, pass control back out to dighost_shutdown() (which is  * part of dig.c, host.c, or nslookup.c) to either shutdown the system as  * a whole or reseed the lookup list.  */
end_comment

begin_function
specifier|static
name|void
name|check_if_done
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"check_if_done()"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"list %s"
argument_list|,
name|ISC_LIST_EMPTY
argument_list|(
name|lookup_list
argument_list|)
condition|?
literal|"empty"
else|:
literal|"full"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|lookup_list
argument_list|)
operator|&&
name|current_lookup
operator|==
name|NULL
operator|&&
name|sendcount
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|sockcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|recvcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"shutting down"
argument_list|)
expr_stmt|;
name|dighost_shutdown
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear out a query when we're done with it.  WARNING: This routine  * WILL invalidate the query pointer.  */
end_comment

begin_function
specifier|static
name|void
name|clear_query
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|lookup
decl_stmt|;
name|REQUIRE
argument_list|(
name|query
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"clear_query(%p)"
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|lookup
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|current_query
operator|==
name|query
condition|)
name|lookup
operator|->
name|current_query
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|lookup
operator|->
name|q
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|query
operator|->
name|recvlist
argument_list|,
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|&
name|query
operator|->
name|lengthbuf
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|query
operator|->
name|lengthlist
argument_list|,
operator|&
name|query
operator|->
name|lengthbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|query
operator|->
name|recvspace
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|sock
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
block|}
name|isc_mempool_put
argument_list|(
name|commctx
argument_list|,
name|query
operator|->
name|recvspace
argument_list|)
expr_stmt|;
name|isc_buffer_invalidate
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
name|isc_buffer_invalidate
argument_list|(
operator|&
name|query
operator|->
name|lengthbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|waiting_senddone
condition|)
name|query
operator|->
name|pending_free
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try and clear out a lookup if we're done with it.  Return ISC_TRUE if  * the lookup was successfully cleared.  If ISC_TRUE is returned, the  * lookup pointer has been invalidated.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|try_clear_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|dig_server_t
modifier|*
name|s
decl_stmt|;
name|dig_query_t
modifier|*
name|q
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|REQUIRE
argument_list|(
name|lookup
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"try_clear_lookup(%p)"
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
block|{
name|q
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"query to %s still pending"
argument_list|,
name|q
operator|->
name|servname
argument_list|)
expr_stmt|;
name|q
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* 	 * At this point, we know there are no queries on the lookup, 	 * so can make it go away also. 	 */
name|debug
argument_list|(
literal|"cleared"
argument_list|)
expr_stmt|;
name|s
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing server %p belonging to %p"
argument_list|,
name|s
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
operator|(
name|dig_server_t
operator|*
operator|)
name|ptr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|sendmsg
operator|!=
name|NULL
condition|)
name|dns_message_destroy
argument_list|(
operator|&
name|lookup
operator|->
name|sendmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|querysig
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing buffer %p"
argument_list|,
name|lookup
operator|->
name|querysig
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|lookup
operator|->
name|querysig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|lookup
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|sendspace
operator|!=
name|NULL
condition|)
name|isc_mempool_put
argument_list|(
name|commctx
argument_list|,
name|lookup
operator|->
name|sendspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|tsigctx
operator|!=
name|NULL
condition|)
name|dst_context_destroy
argument_list|(
operator|&
name|lookup
operator|->
name|tsigctx
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we can, start the next lookup in the queue running.  * This assumes that the lookup on the head of the queue hasn't been  * started yet.  It also removes the lookup from the head of the queue,  * setting the current_lookup pointer pointing to it.  */
end_comment

begin_function
name|void
name|start_lookup
parameter_list|(
name|void
parameter_list|)
block|{
name|debug
argument_list|(
literal|"start_lookup()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_now
condition|)
return|return;
comment|/* 	 * If there's a current lookup running, we really shouldn't get 	 * here. 	 */
name|INSIST
argument_list|(
name|current_lookup
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|current_lookup
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup_list
argument_list|)
expr_stmt|;
comment|/* 	 * Put the current lookup somewhere so cancel_all can find it 	 */
if|if
condition|(
name|current_lookup
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
name|lookup_list
argument_list|,
name|current_lookup
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
if|if
condition|(
name|current_lookup
operator|->
name|do_topdown
operator|&&
operator|!
name|current_lookup
operator|->
name|rdtype_sigchaseset
condition|)
block|{
name|dst_key_t
modifier|*
name|trustedkey
init|=
name|NULL
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|query_name
decl_stmt|;
name|dns_name_t
modifier|*
name|key_name
decl_stmt|;
name|int
name|i
decl_stmt|;
name|result
operator|=
name|get_trusted_key
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; No trusted key, "
literal|"+sigchase option is disabled\n"
argument_list|)
expr_stmt|;
name|current_lookup
operator|->
name|sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|novalidation
goto|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|query_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nameFromString
argument_list|(
name|current_lookup
operator|->
name|textname
argument_list|,
operator|&
name|query_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tk_list
operator|.
name|nb_tk
condition|;
name|i
operator|++
control|)
block|{
name|key_name
operator|=
name|dst_key_name
argument_list|(
name|tk_list
operator|.
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
operator|&
name|query_name
argument_list|,
name|key_name
argument_list|)
operator|==
name|ISC_TRUE
condition|)
name|trustedkey
operator|=
name|tk_list
operator|.
name|key
index|[
name|i
index|]
expr_stmt|;
comment|/* 				 * Verifier que la temp est bien la plus basse 				 * WARNING 				 */
block|}
if|if
condition|(
name|trustedkey
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; The queried zone: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
operator|&
name|query_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" isn't a subdomain of any Trusted Keys"
literal|": +sigchase option is disable\n"
argument_list|)
expr_stmt|;
name|current_lookup
operator|->
name|sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|query_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
goto|goto
name|novalidation
goto|;
block|}
name|free_name
argument_list|(
operator|&
name|query_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|current_lookup
operator|->
name|rdtype_sigchase
operator|=
name|current_lookup
operator|->
name|rdtype
expr_stmt|;
name|current_lookup
operator|->
name|rdtype_sigchaseset
operator|=
name|current_lookup
operator|->
name|rdtypeset
expr_stmt|;
name|current_lookup
operator|->
name|rdtype
operator|=
name|dns_rdatatype_ns
expr_stmt|;
name|current_lookup
operator|->
name|qrdtype_sigchase
operator|=
name|current_lookup
operator|->
name|qrdtype
expr_stmt|;
name|current_lookup
operator|->
name|qrdtype
operator|=
name|dns_rdatatype_ns
expr_stmt|;
name|current_lookup
operator|->
name|rdclass_sigchase
operator|=
name|current_lookup
operator|->
name|rdclass
expr_stmt|;
name|current_lookup
operator|->
name|rdclass_sigchaseset
operator|=
name|current_lookup
operator|->
name|rdclassset
expr_stmt|;
name|current_lookup
operator|->
name|rdclass
operator|=
name|dns_rdataclass_in
expr_stmt|;
name|strncpy
argument_list|(
name|current_lookup
operator|->
name|textnamesigchase
argument_list|,
name|current_lookup
operator|->
name|textname
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|current_lookup
operator|->
name|trace_root_sigchase
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_totext
argument_list|(
name|dst_key_name
argument_list|(
name|trustedkey
argument_list|)
argument_list|,
name|ISC_FALSE
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_name_totext"
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|current_lookup
operator|->
name|textname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|nameFromString
argument_list|(
name|current_lookup
operator|->
name|textnamesigchase
argument_list|,
operator|&
name|chase_name
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|novalidation
label|:
endif|#
directive|endif
name|setup_lookup
argument_list|(
name|current_lookup
argument_list|)
expr_stmt|;
name|do_lookup
argument_list|(
name|current_lookup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_if_done
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If we can, clear the current lookup and start the next one running.  * This calls try_clear_lookup, so may invalidate the lookup pointer.  */
end_comment

begin_function
specifier|static
name|void
name|check_next_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"check_next_lookup(%p)"
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"still have a worker"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|try_clear_lookup
argument_list|(
name|lookup
argument_list|)
condition|)
block|{
name|current_lookup
operator|=
name|NULL
expr_stmt|;
name|start_lookup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create and queue a new lookup as a followup to the current lookup,  * based on the supplied message and section.  This is used in trace and  * name server search modes to start a new lookup using servers from  * NS records in a reply. Returns the number of followup lookups made.  */
end_comment

begin_function
specifier|static
name|int
name|followup_lookup
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dig_query_t
modifier|*
name|query
parameter_list|,
name|dns_section_t
name|section
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|lookup
init|=
name|NULL
decl_stmt|;
name|dig_server_t
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|success
init|=
name|ISC_FALSE
decl_stmt|;
name|int
name|numLookups
init|=
literal|0
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"following up %s"
argument_list|,
name|query
operator|->
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
control|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|DNS_SECTION_AUTHORITY
condition|)
block|{
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|dns_rdatatype_soa
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_findtype
argument_list|(
name|name
argument_list|,
name|dns_rdatatype_ns
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
name|debug
argument_list|(
literal|"found NS set"
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|char
name|namestr
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
if|if
condition|(
name|query
operator|->
name|lookup
operator|->
name|trace_root
operator|&&
name|query
operator|->
name|lookup
operator|->
name|nsfound
operator|>=
name|MXSERV
condition|)
break|break;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|query
operator|->
name|lookup
operator|->
name|nsfound
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|namestr
argument_list|,
sizeof|sizeof
argument_list|(
name|namestr
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
comment|/* Initialize lookup if we've not yet */
name|debug
argument_list|(
literal|"found NS %d %s"
argument_list|,
name|numLookups
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|numLookups
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|success
operator|=
name|ISC_TRUE
expr_stmt|;
name|lookup_counter
operator|++
expr_stmt|;
name|lookup
operator|=
name|requeue_lookup
argument_list|(
name|query
operator|->
name|lookup
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|query
operator|->
name|lookup
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|doing_xfr
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|lookup
operator|->
name|trace_root
operator|&&
name|section
operator|==
name|DNS_SECTION_ANSWER
condition|)
name|lookup
operator|->
name|trace
operator|=
name|ISC_FALSE
expr_stmt|;
else|else
name|lookup
operator|->
name|trace
operator|=
name|query
operator|->
name|lookup
operator|->
name|trace
expr_stmt|;
name|lookup
operator|->
name|ns_search_only
operator|=
name|query
operator|->
name|lookup
operator|->
name|ns_search_only
expr_stmt|;
name|lookup
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|ns_search_only
condition|)
name|lookup
operator|->
name|recurse
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|srv
operator|=
name|make_server
argument_list|(
name|namestr
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"adding server %s"
argument_list|,
name|srv
operator|->
name|servername
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lookup
operator|==
name|NULL
operator|&&
name|section
operator|==
name|DNS_SECTION_ANSWER
operator|&&
operator|(
name|query
operator|->
name|lookup
operator|->
name|trace
operator|||
name|query
operator|->
name|lookup
operator|->
name|ns_search_only
operator|)
condition|)
return|return
operator|(
name|followup_lookup
argument_list|(
name|msg
argument_list|,
name|query
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|)
return|;
return|return
name|numLookups
return|;
block|}
end_function

begin_comment
comment|/*  * Create and queue a new lookup using the next origin from the search  * list, read in setup_system().  *  * Return ISC_TRUE iff there was another searchlist entry.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|next_origin
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dig_query_t
modifier|*
name|query
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|lookup
decl_stmt|;
name|UNUSED
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"next_origin()"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"following up %s"
argument_list|,
name|query
operator|->
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|usesearch
condition|)
comment|/* 		 * We're not using a search list, so don't even think 		 * about finding the next entry. 		 */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|query
operator|->
name|lookup
operator|->
name|origin
operator|==
name|NULL
condition|)
comment|/* 		 * Then we just did rootorg; there's nothing left. 		 */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|lookup
operator|=
name|requeue_lookup
argument_list|(
name|query
operator|->
name|lookup
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|origin
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
operator|->
name|lookup
operator|->
name|origin
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|query
operator|->
name|lookup
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert an SOA record into the sendmessage in a lookup.  Used for  * creating IXFR queries.  */
end_comment

begin_function
specifier|static
name|void
name|insert_soa
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_name_t
modifier|*
name|soaname
init|=
name|NULL
decl_stmt|;
name|debug
argument_list|(
literal|"insert_soa()"
argument_list|)
expr_stmt|;
name|soa
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|soa
operator|.
name|serial
operator|=
name|lookup
operator|->
name|ixfr_serial
expr_stmt|;
name|soa
operator|.
name|refresh
operator|=
literal|0
expr_stmt|;
name|soa
operator|.
name|retry
operator|=
literal|0
expr_stmt|;
name|soa
operator|.
name|expire
operator|=
literal|0
expr_stmt|;
name|soa
operator|.
name|minimum
operator|=
literal|0
expr_stmt|;
name|soa
operator|.
name|common
operator|.
name|rdclass
operator|=
name|lookup
operator|->
name|rdclass
expr_stmt|;
name|soa
operator|.
name|common
operator|.
name|rdtype
operator|=
name|dns_rdatatype_soa
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|soa
operator|.
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|soa
operator|.
name|contact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_rootname
argument_list|,
operator|&
name|soa
operator|.
name|origin
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_rootname
argument_list|,
operator|&
name|soa
operator|.
name|contact
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|lookup
operator|->
name|rdatabuf
argument_list|,
name|lookup
operator|->
name|rdatastore
argument_list|,
sizeof|sizeof
argument_list|(
name|lookup
operator|->
name|rdatastore
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdata
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdata"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_fromstruct
argument_list|(
name|rdata
argument_list|,
name|lookup
operator|->
name|rdclass
argument_list|,
name|dns_rdatatype_soa
argument_list|,
operator|&
name|soa
argument_list|,
operator|&
name|lookup
operator|->
name|rdatabuf
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_rdata_fromstruct"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdatalist
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdatalist"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettemprdataset"
argument_list|)
expr_stmt|;
name|dns_rdatalist_init
argument_list|(
name|rdatalist
argument_list|)
expr_stmt|;
name|rdatalist
operator|->
name|type
operator|=
name|dns_rdatatype_soa
expr_stmt|;
name|rdatalist
operator|->
name|rdclass
operator|=
name|lookup
operator|->
name|rdclass
expr_stmt|;
name|rdatalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|rdatalist
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdatalist_tordataset
argument_list|(
name|rdatalist
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|soaname
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettempname"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|soaname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|lookup
operator|->
name|name
argument_list|,
name|soaname
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|soaname
operator|->
name|list
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|soaname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_message_addname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|soaname
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the supplied lookup structure, making it ready to start sending  * queries to servers.  Create and initialize the message to be sent as  * well as the query structures and buffer space for the replies.  If the  * server list is empty, clone it from the system default list.  */
end_comment

begin_function
name|void
name|setup_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
name|dig_server_t
modifier|*
name|serv
decl_stmt|;
name|dig_query_t
modifier|*
name|query
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_compress_t
name|cctx
decl_stmt|;
name|char
name|store
index|[
name|MXNAME
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|lookup
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"setup_lookup(%p)"
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_create
argument_list|(
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTRENDER
argument_list|,
operator|&
name|lookup
operator|->
name|sendmsg
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|new_search
condition|)
block|{
name|debug
argument_list|(
literal|"resetting lookup counter."
argument_list|)
expr_stmt|;
name|lookup_counter
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"cloning server list"
argument_list|)
expr_stmt|;
name|clone_server_list
argument_list|(
name|server_list
argument_list|,
operator|&
name|lookup
operator|->
name|my_server_list
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettempname"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|lookup
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|lookup
operator|->
name|namebuf
argument_list|,
name|lookup
operator|->
name|namespace
argument_list|,
sizeof|sizeof
argument_list|(
name|lookup
operator|->
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|lookup
operator|->
name|onamebuf
argument_list|,
name|lookup
operator|->
name|onamespace
argument_list|,
sizeof|sizeof
argument_list|(
name|lookup
operator|->
name|onamespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the name has too many dots, force the origin to be NULL 	 * (which produces an absolute lookup).  Otherwise, take the origin 	 * we have if there's one in the struct already.  If it's NULL, 	 * take the first entry in the searchlist iff either usesearch 	 * is TRUE or we got a domain line in the resolv.conf file. 	 */
comment|/* XXX New search here? */
if|if
condition|(
operator|(
name|count_dots
argument_list|(
name|lookup
operator|->
name|textname
argument_list|)
operator|>=
name|ndots
operator|)
operator|||
operator|!
name|usesearch
condition|)
name|lookup
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
comment|/* Force abs lookup */
elseif|else
if|if
condition|(
name|lookup
operator|->
name|origin
operator|==
name|NULL
operator|&&
name|lookup
operator|->
name|new_search
operator|&&
name|usesearch
condition|)
name|lookup
operator|->
name|origin
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|search_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|origin
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"trying origin %s"
argument_list|,
name|lookup
operator|->
name|origin
operator|->
name|origin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_gettempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|oname
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_gettempname"
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|lookup
operator|->
name|oname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX Helper funct to conv char* to name? */
name|len
operator|=
name|strlen
argument_list|(
name|lookup
operator|->
name|origin
operator|->
name|origin
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|lookup
operator|->
name|origin
operator|->
name|origin
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|lookup
operator|->
name|oname
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|lookup
operator|->
name|onamebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|oname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"'%s' is not in legal name syntax (%s)"
argument_list|,
name|lookup
operator|->
name|origin
operator|->
name|origin
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|trace
operator|&&
name|lookup
operator|->
name|trace_root
condition|)
block|{
name|dns_name_clone
argument_list|(
name|dns_rootname
argument_list|,
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|lookup
operator|->
name|textname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|lookup
operator|->
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|lookup
operator|->
name|oname
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|lookup
operator|->
name|namebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|oname
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"'%s' is not in legal name syntax (%s)"
argument_list|,
name|lookup
operator|->
name|textname
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|oname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"using root origin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|trace
operator|&&
name|lookup
operator|->
name|trace_root
condition|)
name|dns_name_clone
argument_list|(
name|dns_rootname
argument_list|,
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|lookup
operator|->
name|textname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|lookup
operator|->
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|lookup
operator|->
name|namebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_puttempname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|lookup
operator|->
name|name
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|store
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"'%s' is not a legal name "
literal|"(%s)"
argument_list|,
name|lookup
operator|->
name|textname
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dns_name_format
argument_list|(
name|lookup
operator|->
name|name
argument_list|,
name|store
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
name|trying
argument_list|(
name|store
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|lookup
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|id
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|id
operator|=
operator|(
name|unsigned
name|short
operator|)
name|id
operator|&
literal|0xFFFF
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|opcode
operator|=
name|dns_opcode_query
expr_stmt|;
name|lookup
operator|->
name|msgcounter
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If this is a trace request, completely disallow recursion, since 	 * it's meaningless for traces. 	 */
if|if
condition|(
name|lookup
operator|->
name|trace
operator|||
operator|(
name|lookup
operator|->
name|ns_search_only
operator|&&
operator|!
name|lookup
operator|->
name|trace_root
operator|)
condition|)
name|lookup
operator|->
name|recurse
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|recurse
operator|&&
name|lookup
operator|->
name|rdtype
operator|!=
name|dns_rdatatype_axfr
operator|&&
name|lookup
operator|->
name|rdtype
operator|!=
name|dns_rdatatype_ixfr
condition|)
block|{
name|debug
argument_list|(
literal|"recursive query"
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_RD
expr_stmt|;
block|}
comment|/* XXX aaflag */
if|if
condition|(
name|lookup
operator|->
name|aaonly
condition|)
block|{
name|debug
argument_list|(
literal|"AA query"
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AA
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|adflag
condition|)
block|{
name|debug
argument_list|(
literal|"AD query"
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_AD
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|cdflag
condition|)
block|{
name|debug
argument_list|(
literal|"CD query"
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|sendmsg
operator|->
name|flags
operator||=
name|DNS_MESSAGEFLAG_CD
expr_stmt|;
block|}
name|dns_message_addname
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|lookup
operator|->
name|name
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|trace
operator|&&
name|lookup
operator|->
name|trace_root
condition|)
block|{
name|lookup
operator|->
name|qrdtype
operator|=
name|lookup
operator|->
name|rdtype
expr_stmt|;
name|lookup
operator|->
name|rdtype
operator|=
name|dns_rdatatype_ns
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lookup
operator|->
name|rdtype
operator|==
name|dns_rdatatype_axfr
operator|)
operator|||
operator|(
name|lookup
operator|->
name|rdtype
operator|==
name|dns_rdatatype_ixfr
operator|)
condition|)
block|{
name|lookup
operator|->
name|doing_xfr
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Force TCP mode if we're doing an xfr. 		 * XXX UDP ixfr's would be useful 		 */
name|lookup
operator|->
name|tcp_mode
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|add_question
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|lookup
operator|->
name|name
argument_list|,
name|lookup
operator|->
name|rdclass
argument_list|,
name|lookup
operator|->
name|rdtype
argument_list|)
expr_stmt|;
comment|/* add_soa */
if|if
condition|(
name|lookup
operator|->
name|rdtype
operator|==
name|dns_rdatatype_ixfr
condition|)
name|insert_soa
argument_list|(
name|lookup
argument_list|)
expr_stmt|;
comment|/* XXX Insist this? */
name|lookup
operator|->
name|tsigctx
operator|=
name|NULL
expr_stmt|;
name|lookup
operator|->
name|querysig
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"initializing keys"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_settsigkey"
argument_list|)
expr_stmt|;
block|}
name|lookup
operator|->
name|sendspace
operator|=
name|isc_mempool_get
argument_list|(
name|commctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|sendspace
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_compress_init
argument_list|(
operator|&
name|cctx
argument_list|,
operator|-
literal|1
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_compress_init"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"starting to render the message"
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|lookup
operator|->
name|renderbuf
argument_list|,
name|lookup
operator|->
name|sendspace
argument_list|,
name|COMMSIZE
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_renderbegin
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
operator|&
name|cctx
argument_list|,
operator|&
name|lookup
operator|->
name|renderbuf
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_renderbegin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|udpsize
operator|>
literal|0
operator|||
name|lookup
operator|->
name|dnssec
condition|)
block|{
if|if
condition|(
name|lookup
operator|->
name|udpsize
operator|==
literal|0
condition|)
name|lookup
operator|->
name|udpsize
operator|=
literal|2048
expr_stmt|;
name|add_opt
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|lookup
operator|->
name|udpsize
argument_list|,
name|lookup
operator|->
name|dnssec
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|DNS_SECTION_QUESTION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_rendersection"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_rendersection
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_rendersection"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_renderend
argument_list|(
name|lookup
operator|->
name|sendmsg
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_renderend"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"done rendering"
argument_list|)
expr_stmt|;
name|dns_compress_invalidate
argument_list|(
operator|&
name|cctx
argument_list|)
expr_stmt|;
comment|/* 	 * Force TCP mode if the request is larger than 512 bytes. 	 */
if|if
condition|(
name|isc_buffer_usedlength
argument_list|(
operator|&
name|lookup
operator|->
name|renderbuf
argument_list|)
operator|>
literal|512
condition|)
name|lookup
operator|->
name|tcp_mode
operator|=
name|ISC_TRUE
expr_stmt|;
name|lookup
operator|->
name|pending
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|serv
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|)
init|;
name|serv
operator|!=
name|NULL
condition|;
name|serv
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|serv
argument_list|,
name|link
argument_list|)
control|)
block|{
name|query
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dig_query_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"create query %p linked to lookup %p"
argument_list|,
name|query
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|query
operator|->
name|lookup
operator|=
name|lookup
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|waiting_senddone
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|pending_free
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|recv_made
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|first_pass
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|first_soa_rcvd
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|second_rr_rcvd
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|first_repeat_rcvd
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|warn_id
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|first_rr_serial
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|second_rr_serial
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|servname
operator|=
name|serv
operator|->
name|servername
expr_stmt|;
name|query
operator|->
name|userarg
operator|=
name|serv
operator|->
name|userarg
expr_stmt|;
name|query
operator|->
name|rr_count
operator|=
literal|0
expr_stmt|;
name|query
operator|->
name|msg_count
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|query
operator|->
name|recvlist
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|query
operator|->
name|lengthlist
argument_list|)
expr_stmt|;
name|query
operator|->
name|sock
operator|=
name|NULL
expr_stmt|;
name|query
operator|->
name|recvspace
operator|=
name|isc_mempool_get
argument_list|(
name|commctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|recvspace
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"memory allocation failure"
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|query
operator|->
name|recvspace
argument_list|,
name|COMMSIZE
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|lengthbuf
argument_list|,
name|query
operator|->
name|lengthspace
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|slbuf
argument_list|,
name|query
operator|->
name|slspace
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|query
operator|->
name|sendbuf
operator|=
name|lookup
operator|->
name|renderbuf
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|lookup
operator|->
name|q
argument_list|,
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* XXX qrflag, print_query, etc... */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
operator|&&
name|qr
condition|)
block|{
name|printmessage
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
argument_list|,
name|lookup
operator|->
name|sendmsg
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Event handler for send completion.  Track send counter, and clear out  * the query if the send was canceled.  */
end_comment

begin_function
specifier|static
name|void
name|send_done
parameter_list|(
name|isc_task_t
modifier|*
name|_task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|dig_query_t
modifier|*
name|query
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_SENDDONE
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|_task
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|debug
argument_list|(
literal|"send_done()"
argument_list|)
expr_stmt|;
name|sendcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"sendcount=%d"
argument_list|,
name|sendcount
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sendcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|)
control|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|query
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|query
operator|->
name|waiting_senddone
operator|=
name|ISC_FALSE
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|ns_search_only
operator|&&
operator|!
name|l
operator|->
name|trace_root
condition|)
block|{
name|debug
argument_list|(
literal|"sending next, since searching"
argument_list|)
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|send_udp
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|pending_free
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_if_done
argument_list|()
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel a lookup, sending isc_socket_cancel() requests to all outstanding  * IO sockets.  The cancel handlers should take care of cleaning up the  * query and lookup structures  */
end_comment

begin_function
specifier|static
name|void
name|cancel_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|dig_query_t
modifier|*
name|query
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|debug
argument_list|(
literal|"cancel_lookup()"
argument_list|)
expr_stmt|;
name|query
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|query
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|sock
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_cancel
argument_list|(
name|query
operator|->
name|sock
argument_list|,
name|global_task
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
name|check_if_done
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
name|query
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|lookup
operator|->
name|timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|lookup
operator|->
name|timer
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|pending
operator|=
name|ISC_FALSE
expr_stmt|;
name|lookup
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bringup_timer
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|,
name|unsigned
name|int
name|default_timeout
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|local_timeout
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"bringup_timer()"
argument_list|)
expr_stmt|;
comment|/* 	 * If the timer already exists, that means we're calling this 	 * a second time (for a retry).  Don't need to recreate it, 	 * just reset it. 	 */
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
if|if
condition|(
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
operator|!=
name|NULL
condition|)
name|local_timeout
operator|=
name|SERVER_TIMEOUT
expr_stmt|;
else|else
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|local_timeout
operator|=
name|default_timeout
expr_stmt|;
else|else
name|local_timeout
operator|=
name|timeout
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"have local timeout of %d"
argument_list|,
name|local_timeout
argument_list|)
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|l
operator|->
name|interval
argument_list|,
name|local_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|l
operator|->
name|timer
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|timermgr
argument_list|,
name|isc_timertype_once
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
operator|->
name|interval
argument_list|,
name|global_task
argument_list|,
name|connect_timeout
argument_list|,
name|l
argument_list|,
operator|&
name|l
operator|->
name|timer
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_timer_create"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|connect_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Unlike send_udp, this can't be called multiple times with the same  * query.  When we retry TCP, we requeue the whole lookup, which should  * start anew.  */
end_comment

begin_function
specifier|static
name|void
name|send_tcp_connect
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dig_query_t
modifier|*
name|next
decl_stmt|;
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|debug
argument_list|(
literal|"send_tcp_connect(%p)"
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|lookup
operator|->
name|current_query
operator|=
name|query
expr_stmt|;
name|get_address
argument_list|(
name|query
operator|->
name|servname
argument_list|,
name|port
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|specified_source
operator|&&
operator|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|!=
name|isc_sockaddr_pf
argument_list|(
operator|&
name|bind_address
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|";; Skipping server %s, incompatible "
literal|"address family\n"
argument_list|,
name|query
operator|->
name|servname
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|";; No acceptable nameservers\n"
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
name|send_tcp_connect
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|query
operator|->
name|sock
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_create
argument_list|(
name|socketmgr
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
argument_list|,
name|isc_sockettype_tcp
argument_list|,
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_create"
argument_list|)
expr_stmt|;
name|sockcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|specified_source
condition|)
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|bind_address
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|==
name|AF_INET
operator|)
operator|&&
name|have_ipv4
condition|)
name|isc_sockaddr_any
argument_list|(
operator|&
name|bind_any
argument_list|)
expr_stmt|;
else|else
name|isc_sockaddr_any6
argument_list|(
operator|&
name|bind_any
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|bind_any
argument_list|)
expr_stmt|;
block|}
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_bind"
argument_list|)
expr_stmt|;
name|bringup_timer
argument_list|(
name|query
argument_list|,
name|TCP_TIMEOUT
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_connect
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
name|global_task
argument_list|,
name|connect_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_connect"
argument_list|)
expr_stmt|;
comment|/* 	 * If we're at the endgame of a nameserver search, we need to 	 * immediately bring up all the queries.  Do it here. 	 */
if|if
condition|(
name|l
operator|->
name|ns_search_only
operator|&&
operator|!
name|l
operator|->
name|trace_root
condition|)
block|{
name|debug
argument_list|(
literal|"sending next, since searching"
argument_list|)
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|send_tcp_connect
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a UDP packet to the remote nameserver, possible starting the  * recv action as well.  Also make sure that the timer is running and  * is properly reset.  */
end_comment

begin_function
specifier|static
name|void
name|send_udp
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|l
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"send_udp(%p)"
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|bringup_timer
argument_list|(
name|query
argument_list|,
name|UDP_TIMEOUT
argument_list|)
expr_stmt|;
name|l
operator|->
name|current_query
operator|=
name|query
expr_stmt|;
name|debug
argument_list|(
literal|"working on lookup %p, query %p"
argument_list|,
name|query
operator|->
name|lookup
argument_list|,
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|recv_made
condition|)
block|{
comment|/* XXX Check the sense of this, need assertion? */
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|get_address
argument_list|(
name|query
operator|->
name|servname
argument_list|,
name|port
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_create
argument_list|(
name|socketmgr
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
argument_list|,
name|isc_sockettype_udp
argument_list|,
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_create"
argument_list|)
expr_stmt|;
name|sockcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|specified_source
condition|)
block|{
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|bind_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|bind_any
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|bind_any
argument_list|)
expr_stmt|;
block|}
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_bind"
argument_list|)
expr_stmt|;
name|query
operator|->
name|recv_made
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|recvlist
argument_list|,
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"recving with lookup=%p, query=%p, sock=%p"
argument_list|,
name|query
operator|->
name|lookup
argument_list|,
name|query
argument_list|,
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_recvv
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|recvlist
argument_list|,
literal|1
argument_list|,
name|global_task
argument_list|,
name|recv_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_recvv"
argument_list|)
expr_stmt|;
name|recvcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"recvcount=%d"
argument_list|,
name|recvcount
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|query
operator|->
name|sendlist
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|sendlist
argument_list|,
operator|&
name|query
operator|->
name|sendbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"sending a request"
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|query
operator|->
name|time_sent
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|query
operator|->
name|sock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_senddone
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_socket_sendtov
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|sendlist
argument_list|,
name|global_task
argument_list|,
name|send_done
argument_list|,
name|query
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_sendtov"
argument_list|)
expr_stmt|;
name|sendcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IO timeout handler, used for both connect and recv timeouts.  If  * retries are still allowed, either resend the UDP packet or queue a  * new TCP lookup.  Otherwise, cancel the lookup.  */
end_comment

begin_function
specifier|static
name|void
name|connect_timeout
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|l
init|=
name|NULL
decl_stmt|;
name|dig_query_t
modifier|*
name|query
init|=
name|NULL
decl_stmt|,
modifier|*
name|cq
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_IDLE
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"connect_timeout()"
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|l
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|query
operator|=
name|l
operator|->
name|current_query
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|query
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|query
operator|->
name|lookup
operator|->
name|current_query
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ISC_LIST_NEXT
argument_list|(
name|query
operator|->
name|lookup
operator|->
name|current_query
argument_list|,
name|link
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|debug
argument_list|(
literal|"trying next server..."
argument_list|)
expr_stmt|;
name|cq
operator|=
name|query
operator|->
name|lookup
operator|->
name|current_query
expr_stmt|;
if|if
condition|(
operator|!
name|l
operator|->
name|tcp_mode
condition|)
name|send_udp
argument_list|(
name|ISC_LIST_NEXT
argument_list|(
name|cq
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|send_tcp_connect
argument_list|(
name|ISC_LIST_NEXT
argument_list|(
name|cq
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|l
operator|->
name|retries
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|tcp_mode
condition|)
block|{
name|l
operator|->
name|retries
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"resending UDP request to first server"
argument_list|)
expr_stmt|;
name|send_udp
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|l
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"making new TCP request, %d tries left"
argument_list|,
name|l
operator|->
name|retries
argument_list|)
expr_stmt|;
name|l
operator|->
name|retries
operator|--
expr_stmt|;
name|requeue_lookup
argument_list|(
name|l
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fputs
argument_list|(
name|l
operator|->
name|cmdline
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; connection timed out; no servers could be "
literal|"reached\n"
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitcode
operator|<
literal|9
condition|)
name|exitcode
operator|=
literal|9
expr_stmt|;
block|}
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Event handler for the TCP recv which gets the length header of TCP  * packets.  Start the next recv of length bytes.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_length_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dig_query_t
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|isc_uint16_t
name|length
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_RECVDONE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"tcp_length_done()"
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|query
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|recvcount
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|recvcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|b
operator|==
operator|&
name|query
operator|->
name|lengthbuf
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sevent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|sockstr
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
name|sockstr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockstr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; communications error to %s: %s\n"
argument_list|,
name|sockstr
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sockcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
name|length
operator|=
name|isc_buffer_getuint16
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|launch_next_query
argument_list|(
name|query
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
comment|/* 	 * Even though the buffer was already init'ed, we need 	 * to redo it now, to force the length we want. 	 */
name|isc_buffer_invalidate
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|query
operator|->
name|recvspace
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|query
operator|->
name|recvlist
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|recvlist
argument_list|,
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"recving with lookup=%p, query=%p"
argument_list|,
name|query
operator|->
name|lookup
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_recvv
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|recvlist
argument_list|,
name|length
argument_list|,
name|task
argument_list|,
name|recv_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_recvv"
argument_list|)
expr_stmt|;
name|recvcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"resubmitted recv request with length %d, recvcount=%d"
argument_list|,
name|length
argument_list|,
name|recvcount
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For transfers that involve multiple recvs (XFR's in particular),  * launch the next recv.  */
end_comment

begin_function
specifier|static
name|void
name|launch_next_query
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|,
name|isc_boolean_t
name|include_question
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"launch_next_query()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|lookup
operator|->
name|pending
condition|)
block|{
name|debug
argument_list|(
literal|"ignoring launch_next_query because !pending"
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sockcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
name|isc_buffer_clear
argument_list|(
operator|&
name|query
operator|->
name|slbuf
argument_list|)
expr_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|query
operator|->
name|lengthbuf
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|query
operator|->
name|slbuf
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|query
operator|->
name|sendbuf
operator|.
name|used
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|query
operator|->
name|sendlist
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|query
operator|->
name|slbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|sendlist
argument_list|,
operator|&
name|query
operator|->
name|slbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_question
condition|)
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|sendlist
argument_list|,
operator|&
name|query
operator|->
name|sendbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|query
operator|->
name|lengthbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|lengthlist
argument_list|,
operator|&
name|query
operator|->
name|lengthbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_recvv
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|lengthlist
argument_list|,
literal|0
argument_list|,
name|global_task
argument_list|,
name|tcp_length_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_recvv"
argument_list|)
expr_stmt|;
name|recvcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"recvcount=%d"
argument_list|,
name|recvcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|first_soa_rcvd
condition|)
block|{
name|debug
argument_list|(
literal|"sending a request in launch_next_query"
argument_list|)
expr_stmt|;
name|TIME_NOW
argument_list|(
operator|&
name|query
operator|->
name|time_sent
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_senddone
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_socket_sendv
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|sendlist
argument_list|,
name|global_task
argument_list|,
name|send_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_sendv"
argument_list|)
expr_stmt|;
name|sendcount
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"sendcount=%d"
argument_list|,
name|sendcount
argument_list|)
expr_stmt|;
block|}
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
if|#
directive|if
literal|0
block|check_next_lookup(query->lookup);
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * Event handler for TCP connect complete.  Make sure the connection was  * successful, then pass into launch_next_query to actually send the  * question.  */
end_comment

begin_function
specifier|static
name|void
name|connect_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
name|NULL
decl_stmt|;
name|dig_query_t
modifier|*
name|query
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dig_lookup_t
modifier|*
name|l
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_CONNECT
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"connect_done()"
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|query
operator|=
name|sevent
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|query
operator|->
name|waiting_connect
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|sevent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|debug
argument_list|(
literal|"in cancel handler"
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sockcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|sockstr
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"unsuccessful connection: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
name|sockstr
argument_list|,
sizeof|sizeof
argument_list|(
name|sockstr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sevent
operator|->
name|result
operator|!=
name|ISC_R_CANCELED
condition|)
name|printf
argument_list|(
literal|";; Connection to %s(%s) for %s failed: "
literal|"%s.\n"
argument_list|,
name|sockstr
argument_list|,
name|query
operator|->
name|servname
argument_list|,
name|query
operator|->
name|lookup
operator|->
name|textname
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sockcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Clean up exitcodes */
if|if
condition|(
name|exitcode
operator|<
literal|9
condition|)
name|exitcode
operator|=
literal|9
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|current_query
operator|!=
name|NULL
condition|)
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|l
operator|->
name|current_query
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|NULL
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|bringup_timer
argument_list|(
name|next
argument_list|,
name|TCP_TIMEOUT
argument_list|)
expr_stmt|;
name|send_tcp_connect
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
name|launch_next_query
argument_list|(
name|query
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the ongoing XFR needs more data before it's complete, using  * the semantics of IXFR and AXFR protocols.  Much of the complexity of  * this routine comes from determining when an IXFR is complete.  * ISC_FALSE means more data is on the way, and the recv has been issued.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|check_for_more_data
parameter_list|(
name|dig_query_t
modifier|*
name|query
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|isc_socketevent_t
modifier|*
name|sevent
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_soa_t
name|soa
decl_stmt|;
name|isc_uint32_t
name|serial
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|debug
argument_list|(
literal|"check_for_more_data()"
argument_list|)
expr_stmt|;
comment|/* 	 * By the time we're in this routine, we know we're doing 	 * either an AXFR or IXFR.  If there's no second_rr_type, 	 * then we don't yet know which kind of answer we got back 	 * from the server.  Here, we're going to walk through the 	 * rr's in the message, acting as necessary whenever we hit 	 * an SOA rr. 	 */
name|query
operator|->
name|msg_count
operator|++
expr_stmt|;
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|puts
argument_list|(
literal|"; Transfer failed."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
do|do
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
do|do
block|{
name|query
operator|->
name|rr_count
operator|++
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 				 * If this is the first rr, make sure 				 * it's an SOA 				 */
if|if
condition|(
operator|(
operator|!
name|query
operator|->
name|first_soa_rcvd
operator|)
operator|&&
operator|(
name|rdata
operator|.
name|type
operator|!=
name|dns_rdatatype_soa
operator|)
condition|)
block|{
name|puts
argument_list|(
literal|"; Transfer failed.  "
literal|"Didn't start with SOA answer."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|query
operator|->
name|second_rr_rcvd
operator|)
operator|&&
operator|(
name|rdata
operator|.
name|type
operator|!=
name|dns_rdatatype_soa
operator|)
condition|)
block|{
name|query
operator|->
name|second_rr_rcvd
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|second_rr_serial
operator|=
literal|0
expr_stmt|;
name|debug
argument_list|(
literal|"got the second rr as nonsoa"
argument_list|)
expr_stmt|;
goto|goto
name|next_rdata
goto|;
block|}
comment|/* 				 * If the record is anything except an SOA 				 * now, just continue on... 				 */
if|if
condition|(
name|rdata
operator|.
name|type
operator|!=
name|dns_rdatatype_soa
condition|)
goto|goto
name|next_rdata
goto|;
comment|/* Now we have an SOA.  Work with it. */
name|debug
argument_list|(
literal|"got an SOA"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|soa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serial
operator|=
name|soa
operator|.
name|serial
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|soa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|first_soa_rcvd
condition|)
block|{
name|query
operator|->
name|first_soa_rcvd
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|first_rr_serial
operator|=
name|serial
expr_stmt|;
name|debug
argument_list|(
literal|"this is the first %d"
argument_list|,
name|query
operator|->
name|lookup
operator|->
name|ixfr_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|lookup
operator|->
name|ixfr_serial
operator|>=
name|serial
condition|)
goto|goto
name|doexit
goto|;
goto|goto
name|next_rdata
goto|;
block|}
if|if
condition|(
name|query
operator|->
name|lookup
operator|->
name|rdtype
operator|==
name|dns_rdatatype_axfr
condition|)
block|{
name|debug
argument_list|(
literal|"doing axfr, got second SOA"
argument_list|)
expr_stmt|;
goto|goto
name|doexit
goto|;
block|}
if|if
condition|(
operator|!
name|query
operator|->
name|second_rr_rcvd
condition|)
block|{
if|if
condition|(
name|query
operator|->
name|first_rr_serial
operator|==
name|serial
condition|)
block|{
name|debug
argument_list|(
literal|"doing ixfr, got "
literal|"empty zone"
argument_list|)
expr_stmt|;
goto|goto
name|doexit
goto|;
block|}
name|debug
argument_list|(
literal|"this is the second %d"
argument_list|,
name|query
operator|->
name|lookup
operator|->
name|ixfr_serial
argument_list|)
expr_stmt|;
name|query
operator|->
name|second_rr_rcvd
operator|=
name|ISC_TRUE
expr_stmt|;
name|query
operator|->
name|second_rr_serial
operator|=
name|serial
expr_stmt|;
goto|goto
name|next_rdata
goto|;
block|}
if|if
condition|(
name|query
operator|->
name|second_rr_serial
operator|==
literal|0
condition|)
block|{
comment|/* 					 * If the second RR was a non-SOA 					 * record, and we're getting any 					 * other SOA, then this is an 					 * AXFR, and we're done. 					 */
name|debug
argument_list|(
literal|"done, since axfr"
argument_list|)
expr_stmt|;
goto|goto
name|doexit
goto|;
block|}
comment|/* 				 * If we get to this point, we're doing an 				 * IXFR and have to start really looking 				 * at serial numbers. 				 */
if|if
condition|(
name|query
operator|->
name|first_rr_serial
operator|==
name|serial
condition|)
block|{
name|debug
argument_list|(
literal|"got a match for ixfr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|first_repeat_rcvd
condition|)
block|{
name|query
operator|->
name|first_repeat_rcvd
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|next_rdata
goto|;
block|}
name|debug
argument_list|(
literal|"done with ixfr"
argument_list|)
expr_stmt|;
goto|goto
name|doexit
goto|;
block|}
name|debug
argument_list|(
literal|"meaningless soa %d"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|next_rdata
label|:
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
block|}
name|result
operator|=
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|launch_next_query
argument_list|(
name|query
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|doexit
label|:
name|received
argument_list|(
name|sevent
operator|->
name|n
argument_list|,
operator|&
name|sevent
operator|->
name|address
argument_list|,
name|query
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Event handler for recv complete.  Perform whatever actions are necessary,  * based on the specifics of the user's request.  */
end_comment

begin_function
specifier|static
name|void
name|recv_done
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|sevent
init|=
name|NULL
decl_stmt|;
name|dig_query_t
modifier|*
name|query
init|=
name|NULL
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|dns_message_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|dig_message_t
modifier|*
name|chase_msg
init|=
name|NULL
decl_stmt|;
name|dig_message_t
modifier|*
name|chase_msg2
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|isc_result_t
name|result
decl_stmt|;
name|dig_lookup_t
modifier|*
name|n
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|isc_boolean_t
name|docancel
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|match
init|=
name|ISC_TRUE
decl_stmt|;
name|unsigned
name|int
name|parseflags
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|unsigned
name|int
name|msgflags
decl_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|isc_result_t
name|do_sigchase
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_message_t
modifier|*
name|msg_temp
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"recv_done()"
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|recvcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"recvcount=%d"
argument_list|,
name|recvcount
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|recvcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|query
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|debug
argument_list|(
literal|"lookup=%p, query=%p"
argument_list|,
name|query
operator|->
name|lookup
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|l
operator|=
name|query
operator|->
name|lookup
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_RECVDONE
argument_list|)
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|b
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|b
operator|==
operator|&
name|query
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|sevent
operator|->
name|bufferlist
argument_list|,
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|->
name|tcp_mode
operator|)
operator|&&
operator|(
name|l
operator|->
name|timer
operator|!=
name|NULL
operator|)
condition|)
name|isc_timer_touch
argument_list|(
name|l
operator|->
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|l
operator|->
name|pending
operator|&&
operator|!
name|l
operator|->
name|ns_search_only
operator|)
operator|||
name|cancel_now
condition|)
block|{
name|debug
argument_list|(
literal|"no longer pending.  Got %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sevent
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|sevent
operator|->
name|result
operator|==
name|ISC_R_CANCELED
condition|)
block|{
name|debug
argument_list|(
literal|"in recv cancel handler"
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|";; communications error: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|sevent
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|query
operator|->
name|sock
argument_list|)
expr_stmt|;
name|sockcount
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"sockcount=%d"
argument_list|,
name|sockcount
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sockcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|l
operator|->
name|tcp_mode
operator|&&
operator|!
name|isc_sockaddr_equal
argument_list|(
operator|&
name|sevent
operator|->
name|address
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
condition|)
block|{
name|char
name|buf1
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
name|any
decl_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|==
name|AF_INET
condition|)
name|isc_sockaddr_any
argument_list|(
operator|&
name|any
argument_list|)
expr_stmt|;
else|else
name|isc_sockaddr_any6
argument_list|(
operator|&
name|any
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
comment|/* 		 * Accept answers from any scope if we havn't specified the 		 * scope as long as the address and port match. 		 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|==
name|AF_INET6
operator|&&
name|query
operator|->
name|sockaddr
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
operator|&
name|sevent
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|query
operator|->
name|sockaddr
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|query
operator|->
name|sockaddr
operator|.
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
operator|&
name|sevent
operator|->
name|address
argument_list|)
operator|==
name|isc_sockaddr_getport
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
condition|)
comment|/* empty */
empty_stmt|;
elseif|else
endif|#
directive|endif
comment|/* 		 * We don't expect a match above when the packet is 		 * sent to 0.0.0.0, :: or to a multicast addresses. 		 * XXXMPA broadcast needs to be handled here as well. 		 */
if|if
condition|(
operator|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
operator|&
name|any
argument_list|)
operator|&&
operator|!
name|isc_sockaddr_ismulticast
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|)
operator|||
name|isc_sockaddr_getport
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|)
operator|!=
name|isc_sockaddr_getport
argument_list|(
operator|&
name|sevent
operator|->
name|address
argument_list|)
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|sevent
operator|->
name|address
argument_list|,
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|query
operator|->
name|sockaddr
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; reply from unexpected source: %s,"
literal|" expected %s\n"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|match
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
name|result
operator|=
name|dns_message_peekheader
argument_list|(
name|b
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|msgflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
name|l
operator|->
name|sendmsg
operator|->
name|id
operator|!=
name|id
condition|)
block|{
name|match
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|tcp_mode
condition|)
block|{
name|isc_boolean_t
name|fail
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|query
operator|->
name|first_soa_rcvd
operator|||
name|query
operator|->
name|warn_id
condition|)
name|printf
argument_list|(
literal|";; %s: ID mismatch: "
literal|"expected ID %u, got %u\n"
argument_list|,
name|query
operator|->
name|first_soa_rcvd
condition|?
literal|"WARNING"
else|:
literal|"ERROR"
argument_list|,
name|l
operator|->
name|sendmsg
operator|->
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|->
name|first_soa_rcvd
condition|)
name|fail
operator|=
name|ISC_FALSE
expr_stmt|;
name|query
operator|->
name|warn_id
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|";; ERROR: short "
literal|"(< header size) message\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
block|{
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
name|match
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|printf
argument_list|(
literal|";; Warning: ID mismatch: "
literal|"expected ID %u, got %u\n"
argument_list|,
name|l
operator|->
name|sendmsg
operator|->
name|id
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|";; Warning: short "
literal|"(< header size) message received\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
name|isc_buffer_invalidate
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|query
operator|->
name|recvspace
argument_list|,
name|COMMSIZE
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|query
operator|->
name|recvlist
argument_list|,
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_socket_recvv
argument_list|(
name|query
operator|->
name|sock
argument_list|,
operator|&
name|query
operator|->
name|recvlist
argument_list|,
literal|1
argument_list|,
name|global_task
argument_list|,
name|recv_done
argument_list|,
name|query
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_socket_recvv"
argument_list|)
expr_stmt|;
name|recvcount
operator|++
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|dns_message_create
argument_list|(
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|querysig
operator|==
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"getting initial querysig"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_getquerytsig
argument_list|(
name|l
operator|->
name|sendmsg
argument_list|,
name|mctx
argument_list|,
operator|&
name|l
operator|->
name|querysig
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_getquerytsig"
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_setquerytsig
argument_list|(
name|msg
argument_list|,
name|l
operator|->
name|querysig
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_setquerytsig"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_settsigkey
argument_list|(
name|msg
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_settsigkey"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|tsigctx
operator|=
name|l
operator|->
name|tsigctx
expr_stmt|;
name|l
operator|->
name|tsigctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|msgcounter
operator|!=
literal|0
condition|)
name|msg
operator|->
name|tcp_continuation
operator|=
literal|1
expr_stmt|;
name|l
operator|->
name|msgcounter
operator|++
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"before parse starts"
argument_list|)
expr_stmt|;
name|parseflags
operator|=
name|DNS_MESSAGEPARSE_PRESERVEORDER
expr_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
operator|!
name|l
operator|->
name|sigchase
condition|)
block|{
name|do_sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|parseflags
operator|=
literal|0
expr_stmt|;
name|do_sigchase
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|l
operator|->
name|besteffort
condition|)
block|{
name|parseflags
operator||=
name|DNS_MESSAGEPARSE_BESTEFFORT
expr_stmt|;
name|parseflags
operator||=
name|DNS_MESSAGEPARSE_IGNORETRUNCATION
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_parse
argument_list|(
name|msg
argument_list|,
name|b
argument_list|,
name|parseflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_RECOVERABLE
condition|)
block|{
name|printf
argument_list|(
literal|";; Warning: Message parser reports malformed "
literal|"message packet.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; Got bad packet: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|hex_dump
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|msg
operator|->
name|flags
operator|&
name|DNS_MESSAGEFLAG_TC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|l
operator|->
name|ignore
operator|&&
operator|!
name|l
operator|->
name|tcp_mode
condition|)
block|{
name|printf
argument_list|(
literal|";; Truncated, retrying in TCP mode.\n"
argument_list|)
expr_stmt|;
name|n
operator|=
name|requeue_lookup
argument_list|(
name|l
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|n
operator|->
name|tcp_mode
operator|=
name|ISC_TRUE
expr_stmt|;
name|n
operator|->
name|origin
operator|=
name|query
operator|->
name|lookup
operator|->
name|origin
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_servfail
operator|&&
operator|!
name|l
operator|->
name|servfail_stops
condition|)
block|{
name|dig_query_t
modifier|*
name|next
init|=
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|current_query
operator|==
name|query
condition|)
name|l
operator|->
name|current_query
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"sending query %p\n"
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|tcp_mode
condition|)
name|send_tcp_connect
argument_list|(
name|next
argument_list|)
expr_stmt|;
else|else
name|send_udp
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If our query is at the head of the list and there 		 * is no next, we're the only one left, so fall 		 * through to print the message. 		 */
if|if
condition|(
operator|(
name|ISC_LIST_HEAD
argument_list|(
name|l
operator|->
name|q
argument_list|)
operator|!=
name|query
operator|)
operator|||
operator|(
name|ISC_LIST_NEXT
argument_list|(
name|query
argument_list|,
name|link
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|";; Got SERVFAIL reply from %s, "
literal|"trying next server\n"
argument_list|,
name|query
operator|->
name|servname
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_tsig_verify
argument_list|(
operator|&
name|query
operator|->
name|recvbuf
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; Couldn't verify signature: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|validated
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|l
operator|->
name|tsigctx
operator|=
name|msg
operator|->
name|tsigctx
expr_stmt|;
name|msg
operator|->
name|tsigctx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|querysig
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing querysig buffer %p"
argument_list|,
name|l
operator|->
name|querysig
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|l
operator|->
name|querysig
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_message_getquerytsig
argument_list|(
name|msg
argument_list|,
name|mctx
argument_list|,
operator|&
name|l
operator|->
name|querysig
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_message_getquerytsig"
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"after parse"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|doing_xfr
operator|&&
name|l
operator|->
name|xfr_q
operator|==
name|NULL
condition|)
block|{
name|l
operator|->
name|xfr_q
operator|=
name|query
expr_stmt|;
comment|/* 		 * Once we are in the XFR message, increase 		 * the timeout to much longer, so brief network 		 * outages won't cause the XFR to abort 		 */
if|if
condition|(
name|timeout
operator|!=
name|INT_MAX
operator|&&
name|l
operator|->
name|timer
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|local_timeout
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|tcp_mode
condition|)
name|local_timeout
operator|=
name|TCP_TIMEOUT
operator|*
literal|4
expr_stmt|;
else|else
name|local_timeout
operator|=
name|UDP_TIMEOUT
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|timeout
operator|<
operator|(
name|INT_MAX
operator|/
literal|4
operator|)
condition|)
name|local_timeout
operator|=
name|timeout
operator|*
literal|4
expr_stmt|;
else|else
name|local_timeout
operator|=
name|INT_MAX
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"have local timeout of %d"
argument_list|,
name|local_timeout
argument_list|)
expr_stmt|;
name|isc_interval_set
argument_list|(
operator|&
name|l
operator|->
name|interval
argument_list|,
name|local_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|l
operator|->
name|timer
argument_list|,
name|isc_timertype_once
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
operator|->
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_timer_reset"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|l
operator|->
name|doing_xfr
operator|||
name|l
operator|->
name|xfr_q
operator|==
name|query
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|rcode
operator|!=
name|dns_rcode_noerror
operator|&&
name|l
operator|->
name|origin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|next_origin
argument_list|(
name|msg
argument_list|,
name|query
argument_list|)
condition|)
block|{
name|printmessage
argument_list|(
name|query
argument_list|,
name|msg
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|received
argument_list|(
name|b
operator|->
name|used
argument_list|,
operator|&
name|sevent
operator|->
name|address
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|l
operator|->
name|trace
operator|&&
operator|!
name|l
operator|->
name|ns_search_only
condition|)
block|{
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
operator|!
name|do_sigchase
condition|)
endif|#
directive|endif
name|printmessage
argument_list|(
name|query
argument_list|,
name|msg
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|trace
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|msg
operator|->
name|counts
index|[
name|DNS_SECTION_ANSWER
index|]
decl_stmt|;
name|debug
argument_list|(
literal|"in TRACE code"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
operator|->
name|ns_search_only
condition|)
name|printmessage
argument_list|(
name|query
argument_list|,
name|msg
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|l
operator|->
name|rdtype
operator|=
name|l
operator|->
name|qrdtype
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|trace_root
operator|||
operator|(
name|l
operator|->
name|ns_search_only
operator|&&
name|count
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|l
operator|->
name|trace_root
condition|)
name|l
operator|->
name|rdtype
operator|=
name|dns_rdatatype_soa
expr_stmt|;
name|n
operator|=
name|followup_lookup
argument_list|(
name|msg
argument_list|,
name|query
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
name|l
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|n
operator|=
name|followup_lookup
argument_list|(
name|msg
argument_list|,
name|query
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|docancel
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"in NSSEARCH code"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|trace_root
condition|)
block|{
comment|/* 				 * This is the initial NS query. 				 */
name|int
name|n
decl_stmt|;
name|l
operator|->
name|rdtype
operator|=
name|dns_rdatatype_soa
expr_stmt|;
name|n
operator|=
name|followup_lookup
argument_list|(
name|msg
argument_list|,
name|query
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|docancel
operator|=
name|ISC_TRUE
expr_stmt|;
name|l
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
operator|!
name|do_sigchase
condition|)
endif|#
directive|endif
name|printmessage
argument_list|(
name|query
argument_list|,
name|msg
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
name|do_sigchase
condition|)
block|{
name|chase_msg
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dig_message_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_msg
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"Memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|chase_message_list
argument_list|,
name|chase_msg
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_message_create
argument_list|(
name|mctx
argument_list|,
name|DNS_MESSAGE_INTENTPARSE
argument_list|,
operator|&
name|msg_temp
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fatal
argument_list|(
literal|"dns_message_create in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|buf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_copyregion
argument_list|(
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_copyregion"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_message_parse
argument_list|(
name|msg_temp
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|chase_msg
operator|->
name|msg
operator|=
name|msg_temp
expr_stmt|;
name|chase_msg2
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dig_message_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_msg2
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"Memory allocation failure in %s:%d"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|chase_message_list2
argument_list|,
name|chase_msg2
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|chase_msg2
operator|->
name|msg
operator|=
name|msg
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
name|l
operator|->
name|sigchase
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|lookup_list
argument_list|)
condition|)
block|{
name|sigchase
argument_list|(
name|msg_temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|l
operator|->
name|pending
condition|)
name|debug
argument_list|(
literal|"still pending."
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|doing_xfr
condition|)
block|{
if|if
condition|(
name|query
operator|!=
name|l
operator|->
name|xfr_q
condition|)
block|{
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|query
operator|->
name|waiting_connect
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|docancel
condition|)
name|docancel
operator|=
name|check_for_more_data
argument_list|(
name|query
argument_list|,
name|msg
argument_list|,
name|sevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|docancel
condition|)
block|{
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|msg
operator|->
name|rcode
operator|==
name|dns_rcode_noerror
operator|||
name|l
operator|->
name|origin
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
operator|!
name|l
operator|->
name|sigchase
condition|)
endif|#
directive|endif
name|received
argument_list|(
name|b
operator|->
name|used
argument_list|,
operator|&
name|sevent
operator|->
name|address
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|query
operator|->
name|lookup
operator|->
name|ns_search_only
condition|)
name|query
operator|->
name|lookup
operator|->
name|pending
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|lookup
operator|->
name|ns_search_only
operator|||
name|query
operator|->
name|lookup
operator|->
name|trace_root
operator|||
name|docancel
condition|)
block|{
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
operator|!
name|do_sigchase
condition|)
endif|#
directive|endif
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|cancel_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
name|clear_query
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|check_next_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
if|if
condition|(
name|do_sigchase
condition|)
name|msg
operator|=
name|NULL
expr_stmt|;
else|else
endif|#
directive|endif
name|dns_message_destroy
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn a name into an address, using system-supplied routines.  This is  * used in looking up server names, etc... and needs to use system-supplied  * routines, since they may be using a non-DNS system for these lookups.  */
end_comment

begin_function
name|void
name|get_address
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_app_block
argument_list|()
expr_stmt|;
name|result
operator|=
name|bind9_getaddresses
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|sockaddr
argument_list|,
literal|1
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
name|isc_app_unblock
argument_list|()
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|fatal
argument_list|(
literal|"couldn't get address for '%s': %s"
argument_list|,
name|host
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|count
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initiate either a TCP or UDP lookup  */
end_comment

begin_function
name|void
name|do_lookup
parameter_list|(
name|dig_lookup_t
modifier|*
name|lookup
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|lookup
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"do_lookup()"
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|pending
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|lookup
operator|->
name|tcp_mode
condition|)
name|send_tcp_connect
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|send_udp
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start everything in action upon task startup.  */
end_comment

begin_function
name|void
name|onrun_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
name|start_lookup
argument_list|()
expr_stmt|;
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make everything on the lookup queue go away.  Mainly used by the  * SIGINT handler.  */
end_comment

begin_function
name|void
name|cancel_all
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|l
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|dig_query_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|nq
decl_stmt|;
name|debug
argument_list|(
literal|"cancel_all()"
argument_list|)
expr_stmt|;
name|LOCK_LOOKUP
expr_stmt|;
if|if
condition|(
name|free_now
condition|)
block|{
name|UNLOCK_LOOKUP
expr_stmt|;
return|return;
block|}
name|cancel_now
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|current_lookup
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|current_lookup
operator|->
name|timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|current_lookup
operator|->
name|timer
argument_list|)
expr_stmt|;
name|q
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|current_lookup
operator|->
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"cancelling query %p, belonging to %p"
argument_list|,
name|q
argument_list|,
name|current_lookup
argument_list|)
expr_stmt|;
name|nq
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|sock
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_cancel
argument_list|(
name|q
operator|->
name|sock
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKCANCEL_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clear_query
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|nq
expr_stmt|;
block|}
block|}
name|l
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|l
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|lookup_list
argument_list|,
name|l
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|try_clear_lookup
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|n
expr_stmt|;
block|}
name|UNLOCK_LOOKUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy all of the libs we are using, and get everything ready for a  * clean shutdown.  */
end_comment

begin_function
name|void
name|destroy_libs
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|void
modifier|*
name|ptr
decl_stmt|;
name|dig_message_t
modifier|*
name|chase_msg
decl_stmt|;
endif|#
directive|endif
name|debug
argument_list|(
literal|"destroy_libs()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_task
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing task"
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|global_task
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The taskmgr_destroy() call blocks until all events are cleared 	 * from the task. 	 */
if|if
condition|(
name|taskmgr
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing taskmgr"
argument_list|)
expr_stmt|;
name|isc_taskmgr_destroy
argument_list|(
operator|&
name|taskmgr
argument_list|)
expr_stmt|;
block|}
name|LOCK_LOOKUP
expr_stmt|;
name|REQUIRE
argument_list|(
name|sockcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|recvcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sendcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_HEAD
argument_list|(
name|lookup_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|current_lookup
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|free_now
argument_list|)
expr_stmt|;
name|free_now
operator|=
name|ISC_TRUE
expr_stmt|;
name|lwres_conf_clear
argument_list|(
name|lwctx
argument_list|)
expr_stmt|;
name|lwres_context_destroy
argument_list|(
operator|&
name|lwctx
argument_list|)
expr_stmt|;
name|flush_server_list
argument_list|()
expr_stmt|;
name|clear_searchlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|commctx
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing commctx"
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|commctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|socketmgr
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing socketmgr"
argument_list|)
expr_stmt|;
name|isc_socketmgr_destroy
argument_list|(
operator|&
name|socketmgr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timermgr
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing timermgr"
argument_list|)
expr_stmt|;
name|isc_timermgr_destroy
argument_list|(
operator|&
name|timermgr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing key %p"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|dns_tsigkey_detach
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namebuf
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dst_up
condition|)
block|{
name|debug
argument_list|(
literal|"destroy DST lib"
argument_list|)
expr_stmt|;
name|dst_lib_destroy
argument_list|()
expr_stmt|;
name|is_dst_up
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|entp
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"detach from entropy"
argument_list|)
expr_stmt|;
name|isc_entropy_detach
argument_list|(
operator|&
name|entp
argument_list|)
expr_stmt|;
block|}
name|UNLOCK_LOOKUP
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|lookup_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
name|debug
argument_list|(
literal|"Destroy the messages kept for sigchase"
argument_list|)
expr_stmt|;
comment|/* Destroy the messages kept for sigchase */
name|chase_msg
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|chase_message_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|chase_msg
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|chase_msg
operator|->
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
operator|(
name|chase_msg
operator|->
name|msg
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|chase_msg
expr_stmt|;
name|chase_msg
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|chase_msg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|chase_msg
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|chase_message_list2
argument_list|)
expr_stmt|;
while|while
condition|(
name|chase_msg
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|chase_msg
operator|->
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_message_destroy
argument_list|(
operator|&
operator|(
name|chase_msg
operator|->
name|msg
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|chase_msg
expr_stmt|;
name|chase_msg
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|chase_msg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIG_SIGCHASE_TD
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_current_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_authority_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|DIG_SIGCHASE_BU
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_signame
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug
argument_list|(
literal|"Destroy memory"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|memdebugging
operator|!=
literal|0
condition|)
name|isc_mem_stats
argument_list|(
name|mctx
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mctx
operator|!=
name|NULL
condition|)
name|isc_mem_destroy
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIG_SIGCHASE
end_ifdef

begin_function
name|void
name|print_type
parameter_list|(
name|dns_rdatatype_t
name|type
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatatype_totext
argument_list|(
name|type
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"print_type"
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_database_section
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|int
name|section
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|msg_name
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
do|do
block|{
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|,
operator|&
name|msg_name
argument_list|)
expr_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|msg_name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_name_print
argument_list|(
name|msg_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
name|msg_name
argument_list|,
name|rdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"end\n"
argument_list|)
expr_stmt|;
block|}
name|msg_name
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
block|}
end_function

begin_function
name|void
name|dump_database
parameter_list|(
name|void
parameter_list|)
block|{
name|dig_message_t
modifier|*
name|msg
decl_stmt|;
for|for
control|(
name|msg
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|chase_message_list
argument_list|)
init|;
name|msg
operator|!=
name|NULL
condition|;
name|msg
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|msg
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|dump_database_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|dump_database_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|dump_database_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|dns_rdataset_t
modifier|*
name|search_type
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdata_sig_t
name|siginfo
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|name
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
block|{
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_rrsig
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|)
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
operator|)
condition|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty rdataset"
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|siginfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"sigrdata tostruct siginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|siginfo
operator|.
name|covered
operator|==
name|covers
operator|)
operator|||
operator|(
name|covers
operator|==
name|dns_rdatatype_any
operator|)
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|type
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dns_rdataset_t
modifier|*
name|chase_scanname_section
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|int
name|section
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_name_t
modifier|*
name|msg_name
init|=
name|NULL
decl_stmt|;
do|do
block|{
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|,
operator|&
name|msg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_compare
argument_list|(
name|msg_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rdataset
operator|=
name|search_type
argument_list|(
name|msg_name
argument_list|,
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
name|msg_name
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|section
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dns_rdataset_t
modifier|*
name|chase_scanname
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|dig_message_t
modifier|*
name|msg
decl_stmt|;
for|for
control|(
name|msg
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|chase_message_list2
argument_list|)
init|;
name|msg
operator|!=
name|NULL
condition|;
name|msg
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|msg
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|rdataset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|covers
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|rdataset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|covers
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
if|if
condition|(
name|dns_message_firstname
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|rdataset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|covers
argument_list|,
name|DNS_SECTION_ADDITIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|rdataset
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|dns_rdataset_t
modifier|*
name|sigchase_scanname
parameter_list|(
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_boolean_t
modifier|*
name|lookedup
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|)
block|{
name|dig_lookup_t
modifier|*
name|lookup
decl_stmt|;
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|temp
decl_stmt|;
name|dns_rdatatype_t
name|querytype
decl_stmt|;
name|temp
operator|=
name|chase_scanname
argument_list|(
name|rdata_name
argument_list|,
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|temp
operator|)
return|;
if|if
condition|(
operator|*
name|lookedup
operator|==
name|ISC_TRUE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lookup
operator|=
name|clone_lookup
argument_list|(
name|current_lookup
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
name|lookup
operator|->
name|new_search
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
name|BUFSIZE
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_totext
argument_list|(
name|rdata_name
argument_list|,
name|ISC_FALSE
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_name_totext"
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|lookup
operator|->
name|textname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
name|querytype
operator|=
name|covers
expr_stmt|;
else|else
name|querytype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|querytype
operator|==
literal|0
operator|||
name|querytype
operator|==
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"Error in the queried type: %d\n"
argument_list|,
name|querytype
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lookup
operator|->
name|rdtype
operator|=
name|querytype
expr_stmt|;
name|lookup
operator|->
name|rdtypeset
operator|=
name|ISC_TRUE
expr_stmt|;
name|lookup
operator|->
name|qrdtype
operator|=
name|querytype
expr_stmt|;
operator|*
name|lookedup
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lookup_list
argument_list|,
name|lookup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nLaunch a query to find a RRset of type "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for zone: %s\n"
argument_list|,
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|insert_trustedkey
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|tk_list
operator|.
name|nb_tk
operator|>=
name|MAX_TRUSTED_KEY
condition|)
return|return;
name|tk_list
operator|.
name|key
index|[
name|tk_list
operator|.
name|nb_tk
operator|++
index|]
operator|=
name|key
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|clean_trustedkey
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TRUSTED_KEY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tk_list
operator|.
name|key
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|dst_key_free
argument_list|(
operator|&
name|tk_list
operator|.
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tk_list
operator|.
name|key
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
name|tk_list
operator|.
name|nb_tk
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|char
name|alphnum
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|removetmpkey
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
modifier|*
name|tempnamekey
init|=
name|NULL
decl_stmt|;
name|int
name|tempnamekeylen
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|tempnamekeylen
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|10
expr_stmt|;
name|tempnamekey
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|tempnamekeylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempnamekey
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|tempnamekey
argument_list|,
literal|0
argument_list|,
name|tempnamekeylen
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempnamekey
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempnamekey
argument_list|,
literal|".key"
argument_list|)
expr_stmt|;
name|isc_file_remove
argument_list|(
name|tempnamekey
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_file_remove
argument_list|(
name|tempnamekey
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempnamekey
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|opentmpkey
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|tempp
parameter_list|,
name|FILE
modifier|*
modifier|*
name|fp
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|tempname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tempnamekey
init|=
name|NULL
decl_stmt|;
name|int
name|tempnamelen
decl_stmt|;
name|int
name|tempnamekeylen
decl_stmt|;
name|char
modifier|*
name|x
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|isc_uint32_t
name|which
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tempnamelen
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|20
expr_stmt|;
name|tempname
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempname
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|tempname
argument_list|,
literal|0
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_file_mktemplate
argument_list|(
name|file
argument_list|,
name|tempname
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|=
name|tempname
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|tempname
condition|)
block|{
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|x
operator|=
name|cp
operator|--
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|tempname
operator|&&
operator|*
name|cp
operator|==
literal|'X'
condition|)
block|{
name|isc_random_get
argument_list|(
operator|&
name|which
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|alphnum
index|[
name|which
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|alphnum
argument_list|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|x
operator|=
name|cp
operator|--
expr_stmt|;
block|}
name|tempnamekeylen
operator|=
name|tempnamelen
operator|+
literal|5
expr_stmt|;
name|tempnamekey
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|tempnamekeylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempnamekey
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|tempnamekey
argument_list|,
literal|0
argument_list|,
name|tempnamekeylen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tempnamekey
argument_list|,
name|tempname
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempnamekey
argument_list|,
literal|".key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_file_exists
argument_list|(
name|tempnamekey
argument_list|)
condition|)
block|{
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempnamekey
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|tempnamekey
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"get_trusted_key(): trusted key not found %s\n"
argument_list|,
name|tempnamekey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
break|break;
block|}
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempnamekey
argument_list|)
expr_stmt|;
operator|*
name|tempp
operator|=
name|tempname
expr_stmt|;
operator|*
name|fp
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|get_trusted_key
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|filetemp
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
literal|1500
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fptemp
decl_stmt|;
name|dst_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|isc_file_exists
argument_list|(
name|trustedkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_TRUE
condition|)
block|{
name|result
operator|=
name|isc_file_exists
argument_list|(
literal|"/etc/trusted-key.key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_TRUE
condition|)
block|{
name|result
operator|=
name|isc_file_exists
argument_list|(
literal|"./trusted-key.key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_TRUE
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
else|else
name|filename
operator|=
literal|"./trusted-key.key"
expr_stmt|;
block|}
else|else
name|filename
operator|=
literal|"/etc/trusted-key.key"
expr_stmt|;
block|}
else|else
name|filename
operator|=
name|trustedkey
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No trusted key\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"get_trusted_key(): trusted key not found %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|1500
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|opentmpkey
argument_list|(
name|mctx
argument_list|,
literal|"tmp_file"
argument_list|,
operator|&
name|filetemp
argument_list|,
operator|&
name|fptemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|fputs
argument_list|(
name|buf
argument_list|,
name|fptemp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fptemp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|fclose
argument_list|(
name|fptemp
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_fromnamedfile
argument_list|(
name|filetemp
argument_list|,
name|DST_TYPE_PUBLIC
argument_list|,
name|mctx
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|removetmpkey
argument_list|(
name|mctx
argument_list|,
name|filetemp
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|filetemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|insert_trustedkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|dst_key_tofile(key, DST_TYPE_PUBLIC,"/tmp");
endif|#
directive|endif
name|key
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nameFromString
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|dns_name_t
modifier|*
name|p_ret
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|REQUIRE
argument_list|(
name|p_ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|str
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"nameFromString"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
name|p_ret
argument_list|)
condition|)
name|free_name
argument_list|(
name|p_ret
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
name|mctx
argument_list|,
name|p_ret
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"nameFromString"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DIG_SIGCHASE_TD
end_if

begin_function
name|isc_result_t
name|prepare_lookup
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dig_lookup_t
modifier|*
name|lookup
init|=
name|NULL
decl_stmt|;
name|dig_server_t
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lookup
operator|=
name|clone_lookup
argument_list|(
name|current_lookup
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|trace_root
operator|=
name|ISC_FALSE
expr_stmt|;
name|lookup
operator|->
name|new_search
operator|=
name|ISC_TRUE
expr_stmt|;
name|lookup
operator|->
name|trace_root_sigchase
operator|=
name|ISC_FALSE
expr_stmt|;
name|strncpy
argument_list|(
name|lookup
operator|->
name|textname
argument_list|,
name|lookup
operator|->
name|textnamesigchase
argument_list|,
name|MXNAME
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|rdtype
operator|=
name|lookup
operator|->
name|rdtype_sigchase
expr_stmt|;
name|lookup
operator|->
name|rdtypeset
operator|=
name|ISC_TRUE
expr_stmt|;
name|lookup
operator|->
name|qrdtype
operator|=
name|lookup
operator|->
name|qrdtype_sigchase
expr_stmt|;
name|s
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|debug
argument_list|(
literal|"freeing server %p belonging to %p"
argument_list|,
name|s
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|s
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_DEQUEUE
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
operator|(
name|dig_server_t
operator|*
operator|)
name|ptr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|chase_nsrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|chase_nsrdataset
argument_list|)
control|)
block|{
name|char
name|namestr
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_rdata_ns_t
name|ns
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dig_server_t
modifier|*
name|srv
init|=
name|NULL
decl_stmt|;
define|#
directive|define
name|__FOLLOW_GLUE__
ifdef|#
directive|ifdef
name|__FOLLOW_GLUE__
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|rdataset
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|true
init|=
name|ISC_TRUE
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|namestr
argument_list|,
literal|0
argument_list|,
name|DNS_NAME_FORMATSIZE
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|chase_nsrdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|ns
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FOLLOW_GLUE__
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rdatatype_aaaa
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|aaaa
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|aaaa
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|dns_rdata_totext
argument_list|(
operator|&
name|aaaa
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|namestr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|,
name|DNS_NAME_FORMATSIZE
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|aaaa
argument_list|)
expr_stmt|;
name|srv
operator|=
name|make_server
argument_list|(
name|namestr
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|rdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|dns_rdatatype_a
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|a
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|dns_rdata_totext
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|ns
operator|.
name|name
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|namestr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|,
name|DNS_NAME_FORMATSIZE
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ns name: %s\n"
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|srv
operator|=
name|make_server
argument_list|(
name|namestr
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|dns_name_format
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|namestr
argument_list|,
sizeof|sizeof
argument_list|(
name|namestr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ns name: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
operator|&
name|ns
operator|.
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|srv
operator|=
name|make_server
argument_list|(
name|namestr
argument_list|,
name|namestr
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|lookup
operator|->
name|my_server_list
argument_list|,
name|srv
argument_list|,
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dns_rdata_freestruct
argument_list|(
operator|&
name|ns
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|lookup_list
argument_list|,
name|lookup
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nLaunch a query to find a RRset of type "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|lookup
operator|->
name|rdtype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" for zone: %s"
argument_list|,
name|lookup
operator|->
name|textname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" with nameservers:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
name|name
argument_list|,
name|chase_nsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|child_of_zone
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|zone_name
parameter_list|,
name|dns_name_t
modifier|*
name|child_name
parameter_list|)
block|{
name|dns_namereln_t
name|name_reln
decl_stmt|;
name|int
name|orderp
decl_stmt|;
name|unsigned
name|int
name|nlabelsp
decl_stmt|;
name|name_reln
operator|=
name|dns_name_fullcompare
argument_list|(
name|name
argument_list|,
name|zone_name
argument_list|,
operator|&
name|orderp
argument_list|,
operator|&
name|nlabelsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_reln
operator|!=
name|dns_namereln_subdomain
operator|||
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|<=
name|dns_name_countlabels
argument_list|(
name|zone_name
argument_list|)
operator|+
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; ERROR : "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" is not a subdomain of: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
name|zone_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|-
name|dns_name_countlabels
argument_list|(
name|zone_name
argument_list|)
operator|-
literal|1
argument_list|,
name|dns_name_countlabels
argument_list|(
name|zone_name
argument_list|)
operator|+
literal|1
argument_list|,
name|child_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|grandfather_pb_test
parameter_list|(
name|dns_name_t
modifier|*
name|zone_name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|dns_rdata_sig_t
name|siginfo
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty RRSIG dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|siginfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"sigrdata tostruct siginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_compare
argument_list|(
operator|&
name|siginfo
operator|.
name|signer
argument_list|,
name|zone_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|chase_sigkeyrdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|initialization
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|true
init|=
name|ISC_TRUE
decl_stmt|;
name|chase_nsrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_nsrdataset
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; NS RRset is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|INSIST
argument_list|(
name|chase_nsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|prepare_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
name|name
argument_list|,
operator|&
name|chase_current_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_rdataset
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_buffer_t
modifier|*
name|b
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|result
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|b
argument_list|,
literal|9000
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"isc_buffer_allocate"
argument_list|)
expr_stmt|;
name|printrdataset
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|isc_buffer_free
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dup_name
parameter_list|(
name|dns_name_t
modifier|*
name|source
parameter_list|,
name|dns_name_t
modifier|*
name|target
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
name|target
argument_list|)
condition|)
name|free_name
argument_list|(
name|target
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|source
argument_list|,
name|mctx
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_name_dup"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_name
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_name_free
argument_list|(
name|name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * take a DNSKEY RRset and the RRSIG RRset corresponding in parameter  * return ISC_R_SUCCESS if the DNSKEY RRset contains a trusted_key  * 			and the RRset is valid  * return ISC_R_NOTFOUND if not contains trusted key  			or if the RRset isn't valid  * return ISC_R_FAILURE if problem  *  */
end_comment

begin_function
name|isc_result_t
name|contains_trusted_key
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|rdata
decl_stmt|;
name|dst_key_t
modifier|*
name|trustedKey
init|=
name|NULL
decl_stmt|;
name|dst_key_t
modifier|*
name|dnsseckey
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|rdataset
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty rdataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
operator|&
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_dnssec_keyfromrdata"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tk_list
operator|.
name|nb_tk
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dst_key_compare
argument_list|(
name|tk_list
operator|.
name|key
index|[
name|i
index|]
argument_list|,
name|dnsseckey
argument_list|)
operator|==
name|ISC_TRUE
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; Ok, find a Trusted Key in the "
literal|"DNSKEY RRset: %d\n"
argument_list|,
name|dst_key_id
argument_list|(
name|dnsseckey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigchase_verify_sig_key
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|dnsseckey
argument_list|,
name|sigrdataset
argument_list|,
name|mctx
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|dnsseckey
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnsseckey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
if|if
condition|(
name|trustedKey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|trustedKey
argument_list|)
expr_stmt|;
name|trustedKey
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|sigchase_verify_sig
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyrdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|keyrdata
decl_stmt|;
name|dst_key_t
modifier|*
name|dnsseckey
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|keyrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty DNSKEY dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|keyrdataset
argument_list|,
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|keyrdata
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
operator|&
name|keyrdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_dnssec_keyfromrdata"
argument_list|)
expr_stmt|;
name|result
operator|=
name|sigchase_verify_sig_key
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|dnsseckey
argument_list|,
name|sigrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|chase_keyrdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|dns_rdata_reset
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|sigchase_verify_sig_key
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dst_key_t
modifier|*
name|dnsseckey
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|dns_rdata_sig_t
name|siginfo
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty RRSIG dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|siginfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"sigrdata tostruct siginfo"
argument_list|)
expr_stmt|;
comment|/* 		 * Test if the id of the DNSKEY is 		 * the id of the DNSKEY signer's 		 */
if|if
condition|(
name|siginfo
operator|.
name|keyid
operator|==
name|dst_key_id
argument_list|(
name|dnsseckey
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty DS dataset"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_verify
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|dnsseckey
argument_list|,
name|ISC_FALSE
argument_list|,
name|mctx
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; VERIFYING "
argument_list|)
expr_stmt|;
name|print_type
argument_list|(
name|rdataset
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" RRset for "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" with DNSKEY:%d: %s\n"
argument_list|,
name|dst_key_id
argument_list|(
name|dnsseckey
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|chase_sigkeyrdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|sigchase_verify_ds
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyrdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|dsrdataset
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdata_t
name|keyrdata
decl_stmt|;
name|dns_rdata_t
name|newdsrdata
decl_stmt|;
name|dns_rdata_t
name|dsrdata
decl_stmt|;
name|dns_rdata_ds_t
name|dsinfo
decl_stmt|;
name|dst_key_t
modifier|*
name|dnsseckey
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|dsbuf
index|[
name|DNS_DS_BUFFERSIZE
index|]
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|dsrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty DSset dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|dsrdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|dsrdataset
argument_list|,
operator|&
name|dsrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|dsrdata
argument_list|,
operator|&
name|dsinfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_rdata_tostruct  for DS"
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|keyrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty KEY dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
do|do
block|{
name|dns_rdataset_current
argument_list|(
name|keyrdataset
argument_list|,
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|keyrdata
operator|.
name|type
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
operator|&
name|keyrdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"dns_dnssec_keyfromrdata"
argument_list|)
expr_stmt|;
comment|/* 			 * Test if the id of the DNSKEY is the 			 * id of DNSKEY referenced by the DS 			 */
if|if
condition|(
name|dsinfo
operator|.
name|key_tag
operator|==
name|dst_key_id
argument_list|(
name|dnsseckey
argument_list|)
condition|)
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|newdsrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_ds_buildrdata
argument_list|(
name|name
argument_list|,
operator|&
name|keyrdata
argument_list|,
name|dsinfo
operator|.
name|digest_type
argument_list|,
name|dsbuf
argument_list|,
operator|&
name|newdsrdata
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dsinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|newdsrdata
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|dsrdata
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|dsinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Oops: impossible to build"
literal|" new DS rdata\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|dns_rdata_compare
argument_list|(
operator|&
name|dsrdata
argument_list|,
operator|&
name|newdsrdata
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|";; OK a DS valids a DNSKEY"
literal|" in the RRset\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; Now verify that this"
literal|" DNSKEY validates the "
literal|"DNSKEY RRset\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|sigchase_verify_sig_key
argument_list|(
name|name
argument_list|,
name|keyrdataset
argument_list|,
name|dnsseckey
argument_list|,
name|chase_sigkeyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|newdsrdata
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|dsrdata
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|";; This DS is NOT the DS for"
literal|" the chasing KEY: FAILED\n"
argument_list|)
expr_stmt|;
block|}
name|dns_rdata_reset
argument_list|(
operator|&
name|newdsrdata
argument_list|)
expr_stmt|;
block|}
name|dst_key_free
argument_list|(
operator|&
name|dnsseckey
argument_list|)
expr_stmt|;
name|dnsseckey
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|chase_keyrdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
name|dns_rdata_reset
argument_list|(
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
name|chase_dsrdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
if|#
directive|if
literal|0
block|dns_rdata_reset(&dsrdata); WARNING
endif|#
directive|endif
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  * take a pointer on a rdataset in parameter and try to resolv it.  * the searched rrset is a rrset on 'name' with type 'type'  * (and if the type is a rrsig the signature cover 'covers').  * the lookedup is to known if you have already done the query on the net.  * ISC_R_SUCCESS: if we found the rrset  * ISC_R_NOTFOUND: we do not found the rrset in cache  * and we do a query on the net  * ISC_R_FAILURE: rrset not found  */
end_comment

begin_function
name|isc_result_t
name|advanced_rrsearch
parameter_list|(
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_boolean_t
modifier|*
name|lookedup
parameter_list|)
block|{
name|isc_boolean_t
name|tmplookedup
decl_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rdataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|tmplookedup
operator|=
operator|*
name|lookedup
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rdataset
operator|=
name|sigchase_scanname
argument_list|(
name|type
argument_list|,
name|covers
argument_list|,
name|lookedup
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tmplookedup
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
operator|*
name|lookedup
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DIG_SIGCHASE_TD
end_if

begin_function
name|void
name|sigchase_td
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|have_answer
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|true
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
operator|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_lookup
operator|->
name|trace_root_sigchase
condition|)
block|{
name|initialization
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|have_answer
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|current_lookup
operator|->
name|trace_root_sigchase
condition|)
block|{
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|chase_nsrdataset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_any
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
name|name
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_nsrdataset
operator|!=
name|NULL
condition|)
block|{
name|have_delegation_ns
operator|=
name|ISC_TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"no response but there is a delegation"
literal|" in authority section:"
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no response and no delegation in "
literal|"authority section but a reference"
literal|" to: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_message
operator|=
name|msg
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|";; NO ANSWERS: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|have_answer
condition|)
block|{
name|chase_rdataset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
argument_list|,
operator|&
name|chase_name
argument_list|,
name|current_lookup
operator|->
name|rdtype_sigchase
argument_list|,
name|dns_rdatatype_any
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_rdataset
operator|!=
name|NULL
condition|)
name|have_response
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_keyrdataset
argument_list|,
operator|&
name|chase_current_name
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|chase_keylookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; DNSKEY is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return;
name|INSIST
argument_list|(
name|chase_keyrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; DNSKEYset:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|chase_keyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigkeyrdataset
argument_list|,
operator|&
name|chase_current_name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|chase_sigkeylookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRSIG of DNSKEY is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return;
name|INSIST
argument_list|(
name|chase_sigkeyrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; RRSIG of the DNSKEYset:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|chase_sigkeyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chase_dslookedup
operator|&&
operator|!
name|chase_nslookedup
condition|)
block|{
if|if
condition|(
operator|!
name|delegation_follow
condition|)
block|{
name|result
operator|=
name|contains_trusted_key
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_sigkeyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|chase_dsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|chase_sigdsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|sigchase_verify_ds
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_dsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; chain of trust can't be validated:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
else|else
block|{
name|chase_dsrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigdsrdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_response
operator|||
operator|(
operator|!
name|have_delegation_ns
operator|&&
operator|!
name|have_response
operator|)
condition|)
block|{
comment|/* test if it's a grand father case */
if|if
condition|(
name|have_response
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigrdataset
argument_list|,
operator|&
name|chase_name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|current_lookup
operator|->
name|rdtype_sigchase
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRset is missing to continue"
literal|" validation SHOULD NOT APPEND:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigrdataset
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRSIG is missing  to continue"
literal|" validation SHOULD NOT APPEND:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
block|}
name|result
operator|=
name|grandfather_pb_test
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|chase_sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_name_t
name|tmp_name
decl_stmt|;
name|printf
argument_list|(
literal|"\n;; We are in a Grand Father Problem:"
literal|" See 2.2.1 in RFC 3568\n"
argument_list|)
expr_stmt|;
name|chase_rdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigrdataset
operator|=
name|NULL
expr_stmt|;
name|have_response
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_delegation_ns
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|tmp_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|child_of_zone
argument_list|(
operator|&
name|chase_name
argument_list|,
operator|&
name|chase_current_name
argument_list|,
operator|&
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_authority_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
operator|&
name|tmp_name
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; and we try to continue chain of trust"
literal|" validation of the zone: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|have_delegation_ns
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|have_response
condition|)
goto|goto
name|finalstep
goto|;
else|else
name|chase_sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_delegation_ns
condition|)
block|{
name|chase_nsrdataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_nsrdataset
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|dns_rdatatype_ns
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|chase_nslookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;;NSset is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
return|return;
block|}
name|INSIST
argument_list|(
name|chase_nsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_dsrdataset
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|dns_rdatatype_ds
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|chase_dslookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; DSset is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return;
name|INSIST
argument_list|(
name|chase_dsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; DSset:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|chase_dsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigdsrdataset
argument_list|,
operator|&
name|chase_authority_name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_ds
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; DSset is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
name|printf
argument_list|(
literal|"\n;; RRSIGset of DSset\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|chase_sigdsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|chase_sigdsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|sigchase_verify_sig
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|chase_dsrdataset
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_sigdsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; Impossible to verify the DSset:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
name|chase_keyrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigkeyrdataset
operator|=
name|NULL
expr_stmt|;
name|prepare_lookup
argument_list|(
operator|&
name|chase_authority_name
argument_list|)
expr_stmt|;
name|have_response
operator|=
name|ISC_FALSE
expr_stmt|;
name|have_delegation_ns
operator|=
name|ISC_FALSE
expr_stmt|;
name|delegation_follow
operator|=
name|ISC_TRUE
expr_stmt|;
name|error_message
operator|=
name|NULL
expr_stmt|;
name|dup_name
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
operator|&
name|chase_current_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|error_message
operator|!=
name|NULL
condition|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_name_t
name|rdata_name
decl_stmt|;
name|isc_result_t
name|ret
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|prove_nx
argument_list|(
name|error_message
argument_list|,
operator|&
name|chase_name
argument_list|,
name|current_lookup
operator|->
name|rdclass_sigchase
argument_list|,
name|current_lookup
operator|->
name|rdtype_sigchase
argument_list|,
operator|&
name|rdata_name
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
operator|||
name|dns_name_countlabels
argument_list|(
operator|&
name|rdata_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; Impossible to verify the non-existence,"
literal|" the NSEC RRset can't be validated:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
name|ret
operator|=
name|sigchase_verify_sig
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|rdataset
argument_list|,
name|chase_keyrdataset
argument_list|,
name|sigrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; Impossible to verify the NSEC RR to prove"
literal|" the non-existence : FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
name|free_name
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; Impossible to verify the non-existence:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n;; OK the query doesn't have response but"
literal|" we have validate this fact : SUCCESS\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
block|}
name|cleanandgo
label|:
name|printf
argument_list|(
literal|";; cleanandgo \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_current_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_current_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_authority_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_authority_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
name|finalstep
label|:
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_rdataset
argument_list|,
operator|&
name|chase_name
argument_list|,
name|current_lookup
operator|->
name|rdtype_sigchase
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRsig of RRset is missing to continue validation"
literal|" SHOULD NOT APPEND: FAILED\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
name|result
operator|=
name|sigchase_verify_sig
argument_list|(
operator|&
name|chase_name
argument_list|,
name|chase_rdataset
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_sigrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; Impossible to verify the RRset : FAILED\n\n"
argument_list|)
expr_stmt|;
comment|/* 		  printf("RRset:\n"); 		  print_rdataset(&chase_name , chase_rdataset, mctx); 		  printf("DNSKEYset:\n"); 		  print_rdataset(&chase_name , chase_keyrdataset, mctx); 		  printf("RRSIG of RRset:\n"); 		  print_rdataset(&chase_name , chase_sigrdataset, mctx); 		  printf("\n"); 		*/
goto|goto
name|cleanandgo
goto|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n;; The Answer:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_name
argument_list|,
name|chase_rdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; FINISH : we have validate the DNSSEC chain"
literal|" of trust: SUCCESS\n\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanandgo
goto|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DIG_SIGCHASE_BU
end_if

begin_function
name|isc_result_t
name|getneededrr
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|sigrdata
decl_stmt|;
name|dns_rdata_sig_t
name|siginfo
decl_stmt|;
name|isc_boolean_t
name|true
init|=
name|ISC_TRUE
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|)
operator|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; NO ANSWERS: %s\n"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_name
operator|.
name|ndata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
block|}
else|else
block|{
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_ANSWER
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* What do we chase? */
if|if
condition|(
name|chase_rdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_rdataset
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_any
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; No Answers: Validation FAILED\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|dup_name
argument_list|(
name|name
argument_list|,
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; RRset to chase:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_name
argument_list|,
name|chase_rdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|chase_rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_sigrdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigrdataset
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|chase_rdataset
operator|->
name|type
argument_list|,
operator|&
name|chase_siglookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRSIG is missing for continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n;; RRSIG of the RRset to chase:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_name
argument_list|,
name|chase_sigrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|chase_sigrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* first find the DNSKEY name */
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|chase_sigrdataset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"empty RRSIG dataset"
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|chase_sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|siginfo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|result
argument_list|,
literal|"sigrdata tostruct siginfo"
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
operator|&
name|siginfo
operator|.
name|signer
argument_list|,
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|siginfo
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
comment|/* Do we have a key?  */
if|if
condition|(
name|chase_keyrdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_keyrdataset
argument_list|,
operator|&
name|chase_signame
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|chase_keylookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; DNSKEY is missing to continue validation:"
literal|" FAILED\n\n"
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n;; DNSKEYset that signs the RRset to chase:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_keyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|chase_keyrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_sigkeyrdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigkeyrdataset
argument_list|,
operator|&
name|chase_signame
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|chase_sigkeylookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; RRSIG for DNSKEY  is missing  to continue"
literal|" validation : FAILED\n\n"
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|chase_name
argument_list|)
condition|)
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n;; RRSIG of the DNSKEYset that signs the "
literal|"RRset to chase:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_sigkeyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|chase_sigkeyrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_dsrdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_dsrdataset
argument_list|,
operator|&
name|chase_signame
argument_list|,
name|dns_rdatatype_ds
argument_list|,
name|dns_rdatatype_any
argument_list|,
operator|&
name|chase_dslookedup
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; WARNING There is no DS for the zone: "
argument_list|)
expr_stmt|;
name|dns_name_print
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|chase_dsrdataset
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; DSset of the DNSKEYset\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_dsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chase_dsrdataset
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * if there is no RRSIG of DS, 		 * we don't want to search on the network 		 */
name|result
operator|=
name|advanced_rrsearch
argument_list|(
operator|&
name|chase_sigdsrdataset
argument_list|,
operator|&
name|chase_signame
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_ds
argument_list|,
operator|&
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|";; WARNING : NO RRSIG DS : RRSIG DS"
literal|" should come with DS\n"
argument_list|)
expr_stmt|;
comment|/* 			 * We continue even the DS couldn't be validated, 			 * because the DNSKEY could be a Trusted Key. 			 */
name|chase_dsrdataset
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n;; RRSIG of the DSset of the DNSKEYset\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_sigdsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sigchase_bu
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|tk_list
operator|.
name|nb_tk
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|get_trusted_key
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"No trusted keys present\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ret
operator|=
name|getneededrr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ISC_R_NOTFOUND
condition|)
return|return;
if|if
condition|(
name|ret
operator|==
name|ISC_R_ADDRNOTAVAIL
condition|)
block|{
comment|/* We have no response */
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sigrdataset
decl_stmt|;
name|dns_name_t
name|rdata_name
decl_stmt|;
name|dns_name_t
name|query_name
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|query_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nameFromString
argument_list|(
name|current_lookup
operator|->
name|textname
argument_list|,
operator|&
name|query_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|prove_nx
argument_list|(
name|msg
argument_list|,
operator|&
name|query_name
argument_list|,
name|current_lookup
operator|->
name|rdclass
argument_list|,
name|current_lookup
operator|->
name|rdtype
argument_list|,
operator|&
name|rdata_name
argument_list|,
operator|&
name|rdataset
argument_list|,
operator|&
name|sigrdataset
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|query_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|==
name|NULL
operator|||
name|sigrdataset
operator|==
name|NULL
operator|||
name|dns_name_countlabels
argument_list|(
operator|&
name|rdata_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n;; Impossible to verify the Non-existence,"
literal|" the NSEC RRset can't be validated: "
literal|"FAILED\n\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\n No Answers and impossible to prove the"
literal|" unsecurity : Validation FAILED\n\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|";; An NSEC prove the non-existence of a answers,"
literal|" Now we want validate this NSEC\n"
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
operator|&
name|rdata_name
argument_list|,
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|rdata_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|chase_rdataset
operator|=
name|rdataset
expr_stmt|;
name|chase_sigrdataset
operator|=
name|sigrdataset
expr_stmt|;
name|chase_keyrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigkeyrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_dsrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigdsrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_siglookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|chase_keylookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|chase_dslookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|chase_sigdslookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|sigchase
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n\n\n;; WE HAVE MATERIAL, WE NOW DO VALIDATION\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|sigchase_verify_sig
argument_list|(
operator|&
name|chase_name
argument_list|,
name|chase_rdataset
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_sigrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; No DNSKEY is valid to check the RRSIG"
literal|" of the RRset: FAILED\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|";; OK We found DNSKEY (or more) to validate the RRset\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|contains_trusted_key
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_sigkeyrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n;; Ok this DNSKEY is a Trusted Key,"
literal|" DNSSEC validation is ok: SUCCESS\n\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|";; Now, we are going to validate this DNSKEY by the DS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chase_dsrdataset
operator|==
name|NULL
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; the DNSKEY isn't trusted-key and there isn't"
literal|" DS to validate the DNSKEY: FAILED\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
name|result
operator|=
name|sigchase_verify_ds
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|chase_keyrdataset
argument_list|,
name|chase_dsrdataset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; ERROR no DS validates a DNSKEY in the"
literal|" DNSKEY RRset: FAILED\n"
argument_list|)
expr_stmt|;
name|clean_trustedkey
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
name|printf
argument_list|(
literal|";; OK this DNSKEY (validated by the DS) validates"
literal|" the RRset of the DNSKEYs, thus the DNSKEY validates"
literal|" the RRset\n"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|chase_sigdsrdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dup_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
operator|&
name|chase_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|free_name
argument_list|(
operator|&
name|chase_signame
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|chase_rdataset
operator|=
name|chase_dsrdataset
expr_stmt|;
name|chase_sigrdataset
operator|=
name|chase_sigdsrdataset
expr_stmt|;
name|chase_keyrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigkeyrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_dsrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_sigdsrdataset
operator|=
name|NULL
expr_stmt|;
name|chase_siglookedup
operator|=
name|chase_keylookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|chase_dslookedup
operator|=
name|chase_sigdslookedup
operator|=
name|ISC_FALSE
expr_stmt|;
name|printf
argument_list|(
literal|";; Now, we want to validate the DS :  recursive call\n"
argument_list|)
expr_stmt|;
name|sigchase
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sigchase
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|)
block|{
if|#
directive|if
name|DIG_SIGCHASE_TD
if|if
condition|(
name|current_lookup
operator|->
name|do_topdown
condition|)
block|{
name|sigchase_td
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|DIG_SIGCHASE_BU
name|sigchase_bu
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * return 1  if name1<  name2  *	  0  if name1  == name2  *	  -1 if name1>  name2  *    and -2 if problem  */
end_comment

begin_function
name|int
name|inf_name
parameter_list|(
name|dns_name_t
modifier|*
name|name1
parameter_list|,
name|dns_name_t
modifier|*
name|name2
parameter_list|)
block|{
name|dns_label_t
name|label1
decl_stmt|;
name|dns_label_t
name|label2
decl_stmt|;
name|unsigned
name|int
name|nblabel1
decl_stmt|;
name|unsigned
name|int
name|nblabel2
decl_stmt|;
name|int
name|min_lum_label
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|2
decl_stmt|;
name|nblabel1
operator|=
name|dns_name_countlabels
argument_list|(
name|name1
argument_list|)
expr_stmt|;
name|nblabel2
operator|=
name|dns_name_countlabels
argument_list|(
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblabel1
operator|>=
name|nblabel2
condition|)
name|min_lum_label
operator|=
name|nblabel2
expr_stmt|;
else|else
name|min_lum_label
operator|=
name|nblabel1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|min_lum_label
condition|;
name|i
operator|++
control|)
block|{
name|dns_name_getlabel
argument_list|(
name|name1
argument_list|,
name|nblabel1
operator|-
literal|1
operator|-
name|i
argument_list|,
operator|&
name|label1
argument_list|)
expr_stmt|;
name|dns_name_getlabel
argument_list|(
name|name2
argument_list|,
name|nblabel2
operator|-
literal|1
operator|-
name|i
argument_list|,
operator|&
name|label2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|isc_region_compare
argument_list|(
operator|&
name|label1
argument_list|,
operator|&
name|label2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nblabel1
operator|==
name|nblabel2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nblabel1
operator|<
name|nblabel2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  *  *  */
end_comment

begin_function
name|isc_result_t
name|prove_nx_domain
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|ret
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|nsecset
init|=
name|NULL
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|signsecset
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
name|nsec
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_name_t
modifier|*
name|nsecname
decl_stmt|;
name|dns_rdata_nsec_t
name|nsecstruct
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; nothing in authority section : impossible to"
literal|" validate the non-existence : FAILED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
do|do
block|{
name|nsecname
operator|=
name|NULL
expr_stmt|;
name|dns_message_currentname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|,
operator|&
name|nsecname
argument_list|)
expr_stmt|;
name|nsecset
operator|=
name|search_type
argument_list|(
name|nsecname
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecset
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"There is a NSEC for this zone in the"
literal|" AUTHORITY section:\n"
argument_list|)
expr_stmt|;
name|print_rdataset
argument_list|(
name|nsecname
argument_list|,
name|nsecset
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|nsecset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|nsecset
argument_list|)
control|)
block|{
name|dns_rdataset_current
argument_list|(
name|nsecset
argument_list|,
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|signsecset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
argument_list|,
name|nsecname
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|signsecset
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|";; no RRSIG NSEC in authority section:"
literal|" impossible to validate the "
literal|"non-existence: FAILED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|ret
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|nsec
argument_list|,
operator|&
name|nsecstruct
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|ret
argument_list|,
literal|"dns_rdata_tostruct"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inf_name
argument_list|(
name|nsecname
argument_list|,
operator|&
name|nsecstruct
operator|.
name|next
argument_list|)
operator|==
literal|1
operator|&&
name|inf_name
argument_list|(
name|name
argument_list|,
operator|&
name|nsecstruct
operator|.
name|next
argument_list|)
operator|==
literal|1
operator|)
operator|||
operator|(
name|inf_name
argument_list|(
name|name
argument_list|,
name|nsecname
argument_list|)
operator|==
literal|1
operator|&&
name|inf_name
argument_list|(
operator|&
name|nsecstruct
operator|.
name|next
argument_list|,
name|name
argument_list|)
operator|==
literal|1
operator|)
condition|)
block|{
name|dns_rdata_freestruct
argument_list|(
operator|&
name|nsecstruct
argument_list|)
expr_stmt|;
operator|*
name|rdataset
operator|=
name|nsecset
expr_stmt|;
operator|*
name|sigrdataset
operator|=
name|signsecset
expr_stmt|;
name|dup_name
argument_list|(
name|nsecname
argument_list|,
name|rdata_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|dns_rdata_freestruct
argument_list|(
operator|&
name|nsecstruct
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dns_message_nextname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
operator|*
name|rdataset
operator|=
name|NULL
expr_stmt|;
operator|*
name|sigrdataset
operator|=
name|NULL
expr_stmt|;
name|rdata_name
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  *  *  *  *  */
end_comment

begin_function
name|isc_result_t
name|prove_nx_type
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsecset
parameter_list|,
name|dns_rdataclass_t
name|class
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|signsecset
decl_stmt|;
name|dns_rdata_t
name|nsec
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|UNUSED
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dns_rdataset_first
argument_list|(
name|nsecset
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
name|ret
argument_list|,
literal|"dns_rdataset_first"
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|nsecset
argument_list|,
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dns_nsec_typepresent
argument_list|(
operator|&
name|nsec
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ISC_R_SUCCESS
condition|)
name|printf
argument_list|(
literal|"OK the NSEC said that the type doesn't exist \n"
argument_list|)
expr_stmt|;
name|signsecset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|signsecset
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"There isn't RRSIG NSEC for the zone \n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|dup_name
argument_list|(
name|name
argument_list|,
name|rdata_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|rdataset
operator|=
name|nsecset
expr_stmt|;
operator|*
name|sigrdataset
operator|=
name|signsecset
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *  *  *  *  */
end_comment

begin_function
name|isc_result_t
name|prove_nx
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataclass_t
name|class
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|rdata_name
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|nsecset
init|=
name|NULL
decl_stmt|;
name|printf
argument_list|(
literal|"We want to prove the non-existance of a type of rdata %d"
literal|" or of the zone: \n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|dns_message_firstname
argument_list|(
name|msg
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
operator|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|";; nothing in authority section : impossible to"
literal|" validate the non-existence : FAILED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|nsecset
operator|=
name|chase_scanname_section
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
name|dns_rdatatype_any
argument_list|,
name|DNS_SECTION_AUTHORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecset
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"We have a NSEC for this zone :OK\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prove_nx_type
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|nsecset
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|rdata_name
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"prove_nx: ERROR type exist\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"prove_nx: OK type does not exist\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"there is no NSEC for this zone: validating "
literal|"that the zone doesn't exist\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|prove_nx_domain
argument_list|(
name|msg
argument_list|,
name|name
argument_list|,
name|rdata_name
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

