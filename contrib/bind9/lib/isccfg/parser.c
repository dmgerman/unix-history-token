begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: parser.c,v 1.70.2.20.2.21 2006/02/28 06:32:54 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/formatcheck.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/netscope.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isc/symtab.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/cfg.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/grammar.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/log.h>
end_include

begin_comment
comment|/* Shorthand */
end_comment

begin_define
define|#
directive|define
name|CAT
value|CFG_LOGCATEGORY_CONFIG
end_define

begin_define
define|#
directive|define
name|MOD
value|CFG_LOGMODULE_PARSER
end_define

begin_define
define|#
directive|define
name|MAP_SYM
value|1
end_define

begin_comment
comment|/* Unique type for isc_symtab */
end_comment

begin_define
define|#
directive|define
name|TOKEN_STRING
parameter_list|(
name|pctx
parameter_list|)
value|(pctx->token.value.as_textregion.base)
end_define

begin_comment
comment|/* Check a return value. */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op); 					\ 		if (result != ISC_R_SUCCESS) goto cleanup; 	\ 	} while (0)
end_define

begin_comment
comment|/* Clean up a configuration object if non-NULL. */
end_comment

begin_define
define|#
directive|define
name|CLEANUP_OBJ
parameter_list|(
name|obj
parameter_list|)
define|\
value|do { if ((obj) != NULL) cfg_obj_destroy(pctx,&(obj)); } while (0)
end_define

begin_comment
comment|/*  * Forward declarations of static functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|free_tuple
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_list
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|create_listelt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_listelt_t
modifier|*
modifier|*
name|eltp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|create_string
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_string
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|create_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|objp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_symtab_elt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|cfg_type_t
modifier|*
name|elttype
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_boolean_t
name|callback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_noop
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|cfg_getstringtoken
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parser_complain
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|isc_boolean_t
name|is_warning
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Data representations.  These correspond to members of the  * "value" union in struct cfg_obj (except "void", which does  * not need a union member).  */
end_comment

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_uint32
init|=
block|{
literal|"uint32"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_uint64
init|=
block|{
literal|"uint64"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_string
init|=
block|{
literal|"string"
block|,
name|free_string
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_boolean
init|=
block|{
literal|"boolean"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_map
init|=
block|{
literal|"map"
block|,
name|free_map
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_list
init|=
block|{
literal|"list"
block|,
name|free_list
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_tuple
init|=
block|{
literal|"tuple"
block|,
name|free_tuple
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_sockaddr
init|=
block|{
literal|"sockaddr"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_netprefix
init|=
block|{
literal|"netprefix"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_rep_t
name|cfg_rep_void
init|=
block|{
literal|"void"
block|,
name|free_noop
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Configuration type definitions.  */
end_comment

begin_comment
comment|/*  * An implicit list.  These are formed by clauses that occur multiple times.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_implicitlist
init|=
block|{
literal|"implicitlist"
block|,
name|NULL
block|,
name|print_list
block|,
name|NULL
block|,
operator|&
name|cfg_rep_list
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions. */
end_comment

begin_function
name|void
name|cfg_print_obj
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|obj
operator|->
name|type
operator|->
name|print
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_print_chars
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|pctx
operator|->
name|f
argument_list|(
name|pctx
operator|->
name|closure
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_open
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"{\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|indent
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_indent
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|)
block|{
name|int
name|indent
init|=
name|pctx
operator|->
name|indent
decl_stmt|;
while|while
condition|(
name|indent
operator|>
literal|0
condition|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_close
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|)
block|{
name|pctx
operator|->
name|indent
operator|--
expr_stmt|;
name|print_indent
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_obj
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|ret
operator|!=
name|NULL
operator|&&
operator|*
name|ret
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|type
operator|->
name|parse
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|INSIST
argument_list|(
operator|*
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
modifier|*
name|closure
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|textlen
parameter_list|)
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|cfg_printer_t
name|pctx
decl_stmt|;
name|pctx
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|pctx
operator|.
name|closure
operator|=
name|closure
expr_stmt|;
name|pctx
operator|.
name|indent
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|type
operator|->
name|print
argument_list|(
operator|&
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tuples. */
end_comment

begin_function
name|isc_result_t
name|cfg_create_tuple
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|f
operator|=
name|fields
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
control|)
name|nfields
operator|++
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|tuple
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
name|cfg_obj_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|f
operator|=
name|fields
operator|,
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_tuple
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fields
operator|,
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|f
operator|->
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_tuple
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|obj
operator|->
name|type
operator|->
name|of
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|isc_boolean_t
name|need_space
init|=
name|ISC_FALSE
decl_stmt|;
for|for
control|(
name|f
operator|=
name|fields
operator|,
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|fieldobj
init|=
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|need_space
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|fieldobj
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|ISC_TF
argument_list|(
name|fieldobj
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cfg_doc_tuple
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|isc_boolean_t
name|need_space
init|=
name|ISC_FALSE
decl_stmt|;
for|for
control|(
name|f
operator|=
name|fields
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|need_space
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|f
operator|->
name|type
argument_list|)
expr_stmt|;
name|need_space
operator|=
name|ISC_TF
argument_list|(
name|f
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_tuple
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|obj
operator|->
name|type
operator|->
name|of
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|unsigned
name|int
name|nfields
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|fields
operator|,
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|CLEANUP_OBJ
argument_list|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
name|cfg_obj_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_istuple
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_tuple
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|cfg_obj_t
modifier|*
name|cfg_tuple_get
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|tupleobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|f
decl_stmt|;
name|REQUIRE
argument_list|(
name|tupleobj
operator|!=
name|NULL
operator|&&
name|tupleobj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_tuple
argument_list|)
expr_stmt|;
name|fields
operator|=
name|tupleobj
operator|->
name|type
operator|->
name|of
expr_stmt|;
for|for
control|(
name|f
operator|=
name|fields
operator|,
name|i
operator|=
literal|0
init|;
name|f
operator|->
name|name
operator|!=
name|NULL
condition|;
name|f
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tupleobj
operator|->
name|value
operator|.
name|tuple
index|[
name|i
index|]
operator|)
return|;
block|}
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_special
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|int
name|special
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
name|special
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"'%c' expected"
argument_list|,
name|special
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a required semicolon.  If it is not there, log  * an error and increment the error count but continue  * parsing.  Since the next token is pushed back,  * care must be taken to make sure it is eventually  * consumed or an infinite loop may result.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_semicolon
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|';'
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_BEFORE
argument_list|,
literal|"missing ';'"
argument_list|)
expr_stmt|;
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse EOF, logging and returning an error if not there.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_eof
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A list of files, used internally for pctx->files. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_filelist
init|=
block|{
literal|"filelist"
block|,
name|NULL
block|,
name|print_list
block|,
name|NULL
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_qstring
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|cfg_parser_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|cfg_parser_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_parser_t
modifier|*
name|pctx
decl_stmt|;
name|isc_lexspecials_t
name|specials
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ret
operator|!=
name|NULL
operator|&&
operator|*
name|ret
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|pctx
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|pctx
operator|->
name|lctx
operator|=
name|lctx
expr_stmt|;
name|pctx
operator|->
name|lexer
operator|=
name|NULL
expr_stmt|;
name|pctx
operator|->
name|seen_eof
operator|=
name|ISC_FALSE
expr_stmt|;
name|pctx
operator|->
name|ungotten
operator|=
name|ISC_FALSE
expr_stmt|;
name|pctx
operator|->
name|errors
operator|=
literal|0
expr_stmt|;
name|pctx
operator|->
name|warnings
operator|=
literal|0
expr_stmt|;
name|pctx
operator|->
name|open_files
operator|=
name|NULL
expr_stmt|;
name|pctx
operator|->
name|closed_files
operator|=
name|NULL
expr_stmt|;
name|pctx
operator|->
name|line
operator|=
literal|0
expr_stmt|;
name|pctx
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|pctx
operator|->
name|callbackarg
operator|=
name|NULL
expr_stmt|;
name|pctx
operator|->
name|token
operator|.
name|type
operator|=
name|isc_tokentype_unknown
expr_stmt|;
name|memset
argument_list|(
name|specials
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|specials
argument_list|)
argument_list|)
expr_stmt|;
name|specials
index|[
literal|'{'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|'}'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|';'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|'/'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|'"'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|'!'
index|]
operator|=
literal|1
expr_stmt|;
name|CHECK
argument_list|(
name|isc_lex_create
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
literal|1024
argument_list|,
operator|&
name|pctx
operator|->
name|lexer
argument_list|)
argument_list|)
expr_stmt|;
name|isc_lex_setspecials
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
name|specials
argument_list|)
expr_stmt|;
name|isc_lex_setcomments
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
operator|(
name|ISC_LEXCOMMENT_C
operator||
name|ISC_LEXCOMMENT_CPLUSPLUS
operator||
name|ISC_LEXCOMMENT_SHELL
operator|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_filelist
argument_list|,
operator|&
name|pctx
operator|->
name|open_files
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_filelist
argument_list|,
operator|&
name|pctx
operator|->
name|closed_files
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|pctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|pctx
operator|->
name|lexer
operator|!=
name|NULL
condition|)
name|isc_lex_destroy
argument_list|(
operator|&
name|pctx
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|pctx
operator|->
name|open_files
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|pctx
operator|->
name|closed_files
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|pctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parser_openfile
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_listelt_t
modifier|*
name|elt
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|stringobj
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|isc_lex_openfile
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"open: %s: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CHECK
argument_list|(
name|create_string
argument_list|(
name|pctx
argument_list|,
name|filename
argument_list|,
operator|&
name|cfg_type_qstring
argument_list|,
operator|&
name|stringobj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|create_listelt
argument_list|(
name|pctx
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|->
name|obj
operator|=
name|stringobj
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|pctx
operator|->
name|open_files
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|stringobj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_parser_setcallback
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_parsecallback_t
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|pctx
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|pctx
operator|->
name|callbackarg
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a configuration using a pctx where a lexer has already  * been set up with a source.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse2
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|errors
operator|!=
literal|0
condition|)
block|{
comment|/* Errors have been logged. */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* Parsing failed but no errors have been logged. */
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"parsing failed"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CHECK
argument_list|(
name|parse_eof
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_file
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parser_openfile
argument_list|(
name|pctx
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse2
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_buffer
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|isc_lex_openbuffer
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse2
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_parser_destroy
parameter_list|(
name|cfg_parser_t
modifier|*
modifier|*
name|pctxp
parameter_list|)
block|{
name|cfg_parser_t
modifier|*
name|pctx
init|=
operator|*
name|pctxp
decl_stmt|;
name|isc_lex_destroy
argument_list|(
operator|&
name|pctx
operator|->
name|lexer
argument_list|)
expr_stmt|;
comment|/* 	 * Cleaning up open_files does not 	 * close the files; that was already done 	 * by closing the lexer. 	 */
name|CLEANUP_OBJ
argument_list|(
name|pctx
operator|->
name|open_files
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|pctx
operator|->
name|closed_files
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|pctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_void
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_void
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_doc_void
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_isvoid
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_void
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_void
init|=
block|{
literal|"void"
block|,
name|cfg_parse_void
block|,
name|cfg_print_void
block|,
name|cfg_doc_void
block|,
operator|&
name|cfg_rep_void
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * uint32  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_uint32
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
operator||
name|ISC_LEXOPT_CNUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_number
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|uint32
operator|=
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_ulong
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_cstr
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_print_rawuint
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|u
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_print_uint32
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_rawuint
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|uint32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_isuint32
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_uint32
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|cfg_obj_asuint32
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_uint32
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|->
name|value
operator|.
name|uint32
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_uint32
init|=
block|{
literal|"integer"
block|,
name|cfg_parse_uint32
block|,
name|cfg_print_uint32
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_uint32
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * uint64  */
end_comment

begin_function
name|isc_boolean_t
name|cfg_obj_isuint64
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_uint64
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint64_t
name|cfg_obj_asuint64
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_uint64
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|->
name|value
operator|.
name|uint64
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_uint64
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%"
name|ISC_PRINT_QUADFORMAT
literal|"u"
argument_list|,
name|obj
operator|->
name|value
operator|.
name|uint64
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_uint64
init|=
block|{
literal|"64_bit_integer"
block|,
name|NULL
block|,
name|cfg_print_uint64
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_uint64
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * qstring (quoted string), ustring (unquoted string), astring  * (any string)  */
end_comment

begin_comment
comment|/* Create a string object from a null-terminated C string. */
end_comment

begin_function
specifier|static
name|isc_result_t
name|create_string
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|=
name|len
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|==
literal|0
condition|)
block|{
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
name|contents
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_qstring
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_qstring
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected quoted string"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
return|return
operator|(
name|create_string
argument_list|(
name|pctx
argument_list|,
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
operator|&
name|cfg_type_qstring
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_ustring
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected unquoted string"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
return|return
operator|(
name|create_string
argument_list|(
name|pctx
argument_list|,
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
operator|&
name|cfg_type_ustring
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_astring
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_getstringtoken
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|create_string
argument_list|(
name|pctx
argument_list|,
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
operator|&
name|cfg_type_qstring
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_is_enum
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|enums
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|enums
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_enum
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|enums
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
decl_stmt|;
if|if
condition|(
name|cfg_is_enum
argument_list|(
name|s
argument_list|,
name|enums
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"'%s' unexpected"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_enum
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|parse_ustring
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|check_enum
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|,
name|type
operator|->
name|of
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_doc_enum
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|type
operator|->
name|of
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" )"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_print_ustring
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_qstring
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_ustring
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_string
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_isstring
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_string
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|cfg_obj_asstring
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_string
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Quoted string only */
end_comment

begin_decl_stmt
name|cfg_type_t
name|cfg_type_qstring
init|=
block|{
literal|"quoted_string"
block|,
name|cfg_parse_qstring
block|,
name|print_qstring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unquoted string only */
end_comment

begin_decl_stmt
name|cfg_type_t
name|cfg_type_ustring
init|=
block|{
literal|"string"
block|,
name|parse_ustring
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Any string (quoted or unquoted); printed with quotes */
end_comment

begin_decl_stmt
name|cfg_type_t
name|cfg_type_astring
init|=
block|{
literal|"string"
block|,
name|cfg_parse_astring
block|,
name|print_qstring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Booleans  */
end_comment

begin_function
name|isc_boolean_t
name|cfg_obj_isboolean
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_boolean
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_asboolean
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_boolean
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|->
name|value
operator|.
name|boolean
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_boolean
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|value
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
goto|goto
name|bad_boolean
goto|;
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|value
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|value
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad_boolean
goto|;
block|}
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|boolean
operator|=
name|value
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|bad_boolean
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"boolean expected"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_boolean
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|boolean
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_boolean
init|=
block|{
literal|"boolean"
block|,
name|parse_boolean
block|,
name|print_boolean
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_boolean
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Lists.  */
end_comment

begin_function
name|isc_result_t
name|cfg_create_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|obj
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
operator|(
operator|*
name|obj
operator|)
operator|->
name|value
operator|.
name|list
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|create_listelt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_listelt_t
modifier|*
modifier|*
name|eltp
parameter_list|)
block|{
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|elt
operator|->
name|obj
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|eltp
operator|=
name|elt
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_list_elt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_listelt_t
modifier|*
name|elt
parameter_list|)
block|{
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
operator|&
name|elt
operator|->
name|obj
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|elt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|obj
operator|->
name|value
operator|.
name|list
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_list_elt
argument_list|(
name|pctx
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_listelt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|elttype
parameter_list|,
name|cfg_listelt_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_listelt_t
modifier|*
name|elt
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|create_listelt
argument_list|(
name|pctx
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|elttype
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|elt
operator|->
name|obj
operator|=
name|value
expr_stmt|;
operator|*
name|ret
operator|=
name|elt
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|elt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a homogeneous list whose elements are of type 'elttype'  * and where each element is terminated by a semicolon.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|listtype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|listobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_type_t
modifier|*
name|listof
init|=
name|listtype
operator|->
name|of
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|cfg_listelt_t
modifier|*
name|elt
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
name|listtype
argument_list|,
operator|&
name|listobj
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
comment|/*{*/
literal|'}'
condition|)
break|break;
name|CHECK
argument_list|(
name|cfg_parse_listelt
argument_list|(
name|pctx
argument_list|,
name|listof
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_semicolon
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|listobj
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elt
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|listobj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|elt
operator|!=
name|NULL
condition|)
name|free_list_elt
argument_list|(
name|pctx
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|listobj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_list
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|cfg_list_t
modifier|*
name|list
init|=
operator|&
name|obj
operator|->
name|value
operator|.
name|list
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|list
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
control|)
block|{
name|print_indent
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|elt
operator|->
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_bracketed_list
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'{'
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_list
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'}'
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_bracketed_list
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|print_open
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|print_list
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|print_close
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_doc_bracketed_list
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"{ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|type
operator|->
name|of
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"; ... }"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a homogeneous list whose elements are of type 'elttype'  * and where elements are separated by space.  The list ends  * before the first semicolon.  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_spacelist
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|listtype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|listobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_type_t
modifier|*
name|listof
init|=
name|listtype
operator|->
name|of
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
name|listtype
argument_list|,
operator|&
name|listobj
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cfg_listelt_t
modifier|*
name|elt
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|';'
condition|)
break|break;
name|CHECK
argument_list|(
name|cfg_parse_listelt
argument_list|(
name|pctx
argument_list|,
name|listof
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|listobj
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|listobj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|listobj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_spacelist
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|cfg_list_t
modifier|*
name|list
init|=
operator|&
name|obj
operator|->
name|value
operator|.
name|list
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|list
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
control|)
block|{
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|elt
operator|->
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
operator|!=
name|NULL
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_islist
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|cfg_listelt_t
modifier|*
name|cfg_list_first
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|==
name|NULL
operator|||
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ISC_LIST_HEAD
argument_list|(
name|obj
operator|->
name|value
operator|.
name|list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|cfg_listelt_t
modifier|*
name|cfg_list_next
parameter_list|(
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|elt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|cfg_obj_t
modifier|*
name|cfg_listelt_value
parameter_list|(
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|elt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|elt
operator|->
name|obj
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Maps.  */
end_comment

begin_comment
comment|/*  * Parse a map body.  That's something like  *  *   "foo 1; bar { glub; }; zap true; zap false;"  *  * i.e., a sequence of option names followed by values and  * terminated by semicolons.  Used for the top level of  * the named.conf syntax, as well as for the body of the  * options, view, zone, and other statements.  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_mapbody
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
specifier|const
name|cfg_clausedef_t
modifier|*
specifier|const
modifier|*
name|clausesets
init|=
name|type
operator|->
name|of
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
specifier|const
modifier|*
name|clauseset
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
name|clause
decl_stmt|;
name|cfg_obj_t
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|eltobj
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|includename
init|=
name|NULL
decl_stmt|;
name|isc_symvalue_t
name|symval
decl_stmt|;
name|cfg_list_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|create_map
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|clausesets
operator|=
name|clausesets
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|redo
label|:
comment|/* 		 * Parse the option name and see if it is known. 		 */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We accept "include" statements wherever a map body 		 * clause can occur. 		 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"include"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Turn the file name into a temporary configuration 			 * object just so that it is not overwritten by the 			 * semicolon token. 			 */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_qstring
argument_list|,
operator|&
name|includename
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_semicolon
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parser_openfile
argument_list|(
name|pctx
argument_list|,
name|includename
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
operator|&
name|includename
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
name|clause
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|clauseset
operator|=
name|clausesets
init|;
operator|*
name|clauseset
operator|!=
name|NULL
condition|;
name|clauseset
operator|++
control|)
block|{
for|for
control|(
name|clause
operator|=
operator|*
name|clauseset
init|;
name|clause
operator|->
name|name
operator|!=
name|NULL
condition|;
name|clause
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|clause
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|clause
operator|==
name|NULL
operator|||
name|clause
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NOPREP
argument_list|,
literal|"unknown option"
argument_list|)
expr_stmt|;
comment|/* 			 * Try to recover by parsing this option as an unknown 			 * option and discarding it. 			 */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_unsupported
argument_list|,
operator|&
name|eltobj
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
operator|&
name|eltobj
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_semicolon
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Clause is known. */
comment|/* Issue warnings if appropriate */
if|if
condition|(
operator|(
name|clause
operator|->
name|flags
operator|&
name|CFG_CLAUSEFLAG_OBSOLETE
operator|)
operator|!=
literal|0
condition|)
name|cfg_parser_warning
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"option '%s' is obsolete"
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clause
operator|->
name|flags
operator|&
name|CFG_CLAUSEFLAG_NOTIMP
operator|)
operator|!=
literal|0
condition|)
name|cfg_parser_warning
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"option '%s' is "
literal|"not implemented"
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clause
operator|->
name|flags
operator|&
name|CFG_CLAUSEFLAG_NYI
operator|)
operator|!=
literal|0
condition|)
name|cfg_parser_warning
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"option '%s' is "
literal|"not implemented"
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Don't log options with CFG_CLAUSEFLAG_NEWDEFAULT 		 * set here - we need to log the *lack* of such an option, 		 * not its presence. 		 */
comment|/* See if the clause already has a value; if not create one. */
name|result
operator|=
name|isc_symtab_lookup
argument_list|(
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
argument_list|,
name|clause
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|symval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clause
operator|->
name|flags
operator|&
name|CFG_CLAUSEFLAG_MULTI
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Multivalued clause */
name|cfg_obj_t
modifier|*
name|listobj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_implicitlist
argument_list|,
operator|&
name|listobj
argument_list|)
argument_list|)
expr_stmt|;
name|symval
operator|.
name|as_pointer
operator|=
name|listobj
expr_stmt|;
name|result
operator|=
name|isc_symtab_define
argument_list|(
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
argument_list|,
name|clause
operator|->
name|name
argument_list|,
literal|1
argument_list|,
name|symval
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"isc_symtab_define(%s) "
literal|"failed"
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_list_t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|listobj
operator|=
name|symval
operator|.
name|as_pointer
expr_stmt|;
block|}
name|elt
operator|=
name|NULL
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_listelt
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|type
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_semicolon
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|listobj
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Single-valued clause */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|isc_boolean_t
name|callback
init|=
name|ISC_TF
argument_list|(
operator|(
name|clause
operator|->
name|flags
operator|&
name|CFG_CLAUSEFLAG_CALLBACK
operator|)
operator|!=
literal|0
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|parse_symtab_elt
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|name
argument_list|,
name|clause
operator|->
name|type
argument_list|,
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
argument_list|,
name|callback
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_semicolon
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"'%s' redefined"
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"isc_symtab_define() failed"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|eltobj
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|includename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_symtab_elt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|cfg_type_t
modifier|*
name|elttype
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_boolean_t
name|callback
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_symvalue_t
name|symval
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|elttype
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback
operator|&&
name|pctx
operator|->
name|callback
operator|!=
name|NULL
condition|)
name|CHECK
argument_list|(
name|pctx
operator|->
name|callback
argument_list|(
name|name
argument_list|,
name|obj
argument_list|,
name|pctx
operator|->
name|callbackarg
argument_list|)
argument_list|)
expr_stmt|;
name|symval
operator|.
name|as_pointer
operator|=
name|obj
expr_stmt|;
name|CHECK
argument_list|(
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|name
argument_list|,
literal|1
argument_list|,
name|symval
argument_list|,
name|isc_symexists_reject
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a map; e.g., "{ foo 1; bar { glub; }; zap true; zap false; }"  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'{'
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_mapbody
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'}'
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Subroutine for cfg_parse_named_map() and cfg_parse_addressed_map().  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_any_named_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_type_t
modifier|*
name|nametype
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|idobj
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|mapobj
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|nametype
argument_list|,
operator|&
name|idobj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_map
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|mapobj
argument_list|)
argument_list|)
expr_stmt|;
name|mapobj
operator|->
name|value
operator|.
name|map
operator|.
name|id
operator|=
name|idobj
expr_stmt|;
name|idobj
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret
operator|=
name|mapobj
expr_stmt|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|idobj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a map identified by a string name.  E.g., "name { foo 1; }".    * Used for the "key" and "channel" statements.  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_named_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_any_named_map
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a map identified by a network address.  * Used for the "server" statement.  */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_addressed_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_any_named_map
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_netaddr
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_mapbody
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
specifier|const
modifier|*
name|clauseset
decl_stmt|;
for|for
control|(
name|clauseset
operator|=
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|clausesets
init|;
operator|*
name|clauseset
operator|!=
name|NULL
condition|;
name|clauseset
operator|++
control|)
block|{
name|isc_symvalue_t
name|symval
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
name|clause
decl_stmt|;
for|for
control|(
name|clause
operator|=
operator|*
name|clauseset
init|;
name|clause
operator|->
name|name
operator|!=
name|NULL
condition|;
name|clause
operator|++
control|)
block|{
name|result
operator|=
name|isc_symtab_lookup
argument_list|(
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
argument_list|,
name|clause
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|&
name|symval
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
name|symval
operator|.
name|as_pointer
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|type
operator|==
operator|&
name|cfg_type_implicitlist
condition|)
block|{
comment|/* Multivalued. */
name|cfg_list_t
modifier|*
name|list
init|=
operator|&
name|obj
operator|->
name|value
operator|.
name|list
decl_stmt|;
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|list
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|elt
argument_list|,
name|link
argument_list|)
control|)
block|{
name|print_indent
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|elt
operator|->
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Single-valued. */
name|print_indent
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
empty_stmt|;
comment|/* do nothing */
block|}
else|else
block|{
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|cfg_doc_mapbody
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|cfg_clausedef_t
modifier|*
specifier|const
modifier|*
name|clauseset
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
name|clause
decl_stmt|;
for|for
control|(
name|clauseset
operator|=
name|type
operator|->
name|of
init|;
operator|*
name|clauseset
operator|!=
name|NULL
condition|;
name|clauseset
operator|++
control|)
block|{
for|for
control|(
name|clause
operator|=
operator|*
name|clauseset
init|;
name|clause
operator|->
name|name
operator|!=
name|NULL
condition|;
name|clause
operator|++
control|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX print flags here? */
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\n\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
name|flagtext
block|{
name|unsigned
name|int
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|flagtexts
index|[]
init|=
block|{
block|{
name|CFG_CLAUSEFLAG_NOTIMP
block|,
literal|"not implemented"
block|}
block|,
block|{
name|CFG_CLAUSEFLAG_NYI
block|,
literal|"not yet implemented"
block|}
block|,
block|{
name|CFG_CLAUSEFLAG_OBSOLETE
block|,
literal|"obsolete"
block|}
block|,
block|{
name|CFG_CLAUSEFLAG_NEWDEFAULT
block|,
literal|"default changed"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|cfg_print_map
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|id
operator|!=
name|NULL
condition|)
block|{
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|id
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|print_open
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_mapbody
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|print_close
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_clause_flags
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|struct
name|flagtext
modifier|*
name|p
decl_stmt|;
name|isc_boolean_t
name|first
init|=
name|ISC_TRUE
decl_stmt|;
for|for
control|(
name|p
operator|=
name|flagtexts
init|;
name|p
operator|->
name|flag
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|p
operator|->
name|flag
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" // "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cfg_doc_map
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|cfg_clausedef_t
modifier|*
specifier|const
modifier|*
name|clauseset
decl_stmt|;
specifier|const
name|cfg_clausedef_t
modifier|*
name|clause
decl_stmt|;
if|if
condition|(
name|type
operator|->
name|parse
operator|==
name|cfg_parse_named_map
condition|)
block|{
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|->
name|parse
operator|==
name|cfg_parse_addressed_map
condition|)
block|{
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_netaddr
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|print_open
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
for|for
control|(
name|clauseset
operator|=
name|type
operator|->
name|of
init|;
operator|*
name|clauseset
operator|!=
name|NULL
condition|;
name|clauseset
operator|++
control|)
block|{
for|for
control|(
name|clause
operator|=
operator|*
name|clauseset
init|;
name|clause
operator|->
name|name
operator|!=
name|NULL
condition|;
name|clause
operator|++
control|)
block|{
name|print_indent
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|clause
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_clause_flags
argument_list|(
name|pctx
argument_list|,
name|clause
operator|->
name|flags
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|print_close
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_ismap
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_map
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_map_get
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|mapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
modifier|*
name|obj
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_symvalue_t
name|val
decl_stmt|;
specifier|const
name|cfg_map_t
modifier|*
name|map
decl_stmt|;
name|REQUIRE
argument_list|(
name|mapobj
operator|!=
name|NULL
operator|&&
name|mapobj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_map
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
operator|*
name|obj
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|mapobj
operator|->
name|value
operator|.
name|map
expr_stmt|;
name|result
operator|=
name|isc_symtab_lookup
argument_list|(
name|map
operator|->
name|symtab
argument_list|,
name|name
argument_list|,
name|MAP_SYM
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
operator|*
name|obj
operator|=
name|val
operator|.
name|as_pointer
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|cfg_obj_t
modifier|*
name|cfg_map_getname
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|mapobj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|mapobj
operator|!=
name|NULL
operator|&&
name|mapobj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_map
argument_list|)
expr_stmt|;
return|return
operator|(
name|mapobj
operator|->
name|value
operator|.
name|map
operator|.
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an arbitrary token, storing its raw text representation. */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_token
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_token
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EOF
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_lex_getlasttokentext
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
operator|&
name|pctx
operator|->
name|token
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|r
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|=
name|r
operator|.
name|length
expr_stmt|;
name|memcpy
argument_list|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
index|[
name|r
operator|.
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_token
init|=
block|{
literal|"token"
block|,
name|parse_token
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An unsupported option.  This is just a list of tokens with balanced braces  * ending in a semicolon.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_unsupported
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|listobj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|braces
init|=
literal|0
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_list
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|listobj
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cfg_listelt_t
modifier|*
name|elt
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
condition|)
block|{
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
name|braces
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'}'
condition|)
name|braces
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|';'
condition|)
if|if
condition|(
name|braces
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
operator|||
name|braces
operator|<
literal|0
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"unexpected token"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTEDTOKEN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CHECK
argument_list|(
name|cfg_parse_listelt
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_token
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|listobj
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|braces
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|listobj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|listobj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_unsupported
init|=
block|{
literal|"unsupported"
block|,
name|parse_unsupported
block|,
name|cfg_print_spacelist
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_list
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Try interpreting the current token as a network address.  *  * If CFG_ADDR_WILDOK is set in flags, "*" can be used as a wildcard  * and at least one of CFG_ADDR_V4OK and CFG_ADDR_V6OK must also be set.  The  * "*" is interpreted as the IPv4 wildcard address if CFG_ADDR_V4OK is   * set (including the case where CFG_ADDR_V4OK and CFG_ADDR_V6OK are both set),  * and the IPv6 wildcard address otherwise.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|token_addr
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|isc_netaddr_t
modifier|*
name|na
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|in_addr
name|in4a
decl_stmt|;
name|struct
name|in6_addr
name|in6a
decl_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
name|s
operator|=
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_WILDOK
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V4OK
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_netaddr_any
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V6OK
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_netaddr_any6
argument_list|(
name|na
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
else|else
block|{
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V4PREFIXOK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|s
argument_list|,
operator|&
name|in4a
argument_list|)
operator|==
literal|1
condition|)
block|{
name|isc_netaddr_fromin
argument_list|(
name|na
argument_list|,
operator|&
name|in4a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V4PREFIXOK
operator|)
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|s
argument_list|)
operator|<=
literal|15U
condition|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|buf
argument_list|,
operator|&
name|in4a
argument_list|)
operator|==
literal|1
condition|)
block|{
name|isc_netaddr_fromin
argument_list|(
name|na
argument_list|,
operator|&
name|in4a
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V6OK
operator|)
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|s
argument_list|)
operator|<=
literal|127U
condition|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* see lib/bind9/getaddresses.c */
name|char
modifier|*
name|d
decl_stmt|;
comment|/* zone delimiter */
name|isc_uint32_t
name|zone
init|=
literal|0
decl_stmt|;
comment|/* scope zone ID */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|d
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
operator|&
name|in6a
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESCOPEID
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_netscope_pton
argument_list|(
name|AF_INET6
argument_list|,
name|d
operator|+
literal|1
argument_list|,
operator|&
name|in6a
argument_list|,
operator|&
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ISC_R_BADADDRESSFORM
operator|)
return|;
endif|#
directive|endif
block|}
name|isc_netaddr_fromin6
argument_list|(
name|na
argument_list|,
operator|&
name|in6a
argument_list|)
expr_stmt|;
name|isc_netaddr_setzone
argument_list|(
name|na
argument_list|,
name|zone
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_rawaddr
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|isc_netaddr_t
modifier|*
name|na
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|token_addr
argument_list|(
name|pctx
argument_list|,
name|flags
argument_list|,
name|na
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_UNEXPECTEDTOKEN
condition|)
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP address"
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_lookingat_netaddr
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_netaddr_t
name|na_dummy
decl_stmt|;
name|result
operator|=
name|token_addr
argument_list|(
name|pctx
argument_list|,
name|flags
argument_list|,
operator|&
name|na_dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_parse_rawport
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|in_port_t
modifier|*
name|port
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_WILDOK
operator|)
operator|!=
literal|0
operator|&&
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|port
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_number
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected port number or '*'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_ulong
operator|>=
literal|65536U
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"port number out of range"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
operator|*
name|port
operator|=
call|(
name|in_port_t
call|)
argument_list|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_ulong
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_rawaddr
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|isc_netaddr_t
modifier|*
name|na
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
name|text
index|[
literal|128
index|]
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_netaddr_totext
argument_list|(
name|na
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
name|isc_buffer_base
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|,
name|isc_buffer_usedlength
argument_list|(
operator|&
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* netaddr */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_netaddr
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
argument_list|,
operator|&
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_fromnetaddr
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|,
operator|&
name|netaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_netaddr
init|=
block|{
literal|"netaddr"
block|,
name|parse_netaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_sockaddr
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netprefix */
end_comment

begin_function
name|isc_result_t
name|cfg_parse_netprefix
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|unsigned
name|int
name|addrlen
decl_stmt|,
name|prefixlen
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V4PREFIXOK
operator||
name|CFG_ADDR_V6OK
argument_list|,
operator|&
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|netaddr
operator|.
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|addrlen
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|addrlen
operator|=
literal|128
expr_stmt|;
break|break;
default|default:
name|addrlen
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'/'
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "/" */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_number
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected prefix length"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|prefixlen
operator|=
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_ulong
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|>
name|addrlen
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NOPREP
argument_list|,
literal|"invalid prefix length"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
block|}
else|else
block|{
name|prefixlen
operator|=
name|addrlen
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_netprefix
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|netprefix
operator|.
name|address
operator|=
name|netaddr
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|netprefix
operator|.
name|prefixlen
operator|=
name|prefixlen
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected network prefix"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_netprefix
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|cfg_netprefix_t
modifier|*
name|p
init|=
operator|&
name|obj
operator|->
name|value
operator|.
name|netprefix
decl_stmt|;
name|cfg_print_rawaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|p
operator|->
name|address
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_rawuint
argument_list|(
name|pctx
argument_list|,
name|p
operator|->
name|prefixlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_isnetprefix
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_netprefix
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_obj_asnetprefix
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
name|isc_netaddr_t
modifier|*
name|netaddr
parameter_list|,
name|unsigned
name|int
modifier|*
name|prefixlen
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_netprefix
argument_list|)
expr_stmt|;
operator|*
name|netaddr
operator|=
name|obj
operator|->
name|value
operator|.
name|netprefix
operator|.
name|address
expr_stmt|;
operator|*
name|prefixlen
operator|=
name|obj
operator|->
name|value
operator|.
name|netprefix
operator|.
name|prefixlen
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|cfg_type_t
name|cfg_type_netprefix
init|=
block|{
literal|"netprefix"
block|,
name|cfg_parse_netprefix
block|,
name|print_netprefix
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_netprefix
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_sockaddrsub
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|in_port_t
name|port
init|=
literal|0
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawaddr
argument_list|(
name|pctx
argument_list|,
name|flags
argument_list|,
operator|&
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "port" */
name|CHECK
argument_list|(
name|cfg_parse_rawport
argument_list|(
name|pctx
argument_list|,
name|flags
argument_list|,
operator|&
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_sockaddr_fromnetaddr
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|,
operator|&
name|netaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sockaddr_flags
init|=
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cfg_type_t
name|cfg_type_sockaddr
init|=
block|{
literal|"sockaddr"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|sockaddr_flags
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
name|cfg_parse_sockaddr
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
modifier|*
name|flagp
init|=
name|type
operator|->
name|of
decl_stmt|;
return|return
operator|(
name|parse_sockaddrsub
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_sockaddr
argument_list|,
operator|*
name|flagp
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_print_sockaddr
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|char
name|buf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|netaddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|port
operator|=
name|isc_sockaddr_getport
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" port "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cfg_print_rawuint
argument_list|(
name|pctx
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cfg_doc_sockaddr
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|unsigned
name|int
modifier|*
name|flagp
init|=
name|type
operator|->
name|of
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_V4OK
condition|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv4_address>"
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_V6OK
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv6_address>"
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_WILDOK
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"*"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ) "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_WILDOK
condition|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port (<integer> | * ) ]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_issockaddr
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_sockaddr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|isc_sockaddr_t
modifier|*
name|cfg_obj_assockaddr
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|obj
operator|!=
name|NULL
operator|&&
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_sockaddr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_gettoken
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|pctx
operator|->
name|seen_eof
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|options
operator||=
operator|(
name|ISC_LEXOPT_EOF
operator||
name|ISC_LEXOPT_NOMORE
operator|)
expr_stmt|;
name|redo
label|:
name|pctx
operator|->
name|token
operator|.
name|type
operator|=
name|isc_tokentype_unknown
expr_stmt|;
name|result
operator|=
name|isc_lex_gettoken
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
name|options
argument_list|,
operator|&
name|pctx
operator|->
name|token
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|ungotten
operator|=
name|ISC_FALSE
expr_stmt|;
name|pctx
operator|->
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
name|result
operator|=
name|isc_lex_close
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOMORE
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_lex_getsourcename
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Closed an included file, not the main file. 				 */
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|elt
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|pctx
operator|->
name|open_files
operator|->
name|value
operator|.
name|list
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|elt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|pctx
operator|->
name|open_files
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|pctx
operator|->
name|closed_files
operator|->
name|value
operator|.
name|list
argument_list|,
name|elt
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
name|pctx
operator|->
name|seen_eof
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|ISC_R_NOSPACE
case|:
comment|/* More understandable than "ran out of space". */
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"token too big"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISC_R_IOERROR
case|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"%s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_ungettoken
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
block|{
if|if
condition|(
name|pctx
operator|->
name|seen_eof
condition|)
return|return;
name|isc_lex_ungettoken
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
operator|&
name|pctx
operator|->
name|token
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|ungotten
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_peektoken
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a string token, accepting both the quoted and the unquoted form.  * Log an error if the next token is not a string.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|cfg_getstringtoken
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
operator|&&
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_qstring
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected string"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cfg_parser_error
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|parser_complain
argument_list|(
name|pctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_parser_warning
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|parser_complain
argument_list|(
name|pctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|flags
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|warnings
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_LOG_TOKEN
value|30
end_define

begin_comment
comment|/* How much of a token to quote in log messages. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|current_file
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|)
block|{
specifier|static
name|char
name|none
index|[]
init|=
literal|"none"
decl_stmt|;
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|cfg_obj_t
modifier|*
name|fileobj
decl_stmt|;
if|if
condition|(
name|pctx
operator|->
name|open_files
operator|==
name|NULL
condition|)
return|return
operator|(
name|none
operator|)
return|;
name|elt
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|pctx
operator|->
name|open_files
operator|->
name|value
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
name|NULL
condition|)
return|return
operator|(
name|none
operator|)
return|;
name|fileobj
operator|=
name|elt
operator|->
name|obj
expr_stmt|;
name|INSIST
argument_list|(
name|fileobj
operator|->
name|type
operator|==
operator|&
name|cfg_type_qstring
argument_list|)
expr_stmt|;
return|return
operator|(
name|fileobj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parser_complain
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|isc_boolean_t
name|is_warning
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|tokenbuf
index|[
name|MAX_LOG_TOKEN
operator|+
literal|10
index|]
decl_stmt|;
specifier|static
name|char
name|where
index|[
name|ISC_DIR_PATHMAX
operator|+
literal|100
index|]
decl_stmt|;
specifier|static
name|char
name|message
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_ERROR
decl_stmt|;
specifier|const
name|char
modifier|*
name|prep
init|=
literal|""
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|is_warning
condition|)
name|level
operator|=
name|ISC_LOG_WARNING
expr_stmt|;
name|snprintf
argument_list|(
name|where
argument_list|,
sizeof|sizeof
argument_list|(
name|where
argument_list|)
argument_list|,
literal|"%s:%u: "
argument_list|,
name|current_file
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|pctx
operator|->
name|line
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|message
argument_list|,
sizeof|sizeof
argument_list|(
name|message
argument_list|)
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|message
argument_list|)
condition|)
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"error message would overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|CFG_LOG_NEAR
operator||
name|CFG_LOG_BEFORE
operator||
name|CFG_LOG_NOPREP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_region_t
name|r
decl_stmt|;
if|if
condition|(
name|pctx
operator|->
name|ungotten
condition|)
operator|(
name|void
operator|)
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
name|snprintf
argument_list|(
name|tokenbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tokenbuf
argument_list|)
argument_list|,
literal|"end of file"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_unknown
condition|)
block|{
name|flags
operator|=
literal|0
expr_stmt|;
name|tokenbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|isc_lex_getlasttokentext
argument_list|(
name|pctx
operator|->
name|lexer
argument_list|,
operator|&
name|pctx
operator|->
name|token
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|>
name|MAX_LOG_TOKEN
condition|)
name|snprintf
argument_list|(
name|tokenbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tokenbuf
argument_list|)
argument_list|,
literal|"'%.*s...'"
argument_list|,
name|MAX_LOG_TOKEN
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tokenbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tokenbuf
argument_list|)
argument_list|,
literal|"'%.*s'"
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|length
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
comment|/* Choose a preposition. */
if|if
condition|(
name|flags
operator|&
name|CFG_LOG_NEAR
condition|)
name|prep
operator|=
literal|" near "
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|CFG_LOG_BEFORE
condition|)
name|prep
operator|=
literal|" before "
expr_stmt|;
else|else
name|prep
operator|=
literal|" "
expr_stmt|;
block|}
else|else
block|{
name|tokenbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|pctx
operator|->
name|lctx
argument_list|,
name|CAT
argument_list|,
name|MOD
argument_list|,
name|level
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|where
argument_list|,
name|message
argument_list|,
name|prep
argument_list|,
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_obj_log
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
name|isc_log_t
modifier|*
name|lctx
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|lctx
argument_list|,
name|CAT
argument_list|,
name|MOD
argument_list|,
name|level
argument_list|,
literal|"%s:%u: %s"
argument_list|,
name|obj
operator|->
name|file
operator|==
name|NULL
condition|?
literal|"<unknown file>"
else|:
name|obj
operator|->
name|file
argument_list|,
name|obj
operator|->
name|line
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|cfg_obj_file
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|file
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|cfg_obj_line
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|->
name|line
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|cfg_create_obj
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_obj_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|obj
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|obj
operator|->
name|file
operator|=
name|current_file
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|obj
operator|->
name|line
operator|=
name|pctx
operator|->
name|line
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|map_symtabitem_destroy
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
name|isc_symvalue_t
name|symval
parameter_list|,
name|void
modifier|*
name|userarg
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
name|symval
operator|.
name|as_pointer
decl_stmt|;
name|cfg_parser_t
modifier|*
name|pctx
init|=
operator|(
name|cfg_parser_t
operator|*
operator|)
name|userarg
decl_stmt|;
name|UNUSED
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|create_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|isc_symtab_create
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
literal|5
argument_list|,
comment|/* XXX */
name|map_symtabitem_destroy
argument_list|,
name|pctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
operator|=
name|symtab
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|id
operator|=
name|NULL
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_map
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|CLEANUP_OBJ
argument_list|(
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|id
argument_list|)
expr_stmt|;
name|isc_symtab_destroy
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|map
operator|.
name|symtab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_boolean_t
name|cfg_obj_istype
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|ISC_TF
argument_list|(
name|obj
operator|->
name|type
operator|==
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy 'obj', a configuration object created in 'pctx'.  */
end_comment

begin_function
name|void
name|cfg_obj_destroy
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|objp
parameter_list|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
operator|*
name|objp
decl_stmt|;
name|obj
operator|->
name|type
operator|->
name|rep
operator|->
name|free
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg_obj_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|objp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_noop
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_doc_obj
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|type
operator|->
name|doc
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_doc_terminal
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"<"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|type
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfg_print_grammar
parameter_list|(
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|(
name|void
modifier|*
name|closure
parameter_list|,
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|textlen
parameter_list|)
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|cfg_printer_t
name|pctx
decl_stmt|;
name|pctx
operator|.
name|f
operator|=
name|f
expr_stmt|;
name|pctx
operator|.
name|closure
operator|=
name|closure
expr_stmt|;
name|pctx
operator|.
name|indent
operator|=
literal|0
expr_stmt|;
name|cfg_doc_obj
argument_list|(
operator|&
name|pctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

