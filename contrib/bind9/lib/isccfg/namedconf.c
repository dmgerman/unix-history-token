begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2012  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2002, 2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/cfg.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/grammar.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/log.h>
end_include

begin_define
define|#
directive|define
name|TOKEN_STRING
parameter_list|(
name|pctx
parameter_list|)
value|(pctx->token.value.as_textregion.base)
end_define

begin_comment
comment|/*% Check a return value. */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op);					\ 		if (result != ISC_R_SUCCESS) goto cleanup;	\ 	} while (0)
end_define

begin_comment
comment|/*% Clean up a configuration object if non-NULL. */
end_comment

begin_define
define|#
directive|define
name|CLEANUP_OBJ
parameter_list|(
name|obj
parameter_list|)
define|\
value|do { if ((obj) != NULL) cfg_obj_destroy(pctx,&(obj)); } while (0)
end_define

begin_comment
comment|/*%  * Forward declarations of static functions.  */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|parse_enum_or_other
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|enumtype
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|othertype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_updatepolicy
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_updatepolicy
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doc_updatepolicy
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doc_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doc_optional_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_acl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_addrmatchelt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_aml
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_namesockaddrkeylist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrnameportlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_sockaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_destinationlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dialuptype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_ixfrdifftype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logseverity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masterselement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameportiplist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_negated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_notifytype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_allow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_facility
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_keyref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_portiplist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server_key_kludge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizenodefault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr4wild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr6wild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_statschannels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_view
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_viewopts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zoneopts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dynamically_loadable_zones
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dynamically_loadable_zones_opts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_v4_aaaa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'dynamically loadable zones' statement  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|dynamically_loadable_zones_clauses
index|[]
init|=
block|{
block|{
literal|"database"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A dynamically loadable zones statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|dynamically_loadable_zones_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_dynamically_loadable_zones_opts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dynamically_loadable_zones
init|=
block|{
literal|"dlz"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|dynamically_loadable_zones_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% tkey-dhkey */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|tkey_dhkey_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"keyid"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_tkey_dhkey
init|=
block|{
literal|"tkey-dhkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|tkey_dhkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% listen-on */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|listenon_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"acl"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_listenon
init|=
block|{
literal|"listenon"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|listenon_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% acl */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|acl_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"value"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_acl
init|=
block|{
literal|"acl"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|acl_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% masters */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|masters_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masters
init|=
block|{
literal|"masters"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|masters_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * "sockaddrkeylist", a list of socket addresses with optional keys  * and an optional default port, as used in the masters option.  * E.g.,  *   "port 1234 { mymasters; 10.0.0.1 key foo; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|namesockaddrkey_fields
index|[]
init|=
block|{
block|{
literal|"masterselement"
block|,
operator|&
name|cfg_type_masterselement
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_optional_keyref
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namesockaddrkey
init|=
block|{
literal|"namesockaddrkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|namesockaddrkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_namesockaddrkeylist
init|=
block|{
literal|"bracketed_namesockaddrkeylist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_namesockaddrkey
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|namesockaddrkeylist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namesockaddrkeylist
init|=
block|{
literal|"sockaddrkeylist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|namesockaddrkeylist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A list of socket addresses with an optional default port,  * as used in the also-notify option.  E.g.,  * "port 1234 { 10.0.0.1; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|portiplist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_portiplist
init|=
block|{
literal|"portiplist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|portiplist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A public key, as in the "pubkey" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|pubkey_fields
index|[]
init|=
block|{
block|{
literal|"flags"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"protocol"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_pubkey
init|=
block|{
literal|"pubkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|pubkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A list of RR types, used in grant statements.  * Note that the old parser allows quotes around the RR type names.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrtypelist
init|=
block|{
literal|"rrtypelist"
block|,
name|cfg_parse_spacelist
block|,
name|cfg_print_spacelist
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mode_enums
index|[]
init|=
block|{
literal|"grant"
block|,
literal|"deny"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_mode
init|=
block|{
literal|"mode"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|mode_enums
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_matchtype
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"zonesub"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pctx
operator|->
name|flags
operator||=
name|CFG_PCTX_SKIP
expr_stmt|;
block|}
return|return
operator|(
name|cfg_parse_enum
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_matchname
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|pctx
operator|->
name|flags
operator|&
name|CFG_PCTX_SKIP
operator|)
operator|!=
literal|0
condition|)
block|{
name|pctx
operator|->
name|flags
operator|&=
operator|~
name|CFG_PCTX_SKIP
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|cfg_parse_astring
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_matchname
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"[ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|type
operator|->
name|of
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ]"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|matchtype_enums
index|[]
init|=
block|{
literal|"name"
block|,
literal|"subdomain"
block|,
literal|"wildcard"
block|,
literal|"self"
block|,
literal|"selfsub"
block|,
literal|"selfwild"
block|,
literal|"krb5-self"
block|,
literal|"ms-self"
block|,
literal|"krb5-subdomain"
block|,
literal|"ms-subdomain"
block|,
literal|"tcp-self"
block|,
literal|"6to4-self"
block|,
literal|"zonesub"
block|,
literal|"external"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_matchtype
init|=
block|{
literal|"matchtype"
block|,
name|parse_matchtype
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|matchtype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_matchname
init|=
block|{
literal|"optional_matchname"
block|,
name|parse_matchname
block|,
name|cfg_print_ustring
block|,
operator|&
name|doc_matchname
block|,
operator|&
name|cfg_rep_tuple
block|,
operator|&
name|cfg_type_ustring
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A grant statement, used in the update policy.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|grant_fields
index|[]
init|=
block|{
block|{
literal|"mode"
block|,
operator|&
name|cfg_type_mode
block|,
literal|0
block|}
block|,
block|{
literal|"identity"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
comment|/* domain name */
block|{
literal|"matchtype"
block|,
operator|&
name|cfg_type_matchtype
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
operator|&
name|cfg_type_matchname
block|,
literal|0
block|}
block|,
comment|/* domain name */
block|{
literal|"types"
block|,
operator|&
name|cfg_type_rrtypelist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_grant
init|=
block|{
literal|"grant"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|grant_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_updatepolicy
init|=
block|{
literal|"update_policy"
block|,
name|parse_updatepolicy
block|,
name|print_updatepolicy
block|,
name|doc_updatepolicy
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_grant
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_updatepolicy
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
block|{
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_bracketed_list
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_ustring
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|=
name|strlen
argument_list|(
literal|"local"
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|=
name|isc_mem_get
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|pctx
operator|->
name|mctx
argument_list|,
name|obj
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
literal|"local"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|string
operator|.
name|base
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_updatepolicy
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
name|cfg_print_ustring
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
else|else
name|cfg_print_bracketed_list
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_updatepolicy
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"( local | { "
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|type
operator|->
name|of
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"; ... }"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * A view statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|view_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_viewopts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_view
init|=
block|{
literal|"view"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|view_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A zone statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|zone_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_zoneopts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zone
init|=
block|{
literal|"zone"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|zone_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A "category" clause in the "logging" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|category_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"destinations"
block|,
operator|&
name|cfg_type_destinationlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_category
init|=
block|{
literal|"category"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|category_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A dnssec key, as used in the "trusted-keys" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|dnsseckey_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"flags"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"protocol"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dnsseckey
init|=
block|{
literal|"dnsseckey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|dnsseckey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A managed key initialization specifier, as used in the  * "managed-keys" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|managedkey_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"init"
block|,
operator|&
name|cfg_type_ustring
block|,
literal|0
block|}
block|,
comment|/* must be literal "initial-key" */
block|{
literal|"flags"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"protocol"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_managedkey
init|=
block|{
literal|"managedkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|managedkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_class_kw
init|=
block|{
literal|"class"
block|,
operator|&
name|cfg_type_ustring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_class
init|=
block|{
literal|"optional_wild_class"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_class_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_type_kw
init|=
block|{
literal|"type"
block|,
operator|&
name|cfg_type_ustring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_type
init|=
block|{
literal|"optional_wild_type"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_type_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_name_kw
init|=
block|{
literal|"name"
block|,
operator|&
name|cfg_type_qstring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_name
init|=
block|{
literal|"optional_wild_name"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_name_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * An rrset ordering element.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|rrsetorderingelement_fields
index|[]
init|=
block|{
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_wild_class
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
operator|&
name|cfg_type_optional_wild_type
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
operator|&
name|cfg_type_optional_wild_name
block|,
literal|0
block|}
block|,
block|{
literal|"order"
block|,
operator|&
name|cfg_type_ustring
block|,
literal|0
block|}
block|,
comment|/* must be literal "order" */
block|{
literal|"ordering"
block|,
operator|&
name|cfg_type_ustring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrsetorderingelement
init|=
block|{
literal|"rrsetorderingelement"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|rrsetorderingelement_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A global or view "check-names" option.  Note that the zone  * "check-names" option has a different syntax.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|checktype_enums
index|[]
init|=
block|{
literal|"master"
block|,
literal|"slave"
block|,
literal|"response"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checktype
init|=
block|{
literal|"checktype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|checktype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|checkmode_enums
index|[]
init|=
block|{
literal|"fail"
block|,
literal|"warn"
block|,
literal|"ignore"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checkmode
init|=
block|{
literal|"checkmode"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|checkmode_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|checknames_fields
index|[]
init|=
block|{
block|{
literal|"type"
block|,
operator|&
name|cfg_type_checktype
block|,
literal|0
block|}
block|,
block|{
literal|"mode"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checknames
init|=
block|{
literal|"checknames"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|checknames_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrlist
init|=
block|{
literal|"bracketed_sockaddrlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_sockaddr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|autodnssec_enums
index|[]
init|=
block|{
literal|"allow"
block|,
literal|"maintain"
block|,
literal|"off"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_autodnssec
init|=
block|{
literal|"autodnssec"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|autodnssec_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrsetorder
init|=
block|{
literal|"rrsetorder"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_rrsetorderingelement
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|port_kw
init|=
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_port
init|=
block|{
literal|"optional_port"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|port_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% A list of keys, as in the "key" clause of the controls statement. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_keylist
init|=
block|{
literal|"keylist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% A list of dnssec keys, as in "trusted-keys" */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dnsseckeys
init|=
block|{
literal|"dnsseckeys"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_dnsseckey
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A list of managed key entries, as in "trusted-keys".  Currently  * (9.7.0) this has a format similar to dnssec keys, except the keyname  * is followed by the keyword "initial-key".  In future releases, this  * keyword may take other values indicating different methods for the  * key to be initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_managedkeys
init|=
block|{
literal|"managedkeys"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_managedkey
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|forwardtype_enums
index|[]
init|=
block|{
literal|"first"
block|,
literal|"only"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_forwardtype
init|=
block|{
literal|"forwardtype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|forwardtype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zonetype_enums
index|[]
init|=
block|{
literal|"master"
block|,
literal|"slave"
block|,
literal|"stub"
block|,
literal|"static-stub"
block|,
literal|"hint"
block|,
literal|"forward"
block|,
literal|"delegation-only"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zonetype
init|=
block|{
literal|"zonetype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|zonetype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|loglevel_enums
index|[]
init|=
block|{
literal|"critical"
block|,
literal|"error"
block|,
literal|"warning"
block|,
literal|"notice"
block|,
literal|"info"
block|,
literal|"dynamic"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_loglevel
init|=
block|{
literal|"loglevel"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|loglevel_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|transferformat_enums
index|[]
init|=
block|{
literal|"many-answers"
block|,
literal|"one-answer"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_transferformat
init|=
block|{
literal|"transferformat"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|transferformat_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * The special keyword "none", as used in the pid-file option.  */
end_comment

begin_function
specifier|static
name|void
name|print_none
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_none
init|=
block|{
literal|"none"
block|,
name|NULL
block|,
name|print_none
block|,
name|NULL
block|,
operator|&
name|cfg_rep_void
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A quoted string or the special keyword "none".  Used in the pid-file option.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_qstringornone
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_none
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_qstring
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_qstringornone
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"(<quoted_string> | none )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_qstringornone
init|=
block|{
literal|"qstringornone"
block|,
name|parse_qstringornone
block|,
name|NULL
block|,
name|doc_qstringornone
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A boolean ("yes" or "no"), or the special keyword "auto".  * Used in the dnssec-validation option.  */
end_comment

begin_function
specifier|static
name|void
name|print_auto
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_auto
init|=
block|{
literal|"auto"
block|,
name|NULL
block|,
name|print_auto
block|,
name|NULL
block|,
operator|&
name|cfg_rep_void
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_boolorauto
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_auto
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_boolean
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_boolorauto
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|->
name|type
operator|->
name|rep
operator|==
operator|&
name|cfg_rep_void
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|boolean
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"yes"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_boolorauto
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"( yes | no | auto )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_boolorauto
init|=
block|{
literal|"boolorauto"
block|,
name|parse_boolorauto
block|,
name|print_boolorauto
block|,
name|doc_boolorauto
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * keyword hostname  */
end_comment

begin_function
specifier|static
name|void
name|print_hostname
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"hostname"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_hostname
init|=
block|{
literal|"hostname"
block|,
name|NULL
block|,
name|print_hostname
block|,
name|NULL
block|,
operator|&
name|cfg_rep_boolean
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * "server-id" argument.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_serverid
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_none
argument_list|,
name|ret
argument_list|)
operator|)
return|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"hostname"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_hostname
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_qstring
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_serverid
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"(<quoted_string> | none | hostname )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_serverid
init|=
block|{
literal|"serverid"
block|,
name|parse_serverid
block|,
name|NULL
block|,
name|doc_serverid
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Port list.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|porttuple_fields
index|[]
init|=
block|{
block|{
literal|"loport"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"hiport"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_porttuple
init|=
block|{
literal|"porttuple"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|porttuple_fields
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_port
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_uint32
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ret
operator|)
operator|->
name|value
operator|.
name|uint32
operator|>
literal|0xffff
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"invalid port"
argument_list|)
expr_stmt|;
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_portrange
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
operator||
name|ISC_LEXOPT_CNUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_number
condition|)
name|CHECK
argument_list|(
name|parse_port
argument_list|(
name|pctx
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
operator|||
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"range"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected integer or 'range'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_porttuple
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_port
argument_list|(
name|pctx
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|parse_port
argument_list|(
name|pctx
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|uint32
operator|>
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|->
name|value
operator|.
name|uint32
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NOPREP
argument_list|,
literal|"low port '%u' must not be larger "
literal|"than high port"
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
operator|->
name|value
operator|.
name|uint32
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_portrange
init|=
block|{
literal|"portrange"
block|,
name|parse_portrange
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_portlist
init|=
block|{
literal|"bracketed_sockaddrlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_portrange
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found within the top level of the named.conf  * file only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|namedconf_clauses
index|[]
init|=
block|{
block|{
literal|"options"
block|,
operator|&
name|cfg_type_options
block|,
literal|0
block|}
block|,
block|{
literal|"controls"
block|,
operator|&
name|cfg_type_controls
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"acl"
block|,
operator|&
name|cfg_type_acl
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"masters"
block|,
operator|&
name|cfg_type_masters
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"logging"
block|,
operator|&
name|cfg_type_logging
block|,
literal|0
block|}
block|,
block|{
literal|"view"
block|,
operator|&
name|cfg_type_view
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"lwres"
block|,
operator|&
name|cfg_type_lwres
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"statistics-channels"
block|,
operator|&
name|cfg_type_statschannels
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can occur at the top level or in the view  * statement, but not in the options block.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|namedconf_or_view_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"zone"
block|,
operator|&
name|cfg_type_zone
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
comment|/* only 1 DLZ per view allowed */
block|{
literal|"dlz"
block|,
operator|&
name|cfg_type_dynamically_loadable_zones
block|,
literal|0
block|}
block|,
block|{
literal|"server"
block|,
operator|&
name|cfg_type_server
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"trusted-keys"
block|,
operator|&
name|cfg_type_dnsseckeys
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"managed-keys"
block|,
operator|&
name|cfg_type_managedkeys
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can occur in the bind.keys file.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|bindkeys_clauses
index|[]
init|=
block|{
block|{
literal|"trusted-keys"
block|,
operator|&
name|cfg_type_dnsseckeys
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"managed-keys"
block|,
operator|&
name|cfg_type_managedkeys
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found within the 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|options_clauses
index|[]
init|=
block|{
block|{
literal|"avoid-v4-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"avoid-v6-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"bindkeys-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"blackhole"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"coresize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"datasize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"session-keyfile"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"session-keyname"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"session-keyalg"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"deallocate-on-exit"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"directory"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_CALLBACK
block|}
block|,
block|{
literal|"dump-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"fake-iquery"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"files"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"flush-zones-on-shutdown"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"has-old-clients"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"heartbeat-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"host-statistics"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"host-statistics-max"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"hostname"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"interface-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"listen-on"
block|,
operator|&
name|cfg_type_listenon
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"listen-on-v6"
block|,
operator|&
name|cfg_type_listenon
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"managed-keys-directory"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"match-mapped-addresses"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"memstatistics-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"memstatistics"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"multiple-cnames"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"named-xfer"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"pid-file"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"querylog"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"recursing-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"random-device"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"recursive-clients"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"reserved-sockets"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"secroots-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"serial-queries"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"serial-query-rate"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"server-id"
block|,
operator|&
name|cfg_type_serverid
block|,
literal|0
block|}
block|,
block|{
literal|"stacksize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"statistics-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"statistics-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"tcp-clients"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"tcp-listen-queue"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-dhkey"
block|,
operator|&
name|cfg_type_tkey_dhkey
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-gssapi-credential"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-gssapi-keytab"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-domain"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-per-ns"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"treat-cr-as-space"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"use-id-pool"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"use-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"use-v4-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"use-v6-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namelist
init|=
block|{
literal|"namelist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_qstring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|exclude_kw
init|=
block|{
literal|"exclude"
block|,
operator|&
name|cfg_type_namelist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_exclude
init|=
block|{
literal|"optional_exclude"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|exclude_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|exceptionnames_kw
init|=
block|{
literal|"except-from"
block|,
operator|&
name|cfg_type_namelist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_exceptionnames
init|=
block|{
literal|"optional_allow"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|exceptionnames_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|denyaddresses_fields
index|[]
init|=
block|{
block|{
literal|"acl"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"except-from"
block|,
operator|&
name|cfg_type_optional_exceptionnames
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_denyaddresses
init|=
block|{
literal|"denyaddresses"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|denyaddresses_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|denyaliases_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_namelist
block|,
literal|0
block|}
block|,
block|{
literal|"except-from"
block|,
operator|&
name|cfg_type_optional_exceptionnames
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_denyaliases
init|=
block|{
literal|"denyaliases"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|denyaliases_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_algorithmlist
init|=
block|{
literal|"algorithmlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|disablealgorithm_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"algorithms"
block|,
operator|&
name|cfg_type_algorithmlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_disablealgorithm
init|=
block|{
literal|"disablealgorithm"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|disablealgorithm_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|mustbesecure_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"value"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_mustbesecure
init|=
block|{
literal|"mustbesecure"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|mustbesecure_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|masterformat_enums
index|[]
init|=
block|{
literal|"text"
block|,
literal|"raw"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masterformat
init|=
block|{
literal|"masterformat"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|masterformat_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  response-policy {  *	zone<string> [ policy (given|disabled|passthru|  *					nxdomain|nodata|cname<domain> ) ];  *  };  *  * this is a chimera of doc_optional_keyvalue() and cfg_doc_enum()  */
end_comment

begin_function
specifier|static
name|void
name|doc_rpz_policies
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|kw
operator|=
name|type
operator|->
name|of
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"[ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|kw
operator|->
name|type
operator|->
name|of
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * print_qstring() from parser.c  */
end_comment

begin_function
specifier|static
name|void
name|print_rpz_cname
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_ustring
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_rpz_cname
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_doc_terminal
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ) ]"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_rpz
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * parse cname domain only after "policy cname" 	 */
if|if
condition|(
name|cfg_obj_isvoid
argument_list|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
operator|||
name|strcasecmp
argument_list|(
literal|"cname"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rpz_policies
index|[]
init|=
block|{
literal|"given"
block|,
literal|"disabled"
block|,
literal|"passthru"
block|,
literal|"no-op"
block|,
literal|"nxdomain"
block|,
literal|"nodata"
block|,
literal|"cname"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rpz_policylist
init|=
block|{
literal|"policies"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|rpz_policies
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|rpz_policies_kw
init|=
block|{
literal|"policy"
block|,
operator|&
name|cfg_type_rpz_policylist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rpz_policy
init|=
block|{
literal|"optional_policy"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_rpz_policies
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|rpz_policies_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_cname
init|=
block|{
literal|"domain"
block|,
name|cfg_parse_astring
block|,
name|print_rpz_cname
block|,
name|doc_rpz_cname
block|,
operator|&
name|cfg_rep_string
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|rpzone_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"policy"
block|,
operator|&
name|cfg_type_rpz_policy
block|,
literal|0
block|}
block|,
block|{
literal|"cname"
block|,
operator|&
name|cfg_type_cname
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rpzone
init|=
block|{
literal|"rpzone"
block|,
name|parse_rpz
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|rpzone_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rpz_clauses
index|[]
init|=
block|{
block|{
literal|"zone"
block|,
operator|&
name|cfg_type_rpzone
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rpz_clausesets
index|[]
init|=
block|{
name|rpz_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rpz
init|=
block|{
literal|"rpz"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|rpz_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * dnssec-lookaside  */
end_comment

begin_function
specifier|static
name|void
name|print_lookaside
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|domain
init|=
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|domain
operator|->
name|value
operator|.
name|string
operator|.
name|length
operator|==
literal|4
operator|&&
name|strncmp
argument_list|(
name|domain
operator|->
name|value
operator|.
name|string
operator|.
name|base
argument_list|,
literal|"auto"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"auto"
argument_list|)
expr_stmt|;
else|else
name|cfg_print_tuple
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_lookaside
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"(<string> trust-anchor<string> | auto | no )"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|keyword_type_t
name|trustanchor_kw
init|=
block|{
literal|"trust-anchor"
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_trustanchor
init|=
block|{
literal|"optional_trustanchor"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|trustanchor_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|lookaside_fields
index|[]
init|=
block|{
block|{
literal|"domain"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"trust-anchor"
block|,
operator|&
name|cfg_type_optional_trustanchor
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lookaside
init|=
block|{
literal|"lookaside"
block|,
name|cfg_parse_tuple
block|,
name|print_lookaside
block|,
name|doc_lookaside
block|,
operator|&
name|cfg_rep_tuple
block|,
name|lookaside_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DNS64.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|dns64_clauses
index|[]
init|=
block|{
block|{
literal|"clients"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"mapped"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"exclude"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"suffix"
block|,
operator|&
name|cfg_type_netaddr6
block|,
literal|0
block|}
block|,
block|{
literal|"recursive-only"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"break-dnssec"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|dns64_clausesets
index|[]
init|=
block|{
name|dns64_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dns64
init|=
block|{
literal|"dns64"
block|,
name|cfg_parse_netprefix_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|dns64_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found within the 'view' statement,  * with defaults in the 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|view_clauses
index|[]
init|=
block|{
block|{
literal|"acache-cleaning-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"acache-enable"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"additional-from-auth"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"additional-from-cache"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"allow-new-zones"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"allow-query-cache"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-query-cache-on"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-recursion"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-recursion-on"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-v6-synthesis"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"attach-cache"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"auth-nxdomain"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NEWDEFAULT
block|}
block|,
block|{
literal|"cache-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"check-names"
block|,
operator|&
name|cfg_type_checknames
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"cleaning-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"clients-per-query"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"deny-answer-addresses"
block|,
operator|&
name|cfg_type_denyaddresses
block|,
literal|0
block|}
block|,
block|{
literal|"deny-answer-aliases"
block|,
operator|&
name|cfg_type_denyaliases
block|,
literal|0
block|}
block|,
block|{
literal|"disable-algorithms"
block|,
operator|&
name|cfg_type_disablealgorithm
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"disable-empty-zone"
block|,
operator|&
name|cfg_type_astring
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dns64"
block|,
operator|&
name|cfg_type_dns64
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dns64-server"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"dns64-contact"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-accept-expired"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-enable"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-lookaside"
block|,
operator|&
name|cfg_type_lookaside
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dnssec-must-be-secure"
block|,
operator|&
name|cfg_type_mustbesecure
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dnssec-validation"
block|,
operator|&
name|cfg_type_boolorauto
block|,
literal|0
block|}
block|,
block|{
literal|"dual-stack-servers"
block|,
operator|&
name|cfg_type_nameportiplist
block|,
literal|0
block|}
block|,
block|{
literal|"edns-udp-size"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"empty-contact"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"empty-server"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"empty-zones-enable"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"fetch-glue"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"ixfr-from-differences"
block|,
operator|&
name|cfg_type_ixfrdifftype
block|,
literal|0
block|}
block|,
block|{
literal|"lame-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-acache-size"
block|,
operator|&
name|cfg_type_sizenodefault
block|,
literal|0
block|}
block|,
block|{
literal|"max-cache-size"
block|,
operator|&
name|cfg_type_sizenodefault
block|,
literal|0
block|}
block|,
block|{
literal|"max-cache-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-clients-per-query"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-ncache-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-recursion-depth"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-recursion-queries"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-udp-size"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-roots"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"minimal-responses"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"preferred-glue"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"provide-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
comment|/* 	 * Note that the query-source option syntax is different 	 * from the other -source options. 	 */
block|{
literal|"query-source"
block|,
operator|&
name|cfg_type_querysource4
block|,
literal|0
block|}
block|,
block|{
literal|"query-source-v6"
block|,
operator|&
name|cfg_type_querysource6
block|,
literal|0
block|}
block|,
block|{
literal|"queryport-pool-ports"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"queryport-pool-updateinterval"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"recursion"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"request-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"request-nsid"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"resolver-query-timeout"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"rfc2308-type1"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"root-delegation-only"
block|,
operator|&
name|cfg_type_optional_exclude
block|,
literal|0
block|}
block|,
block|{
literal|"rrset-order"
block|,
operator|&
name|cfg_type_rrsetorder
block|,
literal|0
block|}
block|,
block|{
literal|"sortlist"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"suppress-initial-notify"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"topology"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"transfer-format"
block|,
operator|&
name|cfg_type_transferformat
block|,
literal|0
block|}
block|,
block|{
literal|"use-queryport-pool"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"zero-no-soa-ttl-cache"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|ALLOW_FILTER_AAAA_ON_V4
block|{
literal|"filter-aaaa"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"filter-aaaa-on-v4"
block|,
operator|&
name|cfg_type_v4_aaaa
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"filter-aaaa"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
name|CFG_CLAUSEFLAG_NOTCONFIGURED
block|}
block|,
block|{
literal|"filter-aaaa-on-v4"
block|,
operator|&
name|cfg_type_v4_aaaa
block|,
name|CFG_CLAUSEFLAG_NOTCONFIGURED
block|}
block|,
endif|#
directive|endif
block|{
literal|"response-policy"
block|,
operator|&
name|cfg_type_rpz
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found within the 'view' statement only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|view_only_clauses
index|[]
init|=
block|{
block|{
literal|"match-clients"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"match-destinations"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"match-recursive-only"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Sig-validity-interval.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_optional_uint32
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
operator||
name|ISC_LEXOPT_CNUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_number
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_optional_uint32
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[<integer> ]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_uint32
init|=
block|{
literal|"optional_uint32"
block|,
name|parse_optional_uint32
block|,
name|NULL
block|,
name|doc_optional_uint32
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|validityinterval_fields
index|[]
init|=
block|{
block|{
literal|"validity"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"re-sign"
block|,
operator|&
name|cfg_type_optional_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_validityinterval
init|=
block|{
literal|"validityinterval"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|validityinterval_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found in a 'zone' statement,  * with defaults in the 'view' or 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|zone_clauses
index|[]
init|=
block|{
block|{
literal|"allow-notify"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-query"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-query-on"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-transfer"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-update"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-update-forwarding"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"also-notify"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"alt-transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"alt-transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"auto-dnssec"
block|,
operator|&
name|cfg_type_autodnssec
block|,
literal|0
block|}
block|,
block|{
literal|"check-dup-records"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
literal|"check-integrity"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"check-mx"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
literal|"check-mx-cname"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
literal|"check-sibling"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"check-srv-cname"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
literal|"check-wildcard"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"dialup"
block|,
operator|&
name|cfg_type_dialuptype
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-dnskey-kskonly"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-secure-to-insecure"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"forward"
block|,
operator|&
name|cfg_type_forwardtype
block|,
literal|0
block|}
block|,
block|{
literal|"forwarders"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"key-directory"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"maintain-ixfr-base"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"masterfile-format"
block|,
operator|&
name|cfg_type_masterformat
block|,
literal|0
block|}
block|,
block|{
literal|"max-ixfr-log-size"
block|,
operator|&
name|cfg_type_size
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"max-journal-size"
block|,
operator|&
name|cfg_type_sizenodefault
block|,
literal|0
block|}
block|,
block|{
literal|"max-refresh-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-retry-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-idle-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-idle-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-time-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-time-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-refresh-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-retry-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"multi-master"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"notify"
block|,
operator|&
name|cfg_type_notifytype
block|,
literal|0
block|}
block|,
block|{
literal|"notify-delay"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"notify-to-soa"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"nsec3-test-zone"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_TESTONLY
block|}
block|,
block|{
literal|"sig-signing-nodes"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"sig-signing-signatures"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"sig-signing-type"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"sig-validity-interval"
block|,
operator|&
name|cfg_type_validityinterval
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"try-tcp-refresh"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"update-check-ksk"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"use-alt-transfer-source"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"zero-no-soa-ttl"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"zone-statistics"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found in a 'zone' statement  * only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|zone_only_clauses
index|[]
init|=
block|{
block|{
literal|"type"
block|,
operator|&
name|cfg_type_zonetype
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"journal"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"ixfr-base"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"ixfr-tmp-file"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"masters"
block|,
operator|&
name|cfg_type_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
literal|"pubkey"
block|,
operator|&
name|cfg_type_pubkey
block|,
name|CFG_CLAUSEFLAG_MULTI
operator||
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"update-policy"
block|,
operator|&
name|cfg_type_updatepolicy
block|,
literal|0
block|}
block|,
block|{
literal|"database"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"delegation-only"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
comment|/* 	 * Note that the format of the check-names option is different between 	 * the zone options and the global/view options.  Ugh. 	 */
block|{
literal|"check-names"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
literal|"ixfr-from-differences"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"server-addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrlist
block|,
literal|0
block|}
block|,
block|{
literal|"server-names"
block|,
operator|&
name|cfg_type_namelist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The top-level named.conf syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|namedconf_clausesets
index|[]
init|=
block|{
name|namedconf_clauses
block|,
name|namedconf_or_view_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_namedconf
init|=
block|{
literal|"namedconf"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|namedconf_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The bind.keys syntax (trusted-keys/managed-keys only). */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|bindkeys_clausesets
index|[]
init|=
block|{
name|bindkeys_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_bindkeys
init|=
block|{
literal|"bindkeys"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|bindkeys_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The new-zone-file syntax (for zones added by 'rndc addzone') */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|newzones_clauses
index|[]
init|=
block|{
block|{
literal|"zone"
block|,
operator|&
name|cfg_type_zone
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|newzones_clausesets
index|[]
init|=
block|{
name|newzones_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_newzones
init|=
block|{
literal|"newzones"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|newzones_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The "options" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|options_clausesets
index|[]
init|=
block|{
name|options_clauses
block|,
name|view_clauses
block|,
name|zone_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_options
init|=
block|{
literal|"options"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|options_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The "view" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|view_clausesets
index|[]
init|=
block|{
name|view_only_clauses
block|,
name|namedconf_or_view_clauses
block|,
name|view_clauses
block|,
name|zone_clauses
block|,
name|dynamically_loadable_zones_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_viewopts
init|=
block|{
literal|"view"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|view_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The "zone" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|zone_clausesets
index|[]
init|=
block|{
name|zone_only_clauses
block|,
name|zone_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zoneopts
init|=
block|{
literal|"zoneopts"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|zone_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% The "dynamically loadable zones" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|dynamically_loadable_zones_clausesets
index|[]
init|=
block|{
name|dynamically_loadable_zones_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dynamically_loadable_zones_opts
init|=
block|{
literal|"dynamically_loadable_zones_opts"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|dynamically_loadable_zones_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found within the 'key' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|key_clauses
index|[]
init|=
block|{
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"secret"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|key_clausesets
index|[]
init|=
block|{
name|key_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_key
init|=
block|{
literal|"key"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|key_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found in a 'server' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|server_clauses
index|[]
init|=
block|{
block|{
literal|"bogus"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"provide-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"request-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"support-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"transfers"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-format"
block|,
operator|&
name|cfg_type_transferformat
block|,
literal|0
block|}
block|,
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_server_key_kludge
block|,
literal|0
block|}
block|,
block|{
literal|"edns"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"edns-udp-size"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-udp-size"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"query-source"
block|,
operator|&
name|cfg_type_querysource4
block|,
literal|0
block|}
block|,
block|{
literal|"query-source-v6"
block|,
operator|&
name|cfg_type_querysource6
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|server_clausesets
index|[]
init|=
block|{
name|server_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server
init|=
block|{
literal|"server"
block|,
name|cfg_parse_netprefix_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|server_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found in a 'channel' clause in the  * 'logging' statement.  *  * These have some additional constraints that need to be  * checked after parsing:  *  - There must exactly one of file/syslog/null/stderr  *  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|channel_clauses
index|[]
init|=
block|{
comment|/* Destinations.  We no longer require these to be first. */
block|{
literal|"file"
block|,
operator|&
name|cfg_type_logfile
block|,
literal|0
block|}
block|,
block|{
literal|"syslog"
block|,
operator|&
name|cfg_type_optional_facility
block|,
literal|0
block|}
block|,
block|{
literal|"null"
block|,
operator|&
name|cfg_type_void
block|,
literal|0
block|}
block|,
block|{
literal|"stderr"
block|,
operator|&
name|cfg_type_void
block|,
literal|0
block|}
block|,
comment|/* Options.  We now accept these for the null channel, too. */
block|{
literal|"severity"
block|,
operator|&
name|cfg_type_logseverity
block|,
literal|0
block|}
block|,
block|{
literal|"print-time"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"print-severity"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"print-category"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|channel_clausesets
index|[]
init|=
block|{
name|channel_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_channel
init|=
block|{
literal|"channel"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|channel_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% A list of log destination, used in the "category" clause. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_destinationlist
init|=
block|{
literal|"destinationlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Clauses that can be found in a 'logging' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|logging_clauses
index|[]
init|=
block|{
block|{
literal|"channel"
block|,
operator|&
name|cfg_type_channel
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"category"
block|,
operator|&
name|cfg_type_category
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|logging_clausesets
index|[]
init|=
block|{
name|logging_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logging
init|=
block|{
literal|"logging"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|logging_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * For parsing an 'addzone' statement  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|addzone_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"view"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_zoneopts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_addzone
init|=
block|{
literal|"addzone"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|addzone_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|addzoneconf_clauses
index|[]
init|=
block|{
block|{
literal|"addzone"
block|,
operator|&
name|cfg_type_addzone
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|addzoneconf_clausesets
index|[]
init|=
block|{
name|addzoneconf_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_addzoneconf
init|=
block|{
literal|"addzoneconf"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|addzoneconf_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_unitstring
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|isc_resourcevalue_t
modifier|*
name|valuep
parameter_list|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|isc_uint64_t
name|value
decl_stmt|;
name|isc_uint64_t
name|unit
decl_stmt|;
name|value
operator|=
name|isc_string_touint64
argument_list|(
name|str
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|||
name|endp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
switch|switch
condition|(
name|str
index|[
name|len
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|unit
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|unit
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|unit
operator|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|value
operator|>
name|ISC_UINT64_MAX
operator|/
name|unit
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
operator|*
name|valuep
operator|=
name|value
operator|*
name|unit
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_sizeval
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_uint64_t
name|val
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|result
operator|=
name|ISC_R_UNEXPECTEDTOKEN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CHECK
argument_list|(
name|parse_unitstring
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint64
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|uint64
operator|=
name|val
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected integer and optional unit"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * A size value (number + optional unit).  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizeval
init|=
block|{
literal|"sizeval"
block|,
name|parse_sizeval
block|,
name|cfg_print_uint64
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_uint64
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A size, "unlimited", or "default".  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_size
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_sizeval
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|size_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
literal|"default"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_size
init|=
block|{
literal|"size"
block|,
name|parse_size
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|size_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A size or "unlimited", but not "default".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sizenodefault_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizenodefault
init|=
block|{
literal|"size_no_default"
block|,
name|parse_size
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|sizenodefault_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * optional_keyvalue  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_maybe_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|isc_boolean_t
name|optional
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|kw
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|kw
operator|->
name|type
operator|->
name|parse
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* XXX kludge */
block|}
else|else
block|{
if|if
condition|(
name|optional
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected '%s'"
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTEDTOKEN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_enum_or_other
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|enumtype
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|othertype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|cfg_is_enum
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|enumtype
operator|->
name|of
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_enum
argument_list|(
name|pctx
argument_list|,
name|enumtype
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|othertype
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_enum_or_other
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_doc_terminal
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|cfg_print_chars(pctx, "( ", 2);...
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_maybe_optional_keyvalue
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ISC_FALSE
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_maybe_optional_keyvalue
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ISC_TRUE
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|obj
operator|->
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kw
operator|->
name|type
operator|->
name|print
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_optional_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"[ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ]"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dialup_enums
index|[]
init|=
block|{
literal|"notify"
block|,
literal|"notify-passive"
block|,
literal|"refresh"
block|,
literal|"passive"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_dialup_type
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dialuptype
init|=
block|{
literal|"dialuptype"
block|,
name|parse_dialup_type
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|dialup_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|notify_enums
index|[]
init|=
block|{
literal|"explicit"
block|,
literal|"master-only"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_notify_type
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_notifytype
init|=
block|{
literal|"notifytype"
block|,
name|parse_notify_type
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|notify_enums
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ixfrdiff_enums
index|[]
init|=
block|{
literal|"master"
block|,
literal|"slave"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_ixfrdiff_type
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_ixfrdifftype
init|=
block|{
literal|"ixfrdiff"
block|,
name|parse_ixfrdiff_type
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|ixfrdiff_enums
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|v4_aaaa_enums
index|[]
init|=
block|{
literal|"break-dnssec"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_v4_aaaa
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_v4_aaaa
init|=
block|{
literal|"v4_aaaa"
block|,
name|parse_v4_aaaa
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|v4_aaaa_enums
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|key_kw
init|=
block|{
literal|"key"
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_keyref
init|=
block|{
literal|"keyref"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|key_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_keyref
init|=
block|{
literal|"optional_keyref"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|key_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A "controls" statement is represented as a map with the multivalued  * "inet" and "unix" clauses.  */
end_comment

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_allow_kw
init|=
block|{
literal|"allow"
block|,
operator|&
name|cfg_type_bracketed_aml
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_allow
init|=
block|{
literal|"controls_allow"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|controls_allow_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_keys_kw
init|=
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_keylist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_keys
init|=
block|{
literal|"controls_keys"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|controls_keys_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|inetcontrol_fields
index|[]
init|=
block|{
block|{
literal|"address"
block|,
operator|&
name|cfg_type_controls_sockaddr
block|,
literal|0
block|}
block|,
block|{
literal|"allow"
block|,
operator|&
name|cfg_type_controls_allow
block|,
literal|0
block|}
block|,
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_controls_keys
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_inetcontrol
init|=
block|{
literal|"inetcontrol"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|inetcontrol_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_perm_kw
init|=
block|{
literal|"perm"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_perm
init|=
block|{
literal|"controls_perm"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|controls_perm_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_owner_kw
init|=
block|{
literal|"owner"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_owner
init|=
block|{
literal|"controls_owner"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|controls_owner_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_group_kw
init|=
block|{
literal|"group"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_group
init|=
block|{
literal|"controls_allow"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|controls_group_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|unixcontrol_fields
index|[]
init|=
block|{
block|{
literal|"path"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"perm"
block|,
operator|&
name|cfg_type_controls_perm
block|,
literal|0
block|}
block|,
block|{
literal|"owner"
block|,
operator|&
name|cfg_type_controls_owner
block|,
literal|0
block|}
block|,
block|{
literal|"group"
block|,
operator|&
name|cfg_type_controls_group
block|,
literal|0
block|}
block|,
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_controls_keys
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_unixcontrol
init|=
block|{
literal|"unixcontrol"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|unixcontrol_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|controls_clauses
index|[]
init|=
block|{
block|{
literal|"inet"
block|,
operator|&
name|cfg_type_inetcontrol
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"unix"
block|,
operator|&
name|cfg_type_unixcontrol
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|controls_clausesets
index|[]
init|=
block|{
name|controls_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls
init|=
block|{
literal|"controls"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
operator|&
name|controls_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A "statistics-channels" statement is represented as a map with the  * multivalued "inet" clauses.  */
end_comment

begin_function
specifier|static
name|void
name|doc_optional_bracketed_list
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"[ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ]"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_allow
init|=
block|{
literal|"optional_allow"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|controls_allow_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|statserver_fields
index|[]
init|=
block|{
block|{
literal|"address"
block|,
operator|&
name|cfg_type_controls_sockaddr
block|,
literal|0
block|}
block|,
comment|/* reuse controls def */
block|{
literal|"allow"
block|,
operator|&
name|cfg_type_optional_allow
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_statschannel
init|=
block|{
literal|"statschannel"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|statserver_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|statservers_clauses
index|[]
init|=
block|{
block|{
literal|"inet"
block|,
operator|&
name|cfg_type_statschannel
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|statservers_clausesets
index|[]
init|=
block|{
name|statservers_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_statschannels
init|=
block|{
literal|"statistics-channels"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
operator|&
name|statservers_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * An optional class, as used in view and zone statements.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_optional_class
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_ustring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_class
init|=
block|{
literal|"optional_class"
block|,
name|parse_optional_class
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_querysource
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|unsigned
name|int
name|have_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|have_port
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|int
modifier|*
name|flagp
init|=
name|type
operator|->
name|of
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_V4OK
operator|)
operator|!=
literal|0
condition|)
name|isc_netaddr_any
argument_list|(
operator|&
name|netaddr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|CFG_ADDR_V6OK
operator|)
operator|!=
literal|0
condition|)
name|isc_netaddr_any6
argument_list|(
operator|&
name|netaddr
argument_list|)
expr_stmt|;
else|else
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"address"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* read "address" */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawaddr
argument_list|(
name|pctx
argument_list|,
operator|*
name|flagp
argument_list|,
operator|&
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|have_address
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* read "port" */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawport
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_WILDOK
argument_list|,
operator|&
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|have_port
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_port
operator|==
literal|0
operator|&&
name|have_address
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cfg_parse_sockaddr
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected 'address' or 'port'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|have_address
operator|>
literal|1
operator|||
name|have_port
operator|>
literal|1
operator|||
name|have_address
operator|+
name|have_port
operator|==
literal|0
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"expected one address and/or port"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_querysource
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_fromnetaddr
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|,
operator|&
name|netaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"invalid query source"
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_querysource
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|isc_netaddr_t
name|na
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"address "
argument_list|)
expr_stmt|;
name|cfg_print_rawaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|na
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|" port "
argument_list|)
expr_stmt|;
name|cfg_print_rawuint
argument_list|(
name|pctx
argument_list|,
name|isc_sockaddr_getport
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sockaddr4wild_flags
init|=
name|CFG_ADDR_WILDOK
operator||
name|CFG_ADDR_V4OK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sockaddr6wild_flags
init|=
name|CFG_ADDR_WILDOK
operator||
name|CFG_ADDR_V6OK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource4
init|=
block|{
literal|"querysource4"
block|,
name|parse_querysource
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
operator|&
name|sockaddr4wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource6
init|=
block|{
literal|"querysource6"
block|,
name|parse_querysource
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
operator|&
name|sockaddr6wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource
init|=
block|{
literal|"querysource"
block|,
name|NULL
block|,
name|print_querysource
block|,
name|NULL
block|,
operator|&
name|cfg_rep_sockaddr
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% addrmatchelt */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_addrmatchelt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"key"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_keyref
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V4PREFIXOK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_netprefix
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_astring
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
condition|)
block|{
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
block|{
comment|/* Nested match list. */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_bracketed_aml
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'!'
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "!" */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_negated
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|bad
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP match list element"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * A negated address match list element (like "! 10.0.0.1").  * Somewhat sneakily, the caller is expected to parse the  * "!", but not to print it.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|negated_fields
index|[]
init|=
block|{
block|{
literal|"value"
block|,
operator|&
name|cfg_type_addrmatchelt
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_negated
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_tuple
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_negated
init|=
block|{
literal|"negated"
block|,
name|cfg_parse_tuple
block|,
name|print_negated
block|,
name|NULL
block|,
operator|&
name|cfg_rep_tuple
block|,
operator|&
name|negated_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% An address match list element */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_addrmatchelt
init|=
block|{
literal|"address_match_element"
block|,
name|parse_addrmatchelt
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% A bracketed address match list */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_aml
init|=
block|{
literal|"bracketed_aml"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_addrmatchelt
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * The socket address syntax in the "controls" statement is silly.  * It allows both socket address families, but also allows "*",  * whis is gratuitously interpreted as the IPv4 wildcard address.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|controls_sockaddr_flags
init|=
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
operator||
name|CFG_ADDR_WILDOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_sockaddr
init|=
block|{
literal|"controls_sockaddr"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|controls_sockaddr_flags
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Handle the special kludge syntax of the "keys" clause in the "server"  * statement, which takes a single key with or without braces and semicolon.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_server_key_kludge
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|braces
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Allow opening brace. */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|braces
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
condition|)
block|{
comment|/* Skip semicolon if present. */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|';'
condition|)
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'}'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server_key_kludge
init|=
block|{
literal|"server_key"
block|,
name|parse_server_key_kludge
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * An optional logging facility.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_optional_facility
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_facility
init|=
block|{
literal|"optional_facility"
block|,
name|parse_optional_facility
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A log severity.  Return as a string, except "debug N",  * which is returned as a keyword object.  */
end_comment

begin_decl_stmt
specifier|static
name|keyword_type_t
name|debug_kw
init|=
block|{
literal|"debug"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_debuglevel
init|=
block|{
literal|"debuglevel"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|debug_kw
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logseverity
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "debug" */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_number
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_uint32
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The debug level is optional and defaults to 1. 			 * This makes little sense, but we support it for 			 * compatibility with BIND 8. 			 */
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|value
operator|.
name|uint32
operator|=
literal|1
expr_stmt|;
block|}
operator|(
operator|*
name|ret
operator|)
operator|->
name|type
operator|=
operator|&
name|cfg_type_debuglevel
expr_stmt|;
comment|/* XXX kludge */
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_loglevel
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logseverity
init|=
block|{
literal|"log_severity"
block|,
name|parse_logseverity
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * The "file" clause of the "channel" statement.  * This is yet another special case.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logversions_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logversions
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logversions
init|=
block|{
literal|"logversions"
block|,
name|parse_logversions
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|logversions_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|logfile_fields
index|[]
init|=
block|{
block|{
literal|"file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"versions"
block|,
operator|&
name|cfg_type_logversions
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logfile
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse the mandatory "file" field */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse "versions" and "size" fields in any order. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"versions"
argument_list|)
operator|==
literal|0
operator|&&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
operator|&&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* Create void objects for missing optional values. */
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_logfile
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* file */
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
condition|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|" versions "
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
condition|)
block|{
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|" size "
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|doc_logfile
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<quoted_string>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ versions ( \"unlimited\" |<integer> ) ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ size<size> ]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logfile
init|=
block|{
literal|"log_file"
block|,
name|parse_logfile
block|,
name|print_logfile
block|,
name|doc_logfile
block|,
operator|&
name|cfg_rep_tuple
block|,
name|logfile_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% An IPv4 address with optional port, "*" accepted as wildcard. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr4wild
init|=
block|{
literal|"sockaddr4wild"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|sockaddr4wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*% An IPv6 address with optional port, "*" accepted as wildcard. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr6wild
init|=
block|{
literal|"v6addrportwild"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|sockaddr6wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * lwres  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|lwres_view_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres_view
init|=
block|{
literal|"lwres_view"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|lwres_view_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres_searchlist
init|=
block|{
literal|"lwres_searchlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|lwres_clauses
index|[]
init|=
block|{
block|{
literal|"listen-on"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"view"
block|,
operator|&
name|cfg_type_lwres_view
block|,
literal|0
block|}
block|,
block|{
literal|"search"
block|,
operator|&
name|cfg_type_lwres_searchlist
block|,
literal|0
block|}
block|,
block|{
literal|"ndots"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|lwres_clausesets
index|[]
init|=
block|{
name|lwres_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres
init|=
block|{
literal|"lwres"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|lwres_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * rndc  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_options_clauses
index|[]
init|=
block|{
block|{
literal|"default-key"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"default-port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"default-server"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"default-source-address"
block|,
operator|&
name|cfg_type_netaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"default-source-address-v6"
block|,
operator|&
name|cfg_type_netaddr6wild
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_options_clausesets
index|[]
init|=
block|{
name|rndcconf_options_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rndcconf_options
init|=
block|{
literal|"rndcconf_options"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_options_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_server_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"source-address"
block|,
operator|&
name|cfg_type_netaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"source-address-v6"
block|,
operator|&
name|cfg_type_netaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrnameportlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_server_clausesets
index|[]
init|=
block|{
name|rndcconf_server_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rndcconf_server
init|=
block|{
literal|"rndcconf_server"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_server_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"server"
block|,
operator|&
name|cfg_type_rndcconf_server
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_rndcconf_options
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_clausesets
index|[]
init|=
block|{
name|rndcconf_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_rndcconf
init|=
block|{
literal|"rndcconf"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndckey_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndckey_clausesets
index|[]
init|=
block|{
name|rndckey_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_rndckey
init|=
block|{
literal|"rndckey"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|rndckey_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * session.key has exactly the same syntax as rndc.key, but it's defined  * separately for clarity (and so we can extend it someday, if needed).  */
end_comment

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_sessionkey
init|=
block|{
literal|"sessionkey"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|rndckey_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|nameport_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameport
init|=
block|{
literal|"nameport"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|nameport_fields
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|doc_sockaddrnameport
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<quoted_string>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv4_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv6_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" )"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_sockaddrnameport
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
name|CHECK
argument_list|(
name|cfg_parse_sockaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_sockaddr
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|cfg_type_nameport
operator|.
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_nameport
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP address or hostname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddrnameport
init|=
block|{
literal|"sockaddrnameport_element"
block|,
name|parse_sockaddrnameport
block|,
name|NULL
block|,
name|doc_sockaddrnameport
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrnameportlist
init|=
block|{
literal|"bracketed_sockaddrnameportlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_sockaddrnameport
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * A list of socket addresses or name with an optional default port,  * as used in the dual-stack-servers option.  E.g.,  * "port 1234 { dual-stack-servers.net; 10.0.0.1; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|nameportiplist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrnameportlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameportiplist
init|=
block|{
literal|"nameportiplist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|nameportiplist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * masters element.  */
end_comment

begin_function
specifier|static
name|void
name|doc_masterselement
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<masters>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv4_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv6_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[ port<integer> ]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" )"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_masterselement
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
name|CHECK
argument_list|(
name|cfg_parse_sockaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_sockaddr
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|cfg_parse_astring
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP address or masters name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masterselement
init|=
block|{
literal|"masters_element"
block|,
name|parse_masterselement
block|,
name|NULL
block|,
name|doc_masterselement
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

