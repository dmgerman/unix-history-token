begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2002, 2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: namedconf.c,v 1.21.44.34 2006/03/02 00:37:20 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/cfg.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/grammar.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/log.h>
end_include

begin_define
define|#
directive|define
name|TOKEN_STRING
parameter_list|(
name|pctx
parameter_list|)
value|(pctx->token.value.as_textregion.base)
end_define

begin_comment
comment|/* Check a return value. */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op); 					\ 		if (result != ISC_R_SUCCESS) goto cleanup; 	\ 	} while (0)
end_define

begin_comment
comment|/* Clean up a configuration object if non-NULL. */
end_comment

begin_define
define|#
directive|define
name|CLEANUP_OBJ
parameter_list|(
name|obj
parameter_list|)
define|\
value|do { if ((obj) != NULL) cfg_obj_destroy(pctx,&(obj)); } while (0)
end_define

begin_comment
comment|/*  * Forward declarations of static functions.  */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|parse_enum_or_other
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|enumtype
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|othertype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|parse_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doc_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doc_optional_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_acl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_addrmatchelt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_aml
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_namesockaddrkeylist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_sockaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_destinationlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dialuptype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logseverity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masterselement
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameportiplist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_negated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_notifytype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_facility
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_facility
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_keyref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_portiplist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server_key_kludge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizenodefault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr4wild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr6wild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_view
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_viewopts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zoneopts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tkey-dhkey */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|tkey_dhkey_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"keyid"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_tkey_dhkey
init|=
block|{
literal|"tkey-dhkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|tkey_dhkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* listen-on */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|listenon_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"acl"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_listenon
init|=
block|{
literal|"listenon"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|listenon_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* acl */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|acl_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"value"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_acl
init|=
block|{
literal|"acl"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|acl_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* masters */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|masters_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masters
init|=
block|{
literal|"masters"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|masters_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "sockaddrkeylist", a list of socket addresses with optional keys  * and an optional default port, as used in the masters option.  * E.g.,  *   "port 1234 { mymasters; 10.0.0.1 key foo; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|namesockaddrkey_fields
index|[]
init|=
block|{
block|{
literal|"masterselement"
block|,
operator|&
name|cfg_type_masterselement
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_optional_keyref
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namesockaddrkey
init|=
block|{
literal|"namesockaddrkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|namesockaddrkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_namesockaddrkeylist
init|=
block|{
literal|"bracketed_namesockaddrkeylist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_namesockaddrkey
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|namesockaddrkeylist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namesockaddrkeylist
init|=
block|{
literal|"sockaddrkeylist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|namesockaddrkeylist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A list of socket addresses with an optional default port,  * as used in the also-notify option.  E.g.,  * "port 1234 { 10.0.0.1; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|portiplist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_portiplist
init|=
block|{
literal|"portiplist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|portiplist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A public key, as in the "pubkey" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|pubkey_fields
index|[]
init|=
block|{
block|{
literal|"flags"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"protocol"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_pubkey
init|=
block|{
literal|"pubkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|pubkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A list of RR types, used in grant statements.  * Note that the old parser allows quotes around the RR type names.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrtypelist
init|=
block|{
literal|"rrtypelist"
block|,
name|cfg_parse_spacelist
block|,
name|cfg_print_spacelist
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mode_enums
index|[]
init|=
block|{
literal|"grant"
block|,
literal|"deny"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_mode
init|=
block|{
literal|"mode"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|mode_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|matchtype_enums
index|[]
init|=
block|{
literal|"name"
block|,
literal|"subdomain"
block|,
literal|"wildcard"
block|,
literal|"self"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_matchtype
init|=
block|{
literal|"matchtype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|matchtype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A grant statement, used in the update policy.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|grant_fields
index|[]
init|=
block|{
block|{
literal|"mode"
block|,
operator|&
name|cfg_type_mode
block|,
literal|0
block|}
block|,
block|{
literal|"identity"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
comment|/* domain name */
block|{
literal|"matchtype"
block|,
operator|&
name|cfg_type_matchtype
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
comment|/* domain name */
block|{
literal|"types"
block|,
operator|&
name|cfg_type_rrtypelist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_grant
init|=
block|{
literal|"grant"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|grant_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_updatepolicy
init|=
block|{
literal|"update_policy"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_grant
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A view statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|view_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_viewopts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_view
init|=
block|{
literal|"view"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|view_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A zone statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|zone_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_zoneopts
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zone
init|=
block|{
literal|"zone"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|zone_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A "category" clause in the "logging" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|category_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"destinations"
block|,
operator|&
name|cfg_type_destinationlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_category
init|=
block|{
literal|"category"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|category_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A trusted key, as used in the "trusted-keys" statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|trustedkey_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"flags"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"protocol"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"key"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_trustedkey
init|=
block|{
literal|"trustedkey"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|trustedkey_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_class_kw
init|=
block|{
literal|"class"
block|,
operator|&
name|cfg_type_ustring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_class
init|=
block|{
literal|"optional_wild_class"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_class_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_type_kw
init|=
block|{
literal|"type"
block|,
operator|&
name|cfg_type_ustring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_type
init|=
block|{
literal|"optional_wild_type"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_type_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|wild_name_kw
init|=
block|{
literal|"name"
block|,
operator|&
name|cfg_type_qstring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_wild_name
init|=
block|{
literal|"optional_wild_name"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|wild_name_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An rrset ordering element.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|rrsetorderingelement_fields
index|[]
init|=
block|{
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_wild_class
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
operator|&
name|cfg_type_optional_wild_type
block|,
literal|0
block|}
block|,
block|{
literal|"name"
block|,
operator|&
name|cfg_type_optional_wild_name
block|,
literal|0
block|}
block|,
block|{
literal|"order"
block|,
operator|&
name|cfg_type_ustring
block|,
literal|0
block|}
block|,
comment|/* must be literal "order" */
block|{
literal|"ordering"
block|,
operator|&
name|cfg_type_ustring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrsetorderingelement
init|=
block|{
literal|"rrsetorderingelement"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|rrsetorderingelement_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A global or view "check-names" option.  Note that the zone  * "check-names" option has a different syntax.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|checktype_enums
index|[]
init|=
block|{
literal|"master"
block|,
literal|"slave"
block|,
literal|"response"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checktype
init|=
block|{
literal|"checktype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|checktype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|checkmode_enums
index|[]
init|=
block|{
literal|"fail"
block|,
literal|"warn"
block|,
literal|"ignore"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checkmode
init|=
block|{
literal|"checkmode"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|checkmode_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|checknames_fields
index|[]
init|=
block|{
block|{
literal|"type"
block|,
operator|&
name|cfg_type_checktype
block|,
literal|0
block|}
block|,
block|{
literal|"mode"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_checknames
init|=
block|{
literal|"checknames"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|checknames_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrlist
init|=
block|{
literal|"bracketed_sockaddrlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_sockaddr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rrsetorder
init|=
block|{
literal|"rrsetorder"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_rrsetorderingelement
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|port_kw
init|=
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_port
init|=
block|{
literal|"optional_port"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|port_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of keys, as in the "key" clause of the controls statement. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_keylist
init|=
block|{
literal|"keylist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_trustedkeys
init|=
block|{
literal|"trusted-keys"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_trustedkey
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|forwardtype_enums
index|[]
init|=
block|{
literal|"first"
block|,
literal|"only"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_forwardtype
init|=
block|{
literal|"forwardtype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|forwardtype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|zonetype_enums
index|[]
init|=
block|{
literal|"master"
block|,
literal|"slave"
block|,
literal|"stub"
block|,
literal|"hint"
block|,
literal|"forward"
block|,
literal|"delegation-only"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zonetype
init|=
block|{
literal|"zonetype"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|zonetype_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|loglevel_enums
index|[]
init|=
block|{
literal|"critical"
block|,
literal|"error"
block|,
literal|"warning"
block|,
literal|"notice"
block|,
literal|"info"
block|,
literal|"dynamic"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_loglevel
init|=
block|{
literal|"loglevel"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|loglevel_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|transferformat_enums
index|[]
init|=
block|{
literal|"many-answers"
block|,
literal|"one-answer"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_transferformat
init|=
block|{
literal|"transferformat"
block|,
name|cfg_parse_enum
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_enum
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|transferformat_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The special keyword "none", as used in the pid-file option.  */
end_comment

begin_function
specifier|static
name|void
name|print_none
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"none"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_none
init|=
block|{
literal|"none"
block|,
name|NULL
block|,
name|print_none
block|,
name|NULL
block|,
operator|&
name|cfg_rep_void
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A quoted string or the special keyword "none".  Used in the pid-file option.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_qstringornone
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_none
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_qstring
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_qstringornone
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"(<quoted_string> | none )"
argument_list|,
literal|26
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_qstringornone
init|=
block|{
literal|"qstringornone"
block|,
name|parse_qstringornone
block|,
name|NULL
block|,
name|doc_qstringornone
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * keyword hostname  */
end_comment

begin_function
specifier|static
name|void
name|print_hostname
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"hostname"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_hostname
init|=
block|{
literal|"hostname"
block|,
name|NULL
block|,
name|print_hostname
block|,
name|NULL
block|,
operator|&
name|cfg_rep_boolean
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "server-id" argument.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_serverid
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_none
argument_list|,
name|ret
argument_list|)
operator|)
return|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"hostname"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_hostname
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
name|cfg_ungettoken
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|cfg_parse_qstring
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ret
argument_list|)
operator|)
return|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_serverid
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"(<quoted_string> | none | hostname )"
argument_list|,
literal|26
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_serverid
init|=
block|{
literal|"serverid"
block|,
name|parse_serverid
block|,
name|NULL
block|,
name|doc_serverid
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Port list.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_port
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_uint32
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ret
operator|)
operator|->
name|value
operator|.
name|uint32
operator|>
literal|0xffff
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"invalid port"
argument_list|)
expr_stmt|;
name|cfg_obj_destroy
argument_list|(
name|pctx
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_port
init|=
block|{
literal|"port"
block|,
name|parse_port
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_portlist
init|=
block|{
literal|"bracketed_sockaddrlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_port
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found within the top level of the named.conf  * file only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|namedconf_clauses
index|[]
init|=
block|{
block|{
literal|"options"
block|,
operator|&
name|cfg_type_options
block|,
literal|0
block|}
block|,
block|{
literal|"controls"
block|,
operator|&
name|cfg_type_controls
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"acl"
block|,
operator|&
name|cfg_type_acl
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"masters"
block|,
operator|&
name|cfg_type_masters
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"logging"
block|,
operator|&
name|cfg_type_logging
block|,
literal|0
block|}
block|,
block|{
literal|"view"
block|,
operator|&
name|cfg_type_view
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"lwres"
block|,
operator|&
name|cfg_type_lwres
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can occur at the top level or in the view  * statement, but not in the options block.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|namedconf_or_view_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"zone"
block|,
operator|&
name|cfg_type_zone
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"server"
block|,
operator|&
name|cfg_type_server
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"trusted-keys"
block|,
operator|&
name|cfg_type_trustedkeys
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found within the 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|options_clauses
index|[]
init|=
block|{
block|{
literal|"avoid-v4-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"avoid-v6-udp-ports"
block|,
operator|&
name|cfg_type_bracketed_portlist
block|,
literal|0
block|}
block|,
block|{
literal|"blackhole"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"coresize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"datasize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"deallocate-on-exit"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"directory"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_CALLBACK
block|}
block|,
block|{
literal|"dump-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"fake-iquery"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"files"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"has-old-clients"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"heartbeat-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"host-statistics"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"host-statistics-max"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"hostname"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"interface-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"listen-on"
block|,
operator|&
name|cfg_type_listenon
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"listen-on-v6"
block|,
operator|&
name|cfg_type_listenon
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"match-mapped-addresses"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"memstatistics-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"multiple-cnames"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"named-xfer"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"pid-file"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"querylog"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"recursing-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"random-device"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"recursive-clients"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"serial-queries"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"serial-query-rate"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"server-id"
block|,
operator|&
name|cfg_type_serverid
block|,
literal|0
block|}
block|,
block|{
literal|"stacksize"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
literal|"statistics-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"statistics-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"tcp-clients"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"tcp-listen-queue"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-dhkey"
block|,
operator|&
name|cfg_type_tkey_dhkey
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-gssapi-credential"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"tkey-domain"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-per-ns"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfers-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"treat-cr-as-space"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"use-id-pool"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"use-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"version"
block|,
operator|&
name|cfg_type_qstringornone
block|,
literal|0
block|}
block|,
block|{
literal|"flush-zones-on-shutdown"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_namelist
init|=
block|{
literal|"namelist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_qstring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|exclude_kw
init|=
block|{
literal|"exclude"
block|,
operator|&
name|cfg_type_namelist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_exclude
init|=
block|{
literal|"optional_exclude"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|exclude_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_algorithmlist
init|=
block|{
literal|"algorithmlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|disablealgorithm_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"algorithms"
block|,
operator|&
name|cfg_type_algorithmlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_disablealgorithm
init|=
block|{
literal|"disablealgorithm"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|disablealgorithm_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|mustbesecure_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"value"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_mustbesecure
init|=
block|{
literal|"mustbesecure"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|mustbesecure_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * dnssec-lookaside  */
end_comment

begin_decl_stmt
specifier|static
name|keyword_type_t
name|trustanchor_kw
init|=
block|{
literal|"trust-anchor"
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_trustanchor
init|=
block|{
literal|"trust-anchor"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|trustanchor_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|lookaside_fields
index|[]
init|=
block|{
block|{
literal|"domain"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"trust-anchor"
block|,
operator|&
name|cfg_type_trustanchor
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lookaside
init|=
block|{
literal|"lookaside"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|lookaside_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found within the 'view' statement,  * with defaults in the 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|view_clauses
index|[]
init|=
block|{
block|{
literal|"allow-recursion"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-v6-synthesis"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"sortlist"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"topology"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"auth-nxdomain"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NEWDEFAULT
block|}
block|,
block|{
literal|"minimal-responses"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"recursion"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"rrset-order"
block|,
operator|&
name|cfg_type_rrsetorder
block|,
literal|0
block|}
block|,
block|{
literal|"provide-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"request-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"fetch-glue"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"rfc2308-type1"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"additional-from-auth"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"additional-from-cache"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
comment|/* 	 * Note that the query-source option syntax is different 	 * from the other -source options. 	 */
block|{
literal|"query-source"
block|,
operator|&
name|cfg_type_querysource4
block|,
literal|0
block|}
block|,
block|{
literal|"query-source-v6"
block|,
operator|&
name|cfg_type_querysource6
block|,
literal|0
block|}
block|,
block|{
literal|"cleaning-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-roots"
block|,
operator|&
name|cfg_type_uint32
block|,
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
literal|"lame-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-ncache-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-cache-ttl"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-format"
block|,
operator|&
name|cfg_type_transferformat
block|,
literal|0
block|}
block|,
block|{
literal|"max-cache-size"
block|,
operator|&
name|cfg_type_sizenodefault
block|,
literal|0
block|}
block|,
block|{
literal|"check-names"
block|,
operator|&
name|cfg_type_checknames
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"cache-file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"suppress-initial-notify"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_NYI
block|}
block|,
block|{
literal|"preferred-glue"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"dual-stack-servers"
block|,
operator|&
name|cfg_type_nameportiplist
block|,
literal|0
block|}
block|,
block|{
literal|"edns-udp-size"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"root-delegation-only"
block|,
operator|&
name|cfg_type_optional_exclude
block|,
literal|0
block|}
block|,
block|{
literal|"disable-algorithms"
block|,
operator|&
name|cfg_type_disablealgorithm
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dnssec-enable"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"dnssec-lookaside"
block|,
operator|&
name|cfg_type_lookaside
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"dnssec-must-be-secure"
block|,
operator|&
name|cfg_type_mustbesecure
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found within the 'view' statement only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|view_only_clauses
index|[]
init|=
block|{
block|{
literal|"match-clients"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"match-destinations"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"match-recursive-only"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'zone' statement,  * with defaults in the 'view' or 'options' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|zone_clauses
index|[]
init|=
block|{
block|{
literal|"allow-query"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-transfer"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-update-forwarding"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"allow-notify"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"notify"
block|,
operator|&
name|cfg_type_notifytype
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"notify-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"also-notify"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"dialup"
block|,
operator|&
name|cfg_type_dialuptype
block|,
literal|0
block|}
block|,
block|{
literal|"forward"
block|,
operator|&
name|cfg_type_forwardtype
block|,
literal|0
block|}
block|,
block|{
literal|"forwarders"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"ixfr-from-differences"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"maintain-ixfr-base"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"max-ixfr-log-size"
block|,
operator|&
name|cfg_type_size
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"max-journal-size"
block|,
operator|&
name|cfg_type_sizenodefault
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-time-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-time-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-idle-in"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-transfer-idle-out"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-retry-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-retry-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"max-refresh-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"min-refresh-time"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"multi-master"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"sig-validity-interval"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"alt-transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"alt-transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
literal|"use-alt-transfer-source"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"zone-statistics"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"key-directory"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'zone' statement  * only.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|zone_only_clauses
index|[]
init|=
block|{
block|{
literal|"type"
block|,
operator|&
name|cfg_type_zonetype
block|,
literal|0
block|}
block|,
block|{
literal|"allow-update"
block|,
operator|&
name|cfg_type_bracketed_aml
block|,
literal|0
block|}
block|,
block|{
literal|"file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"ixfr-base"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"ixfr-tmp-file"
block|,
operator|&
name|cfg_type_qstring
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"masters"
block|,
operator|&
name|cfg_type_namesockaddrkeylist
block|,
literal|0
block|}
block|,
block|{
literal|"pubkey"
block|,
operator|&
name|cfg_type_pubkey
block|,
name|CFG_CLAUSEFLAG_MULTI
operator||
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"update-policy"
block|,
operator|&
name|cfg_type_updatepolicy
block|,
literal|0
block|}
block|,
block|{
literal|"database"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"delegation-only"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
comment|/* 	 * Note that the format of the check-names option is different between 	 * the zone options and the global/view options.  Ugh. 	 */
block|{
literal|"check-names"
block|,
operator|&
name|cfg_type_checkmode
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The top-level named.conf syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|namedconf_clausesets
index|[]
init|=
block|{
name|namedconf_clauses
block|,
name|namedconf_or_view_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_namedconf
init|=
block|{
literal|"namedconf"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|namedconf_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "options" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|options_clausesets
index|[]
init|=
block|{
name|options_clauses
block|,
name|view_clauses
block|,
name|zone_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_options
init|=
block|{
literal|"options"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|options_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "view" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|view_clausesets
index|[]
init|=
block|{
name|view_only_clauses
block|,
name|namedconf_or_view_clauses
block|,
name|view_clauses
block|,
name|zone_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_viewopts
init|=
block|{
literal|"view"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|view_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "zone" statement syntax. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|zone_clausesets
index|[]
init|=
block|{
name|zone_only_clauses
block|,
name|zone_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_zoneopts
init|=
block|{
literal|"zoneopts"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|zone_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found within the 'key' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|key_clauses
index|[]
init|=
block|{
block|{
literal|"algorithm"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"secret"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|key_clausesets
index|[]
init|=
block|{
name|key_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_key
init|=
block|{
literal|"key"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|key_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'server' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|server_clauses
index|[]
init|=
block|{
block|{
literal|"bogus"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"provide-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"request-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"support-ixfr"
block|,
operator|&
name|cfg_type_boolean
block|,
name|CFG_CLAUSEFLAG_OBSOLETE
block|}
block|,
block|{
literal|"transfers"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-format"
block|,
operator|&
name|cfg_type_transferformat
block|,
literal|0
block|}
block|,
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_server_key_kludge
block|,
literal|0
block|}
block|,
block|{
literal|"edns"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source"
block|,
operator|&
name|cfg_type_sockaddr4wild
block|,
literal|0
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
operator|&
name|cfg_type_sockaddr6wild
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|server_clausesets
index|[]
init|=
block|{
name|server_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server
init|=
block|{
literal|"server"
block|,
name|cfg_parse_addressed_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|server_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'channel' clause in the  * 'logging' statement.  *  * These have some additional constraints that need to be  * checked after parsing:  *  - There must exactly one of file/syslog/null/stderr  *  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|channel_clauses
index|[]
init|=
block|{
comment|/* Destinations.  We no longer require these to be first. */
block|{
literal|"file"
block|,
operator|&
name|cfg_type_logfile
block|,
literal|0
block|}
block|,
block|{
literal|"syslog"
block|,
operator|&
name|cfg_type_optional_facility
block|,
literal|0
block|}
block|,
block|{
literal|"null"
block|,
operator|&
name|cfg_type_void
block|,
literal|0
block|}
block|,
block|{
literal|"stderr"
block|,
operator|&
name|cfg_type_void
block|,
literal|0
block|}
block|,
comment|/* Options.  We now accept these for the null channel, too. */
block|{
literal|"severity"
block|,
operator|&
name|cfg_type_logseverity
block|,
literal|0
block|}
block|,
block|{
literal|"print-time"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"print-severity"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
literal|"print-category"
block|,
operator|&
name|cfg_type_boolean
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|channel_clausesets
index|[]
init|=
block|{
name|channel_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_channel
init|=
block|{
literal|"channel"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|channel_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of log destination, used in the "category" clause. */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_destinationlist
init|=
block|{
literal|"destinationlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clauses that can be found in a 'logging' statement.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|logging_clauses
index|[]
init|=
block|{
block|{
literal|"channel"
block|,
operator|&
name|cfg_type_channel
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"category"
block|,
operator|&
name|cfg_type_category
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|logging_clausesets
index|[]
init|=
block|{
name|logging_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logging
init|=
block|{
literal|"logging"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|logging_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_unitstring
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|isc_resourcevalue_t
modifier|*
name|valuep
parameter_list|)
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|isc_uint64_t
name|value
decl_stmt|;
name|isc_uint64_t
name|unit
decl_stmt|;
name|value
operator|=
name|isc_string_touint64
argument_list|(
name|str
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|||
name|endp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
switch|switch
condition|(
name|str
index|[
name|len
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|unit
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|unit
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|unit
operator|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|value
operator|>
name|ISC_UINT64_MAX
operator|/
name|unit
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
operator|*
name|valuep
operator|=
name|value
operator|*
name|unit
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_sizeval
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_uint64_t
name|val
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|result
operator|=
name|ISC_R_UNEXPECTEDTOKEN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|CHECK
argument_list|(
name|parse_unitstring
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint64
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|uint64
operator|=
name|val
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected integer and optional unit"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A size value (number + optional unit).  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizeval
init|=
block|{
literal|"sizeval"
block|,
name|parse_sizeval
block|,
name|cfg_print_uint64
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_uint64
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A size, "unlimited", or "default".  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_size
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_sizeval
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|size_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
literal|"default"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_size
init|=
block|{
literal|"size"
block|,
name|parse_size
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|size_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A size or "unlimited", but not "default".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sizenodefault_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sizenodefault
init|=
block|{
literal|"size_no_default"
block|,
name|parse_size
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|sizenodefault_enums
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * optional_keyvalue  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_maybe_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|isc_boolean_t
name|optional
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|kw
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|kw
operator|->
name|type
operator|->
name|parse
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* XXX kludge */
block|}
else|else
block|{
if|if
condition|(
name|optional
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected '%s'"
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTEDTOKEN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_enum_or_other
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|enumtype
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|othertype
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|cfg_is_enum
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
name|enumtype
operator|->
name|of
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_enum
argument_list|(
name|pctx
argument_list|,
name|enumtype
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|othertype
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_enum_or_other
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|cfg_doc_terminal
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|cfg_print_chars(pctx, "( ", 2);...
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_maybe_optional_keyvalue
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ISC_FALSE
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_optional_keyvalue
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_maybe_optional_keyvalue
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
name|ISC_TRUE
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|obj
operator|->
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kw
operator|->
name|type
operator|->
name|print
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doc_optional_keyvalue
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|keyword_type_t
modifier|*
name|kw
init|=
name|type
operator|->
name|of
decl_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"[ "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_doc_obj
argument_list|(
name|pctx
argument_list|,
name|kw
operator|->
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" ]"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dialup_enums
index|[]
init|=
block|{
literal|"notify"
block|,
literal|"notify-passive"
block|,
literal|"refresh"
block|,
literal|"passive"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_dialup_type
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_dialuptype
init|=
block|{
literal|"dialuptype"
block|,
name|parse_dialup_type
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|dialup_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|notify_enums
index|[]
init|=
block|{
literal|"explicit"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_notify_type
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_boolean
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_notifytype
init|=
block|{
literal|"notifytype"
block|,
name|parse_notify_type
block|,
name|cfg_print_ustring
block|,
name|doc_enum_or_other
block|,
operator|&
name|cfg_rep_string
block|,
name|notify_enums
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|key_kw
init|=
block|{
literal|"key"
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_keyref
init|=
block|{
literal|"keyref"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|key_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_keyref
init|=
block|{
literal|"optional_keyref"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_string
block|,
operator|&
name|key_kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A "controls" statement is represented as a map with the multivalued  * "inet" and "unix" clauses.  Inet controls are tuples; unix controls  * are cfg_unsupported_t objects.  */
end_comment

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_allow_kw
init|=
block|{
literal|"allow"
block|,
operator|&
name|cfg_type_bracketed_aml
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_allow
init|=
block|{
literal|"controls_allow"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|controls_allow_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keyword_type_t
name|controls_keys_kw
init|=
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_keylist
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_keys
init|=
block|{
literal|"controls_keys"
block|,
name|parse_optional_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_optional_keyvalue
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|controls_keys_kw
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|inetcontrol_fields
index|[]
init|=
block|{
block|{
literal|"address"
block|,
operator|&
name|cfg_type_controls_sockaddr
block|,
literal|0
block|}
block|,
block|{
literal|"allow"
block|,
operator|&
name|cfg_type_controls_allow
block|,
literal|0
block|}
block|,
block|{
literal|"keys"
block|,
operator|&
name|cfg_type_controls_keys
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_inetcontrol
init|=
block|{
literal|"inetcontrol"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|inetcontrol_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|controls_clauses
index|[]
init|=
block|{
block|{
literal|"inet"
block|,
operator|&
name|cfg_type_inetcontrol
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"unix"
block|,
operator|&
name|cfg_type_unsupported
block|,
name|CFG_CLAUSEFLAG_MULTI
operator||
name|CFG_CLAUSEFLAG_NOTIMP
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|controls_clausesets
index|[]
init|=
block|{
name|controls_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls
init|=
block|{
literal|"controls"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
operator|&
name|controls_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An optional class, as used in view and zone statements.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_optional_class
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_ustring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_class
init|=
block|{
literal|"optional_class"
block|,
name|parse_optional_class
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_querysource
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
name|int
name|flags
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|unsigned
name|int
name|have_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|have_port
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V4OK
operator|)
operator|!=
literal|0
condition|)
name|isc_netaddr_any
argument_list|(
operator|&
name|netaddr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CFG_ADDR_V6OK
operator|)
operator|!=
literal|0
condition|)
name|isc_netaddr_any6
argument_list|(
operator|&
name|netaddr
argument_list|)
expr_stmt|;
else|else
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_querysource
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"address"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* read "address" */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawaddr
argument_list|(
name|pctx
argument_list|,
name|flags
operator||
name|CFG_ADDR_WILDOK
argument_list|,
operator|&
name|netaddr
argument_list|)
argument_list|)
expr_stmt|;
name|have_address
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"port"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* read "port" */
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_rawport
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_WILDOK
argument_list|,
operator|&
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|have_port
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected 'address' or 'port'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|have_address
operator|>
literal|1
operator|||
name|have_port
operator|>
literal|1
operator|||
name|have_address
operator|+
name|have_port
operator|==
literal|0
condition|)
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|,
literal|"expected one address and/or port"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|isc_sockaddr_fromnetaddr
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|,
operator|&
name|netaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"invalid query source"
argument_list|)
expr_stmt|;
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_querysource4
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|parse_querysource
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_querysource6
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|parse_querysource
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V6OK
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_querysource
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|isc_netaddr_t
name|na
decl_stmt|;
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|na
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"address "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cfg_print_rawaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|na
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" port "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cfg_print_rawuint
argument_list|(
name|pctx
argument_list|,
name|isc_sockaddr_getport
argument_list|(
operator|&
name|obj
operator|->
name|value
operator|.
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource4
init|=
block|{
literal|"querysource4"
block|,
name|parse_querysource4
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource6
init|=
block|{
literal|"querysource6"
block|,
name|parse_querysource6
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_querysource
init|=
block|{
literal|"querysource"
block|,
name|NULL
block|,
name|print_querysource
block|,
name|NULL
block|,
operator|&
name|cfg_rep_sockaddr
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* addrmatchelt */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_addrmatchelt
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"key"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_keyref
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V4PREFIXOK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_netprefix
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_astring
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
condition|)
block|{
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
block|{
comment|/* Nested match list. */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_bracketed_aml
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'!'
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "!" */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_negated
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|bad
label|:
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP match list element"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A negated address match list element (like "! 10.0.0.1").  * Somewhat sneakily, the caller is expected to parse the  * "!", but not to print it.  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|negated_fields
index|[]
init|=
block|{
block|{
literal|"value"
block|,
operator|&
name|cfg_type_addrmatchelt
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|print_negated
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_tuple
argument_list|(
name|pctx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_negated
init|=
block|{
literal|"negated"
block|,
name|cfg_parse_tuple
block|,
name|print_negated
block|,
name|NULL
block|,
operator|&
name|cfg_rep_tuple
block|,
operator|&
name|negated_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An address match list element */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_addrmatchelt
init|=
block|{
literal|"address_match_element"
block|,
name|parse_addrmatchelt
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A bracketed address match list */
end_comment

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_aml
init|=
block|{
literal|"bracketed_aml"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_addrmatchelt
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The socket address syntax in the "controls" statement is silly.  * It allows both socket address families, but also allows "*",  * whis is gratuitously interpreted as the IPv4 wildcard address.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|controls_sockaddr_flags
init|=
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
operator||
name|CFG_ADDR_WILDOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_controls_sockaddr
init|=
block|{
literal|"controls_sockaddr"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|controls_sockaddr_flags
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle the special kludge syntax of the "keys" clause in the "server"  * statement, which takes a single key with or without braces and semicolon.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_server_key_kludge
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|braces
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Allow opening brace. */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|'{'
condition|)
block|{
name|result
operator|=
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|braces
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|braces
condition|)
block|{
comment|/* Skip semicolon if present. */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_special
operator|&&
name|pctx
operator|->
name|token
operator|.
name|value
operator|.
name|as_char
operator|==
literal|';'
condition|)
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_special
argument_list|(
name|pctx
argument_list|,
literal|'}'
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_server_key_kludge
init|=
block|{
literal|"server_key"
block|,
name|parse_server_key_kludge
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An optional logging facility.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|parse_optional_facility
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_void
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_optional_facility
init|=
block|{
literal|"optional_facility"
block|,
name|parse_optional_facility
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A log severity.  Return as a string, except "debug N",  * which is returned as a keyword object.  */
end_comment

begin_decl_stmt
specifier|static
name|keyword_type_t
name|debug_kw
init|=
block|{
literal|"debug"
block|,
operator|&
name|cfg_type_uint32
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_debuglevel
init|=
block|{
literal|"debuglevel"
block|,
name|parse_keyvalue
block|,
name|print_keyvalue
block|,
name|doc_keyvalue
block|,
operator|&
name|cfg_rep_uint32
block|,
operator|&
name|debug_kw
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logseverity
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|&&
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"debug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read "debug" */
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|ISC_LEXOPT_NUMBER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_number
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_uint32
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The debug level is optional and defaults to 1. 			 * This makes little sense, but we support it for 			 * compatibility with BIND 8. 			 */
name|CHECK
argument_list|(
name|cfg_create_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ret
operator|)
operator|->
name|value
operator|.
name|uint32
operator|=
literal|1
expr_stmt|;
block|}
operator|(
operator|*
name|ret
operator|)
operator|->
name|type
operator|=
operator|&
name|cfg_type_debuglevel
expr_stmt|;
comment|/* XXX kludge */
block|}
else|else
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_loglevel
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logseverity
init|=
block|{
literal|"log_severity"
block|,
name|parse_logseverity
block|,
name|NULL
block|,
name|cfg_doc_terminal
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The "file" clause of the "channel" statement.  * This is yet another special case.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logversions_enums
index|[]
init|=
block|{
literal|"unlimited"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logversions
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|parse_enum_or_other
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|cfg_type_uint32
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logversions
init|=
block|{
literal|"logversions"
block|,
name|parse_logversions
block|,
name|cfg_print_ustring
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_string
block|,
name|logversions_enums
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|logfile_fields
index|[]
init|=
block|{
block|{
literal|"file"
block|,
operator|&
name|cfg_type_qstring
block|,
literal|0
block|}
block|,
block|{
literal|"versions"
block|,
operator|&
name|cfg_type_logversions
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
operator|&
name|cfg_type_size
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|parse_logfile
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|type
operator|->
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
name|type
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse the mandatory "file" field */
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse "versions" and "size" fields in any order. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_gettoken
argument_list|(
name|pctx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"versions"
argument_list|)
operator|==
literal|0
operator|&&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|TOKEN_STRING
argument_list|(
name|pctx
argument_list|)
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
operator|&&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|2
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* Create void objects for missing optional values. */
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
name|CHECK
argument_list|(
name|cfg_parse_void
argument_list|(
name|pctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_logfile
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|)
block|{
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* file */
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
condition|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" versions "
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
operator|->
name|type
operator|->
name|print
operator|!=
name|cfg_print_void
condition|)
block|{
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" size "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cfg_print_obj
argument_list|(
name|pctx
argument_list|,
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_logfile
init|=
block|{
literal|"log_file"
block|,
name|parse_logfile
block|,
name|print_logfile
block|,
name|cfg_doc_terminal
block|,
operator|&
name|cfg_rep_tuple
block|,
name|logfile_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An IPv4/IPv6 address with optional port, "*" accepted as wildcard. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sockaddr4wild_flags
init|=
name|CFG_ADDR_WILDOK
operator||
name|CFG_ADDR_V4OK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr4wild
init|=
block|{
literal|"sockaddr4wild"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|sockaddr4wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|sockaddr6wild_flags
init|=
name|CFG_ADDR_WILDOK
operator||
name|CFG_ADDR_V6OK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddr6wild
init|=
block|{
literal|"v6addrportwild"
block|,
name|cfg_parse_sockaddr
block|,
name|cfg_print_sockaddr
block|,
name|cfg_doc_sockaddr
block|,
operator|&
name|cfg_rep_sockaddr
block|,
operator|&
name|sockaddr6wild_flags
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * lwres  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|lwres_view_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"class"
block|,
operator|&
name|cfg_type_optional_class
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres_view
init|=
block|{
literal|"lwres_view"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|lwres_view_fields
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres_searchlist
init|=
block|{
literal|"lwres_searchlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_astring
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|lwres_clauses
index|[]
init|=
block|{
block|{
literal|"listen-on"
block|,
operator|&
name|cfg_type_portiplist
block|,
literal|0
block|}
block|,
block|{
literal|"view"
block|,
operator|&
name|cfg_type_lwres_view
block|,
literal|0
block|}
block|,
block|{
literal|"search"
block|,
operator|&
name|cfg_type_lwres_searchlist
block|,
literal|0
block|}
block|,
block|{
literal|"ndots"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|lwres_clausesets
index|[]
init|=
block|{
name|lwres_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_lwres
init|=
block|{
literal|"lwres"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|lwres_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * rndc  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_options_clauses
index|[]
init|=
block|{
block|{
literal|"default-server"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"default-key"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"default-port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_options_clausesets
index|[]
init|=
block|{
name|rndcconf_options_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rndcconf_options
init|=
block|{
literal|"rndcconf_options"
block|,
name|cfg_parse_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_options_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_server_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_uint32
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_server_clausesets
index|[]
init|=
block|{
name|rndcconf_server_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_rndcconf_server
init|=
block|{
literal|"rndcconf_server"
block|,
name|cfg_parse_named_map
block|,
name|cfg_print_map
block|,
name|cfg_doc_map
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_server_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndcconf_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"server"
block|,
operator|&
name|cfg_type_rndcconf_server
block|,
name|CFG_CLAUSEFLAG_MULTI
block|}
block|,
block|{
literal|"options"
block|,
operator|&
name|cfg_type_rndcconf_options
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndcconf_clausesets
index|[]
init|=
block|{
name|rndcconf_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_rndcconf
init|=
block|{
literal|"rndcconf"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|rndcconf_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
name|rndckey_clauses
index|[]
init|=
block|{
block|{
literal|"key"
block|,
operator|&
name|cfg_type_key
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_clausedef_t
modifier|*
name|rndckey_clausesets
index|[]
init|=
block|{
name|rndckey_clauses
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBISCCFG_EXTERNAL_DATA
name|cfg_type_t
name|cfg_type_rndckey
init|=
block|{
literal|"rndckey"
block|,
name|cfg_parse_mapbody
block|,
name|cfg_print_mapbody
block|,
name|cfg_doc_mapbody
block|,
operator|&
name|cfg_rep_map
block|,
name|rndckey_clausesets
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|nameport_fields
index|[]
init|=
block|{
block|{
literal|"name"
block|,
operator|&
name|cfg_type_astring
block|,
literal|0
block|}
block|,
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameport
init|=
block|{
literal|"nameport"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|nameport_fields
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|doc_sockaddrnameport
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<quoted_string>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[port<integer>]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv4_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[port<integer>]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv6_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[port<integer>]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" )"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_sockaddrnameport
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
name|CHECK
argument_list|(
name|cfg_parse_sockaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_sockaddr
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|cfg_tuplefielddef_t
modifier|*
name|fields
init|=
name|cfg_type_nameport
operator|.
name|of
decl_stmt|;
name|CHECK
argument_list|(
name|cfg_create_tuple
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_nameport
argument_list|,
operator|&
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|0
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_parse_obj
argument_list|(
name|pctx
argument_list|,
name|fields
index|[
literal|1
index|]
operator|.
name|type
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|tuple
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|obj
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP address or hostname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_sockaddrnameport
init|=
block|{
literal|"sockaddrnameport_element"
block|,
name|parse_sockaddrnameport
block|,
name|NULL
block|,
name|doc_sockaddrnameport
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_bracketed_sockaddrnameportlist
init|=
block|{
literal|"bracketed_sockaddrnameportlist"
block|,
name|cfg_parse_bracketed_list
block|,
name|cfg_print_bracketed_list
block|,
name|cfg_doc_bracketed_list
block|,
operator|&
name|cfg_rep_list
block|,
operator|&
name|cfg_type_sockaddrnameport
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A list of socket addresses or name with an optional default port,  * as used in the dual-stack-servers option.  E.g.,  * "port 1234 { dual-stack-servers.net; 10.0.0.1; 1::2 port 69; }"  */
end_comment

begin_decl_stmt
specifier|static
name|cfg_tuplefielddef_t
name|nameportiplist_fields
index|[]
init|=
block|{
block|{
literal|"port"
block|,
operator|&
name|cfg_type_optional_port
block|,
literal|0
block|}
block|,
block|{
literal|"addresses"
block|,
operator|&
name|cfg_type_bracketed_sockaddrnameportlist
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_nameportiplist
init|=
block|{
literal|"nameportiplist"
block|,
name|cfg_parse_tuple
block|,
name|cfg_print_tuple
block|,
name|cfg_doc_tuple
block|,
operator|&
name|cfg_rep_tuple
block|,
name|nameportiplist_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * masters element.  */
end_comment

begin_function
specifier|static
name|void
name|doc_masterselement
parameter_list|(
name|cfg_printer_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|"( "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<masters>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv4_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[port<integer>]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" | "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"<ipv6_address>"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfg_print_cstr
argument_list|(
name|pctx
argument_list|,
literal|"[port<integer>]"
argument_list|)
expr_stmt|;
name|cfg_print_chars
argument_list|(
name|pctx
argument_list|,
literal|" )"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|parse_masterselement
parameter_list|(
name|cfg_parser_t
modifier|*
name|pctx
parameter_list|,
specifier|const
name|cfg_type_t
modifier|*
name|type
parameter_list|,
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|cfg_peektoken
argument_list|(
name|pctx
argument_list|,
name|CFG_LEXOPT_QSTRING
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|pctx
operator|->
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
if|if
condition|(
name|cfg_lookingat_netaddr
argument_list|(
name|pctx
argument_list|,
name|CFG_ADDR_V4OK
operator||
name|CFG_ADDR_V6OK
argument_list|)
condition|)
name|CHECK
argument_list|(
name|cfg_parse_sockaddr
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_sockaddr
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|cfg_parse_astring
argument_list|(
name|pctx
argument_list|,
operator|&
name|cfg_type_astring
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_parser_error
argument_list|(
name|pctx
argument_list|,
name|CFG_LOG_NEAR
argument_list|,
literal|"expected IP address or masters name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDTOKEN
operator|)
return|;
block|}
name|cleanup
label|:
name|CLEANUP_OBJ
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cfg_type_t
name|cfg_type_masterselement
init|=
block|{
literal|"masters_element"
block|,
name|parse_masterselement
block|,
name|NULL
block|,
name|doc_masterselement
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

