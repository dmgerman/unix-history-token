begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007, 2009  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2001  Internet Software Consortium.  *  * This code is derived from software contributed to ISC by  * Berkeley Software Design, Inc.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC AND BERKELEY SOFTWARE DESIGN, INC.  * DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE  * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR  * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: getaddrinfo.c,v 1.52.254.2 2009-03-31 23:47:16 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_comment
comment|/**  *    lwres_getaddrinfo() is used to get a list of IP addresses and port  *    numbers for host hostname and service servname. The function is the  *    lightweight resolver's implementation of getaddrinfo() as defined in  *    RFC2133. hostname and servname are pointers to null-terminated strings  *    or NULL. hostname is either a host name or a numeric host address  *    string: a dotted decimal IPv4 address or an IPv6 address. servname is  *    either a decimal port number or a service name as listed in  *    /etc/services.  *  *    If the operating system does not provide a struct addrinfo, the  *    following structure is used:  *  * \code  * struct  addrinfo {  *         int             ai_flags;       // AI_PASSIVE, AI_CANONNAME  *         int             ai_family;      // PF_xxx  *         int             ai_socktype;    // SOCK_xxx  *         int             ai_protocol;    // 0 or IPPROTO_xxx for IPv4 and IPv6  *         size_t          ai_addrlen;     // length of ai_addr  *         char            *ai_canonname;  // canonical name for hostname  *         struct sockaddr *ai_addr;       // binary address  *         struct addrinfo *ai_next;       // next structure in linked list  * };  * \endcode  *  *  *    hints is an optional pointer to a struct addrinfo. This structure can  *    be used to provide hints concerning the type of socket that the caller  *    supports or wishes to use. The caller can supply the following  *    structure elements in *hints:  *  *<ul>  *<li>ai_family:  *           The protocol family that should be used. When ai_family is set  *           to PF_UNSPEC, it means the caller will accept any protocol  *           family supported by the operating system.</li>  *  *<li>ai_socktype:  *           denotes the type of socket -- SOCK_STREAM, SOCK_DGRAM or  *           SOCK_RAW -- that is wanted. When ai_socktype is zero the caller  *           will accept any socket type.</li>  *  *<li>ai_protocol:  *           indicates which transport protocol is wanted: IPPROTO_UDP or  *           IPPROTO_TCP. If ai_protocol is zero the caller will accept any  *           protocol.</li>  *  *<li>ai_flags:  *           Flag bits. If the AI_CANONNAME bit is set, a successful call to  *           lwres_getaddrinfo() will return a null-terminated string  *           containing the canonical name of the specified hostname in  *           ai_canonname of the first addrinfo structure returned. Setting  *           the AI_PASSIVE bit indicates that the returned socket address  *           structure is intended for used in a call to bind(2). In this  *           case, if the hostname argument is a NULL pointer, then the IP  *           address portion of the socket address structure will be set to  *           INADDR_ANY for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6  *           address.<br /><br />  *  *           When ai_flags does not set the AI_PASSIVE bit, the returned  *           socket address structure will be ready for use in a call to  *           connect(2) for a connection-oriented protocol or connect(2),  *           sendto(2), or sendmsg(2) if a connectionless protocol was  *           chosen. The IP address portion of the socket address structure  *           will be set to the loopback address if hostname is a NULL  *           pointer and AI_PASSIVE is not set in ai_flags.<br /><br />  *  *           If ai_flags is set to AI_NUMERICHOST it indicates that hostname  *           should be treated as a numeric string defining an IPv4 or IPv6  *           address and no name resolution should be attempted.  *</li></ul>  *  *    All other elements of the struct addrinfo passed via hints must be  *    zero.  *  *    A hints of NULL is treated as if the caller provided a struct addrinfo  *    initialized to zero with ai_familyset to PF_UNSPEC.  *  *    After a successful call to lwres_getaddrinfo(), *res is a pointer to a  *    linked list of one or more addrinfo structures. Each struct addrinfo  *    in this list cn be processed by following the ai_next pointer, until a  *    NULL pointer is encountered. The three members ai_family, ai_socktype,  *    and ai_protocol in each returned addrinfo structure contain the  *    corresponding arguments for a call to socket(2). For each addrinfo  *    structure in the list, the ai_addr member points to a filled-in socket  *    address structure of length ai_addrlen.  *  *    All of the information returned by lwres_getaddrinfo() is dynamically  *    allocated: the addrinfo structures, and the socket address structures  *    and canonical host name strings pointed to by the addrinfostructures.  *    Memory allocated for the dynamically allocated structures created by a  *    successful call to lwres_getaddrinfo() is released by  *    lwres_freeaddrinfo(). ai is a pointer to a struct addrinfo created by  *    a call to lwres_getaddrinfo().  *  * \section lwresreturn RETURN VALUES  *  *    lwres_getaddrinfo() returns zero on success or one of the error codes  *    listed in gai_strerror() if an error occurs. If both hostname and  *    servname are NULL lwres_getaddrinfo() returns #EAI_NONAME.  *  * \section lwressee SEE ALSO  *  *    lwres(3), lwres_getaddrinfo(), lwres_freeaddrinfo(),  *    lwres_gai_strerror(), RFC2133, getservbyname(3), connect(2),  *    sendto(2), sendmsg(2), socket(2).  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<lwres/lwres.h>
end_include

begin_include
include|#
directive|include
file|<lwres/net.h>
end_include

begin_include
include|#
directive|include
file|<lwres/netdb.h>
end_include

begin_include
include|#
directive|include
file|<lwres/stdlib.h>
end_include

begin_define
define|#
directive|define
name|SA
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr *)(addr))
end_define

begin_define
define|#
directive|define
name|SIN
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_in *)(addr))
end_define

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_in6 *)(addr))
end_define

begin_define
define|#
directive|define
name|SLOCAL
parameter_list|(
name|addr
parameter_list|)
value|((struct sockaddr_un *)(addr))
end_define

begin_comment
comment|/*! \struct addrinfo  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_reverse
argument_list|(
expr|struct
name|addrinfo
operator|*
name|oai
argument_list|)
decl_stmt|,
modifier|*
name|ai_clone
argument_list|(
expr|struct
name|addrinfo
operator|*
name|oai
argument_list|,
name|int
name|family
argument_list|)
decl_stmt|,
modifier|*
name|ai_alloc
argument_list|(
name|int
name|family
argument_list|,
name|int
name|addrlen
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AF_LOCAL
end_ifdef

begin_function_decl
specifier|static
name|int
name|get_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|socktype
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|add_ipv4
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_order
parameter_list|(
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FOUND_IPV4
value|0x1
end_define

begin_define
define|#
directive|define
name|FOUND_IPV6
value|0x2
end_define

begin_define
define|#
directive|define
name|FOUND_MAX
value|2
end_define

begin_define
define|#
directive|define
name|ISC_AI_MASK
value|(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST)
end_define

begin_comment
comment|/*% Get a list of IP addresses and port numbers for host hostname and service servname. */
end_comment

begin_function
name|int
name|lwres_getaddrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|int
name|family
decl_stmt|,
name|socktype
decl_stmt|,
name|flags
decl_stmt|,
name|protocol
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|,
modifier|*
name|ai_list
decl_stmt|;
name|int
name|port
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|net_order
index|[
name|FOUND_MAX
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|proto
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hints
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
operator|(
name|ISC_AI_MASK
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EAI_BADFLAGS
operator|)
return|;
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|EAI_SYSTEM
operator|)
return|;
block|}
name|family
operator|=
name|hints
operator|->
name|ai_family
expr_stmt|;
name|socktype
operator|=
name|hints
operator|->
name|ai_socktype
expr_stmt|;
name|protocol
operator|=
name|hints
operator|->
name|ai_protocol
expr_stmt|;
name|flags
operator|=
name|hints
operator|->
name|ai_flags
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_RAW
case|:
break|break;
default|default:
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|AF_LOCAL
case|case
name|AF_LOCAL
case|:
switch|switch
condition|(
name|hints
operator|->
name|ai_socktype
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
name|SOCK_STREAM
case|:
break|break;
case|case
name|SOCK_DGRAM
case|:
break|break;
default|default:
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EAI_FAMILY
operator|)
return|;
block|}
block|}
else|else
block|{
name|protocol
operator|=
literal|0
expr_stmt|;
name|family
operator|=
literal|0
expr_stmt|;
name|socktype
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AF_LOCAL
comment|/*! 	 * First, deal with AF_LOCAL.  If the family was not set, 	 * then assume AF_LOCAL if the first character of the 	 * hostname/servname is '/'. 	 */
if|if
condition|(
name|hostname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
name|AF_LOCAL
operator|||
operator|(
name|family
operator|==
literal|0
operator|&&
operator|*
name|hostname
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
operator|(
name|get_local
argument_list|(
name|hostname
argument_list|,
name|socktype
argument_list|,
name|res
argument_list|)
operator|)
return|;
if|if
condition|(
name|servname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
name|AF_LOCAL
operator|||
operator|(
name|family
operator|==
literal|0
operator|&&
operator|*
name|servname
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
operator|(
name|get_local
argument_list|(
name|servname
argument_list|,
name|socktype
argument_list|,
name|res
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Ok, only AF_INET and AF_INET6 left. 	 */
name|ai_list
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * First, look up the service name (port) if it was 	 * requested.  If the socket type wasn't specified, then 	 * try and figure it out. 	 */
if|if
condition|(
name|servname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|port
operator|=
name|strtol
argument_list|(
name|servname
argument_list|,
operator|&
name|e
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
operator|(
name|EAI_SERVICE
operator|)
return|;
name|port
operator|=
name|htons
argument_list|(
operator|(
name|unsigned
name|short
operator|)
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_SERVICE
operator|)
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|s_proto
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
name|socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|s_proto
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
name|socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
block|}
block|}
block|}
else|else
name|port
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Next, deal with just a service name, and no hostname. 	 * (we verified that one of them was non-null up above). 	 */
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|AI_PASSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|family
operator|==
name|AF_INET
operator|||
name|family
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_INET
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|protocol
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|ai_list
expr_stmt|;
name|ai_list
operator|=
name|ai
expr_stmt|;
block|}
if|if
condition|(
name|family
operator|==
name|AF_INET6
operator|||
name|family
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_INET6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|protocol
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|ai_list
expr_stmt|;
name|ai_list
operator|=
name|ai
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ai_list
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the family isn't specified or AI_NUMERICHOST specified, 	 * check first to see if it is a numeric address. 	 * Though the gethostbyname2() routine 	 * will recognize numeric addresses, it will only recognize 	 * the format that it is being called for.  Thus, a numeric 	 * AF_INET address will be treated by the AF_INET6 call as 	 * a domain name, and vice versa.  Checking for both numerics 	 * here avoids that. 	 */
if|if
condition|(
name|hostname
operator|!=
name|NULL
operator|&&
operator|(
name|family
operator|==
literal|0
operator|||
operator|(
name|flags
operator|&
name|AI_NUMERICHOST
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|abuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|int
name|addrsize
decl_stmt|,
name|addroff
decl_stmt|;
ifdef|#
directive|ifdef
name|LWRES_HAVE_SIN6_SCOPE_ID
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|ntmp
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|lwres_uint32_t
name|scopeid
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LWRES_HAVE_SIN6_SCOPE_ID
comment|/* 		 * Scope identifier portion. 		 */
name|ntmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'%'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|ntmp
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|ntmp
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ntmp
index|[
sizeof|sizeof
argument_list|(
name|ntmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|ntmp
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
name|ep
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Vendors may want to support non-numeric 			 * scopeid around here. 			 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|scopeid
operator|=
operator|(
name|lwres_uint32_t
operator|)
name|strtoul
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|ep
operator|!=
name|NULL
operator|&&
name|ep
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|ntmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scopeid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|scopeid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lwres_net_pton
argument_list|(
name|AF_INET
argument_list|,
name|hostname
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* 				 * Convert to a V4 mapped address. 				 */
name|struct
name|in6_addr
modifier|*
name|a6
init|=
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|abuf
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|12
index|]
argument_list|,
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|10
index|]
argument_list|,
literal|0xff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|a6
operator|->
name|s6_addr
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|inet6_addr
goto|;
block|}
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN
argument_list|(
literal|0
argument_list|)
operator|->
name|sin_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET
expr_stmt|;
goto|goto
name|common
goto|;
ifdef|#
directive|ifdef
name|LWRES_HAVE_SIN6_SCOPE_ID
block|}
elseif|else
if|if
condition|(
name|ntmp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|lwres_net_pton
argument_list|(
name|AF_INET6
argument_list|,
name|ntmp
argument_list|,
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN6
argument_list|(
literal|0
argument_list|)
operator|->
name|sin6_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET6
expr_stmt|;
goto|goto
name|common
goto|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|lwres_net_pton
argument_list|(
name|AF_INET6
argument_list|,
name|hostname
argument_list|,
name|abuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|family
operator|!=
literal|0
operator|&&
name|family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
name|inet6_addr
label|:
name|addrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addroff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|SIN6
argument_list|(
literal|0
argument_list|)
operator|->
name|sin6_addr
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|common
label|:
name|ai
operator|=
name|ai_clone
argument_list|(
name|ai_list
argument_list|,
name|family
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|ai_list
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|+
name|addroff
argument_list|,
name|abuf
argument_list|,
name|addrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AI_CANONNAME
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|LWRES_HAVE_SIN6_SCOPE_ID
argument_list|)
if|if
condition|(
name|ai
operator|->
name|ai_family
operator|==
name|AF_INET6
condition|)
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lwres_getnameinfo
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|ai
operator|->
name|ai_addrlen
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* XXX raise error? */
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|AI_NUMERICHOST
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
block|}
block|}
name|set_order
argument_list|(
name|family
argument_list|,
name|net_order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOUND_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|net_order
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|err
operator|=
operator|(
name|net_order
index|[
name|i
index|]
operator|)
operator|(
name|hostname
operator|,
name|flags
operator|,
operator|&
name|ai_list
operator|,
name|socktype
operator|,
name|port
operator|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|ai_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_NODATA
operator|)
return|;
name|done
label|:
name|ai_list
operator|=
name|ai_reverse
argument_list|(
name|ai_list
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|ai_list
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|lwres_strsep
parameter_list|(
name|char
modifier|*
modifier|*
name|stringp
parameter_list|,
specifier|const
name|char
modifier|*
name|delim
parameter_list|)
block|{
name|char
modifier|*
name|string
init|=
operator|*
name|stringp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|char
name|sc
decl_stmt|,
name|dc
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|string
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|sc
operator|=
operator|*
name|s
expr_stmt|;
for|for
control|(
name|d
operator|=
name|delim
init|;
operator|(
name|dc
operator|=
operator|*
name|d
operator|)
operator|!=
literal|'\0'
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|sc
operator|==
name|dc
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|stringp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
block|}
operator|*
name|stringp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_order
parameter_list|(
name|int
name|family
parameter_list|,
name|int
function_decl|(
modifier|*
modifier|*
name|net_order
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|char
modifier|*
name|order
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
name|family
condition|)
block|{
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|order
operator|=
name|getenv
argument_list|(
literal|"NET_ORDER"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|order
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We ignore any unknown names. 			 */
name|tok
operator|=
name|lwres_strsep
argument_list|(
operator|&
name|order
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet6"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV6
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
name|found
operator||=
name|FOUND_IPV6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|tok
argument_list|,
literal|"inet4"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV4
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
name|found
operator||=
name|FOUND_IPV4
expr_stmt|;
block|}
block|}
comment|/* 		 * Add in anything that we didn't find. 		 */
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV4
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv4
expr_stmt|;
if|if
condition|(
operator|(
name|found
operator|&
name|FOUND_IPV6
operator|)
operator|==
literal|0
condition|)
operator|*
name|net_order
operator|++
operator|=
name|add_ipv6
expr_stmt|;
block|}
operator|*
name|net_order
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|v4_loop
index|[
literal|4
index|]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The test against 0 is there to keep the Solaris compiler  * from complaining about "end-of-loop code not reached".  */
end_comment

begin_define
define|#
directive|define
name|SETERROR
parameter_list|(
name|code
parameter_list|)
define|\
value|do { result = (code);			\ 		if (result != 0) goto cleanup;	\ 	} while (0)
end_define

begin_function
specifier|static
name|int
name|add_ipv4
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|lwres_context_t
modifier|*
name|lwrctx
init|=
name|NULL
decl_stmt|;
name|lwres_gabnresponse_t
modifier|*
name|by
init|=
name|NULL
decl_stmt|;
name|lwres_addr_t
modifier|*
name|addr
decl_stmt|;
name|lwres_result_t
name|lwres
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|lwres
operator|=
name|lwres_context_create
argument_list|(
operator|&
name|lwrctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwres
operator|!=
name|LWRES_R_SUCCESS
condition|)
name|SETERROR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lwres_conf_parse
argument_list|(
name|lwrctx
argument_list|,
name|lwres_resolv_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|AI_PASSIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|v4_loop
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lwres
operator|=
name|lwres_getaddrsbyname
argument_list|(
name|lwrctx
argument_list|,
name|hostname
argument_list|,
name|LWRES_ADDRTYPE_V4
argument_list|,
operator|&
name|by
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwres
operator|!=
name|LWRES_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|lwres
operator|==
name|LWRES_R_NOTFOUND
condition|)
goto|goto
name|cleanup
goto|;
else|else
name|SETERROR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|LWRES_LIST_HEAD
argument_list|(
name|by
operator|->
name|addrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|addr
operator|->
name|address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AI_CANONNAME
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
name|by
operator|->
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|LWRES_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|by
operator|!=
name|NULL
condition|)
name|lwres_gabnresponse_free
argument_list|(
name|lwrctx
argument_list|,
operator|&
name|by
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwrctx
operator|!=
name|NULL
condition|)
block|{
name|lwres_conf_clear
argument_list|(
name|lwrctx
argument_list|)
expr_stmt|;
name|lwres_context_destroy
argument_list|(
operator|&
name|lwrctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|v6_loop
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_ipv6
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|aip
parameter_list|,
name|int
name|socktype
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|lwres_context_t
modifier|*
name|lwrctx
init|=
name|NULL
decl_stmt|;
name|lwres_gabnresponse_t
modifier|*
name|by
init|=
name|NULL
decl_stmt|;
name|lwres_addr_t
modifier|*
name|addr
decl_stmt|;
name|lwres_result_t
name|lwres
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|lwres
operator|=
name|lwres_context_create
argument_list|(
operator|&
name|lwrctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwres
operator|!=
name|LWRES_R_SUCCESS
condition|)
name|SETERROR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lwres_conf_parse
argument_list|(
name|lwrctx
argument_list|,
name|lwres_resolv_conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|AI_PASSIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|v6_loop
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lwres
operator|=
name|lwres_getaddrsbyname
argument_list|(
name|lwrctx
argument_list|,
name|hostname
argument_list|,
name|LWRES_ADDRTYPE_V6
argument_list|,
operator|&
name|by
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwres
operator|!=
name|LWRES_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|lwres
operator|==
name|LWRES_R_NOTFOUND
condition|)
goto|goto
name|cleanup
goto|;
else|else
name|SETERROR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|LWRES_LIST_HEAD
argument_list|(
name|by
operator|->
name|addrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|ai
operator|=
name|ai_clone
argument_list|(
operator|*
name|aip
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
operator|*
name|aip
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|ai
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|SIN6
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|addr
operator|->
name|address
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AI_CANONNAME
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
name|by
operator|->
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
name|SETERROR
argument_list|(
name|EAI_MEMORY
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|LWRES_LIST_NEXT
argument_list|(
name|addr
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|by
operator|!=
name|NULL
condition|)
name|lwres_gabnresponse_free
argument_list|(
name|lwrctx
argument_list|,
operator|&
name|by
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwrctx
operator|!=
name|NULL
condition|)
block|{
name|lwres_conf_clear
argument_list|(
name|lwrctx
argument_list|)
expr_stmt|;
name|lwres_context_destroy
argument_list|(
operator|&
name|lwrctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*% Free address info. */
end_comment

begin_function
name|void
name|lwres_freeaddrinfo
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai_next
decl_stmt|;
while|while
condition|(
name|ai
operator|!=
name|NULL
condition|)
block|{
name|ai_next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|ai_next
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AF_LOCAL
end_ifdef

begin_function
specifier|static
name|int
name|get_local
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|socktype
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|slocal
decl_stmt|;
if|if
condition|(
name|socktype
operator|==
literal|0
condition|)
return|return
operator|(
name|EAI_SOCKTYPE
operator|)
return|;
name|ai
operator|=
name|ai_alloc
argument_list|(
name|AF_LOCAL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|slocal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAI_MEMORY
operator|)
return|;
name|slocal
operator|=
name|SLOCAL
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|slocal
operator|->
name|sun_path
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|slocal
operator|->
name|sun_path
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
comment|/* 	 * ai->ai_flags, ai->ai_protocol, ai->ai_canonname, 	 * and ai->ai_next were initialized to zero. 	 */
operator|*
name|res
operator|=
name|ai
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!  * Allocate an addrinfo structure, and a sockaddr structure  * of the specificed length.  We initialize:  *	ai_addrlen  *	ai_family  *	ai_addr  *	ai_addr->sa_family  *	ai_addr->sa_len	(LWRES_PLATFORM_HAVESALEN)  * and everything else is initialized to zero.  */
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_alloc
parameter_list|(
name|int
name|family
parameter_list|,
name|int
name|addrlen
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ai
operator|->
name|ai_addr
operator|=
name|SA
argument_list|(
name|calloc
argument_list|(
literal|1
argument_list|,
name|addrlen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_addr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ai
operator|->
name|ai_addrlen
operator|=
name|addrlen
expr_stmt|;
name|ai
operator|->
name|ai_family
operator|=
name|family
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|family
expr_stmt|;
ifdef|#
directive|ifdef
name|LWRES_PLATFORM_HAVESALEN
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|addrlen
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_clone
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|oai
parameter_list|,
name|int
name|family
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
name|ai_alloc
argument_list|(
name|family
argument_list|,
operator|(
operator|(
name|family
operator|==
name|AF_INET6
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
block|{
name|lwres_freeaddrinfo
argument_list|(
name|oai
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|oai
operator|==
name|NULL
condition|)
return|return
operator|(
name|ai
operator|)
return|;
name|ai
operator|->
name|ai_flags
operator|=
name|oai
operator|->
name|ai_flags
expr_stmt|;
name|ai
operator|->
name|ai_socktype
operator|=
name|oai
operator|->
name|ai_socktype
expr_stmt|;
name|ai
operator|->
name|ai_protocol
operator|=
name|oai
operator|->
name|ai_protocol
expr_stmt|;
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|ai
operator|->
name|ai_next
operator|=
name|oai
expr_stmt|;
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|ai_reverse
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|oai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|nai
decl_stmt|,
modifier|*
name|tai
decl_stmt|;
name|nai
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|oai
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Grab one off the old list. 		 */
name|tai
operator|=
name|oai
expr_stmt|;
name|oai
operator|=
name|oai
operator|->
name|ai_next
expr_stmt|;
comment|/* 		 * Put it on the front of the new list. 		 */
name|tai
operator|->
name|ai_next
operator|=
name|nai
expr_stmt|;
name|nai
operator|=
name|tai
expr_stmt|;
block|}
return|return
operator|(
name|nai
operator|)
return|;
block|}
end_function

end_unit

