begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2009, 2011, 2013, 2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2002  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: acl.c,v 1.55 2011/06/17 23:47:49 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/iptable.h>
end_include

begin_comment
comment|/*  * Create a new ACL, including an IP table and an array with room  * for 'n' ACL elements.  The elements are uninitialized and the  * length is 0.  */
end_comment

begin_function
name|isc_result_t
name|dns_acl_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|int
name|n
parameter_list|,
name|dns_acl_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_acl_t
modifier|*
name|acl
decl_stmt|;
comment|/* 	 * Work around silly limitation of isc_mem_get(). 	 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|acl
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|acl
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|acl
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|acl
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|acl
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|dns_iptable_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|acl
operator|->
name|iptable
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|acl
operator|->
name|elements
operator|=
name|NULL
expr_stmt|;
name|acl
operator|->
name|alloc
operator|=
literal|0
expr_stmt|;
name|acl
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|acl
operator|->
name|has_negatives
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|acl
argument_list|,
name|nextincache
argument_list|)
expr_stmt|;
comment|/* 	 * Must set magic early because we use dns_acl_detach() to clean up. 	 */
name|acl
operator|->
name|magic
operator|=
name|DNS_ACL_MAGIC
expr_stmt|;
name|acl
operator|->
name|elements
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|elements
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|acl
operator|->
name|alloc
operator|=
name|n
expr_stmt|;
name|memset
argument_list|(
name|acl
operator|->
name|elements
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|acl
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|dns_acl_detach
argument_list|(
operator|&
name|acl
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new ACL and initialize it with the value "any" or "none",  * depending on the value of the "neg" parameter.  * "any" is a positive iptable entry with bit length 0.  * "none" is the same as "!any".  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dns_acl_anyornone
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_boolean_t
name|neg
parameter_list|,
name|dns_acl_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_acl_t
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_acl_create
argument_list|(
name|mctx
argument_list|,
literal|0
argument_list|,
operator|&
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_iptable_addprefix
argument_list|(
name|acl
operator|->
name|iptable
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ISC_TF
argument_list|(
operator|!
name|neg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_acl_detach
argument_list|(
operator|&
name|acl
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|target
operator|=
name|acl
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new ACL that matches everything.  */
end_comment

begin_function
name|isc_result_t
name|dns_acl_any
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_acl_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_acl_anyornone
argument_list|(
name|mctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new ACL that matches nothing.  */
end_comment

begin_function
name|isc_result_t
name|dns_acl_none
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_acl_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_acl_anyornone
argument_list|(
name|mctx
argument_list|,
name|ISC_TRUE
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If pos is ISC_TRUE, test whether acl is set to "{ any; }"  * If pos is ISC_FALSE, test whether acl is set to "{ none; }"  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|dns_acl_isanyornone
parameter_list|(
name|dns_acl_t
modifier|*
name|acl
parameter_list|,
name|isc_boolean_t
name|pos
parameter_list|)
block|{
comment|/* Should never happen but let's be safe */
if|if
condition|(
name|acl
operator|==
name|NULL
operator|||
name|acl
operator|->
name|iptable
operator|==
name|NULL
operator|||
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|==
name|NULL
operator|||
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|==
name|NULL
operator|||
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|prefix
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|acl
operator|->
name|length
operator|!=
literal|0
operator|||
name|acl
operator|->
name|node_count
operator|!=
literal|1
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|prefix
operator|->
name|bitlen
operator|==
literal|0
operator|&&
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|data
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|data
index|[
literal|0
index|]
operator|==
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|data
index|[
literal|1
index|]
operator|&&
operator|*
operator|(
name|isc_boolean_t
operator|*
operator|)
operator|(
name|acl
operator|->
name|iptable
operator|->
name|radix
operator|->
name|head
operator|->
name|data
index|[
literal|0
index|]
operator|)
operator|==
name|pos
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* All others */
block|}
end_function

begin_comment
comment|/*  * Test whether acl is set to "{ any; }"  */
end_comment

begin_function
name|isc_boolean_t
name|dns_acl_isany
parameter_list|(
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
return|return
operator|(
name|dns_acl_isanyornone
argument_list|(
name|acl
argument_list|,
name|ISC_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether acl is set to "{ none; }"  */
end_comment

begin_function
name|isc_boolean_t
name|dns_acl_isnone
parameter_list|(
name|dns_acl_t
modifier|*
name|acl
parameter_list|)
block|{
return|return
operator|(
name|dns_acl_isanyornone
argument_list|(
name|acl
argument_list|,
name|ISC_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a given address or signer matches a given ACL.  * For a match with a positive ACL element or iptable radix entry,  * return with a positive value in match; for a match with a negated ACL  * element or radix entry, return with a negative value in match.  */
end_comment

begin_function
name|isc_result_t
name|dns_acl_match
parameter_list|(
specifier|const
name|isc_netaddr_t
modifier|*
name|reqaddr
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|reqsigner
parameter_list|,
specifier|const
name|dns_acl_t
modifier|*
name|acl
parameter_list|,
specifier|const
name|dns_aclenv_t
modifier|*
name|env
parameter_list|,
name|int
modifier|*
name|match
parameter_list|,
specifier|const
name|dns_aclelement_t
modifier|*
modifier|*
name|matchelt
parameter_list|)
block|{
name|isc_uint16_t
name|bitlen
decl_stmt|,
name|family
decl_stmt|;
name|isc_prefix_t
name|pfx
decl_stmt|;
name|isc_radix_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
specifier|const
name|isc_netaddr_t
modifier|*
name|addr
decl_stmt|;
name|isc_netaddr_t
name|v4addr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|match_num
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|reqaddr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|matchelt
operator|==
name|NULL
operator|||
operator|*
name|matchelt
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
operator|||
name|env
operator|->
name|match_mapped
operator|==
name|ISC_FALSE
operator|||
name|reqaddr
operator|->
name|family
operator|!=
name|AF_INET6
operator|||
operator|!
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|reqaddr
operator|->
name|type
operator|.
name|in6
argument_list|)
condition|)
name|addr
operator|=
name|reqaddr
expr_stmt|;
else|else
block|{
name|isc_netaddr_fromv4mapped
argument_list|(
operator|&
name|v4addr
argument_list|,
name|reqaddr
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|&
name|v4addr
expr_stmt|;
block|}
comment|/* Always match with host addresses. */
name|family
operator|=
name|addr
operator|->
name|family
expr_stmt|;
name|bitlen
operator|=
name|family
operator|==
name|AF_INET6
condition|?
literal|128
else|:
literal|32
expr_stmt|;
name|NETADDR_TO_PREFIX_T
argument_list|(
name|addr
argument_list|,
name|pfx
argument_list|,
name|bitlen
argument_list|)
expr_stmt|;
comment|/* Assume no match. */
operator|*
name|match
operator|=
literal|0
expr_stmt|;
comment|/* Search radix. */
name|result
operator|=
name|isc_radix_search
argument_list|(
name|acl
operator|->
name|iptable
operator|->
name|radix
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|pfx
argument_list|)
expr_stmt|;
comment|/* Found a match. */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|node
operator|!=
name|NULL
condition|)
block|{
name|match_num
operator|=
name|node
operator|->
name|node_num
index|[
name|ISC_IS6
argument_list|(
name|family
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|isc_boolean_t
operator|*
operator|)
name|node
operator|->
name|data
index|[
name|ISC_IS6
argument_list|(
name|family
argument_list|)
index|]
operator|==
name|ISC_TRUE
condition|)
operator|*
name|match
operator|=
name|match_num
expr_stmt|;
else|else
operator|*
name|match
operator|=
operator|-
name|match_num
expr_stmt|;
block|}
comment|/* Now search non-radix elements for a match with a lower node_num. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dns_aclelement_t
modifier|*
name|e
init|=
operator|&
name|acl
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
comment|/* Already found a better match? */
if|if
condition|(
name|match_num
operator|!=
operator|-
literal|1
operator|&&
name|match_num
operator|<
name|e
operator|->
name|node_num
condition|)
block|{
name|isc_refcount_destroy
argument_list|(
operator|&
name|pfx
operator|.
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|dns_aclelement_match
argument_list|(
name|reqaddr
argument_list|,
name|reqsigner
argument_list|,
name|e
argument_list|,
name|env
argument_list|,
name|matchelt
argument_list|)
condition|)
block|{
if|if
condition|(
name|match_num
operator|==
operator|-
literal|1
operator|||
name|e
operator|->
name|node_num
operator|<
name|match_num
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|negative
operator|==
name|ISC_TRUE
condition|)
operator|*
name|match
operator|=
operator|-
name|e
operator|->
name|node_num
expr_stmt|;
else|else
operator|*
name|match
operator|=
name|e
operator|->
name|node_num
expr_stmt|;
block|}
name|isc_refcount_destroy
argument_list|(
operator|&
name|pfx
operator|.
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
name|isc_refcount_destroy
argument_list|(
operator|&
name|pfx
operator|.
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge the contents of one ACL into another.  Call dns_iptable_merge()  * for the IP tables, then concatenate the element arrays.  *  * If pos is set to false, then the nested ACL is to be negated.  This  * means reverse the sense of each *positive* element or IP table node,  * but leave negatives alone, so as to prevent a double-negative causing  * an unexpected positive match in the parent ACL.  */
end_comment

begin_function
name|isc_result_t
name|dns_acl_merge
parameter_list|(
name|dns_acl_t
modifier|*
name|dest
parameter_list|,
name|dns_acl_t
modifier|*
name|source
parameter_list|,
name|isc_boolean_t
name|pos
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|newalloc
decl_stmt|,
name|nelem
decl_stmt|,
name|i
decl_stmt|;
name|int
name|max_node
init|=
literal|0
decl_stmt|,
name|nodes
decl_stmt|;
comment|/* Resize the element array if needed. */
if|if
condition|(
name|dest
operator|->
name|length
operator|+
name|source
operator|->
name|length
operator|>
name|dest
operator|->
name|alloc
condition|)
block|{
name|void
modifier|*
name|newmem
decl_stmt|;
name|newalloc
operator|=
name|dest
operator|->
name|alloc
operator|+
name|source
operator|->
name|alloc
expr_stmt|;
if|if
condition|(
name|newalloc
operator|<
literal|4
condition|)
name|newalloc
operator|=
literal|4
expr_stmt|;
name|newmem
operator|=
name|isc_mem_get
argument_list|(
name|dest
operator|->
name|mctx
argument_list|,
name|newalloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* Zero. */
name|memset
argument_list|(
name|newmem
argument_list|,
literal|0
argument_list|,
name|newalloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy in the original elements */
name|memmove
argument_list|(
name|newmem
argument_list|,
name|dest
operator|->
name|elements
argument_list|,
name|dest
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Release the memory for the old elements array */
name|isc_mem_put
argument_list|(
name|dest
operator|->
name|mctx
argument_list|,
name|dest
operator|->
name|elements
argument_list|,
name|dest
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|->
name|elements
operator|=
name|newmem
expr_stmt|;
name|dest
operator|->
name|alloc
operator|=
name|newalloc
expr_stmt|;
block|}
comment|/* 	 * Now copy in the new elements, increasing their node_num 	 * values so as to keep the new ACL consistent.  If we're 	 * negating, then negate positive elements, but keep negative 	 * elements the same for security reasons. 	 */
name|nelem
operator|=
name|dest
operator|->
name|length
expr_stmt|;
name|dest
operator|->
name|length
operator|+=
name|source
operator|->
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|source
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|node_num
operator|>
name|max_node
condition|)
name|max_node
operator|=
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|node_num
expr_stmt|;
comment|/* Copy type. */
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|type
operator|=
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
comment|/* Adjust node numbering. */
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|node_num
operator|=
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|node_num
operator|+
name|dest
operator|->
name|node_count
expr_stmt|;
comment|/* Duplicate nested acl. */
if|if
condition|(
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|type
operator|==
name|dns_aclelementtype_nestedacl
operator|&&
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|nestedacl
operator|!=
name|NULL
condition|)
name|dns_acl_attach
argument_list|(
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|nestedacl
argument_list|,
operator|&
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|nestedacl
argument_list|)
expr_stmt|;
comment|/* Duplicate key name. */
if|if
condition|(
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|type
operator|==
name|dns_aclelementtype_keyname
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|keyname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|keyname
argument_list|,
name|dest
operator|->
name|mctx
argument_list|,
operator|&
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|keyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|result
return|;
block|}
comment|/* reverse sense of positives if this is a negative acl */
if|if
condition|(
operator|!
name|pos
operator|&&
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|negative
operator|==
name|ISC_FALSE
condition|)
block|{
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|negative
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|elements
index|[
name|nelem
operator|+
name|i
index|]
operator|.
name|negative
operator|=
name|source
operator|->
name|elements
index|[
name|i
index|]
operator|.
name|negative
expr_stmt|;
block|}
block|}
comment|/* 	 * Merge the iptables.  Make sure the destination ACL's 	 * node_count value is set correctly afterward. 	 */
name|nodes
operator|=
name|max_node
operator|+
name|dest
operator|->
name|node_count
expr_stmt|;
name|result
operator|=
name|dns_iptable_merge
argument_list|(
name|dest
operator|->
name|iptable
argument_list|,
name|source
operator|->
name|iptable
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|nodes
operator|>
name|dest
operator|->
name|node_count
condition|)
name|dest
operator|->
name|node_count
operator|=
name|nodes
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like dns_acl_match, but matches against the single ACL element 'e'  * rather than a complete ACL, and returns ISC_TRUE iff it matched.  *  * To determine whether the match was positive or negative, the  * caller should examine e->negative.  Since the element 'e' may be  * a reference to a named ACL or a nested ACL, a matching element  * returned through 'matchelt' is not necessarily 'e' itself.  */
end_comment

begin_function
name|isc_boolean_t
name|dns_aclelement_match
parameter_list|(
specifier|const
name|isc_netaddr_t
modifier|*
name|reqaddr
parameter_list|,
specifier|const
name|dns_name_t
modifier|*
name|reqsigner
parameter_list|,
specifier|const
name|dns_aclelement_t
modifier|*
name|e
parameter_list|,
specifier|const
name|dns_aclenv_t
modifier|*
name|env
parameter_list|,
specifier|const
name|dns_aclelement_t
modifier|*
modifier|*
name|matchelt
parameter_list|)
block|{
name|dns_acl_t
modifier|*
name|inner
init|=
name|NULL
decl_stmt|;
name|int
name|indirectmatch
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|dns_aclelementtype_keyname
case|:
if|if
condition|(
name|reqsigner
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
name|reqsigner
argument_list|,
operator|&
name|e
operator|->
name|keyname
argument_list|)
condition|)
block|{
if|if
condition|(
name|matchelt
operator|!=
name|NULL
condition|)
operator|*
name|matchelt
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
case|case
name|dns_aclelementtype_nestedacl
case|:
name|inner
operator|=
name|e
operator|->
name|nestedacl
expr_stmt|;
break|break;
case|case
name|dns_aclelementtype_localhost
case|:
if|if
condition|(
name|env
operator|==
name|NULL
operator|||
name|env
operator|->
name|localhost
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|inner
operator|=
name|env
operator|->
name|localhost
expr_stmt|;
break|break;
case|case
name|dns_aclelementtype_localnets
case|:
if|if
condition|(
name|env
operator|==
name|NULL
operator|||
name|env
operator|->
name|localnets
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|inner
operator|=
name|env
operator|->
name|localnets
expr_stmt|;
break|break;
default|default:
comment|/* Should be impossible. */
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_acl_match
argument_list|(
name|reqaddr
argument_list|,
name|reqsigner
argument_list|,
name|inner
argument_list|,
name|env
argument_list|,
operator|&
name|indirectmatch
argument_list|,
name|matchelt
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 	 * Treat negative matches in indirect ACLs as "no match". 	 * That way, a negated indirect ACL will never become a 	 * surprise positive match through double negation. 	 * XXXDCL this should be documented. 	 */
if|if
condition|(
name|indirectmatch
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|matchelt
operator|!=
name|NULL
condition|)
operator|*
name|matchelt
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
comment|/* 	 * A negative indirect match may have set *matchelt, but we don't 	 * want it set when we return. 	 */
if|if
condition|(
name|matchelt
operator|!=
name|NULL
condition|)
operator|*
name|matchelt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_acl_attach
parameter_list|(
name|dns_acl_t
modifier|*
name|source
parameter_list|,
name|dns_acl_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ACL_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|source
operator|->
name|refcount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_acl_t
modifier|*
name|dacl
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|dacl
argument_list|,
name|nextincache
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dacl
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dns_aclelement_t
modifier|*
name|de
init|=
operator|&
name|dacl
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|de
operator|->
name|type
operator|==
name|dns_aclelementtype_keyname
condition|)
block|{
name|dns_name_free
argument_list|(
operator|&
name|de
operator|->
name|keyname
argument_list|,
name|dacl
operator|->
name|mctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|de
operator|->
name|type
operator|==
name|dns_aclelementtype_nestedacl
condition|)
block|{
name|dns_acl_detach
argument_list|(
operator|&
name|de
operator|->
name|nestedacl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dacl
operator|->
name|elements
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|dacl
operator|->
name|mctx
argument_list|,
name|dacl
operator|->
name|elements
argument_list|,
name|dacl
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|dns_aclelement_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dacl
operator|->
name|name
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|dacl
operator|->
name|mctx
argument_list|,
name|dacl
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dacl
operator|->
name|iptable
operator|!=
name|NULL
condition|)
name|dns_iptable_detach
argument_list|(
operator|&
name|dacl
operator|->
name|iptable
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|dacl
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|dacl
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|dacl
operator|->
name|mctx
argument_list|,
name|dacl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dacl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_acl_detach
parameter_list|(
name|dns_acl_t
modifier|*
modifier|*
name|aclp
parameter_list|)
block|{
name|dns_acl_t
modifier|*
name|acl
init|=
operator|*
name|aclp
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACL_VALID
argument_list|(
name|acl
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|acl
operator|->
name|refcount
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
name|destroy
argument_list|(
name|acl
argument_list|)
expr_stmt|;
operator|*
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|isc_once_t
name|insecure_prefix_once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_mutex_t
name|insecure_prefix_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|insecure_prefix_found
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|initialize_action
parameter_list|(
name|void
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_mutex_init
argument_list|(
operator|&
name|insecure_prefix_lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called via isc_radix_walk() to find IP table nodes that are  * insecure.  */
end_comment

begin_function
specifier|static
name|void
name|is_insecure
parameter_list|(
name|isc_prefix_t
modifier|*
name|prefix
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|isc_boolean_t
name|secure
decl_stmt|;
name|int
name|bitlen
decl_stmt|,
name|family
decl_stmt|;
name|bitlen
operator|=
name|prefix
operator|->
name|bitlen
expr_stmt|;
name|family
operator|=
name|prefix
operator|->
name|family
expr_stmt|;
comment|/* Negated entries are always secure. */
name|secure
operator|=
operator|*
operator|(
name|isc_boolean_t
operator|*
operator|)
name|data
index|[
name|ISC_IS6
argument_list|(
name|family
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|secure
condition|)
block|{
return|return;
block|}
comment|/* If loopback prefix found, return */
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|bitlen
operator|==
literal|32
operator|&&
name|htonl
argument_list|(
name|prefix
operator|->
name|add
operator|.
name|sin
operator|.
name|s_addr
argument_list|)
operator|==
name|INADDR_LOOPBACK
condition|)
return|return;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|bitlen
operator|==
literal|128
operator|&&
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|prefix
operator|->
name|add
operator|.
name|sin6
argument_list|)
condition|)
return|return;
break|break;
default|default:
break|break;
block|}
comment|/* Non-negated, non-loopback */
name|insecure_prefix_found
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* LOCKED */
return|return;
block|}
end_function

begin_comment
comment|/*  * Return ISC_TRUE iff the acl 'a' is considered insecure, that is,  * if it contains IP addresses other than those of the local host.  * This is intended for applications such as printing warning  * messages for suspect ACLs; it is not intended for making access  * control decisions.  We make no guarantee that an ACL for which  * this function returns ISC_FALSE is safe.  */
end_comment

begin_function
name|isc_boolean_t
name|dns_acl_isinsecure
parameter_list|(
specifier|const
name|dns_acl_t
modifier|*
name|a
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|insecure
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|insecure_prefix_once
argument_list|,
name|initialize_action
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 	 * Walk radix tree to find out if there are any non-negated, 	 * non-loopback prefixes. 	 */
name|LOCK
argument_list|(
operator|&
name|insecure_prefix_lock
argument_list|)
expr_stmt|;
name|insecure_prefix_found
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_radix_process
argument_list|(
name|a
operator|->
name|iptable
operator|->
name|radix
argument_list|,
name|is_insecure
argument_list|)
expr_stmt|;
name|insecure
operator|=
name|insecure_prefix_found
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|insecure_prefix_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|insecure
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* Now check non-radix elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dns_aclelement_t
modifier|*
name|e
init|=
operator|&
name|a
operator|->
name|elements
index|[
name|i
index|]
decl_stmt|;
comment|/* A negated match can never be insecure. */
if|if
condition|(
name|e
operator|->
name|negative
condition|)
continue|continue;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|dns_aclelementtype_keyname
case|:
case|case
name|dns_aclelementtype_localhost
case|:
continue|continue;
case|case
name|dns_aclelementtype_nestedacl
case|:
if|if
condition|(
name|dns_acl_isinsecure
argument_list|(
name|e
operator|->
name|nestedacl
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
continue|continue;
case|case
name|dns_aclelementtype_localnets
case|:
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
block|}
comment|/* No insecure elements were found. */
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize ACL environment, setting up localhost and localnets ACLs  */
end_comment

begin_function
name|isc_result_t
name|dns_aclenv_init
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_aclenv_t
modifier|*
name|env
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|env
operator|->
name|localhost
operator|=
name|NULL
expr_stmt|;
name|env
operator|->
name|localnets
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_acl_create
argument_list|(
name|mctx
argument_list|,
literal|0
argument_list|,
operator|&
name|env
operator|->
name|localhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_nothing
goto|;
name|result
operator|=
name|dns_acl_create
argument_list|(
name|mctx
argument_list|,
literal|0
argument_list|,
operator|&
name|env
operator|->
name|localnets
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_localhost
goto|;
name|env
operator|->
name|match_mapped
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_localhost
label|:
name|dns_acl_detach
argument_list|(
operator|&
name|env
operator|->
name|localhost
argument_list|)
expr_stmt|;
name|cleanup_nothing
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_aclenv_copy
parameter_list|(
name|dns_aclenv_t
modifier|*
name|t
parameter_list|,
name|dns_aclenv_t
modifier|*
name|s
parameter_list|)
block|{
name|dns_acl_detach
argument_list|(
operator|&
name|t
operator|->
name|localhost
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|s
operator|->
name|localhost
argument_list|,
operator|&
name|t
operator|->
name|localhost
argument_list|)
expr_stmt|;
name|dns_acl_detach
argument_list|(
operator|&
name|t
operator|->
name|localnets
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|s
operator|->
name|localnets
argument_list|,
operator|&
name|t
operator|->
name|localnets
argument_list|)
expr_stmt|;
name|t
operator|->
name|match_mapped
operator|=
name|s
operator|->
name|match_mapped
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_aclenv_destroy
parameter_list|(
name|dns_aclenv_t
modifier|*
name|env
parameter_list|)
block|{
name|dns_acl_detach
argument_list|(
operator|&
name|env
operator|->
name|localhost
argument_list|)
expr_stmt|;
name|dns_acl_detach
argument_list|(
operator|&
name|env
operator|->
name|localnets
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

