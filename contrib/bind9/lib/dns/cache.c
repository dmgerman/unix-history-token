begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2006, 2008  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: cache.c,v 1.57.18.18 2008/02/07 23:45:56 tbox Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/cache.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/lib.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/masterdump.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_define
define|#
directive|define
name|CACHE_MAGIC
value|ISC_MAGIC('$', '$', '$', '$')
end_define

begin_define
define|#
directive|define
name|VALID_CACHE
parameter_list|(
name|cache
parameter_list|)
value|ISC_MAGIC_VALID(cache, CACHE_MAGIC)
end_define

begin_comment
comment|/*!  * Control incremental cleaning.  * DNS_CACHE_MINSIZE is how many bytes is the floor for dns_cache_setcachesize().  * See also DNS_CACHE_CLEANERINCREMENT  */
end_comment

begin_define
define|#
directive|define
name|DNS_CACHE_MINSIZE
value|2097152
end_define

begin_comment
comment|/*%< Bytes.  2097152 = 2 MB */
end_comment

begin_comment
comment|/*!  * Control incremental cleaning.  * CLEANERINCREMENT is how many nodes are examined in one pass.  * See also DNS_CACHE_MINSIZE  */
end_comment

begin_define
define|#
directive|define
name|DNS_CACHE_CLEANERINCREMENT
value|1000U
end_define

begin_comment
comment|/*%< Number of nodes. */
end_comment

begin_comment
comment|/***  ***	Types  ***/
end_comment

begin_comment
comment|/*  * A cache_cleaner_t encapsulsates the state of the periodic  * cache cleaning.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cache_cleaner
name|cache_cleaner_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|cleaner_s_idle
block|,
comment|/*%< Waiting for cleaning-interval to expire. */
name|cleaner_s_busy
block|,
comment|/*%< Currently cleaning. */
name|cleaner_s_done
comment|/*%< Freed enough memory after being overmem. */
block|}
name|cleaner_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * Convenience macros for comprehensive assertion checking.  */
end_comment

begin_define
define|#
directive|define
name|CLEANER_IDLE
parameter_list|(
name|c
parameter_list|)
value|((c)->state == cleaner_s_idle&& \ 			 (c)->resched_event != NULL)
end_define

begin_define
define|#
directive|define
name|CLEANER_BUSY
parameter_list|(
name|c
parameter_list|)
value|((c)->state == cleaner_s_busy&& \ 			 (c)->iterator != NULL&& \ 			 (c)->resched_event == NULL)
end_define

begin_comment
comment|/*%  * Accesses to a cache cleaner object are synchronized through  * task/event serialization, or locked from the cache object.  */
end_comment

begin_struct
struct|struct
name|cache_cleaner
block|{
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/*%< 	 * Locks overmem_event, overmem.  Note: never allocate memory 	 * while holding this lock - that could lead to deadlock since 	 * the lock is take by water() which is called from the memory 	 * allocator. 	 */
name|dns_cache_t
modifier|*
name|cache
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|unsigned
name|int
name|cleaning_interval
decl_stmt|;
comment|/*% The cleaning-interval from 					      named.conf, in seconds. */
name|isc_timer_t
modifier|*
name|cleaning_timer
decl_stmt|;
name|isc_event_t
modifier|*
name|resched_event
decl_stmt|;
comment|/*% Sent by cleaner task to 					   itself to reschedule */
name|isc_event_t
modifier|*
name|overmem_event
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|iterator
decl_stmt|;
name|unsigned
name|int
name|increment
decl_stmt|;
comment|/*% Number of names to 					   clean in one increment */
name|cleaner_state_t
name|state
decl_stmt|;
comment|/*% Idle/Busy. */
name|isc_boolean_t
name|overmem
decl_stmt|;
comment|/*% The cache is in an overmem state. */
name|isc_boolean_t
name|replaceiterator
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * The actual cache object.  */
end_comment

begin_struct
struct|struct
name|dns_cache
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_mutex_t
name|filelock
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* Locked by 'lock'. */
name|int
name|references
decl_stmt|;
name|int
name|live_tasks
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|cache_cleaner_t
name|cleaner
decl_stmt|;
name|char
modifier|*
name|db_type
decl_stmt|;
name|int
name|db_argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|db_argv
decl_stmt|;
comment|/* Locked by 'filelock'. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Access to the on-disk cache file is also locked by 'filelock'. */
block|}
struct|;
end_struct

begin_comment
comment|/***  ***	Functions  ***/
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|cache_cleaner_init
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|cache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleaning_timer_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|incremental_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleaner_shutdown_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overmem_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%  * Work out how many nodes can be cleaned in the time between two  * requests to the nameserver.  Smooth the resulting number and use  * it as a estimate for the number of nodes to be cleaned in the next  * iteration.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_increment
parameter_list|(
name|cache_cleaner_t
modifier|*
name|cleaner
parameter_list|,
name|unsigned
name|int
name|remaining
parameter_list|,
name|isc_time_t
modifier|*
name|start
parameter_list|)
block|{
name|isc_time_t
name|end
decl_stmt|;
name|isc_uint64_t
name|usecs
decl_stmt|;
name|isc_uint64_t
name|new
decl_stmt|;
name|unsigned
name|int
name|pps
init|=
name|dns_pps
decl_stmt|;
name|unsigned
name|int
name|interval
decl_stmt|;
name|unsigned
name|int
name|names
decl_stmt|;
comment|/* 	 * Tune for minumum of 100 packets per second (pps). 	 */
if|if
condition|(
name|pps
operator|<
literal|100
condition|)
name|pps
operator|=
literal|100
expr_stmt|;
name|isc_time_now
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
name|interval
operator|=
literal|1000000
operator|/
name|pps
expr_stmt|;
comment|/* Interval between packets in usecs. */
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
name|INSIST
argument_list|(
name|cleaner
operator|->
name|increment
operator|>=
name|remaining
argument_list|)
expr_stmt|;
name|names
operator|=
name|cleaner
operator|->
name|increment
operator|-
name|remaining
expr_stmt|;
name|usecs
operator|=
name|isc_time_microdiff
argument_list|(
operator|&
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"adjust_increment interval=%u "
literal|"names=%u usec=%"
name|ISC_PLATFORM_QUADFORMAT
literal|"u"
argument_list|,
name|interval
argument_list|,
name|names
argument_list|,
name|usecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|usecs
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we cleaned all the nodes in unmeasurable time 		 * double the number of nodes to be cleaned next time. 		 */
if|if
condition|(
name|names
operator|==
name|cleaner
operator|->
name|increment
condition|)
block|{
name|cleaner
operator|->
name|increment
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|increment
operator|>
name|DNS_CACHE_CLEANERINCREMENT
condition|)
name|cleaner
operator|->
name|increment
operator|=
name|DNS_CACHE_CLEANERINCREMENT
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"%p:new cleaner->increment = %u\n"
argument_list|,
name|cleaner
argument_list|,
name|cleaner
operator|->
name|increment
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|new
operator|=
operator|(
name|names
operator|*
name|interval
operator|)
expr_stmt|;
name|new
operator|/=
operator|(
name|usecs
operator|*
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
literal|1
expr_stmt|;
comment|/* Smooth */
name|new
operator|=
operator|(
name|new
operator|+
name|cleaner
operator|->
name|increment
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|DNS_CACHE_CLEANERINCREMENT
condition|)
name|new
operator|=
name|DNS_CACHE_CLEANERINCREMENT
expr_stmt|;
name|cleaner
operator|->
name|increment
operator|=
operator|(
name|unsigned
name|int
operator|)
name|new
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"%p:new cleaner->increment = %u\n"
argument_list|,
name|cleaner
argument_list|,
name|cleaner
operator|->
name|increment
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|cache_create_db
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|db
parameter_list|)
block|{
return|return
operator|(
name|dns_db_create
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|db_type
argument_list|,
name|dns_rootname
argument_list|,
name|dns_dbtype_cache
argument_list|,
name|cache
operator|->
name|rdclass
argument_list|,
name|cache
operator|->
name|db_argc
argument_list|,
name|cache
operator|->
name|db_argv
argument_list|,
name|db
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
specifier|const
name|char
modifier|*
name|db_type
parameter_list|,
name|unsigned
name|int
name|db_argc
parameter_list|,
name|char
modifier|*
modifier|*
name|db_argv
parameter_list|,
name|dns_cache_t
modifier|*
modifier|*
name|cachep
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_cache_t
modifier|*
name|cache
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|cachep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|*
name|cachep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cache
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|cache
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|cache
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_mem
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_lock
goto|;
name|cache
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|cache
operator|->
name|live_tasks
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|cache
operator|->
name|db_type
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|db_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_type
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_filelock
goto|;
block|}
name|cache
operator|->
name|db_argc
operator|=
name|db_argc
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_argc
operator|==
literal|0
condition|)
name|cache
operator|->
name|db_argv
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|cache
operator|->
name|db_argv
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|cache
operator|->
name|db_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_argv
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_dbtype
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
block|{
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|db_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_dbargv
goto|;
block|}
block|}
block|}
name|cache
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|cache_create_db
argument_list|(
name|cache
argument_list|,
operator|&
name|cache
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_dbargv
goto|;
name|cache
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|magic
operator|=
name|CACHE_MAGIC
expr_stmt|;
name|result
operator|=
name|cache_cleaner_init
argument_list|(
name|cache
argument_list|,
name|taskmgr
argument_list|,
name|timermgr
argument_list|,
operator|&
name|cache
operator|->
name|cleaner
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_db
goto|;
operator|*
name|cachep
operator|=
name|cache
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_db
label|:
name|dns_db_detach
argument_list|(
operator|&
name|cache
operator|->
name|db
argument_list|)
expr_stmt|;
name|cleanup_dbargv
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_argv
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cache
operator|->
name|db_argv
argument_list|,
name|cache
operator|->
name|db_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_dbtype
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|cache
operator|->
name|db_type
argument_list|)
expr_stmt|;
name|cleanup_filelock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
name|cleanup_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cleanup_mem
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_free
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cache
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|isc_mem_setwater
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|overmem_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|resched_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|resched_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|iterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|iterator
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|filename
condition|)
block|{
name|isc_mem_free
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|filename
argument_list|)
expr_stmt|;
name|cache
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|cache
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db_argv
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cache
operator|->
name|db_argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|db_argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|db_argv
argument_list|,
name|cache
operator|->
name|db_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|db_type
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|db_type
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
name|cache
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|cache
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_cache_attach
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|dns_cache_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cache
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|cache
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_cache_detach
parameter_list|(
name|dns_cache_t
modifier|*
modifier|*
name|cachep
parameter_list|)
block|{
name|dns_cache_t
modifier|*
name|cache
decl_stmt|;
name|isc_boolean_t
name|free_cache
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|cachep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|cachep
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cache
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|cache
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|cache
operator|->
name|cleaner
operator|.
name|overmem
operator|=
name|ISC_FALSE
expr_stmt|;
name|free_cache
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
operator|*
name|cachep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|free_cache
condition|)
block|{
comment|/* 		 * When the cache is shut down, dump it to a file if one is 		 * specified. 		 */
name|isc_result_t
name|result
init|=
name|dns_cache_dump
argument_list|(
name|cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"error dumping cache: %s "
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the cleaner task exists, let it free the cache. 		 */
if|if
condition|(
name|cache
operator|->
name|live_tasks
operator|>
literal|0
condition|)
block|{
name|isc_task_shutdown
argument_list|(
name|cache
operator|->
name|cleaner
operator|.
name|task
argument_list|)
expr_stmt|;
name|free_cache
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_cache
condition|)
name|cache_free
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_cache_attachdb
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cache
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_setfilename
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|newname
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newname
operator|=
name|isc_mem_strdup
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|filename
condition|)
name|isc_mem_free
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|filename
argument_list|)
expr_stmt|;
name|cache
operator|->
name|filename
operator|=
name|newname
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_load
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_load
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|cache
operator|->
name|filename
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_dump
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_master_dump
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cache
operator|->
name|db
argument_list|,
name|NULL
argument_list|,
operator|&
name|dns_master_style_cache
argument_list|,
name|cache
operator|->
name|filename
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|filelock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_cache_setcleaninginterval
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|unsigned
name|int
name|t
parameter_list|)
block|{
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * It may be the case that the cache has already shut down. 	 * If so, it has no timer. 	 */
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_timer
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_interval
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_interval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|,
name|isc_timertype_ticker
argument_list|,
name|NULL
argument_list|,
operator|&
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"could not set cache cleaning interval: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the cache cleaner object at *cleaner.  * Space for the object must be allocated by the caller.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|cache_cleaner_init
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|cache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|cleaner
operator|->
name|increment
operator|=
name|DNS_CACHE_CLEANERINCREMENT
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_idle
expr_stmt|;
name|cleaner
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|cleaner
operator|->
name|iterator
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|overmem
operator|=
name|ISC_FALSE
expr_stmt|;
name|cleaner
operator|->
name|replaceiterator
operator|=
name|ISC_FALSE
expr_stmt|;
name|cleaner
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|cleaning_timer
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|resched_event
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|overmem_event
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|taskmgr
operator|!=
name|NULL
operator|&&
name|timermgr
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|1
argument_list|,
operator|&
name|cleaner
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_task_create() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|cache
operator|->
name|live_tasks
operator|++
expr_stmt|;
name|isc_task_setname
argument_list|(
name|cleaner
operator|->
name|task
argument_list|,
literal|"cachecleaner"
argument_list|,
name|cleaner
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_task_onshutdown
argument_list|(
name|cleaner
operator|->
name|task
argument_list|,
name|cleaner_shutdown_action
argument_list|,
name|cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cache cleaner: "
literal|"isc_task_onshutdown() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|cleaning_interval
operator|=
literal|0
expr_stmt|;
comment|/* Initially turned off. */
name|result
operator|=
name|isc_timer_create
argument_list|(
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cleaner
operator|->
name|task
argument_list|,
name|cleaning_timer_action
argument_list|,
name|cleaner
argument_list|,
operator|&
name|cleaner
operator|->
name|cleaning_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_create() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|resched_event
operator|=
name|isc_event_allocate
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cleaner
argument_list|,
name|DNS_EVENT_CACHECLEAN
argument_list|,
name|incremental_cleaning_action
argument_list|,
name|cleaner
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|resched_event
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|overmem_event
operator|=
name|isc_event_allocate
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|cleaner
argument_list|,
name|DNS_EVENT_CACHEOVERMEM
argument_list|,
name|overmem_cleaning_action
argument_list|,
name|cleaner
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem_event
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|cleaner
operator|->
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cleaner
operator|->
name|overmem_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|resched_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cleaner
operator|->
name|resched_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|cleaning_timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|cleaner
operator|->
name|cleaning_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|cleaner
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|iterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|begin_cleaning
parameter_list|(
name|cache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|CLEANER_IDLE
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create an iterator, if it does not already exist, and 	 * position it at the beginning of the cache. 	 */
if|if
condition|(
name|cleaner
operator|->
name|iterator
operator|==
name|NULL
condition|)
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"cache cleaner could not create "
literal|"iterator: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|dns_dbiterator_setcleanmode
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * If the result is ISC_R_NOMORE, the database is empty, 		 * so there is nothing to be cleaned. 		 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
operator|&&
name|cleaner
operator|->
name|iterator
operator|!=
name|NULL
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cache cleaner: "
literal|"dns_dbiterator_first() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cleaner
operator|->
name|iterator
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_dbiterator_pause
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Pause the iterator to free its lock. 		 */
name|result
operator|=
name|dns_dbiterator_pause
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"begin cache cleaning, mem inuse %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_busy
expr_stmt|;
name|isc_task_send
argument_list|(
name|cleaner
operator|->
name|task
argument_list|,
operator|&
name|cleaner
operator|->
name|resched_event
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|end_cleaning
parameter_list|(
name|cache_cleaner_t
modifier|*
name|cleaner
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_pause
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|dns_cache_setcleaninginterval
argument_list|(
name|cleaner
operator|->
name|cache
argument_list|,
name|cleaner
operator|->
name|cleaning_interval
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"end cache cleaning, mem inuse %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_idle
expr_stmt|;
name|cleaner
operator|->
name|resched_event
operator|=
name|event
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is run once for every cache-cleaning-interval as defined in named.conf.  */
end_comment

begin_function
specifier|static
name|void
name|cleaning_timer_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|cache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|cleaner
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_TICK
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"cache cleaning timer fired, "
literal|"cleaner state = %d"
argument_list|,
name|cleaner
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_idle
condition|)
name|begin_cleaning
argument_list|(
name|cleaner
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when the cache either surpasses its upper limit  * or shrinks beyond its lower limit.  */
end_comment

begin_function
specifier|static
name|void
name|overmem_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|cache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|want_cleaning
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|cleaner
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_CACHEOVERMEM
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|cleaner
operator|->
name|overmem_event
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"overmem_cleaning_action called, "
literal|"overmem = %d, state = %d"
argument_list|,
name|cleaner
operator|->
name|overmem
argument_list|,
name|cleaner
operator|->
name|state
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_idle
condition|)
name|want_cleaning
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_busy
condition|)
comment|/* 			 * end_cleaning() can't be called here because 			 * then both cleaner->overmem_event and 			 * cleaner->resched_event will point to this 			 * event.  Set the state to done, and then 			 * when the incremental_cleaning_action() event 			 * is posted, it will handle the end_cleaning. 			 */
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_done
expr_stmt|;
block|}
name|cleaner
operator|->
name|overmem_event
operator|=
name|event
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_cleaning
condition|)
name|begin_cleaning
argument_list|(
name|cleaner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do incremental cleaning.  */
end_comment

begin_function
specifier|static
name|void
name|incremental_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|cache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|n_names
decl_stmt|;
name|isc_time_t
name|start
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|cleaner
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_CACHECLEAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_done
condition|)
block|{
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_busy
expr_stmt|;
name|end_cleaning
argument_list|(
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|replaceiterator
condition|)
block|{
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_db_createiterator
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|cleaner
operator|->
name|replaceiterator
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
name|n_names
operator|=
name|cleaner
operator|->
name|increment
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DBITERATOR_VALID
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
name|isc_time_now
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|n_names
operator|--
operator|>
literal|0
condition|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cache cleaner: dns_dbiterator_current() "
literal|"failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|adjust_increment
argument_list|(
name|cleaner
argument_list|,
name|n_names
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|end_cleaning
argument_list|(
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * The node was not needed, but was required by 		 * dns_dbiterator_current().  Give up its reference. 		 */
name|dns_db_detachnode
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
comment|/* 		 * Step to the next node. 		 */
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			 * Either the end was reached (ISC_R_NOMORE) or 			 * some error was signaled.  If the cache is still 			 * overmem and no error was encountered, 			 * keep trying to clean it, otherwise stop cleaning. 			 */
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cache cleaner: "
literal|"dns_dbiterator_next() "
literal|"failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"cache cleaner: "
literal|"still overmem, "
literal|"reset and try again"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|adjust_increment
argument_list|(
name|cleaner
argument_list|,
name|n_names
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|end_cleaning
argument_list|(
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|adjust_increment
argument_list|(
name|cleaner
argument_list|,
literal|0U
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * We have successfully performed a cleaning increment but have 	 * not gone through the entire cache.  Free the iterator locks 	 * and reschedule another batch.  If it fails, just try to continue 	 * anyway. 	 */
name|result
operator|=
name|dns_dbiterator_pause
argument_list|(
name|cleaner
operator|->
name|iterator
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"cache cleaner: checked %u nodes, "
literal|"mem inuse %lu, sleeping"
argument_list|,
name|cleaner
operator|->
name|increment
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|cache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Do immediate cleaning.  */
end_comment

begin_function
name|isc_result_t
name|dns_cache_clean
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|iterator
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
name|result
return|;
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|iterator
argument_list|,
operator|&
name|node
argument_list|,
operator|(
name|dns_name_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
comment|/* 		 * Check TTLs, mark expired rdatasets stale. 		 */
name|result
operator|=
name|dns_db_expirenode
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cache cleaner: dns_db_expirenode() "
literal|"failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Continue anyway. 			 */
block|}
comment|/* 		 * This is where the actual freeing takes place. 		 */
name|dns_db_detachnode
argument_list|(
name|cache
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|iterator
argument_list|)
expr_stmt|;
block|}
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|iterator
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|water
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
name|dns_cache_t
modifier|*
name|cache
init|=
name|arg
decl_stmt|;
name|isc_boolean_t
name|overmem
init|=
name|ISC_TF
argument_list|(
name|mark
operator|==
name|ISC_MEM_HIWATER
argument_list|)
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|overmem
operator|!=
name|cache
operator|->
name|cleaner
operator|.
name|overmem
condition|)
block|{
name|dns_db_overmem
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|overmem
argument_list|)
expr_stmt|;
name|cache
operator|->
name|cleaner
operator|.
name|overmem
operator|=
name|overmem
expr_stmt|;
name|isc_mem_waterack
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_task_send
argument_list|(
name|cache
operator|->
name|cleaner
operator|.
name|task
argument_list|,
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|overmem_event
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_cache_setcachesize
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|isc_uint32_t
name|size
parameter_list|)
block|{
name|isc_uint32_t
name|lowater
decl_stmt|;
name|isc_uint32_t
name|hiwater
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CACHE
argument_list|(
name|cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Impose a minumum cache size; pathological things happen if there 	 * is too little room. 	 */
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|size
operator|<
name|DNS_CACHE_MINSIZE
condition|)
name|size
operator|=
name|DNS_CACHE_MINSIZE
expr_stmt|;
name|hiwater
operator|=
name|size
operator|-
operator|(
name|size
operator|>>
literal|3
operator|)
expr_stmt|;
comment|/* Approximately 7/8ths. */
name|lowater
operator|=
name|size
operator|-
operator|(
name|size
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* Approximately 3/4ths. */
comment|/* 	 * If the cache was overmem and cleaning, but now with the new limits 	 * it is no longer in an overmem condition, then the next 	 * isc_mem_put for cache memory will do the right thing and trigger 	 * water(). 	 */
if|if
condition|(
name|size
operator|==
literal|0
operator|||
name|hiwater
operator|==
literal|0
operator|||
name|lowater
operator|==
literal|0
condition|)
comment|/* 		 * Disable cache memory limiting. 		 */
name|isc_mem_setwater
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|water
argument_list|,
name|cache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * Establish new cache memory limits (either for the first 		 * time, or replacing other limits). 		 */
name|isc_mem_setwater
argument_list|(
name|cache
operator|->
name|mctx
argument_list|,
name|water
argument_list|,
name|cache
argument_list|,
name|hiwater
argument_list|,
name|lowater
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The cleaner task is shutting down; do the necessary cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|cleaner_shutdown_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_cache_t
modifier|*
name|cache
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|should_free
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|cache
operator|->
name|cleaner
operator|.
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TASKEVENT_SHUTDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLEANER_BUSY
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
argument_list|)
condition|)
name|end_cleaning
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cache
operator|->
name|live_tasks
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|cache
operator|->
name|live_tasks
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|references
operator|==
literal|0
condition|)
name|should_free
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * By detaching the timer in the context of its task, 	 * we are guaranteed that there will be no further timer 	 * events. 	 */
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|)
expr_stmt|;
comment|/* Make sure we don't reschedule anymore. */
operator|(
name|void
operator|)
name|isc_task_purge
argument_list|(
name|task
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_CACHECLEAN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_free
condition|)
name|cache_free
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_flush
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|cache_create_db
argument_list|(
name|cache
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|state
operator|==
name|cleaner_s_idle
condition|)
block|{
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|iterator
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|iterator
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_db_createiterator
argument_list|(
name|db
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|iterator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cache
operator|->
name|cleaner
operator|.
name|state
operator|==
name|cleaner_s_busy
condition|)
name|cache
operator|->
name|cleaner
operator|.
name|state
operator|=
name|cleaner_s_done
expr_stmt|;
name|cache
operator|->
name|cleaner
operator|.
name|replaceiterator
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|dns_db_detach
argument_list|(
operator|&
name|cache
operator|->
name|db
argument_list|)
expr_stmt|;
name|cache
operator|->
name|db
operator|=
name|db
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cache_flushname
parameter_list|(
name|dns_cache_t
modifier|*
name|cache
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|iter
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|cache
operator|->
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|name
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup_db
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_db
goto|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
literal|0
argument_list|,
operator|&
name|iter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_node
goto|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|iter
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|iter
argument_list|)
control|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_current
argument_list|(
name|iter
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_deleterdataset
argument_list|(
name|cache
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|rdataset
operator|.
name|type
argument_list|,
name|rdataset
operator|.
name|covers
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_UNCHANGED
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|cleanup_node
label|:
name|dns_db_detachnode
argument_list|(
name|cache
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|cleanup_db
label|:
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

