begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_comment
comment|/*  * Principal Author: Bob Halley  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_comment
comment|/* #define inline */
end_comment

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/heap.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/refcount.h>
end_include

begin_include
include|#
directive|include
file|<isc/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acache.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/lib.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/masterdump.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec.h>
end_include

begin_include
include|#
directive|include
file|<dns/nsec3.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/rpz.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataslab.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_include
include|#
directive|include
file|<dns/zonekey.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_include
include|#
directive|include
file|"rbtdb64.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"rbtdb.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_define
define|#
directive|define
name|RBTDB_MAGIC
value|ISC_MAGIC('R', 'B', 'D', '8')
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RBTDB_MAGIC
value|ISC_MAGIC('R', 'B', 'D', '4')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Note that "impmagic" is not the first four bytes of the struct, so  * ISC_MAGIC_VALID cannot be used.  */
end_comment

begin_define
define|#
directive|define
name|VALID_RBTDB
parameter_list|(
name|rbtdb
parameter_list|)
value|((rbtdb) != NULL&& \ 				 (rbtdb)->common.impmagic == RBTDB_MAGIC)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_typedef
typedef|typedef
name|isc_uint64_t
name|rbtdb_serial_t
typedef|;
end_typedef

begin_comment
comment|/*%  * Make casting easier in symbolic debuggers by using different names  * for the 64 bit version.  */
end_comment

begin_define
define|#
directive|define
name|dns_rbtdb_t
value|dns_rbtdb64_t
end_define

begin_define
define|#
directive|define
name|rdatasetheader_t
value|rdatasetheader64_t
end_define

begin_define
define|#
directive|define
name|rbtdb_version_t
value|rbtdb_version64_t
end_define

begin_define
define|#
directive|define
name|init_count
value|init_count64
end_define

begin_define
define|#
directive|define
name|cache_methods
value|cache_methods64
end_define

begin_define
define|#
directive|define
name|dbiterator_methods
value|dbiterator_methods64
end_define

begin_define
define|#
directive|define
name|rdataset_methods
value|rdataset_methods64
end_define

begin_define
define|#
directive|define
name|rdatasetiter_methods
value|rdatasetiter_methods64
end_define

begin_define
define|#
directive|define
name|zone_methods
value|zone_methods64
end_define

begin_define
define|#
directive|define
name|acache_callback
value|acache_callback64
end_define

begin_define
define|#
directive|define
name|acache_cancelentry
value|acache_cancelentry64
end_define

begin_define
define|#
directive|define
name|activeempty
value|activeempty64
end_define

begin_define
define|#
directive|define
name|activeemtpynode
value|activeemtpynode64
end_define

begin_define
define|#
directive|define
name|add32
value|add64
end_define

begin_define
define|#
directive|define
name|add_changed
value|add_changed64
end_define

begin_define
define|#
directive|define
name|add_empty_wildcards
value|add_empty_wildcards64
end_define

begin_define
define|#
directive|define
name|add_wildcard_magic
value|add_wildcard_magic64
end_define

begin_define
define|#
directive|define
name|addrdataset
value|addrdataset64
end_define

begin_define
define|#
directive|define
name|allrdatasets
value|allrdatasets64
end_define

begin_define
define|#
directive|define
name|attach
value|attach64
end_define

begin_define
define|#
directive|define
name|attachnode
value|attachnode64
end_define

begin_define
define|#
directive|define
name|attachversion
value|attachversion64
end_define

begin_define
define|#
directive|define
name|beginload
value|beginload64
end_define

begin_define
define|#
directive|define
name|bind_rdataset
value|bind_rdataset64
end_define

begin_define
define|#
directive|define
name|cache_find
value|cache_find64
end_define

begin_define
define|#
directive|define
name|cache_findrdataset
value|cache_findrdataset64
end_define

begin_define
define|#
directive|define
name|cache_findzonecut
value|cache_findzonecut64
end_define

begin_define
define|#
directive|define
name|cache_zonecut_callback
value|cache_zonecut_callback64
end_define

begin_define
define|#
directive|define
name|cleanup_dead_nodes
value|cleanup_dead_nodes64
end_define

begin_define
define|#
directive|define
name|cleanup_dead_nodes_callback
value|cleanup_dead_nodes_callback64
end_define

begin_define
define|#
directive|define
name|closeversion
value|closeversion64
end_define

begin_define
define|#
directive|define
name|createiterator
value|createiterator64
end_define

begin_define
define|#
directive|define
name|currentversion
value|currentversion64
end_define

begin_define
define|#
directive|define
name|dbiterator_current
value|dbiterator_current64
end_define

begin_define
define|#
directive|define
name|dbiterator_destroy
value|dbiterator_destroy64
end_define

begin_define
define|#
directive|define
name|dbiterator_first
value|dbiterator_first64
end_define

begin_define
define|#
directive|define
name|dbiterator_last
value|dbiterator_last64
end_define

begin_define
define|#
directive|define
name|dbiterator_next
value|dbiterator_next64
end_define

begin_define
define|#
directive|define
name|dbiterator_origin
value|dbiterator_origin64
end_define

begin_define
define|#
directive|define
name|dbiterator_pause
value|dbiterator_pause64
end_define

begin_define
define|#
directive|define
name|dbiterator_prev
value|dbiterator_prev64
end_define

begin_define
define|#
directive|define
name|dbiterator_seek
value|dbiterator_seek64
end_define

begin_define
define|#
directive|define
name|decrement_reference
value|decrement_reference64
end_define

begin_define
define|#
directive|define
name|delete_callback
value|delete_callback64
end_define

begin_define
define|#
directive|define
name|delete_node
value|delete_node64
end_define

begin_define
define|#
directive|define
name|deleterdataset
value|deleterdataset64
end_define

begin_define
define|#
directive|define
name|detach
value|detach64
end_define

begin_define
define|#
directive|define
name|detachnode
value|detachnode64
end_define

begin_define
define|#
directive|define
name|dump
value|dump64
end_define

begin_define
define|#
directive|define
name|endload
value|endload64
end_define

begin_define
define|#
directive|define
name|expire_header
value|expire_header64
end_define

begin_define
define|#
directive|define
name|expirenode
value|expirenode64
end_define

begin_define
define|#
directive|define
name|find_closest_nsec
value|find_closest_nsec64
end_define

begin_define
define|#
directive|define
name|find_coveringnsec
value|find_coveringnsec64
end_define

begin_define
define|#
directive|define
name|find_deepest_zonecut
value|find_deepest_zonecut64
end_define

begin_define
define|#
directive|define
name|findnode
value|findnode64
end_define

begin_define
define|#
directive|define
name|findnodeintree
value|findnodeintree64
end_define

begin_define
define|#
directive|define
name|findnsec3node
value|findnsec3node64
end_define

begin_define
define|#
directive|define
name|flush_deletions
value|flush_deletions64
end_define

begin_define
define|#
directive|define
name|free_acachearray
value|free_acachearray64
end_define

begin_define
define|#
directive|define
name|free_noqname
value|free_noqname64
end_define

begin_define
define|#
directive|define
name|free_rbtdb
value|free_rbtdb64
end_define

begin_define
define|#
directive|define
name|free_rbtdb_callback
value|free_rbtdb_callback64
end_define

begin_define
define|#
directive|define
name|free_rdataset
value|free_rdataset64
end_define

begin_define
define|#
directive|define
name|getnsec3parameters
value|getnsec3parameters64
end_define

begin_define
define|#
directive|define
name|getoriginnode
value|getoriginnode64
end_define

begin_define
define|#
directive|define
name|getrrsetstats
value|getrrsetstats64
end_define

begin_define
define|#
directive|define
name|getsigningtime
value|getsigningtime64
end_define

begin_define
define|#
directive|define
name|isdnssec
value|isdnssec64
end_define

begin_define
define|#
directive|define
name|ispersistent
value|ispersistent64
end_define

begin_define
define|#
directive|define
name|issecure
value|issecure64
end_define

begin_define
define|#
directive|define
name|iszonesecure
value|iszonesecure64
end_define

begin_define
define|#
directive|define
name|loading_addrdataset
value|loading_addrdataset64
end_define

begin_define
define|#
directive|define
name|loadnode
value|loadnode64
end_define

begin_define
define|#
directive|define
name|matchparams
value|matchparams64
end_define

begin_define
define|#
directive|define
name|maybe_free_rbtdb
value|maybe_free_rbtdb64
end_define

begin_define
define|#
directive|define
name|new_reference
value|new_reference64
end_define

begin_define
define|#
directive|define
name|newversion
value|newversion64
end_define

begin_define
define|#
directive|define
name|nodecount
value|nodecount64
end_define

begin_define
define|#
directive|define
name|overmem
value|overmem64
end_define

begin_define
define|#
directive|define
name|previous_closest_nsec
value|previous_closest_nsec64
end_define

begin_define
define|#
directive|define
name|printnode
value|printnode64
end_define

begin_define
define|#
directive|define
name|prune_tree
value|prune_tree64
end_define

begin_define
define|#
directive|define
name|rdataset_clone
value|rdataset_clone64
end_define

begin_define
define|#
directive|define
name|rdataset_count
value|rdataset_count64
end_define

begin_define
define|#
directive|define
name|rdataset_current
value|rdataset_current64
end_define

begin_define
define|#
directive|define
name|rdataset_disassociate
value|rdataset_disassociate64
end_define

begin_define
define|#
directive|define
name|rdataset_expire
value|rdataset_expire64
end_define

begin_define
define|#
directive|define
name|rdataset_first
value|rdataset_first64
end_define

begin_define
define|#
directive|define
name|rdataset_getadditional
value|rdataset_getadditional64
end_define

begin_define
define|#
directive|define
name|rdataset_getclosest
value|rdataset_getclosest64
end_define

begin_define
define|#
directive|define
name|rdataset_getnoqname
value|rdataset_getnoqname64
end_define

begin_define
define|#
directive|define
name|rdataset_next
value|rdataset_next64
end_define

begin_define
define|#
directive|define
name|rdataset_putadditional
value|rdataset_putadditional64
end_define

begin_define
define|#
directive|define
name|rdataset_setadditional
value|rdataset_setadditional64
end_define

begin_define
define|#
directive|define
name|rdataset_settrust
value|rdataset_settrust64
end_define

begin_define
define|#
directive|define
name|rdatasetiter_current
value|rdatasetiter_current64
end_define

begin_define
define|#
directive|define
name|rdatasetiter_destroy
value|rdatasetiter_destroy64
end_define

begin_define
define|#
directive|define
name|rdatasetiter_first
value|rdatasetiter_first64
end_define

begin_define
define|#
directive|define
name|rdatasetiter_next
value|rdatasetiter_next64
end_define

begin_define
define|#
directive|define
name|reactivate_node
value|reactivate_node64
end_define

begin_define
define|#
directive|define
name|resign_delete
value|resign_delete64
end_define

begin_define
define|#
directive|define
name|resign_insert
value|resign_insert64
end_define

begin_define
define|#
directive|define
name|resign_sooner
value|resign_sooner64
end_define

begin_define
define|#
directive|define
name|resigned
value|resigned64
end_define

begin_define
define|#
directive|define
name|rpz_enabled
value|rpz_enabled64
end_define

begin_define
define|#
directive|define
name|rpz_findips
value|rpz_findips64
end_define

begin_define
define|#
directive|define
name|set_index
value|set_index64
end_define

begin_define
define|#
directive|define
name|set_ttl
value|set_ttl64
end_define

begin_define
define|#
directive|define
name|setsigningtime
value|setsigningtime64
end_define

begin_define
define|#
directive|define
name|settask
value|settask64
end_define

begin_define
define|#
directive|define
name|setup_delegation
value|setup_delegation64
end_define

begin_define
define|#
directive|define
name|subtractrdataset
value|subtractrdataset64
end_define

begin_define
define|#
directive|define
name|ttl_sooner
value|ttl_sooner64
end_define

begin_define
define|#
directive|define
name|update_header
value|update_header64
end_define

begin_define
define|#
directive|define
name|update_rrsetstats
value|update_rrsetstats64
end_define

begin_define
define|#
directive|define
name|zone_find
value|zone_find64
end_define

begin_define
define|#
directive|define
name|zone_findrdataset
value|zone_findrdataset64
end_define

begin_define
define|#
directive|define
name|zone_findzonecut
value|zone_findzonecut64
end_define

begin_define
define|#
directive|define
name|zone_zonecut_callback
value|zone_zonecut_callback64
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|isc_uint32_t
name|rbtdb_serial_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|isc_uint32_t
name|rbtdb_rdatatype_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_BASE
parameter_list|(
name|type
parameter_list|)
value|((dns_rdatatype_t)((type)& 0xFFFF))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_EXT
parameter_list|(
name|type
parameter_list|)
value|((dns_rdatatype_t)((type)>> 16))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_VALUE
parameter_list|(
name|b
parameter_list|,
name|e
parameter_list|)
value|((rbtdb_rdatatype_t)((e)<< 16) | (b))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGNSEC
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_nsec)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGNSEC3
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_nsec3)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGNS
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_ns)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGCNAME
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_cname)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGDNAME
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_dname)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGDDS
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_ds)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_NCACHEANY
define|\
value|RBTDB_RDATATYPE_VALUE(0, dns_rdatatype_any)
end_define

begin_comment
comment|/*  * We use rwlock for DB lock only when ISC_RWLOCK_USEATOMIC is non 0.  * Using rwlock is effective with regard to lookup performance only when  * it is implemented in an efficient way.  * Otherwise, it is generally wise to stick to the simple locking since rwlock  * would require more memory or can even make lookups slower due to its own  * overhead (when it internally calls mutex locks).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_RWLOCK_USEATOMIC
end_ifdef

begin_define
define|#
directive|define
name|DNS_RBTDB_USERWLOCK
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DNS_RBTDB_USERWLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DNS_RBTDB_USERWLOCK
end_if

begin_define
define|#
directive|define
name|RBTDB_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_init((l), 0, 0)
end_define

begin_define
define|#
directive|define
name|RBTDB_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_destroy(l)
end_define

begin_define
define|#
directive|define
name|RBTDB_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|RBTDB_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWUNLOCK((l), (t))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RBTDB_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_mutex_init(l)
end_define

begin_define
define|#
directive|define
name|RBTDB_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|DESTROYLOCK(l)
end_define

begin_define
define|#
directive|define
name|RBTDB_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|LOCK(l)
end_define

begin_define
define|#
directive|define
name|RBTDB_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|UNLOCK(l)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Since node locking is sensitive to both performance and memory footprint,  * we need some trick here.  If we have both high-performance rwlock and  * high performance and small-memory reference counters, we use rwlock for  * node lock and isc_refcount for node references.  In this case, we don't have  * to protect the access to the counters by locks.  * Otherwise, we simply use ordinary mutex lock for node locking, and use  * simple integers as reference counters which is protected by the lock.  * In most cases, we can simply use wrapper macros such as NODE_LOCK and  * NODE_UNLOCK.  In some other cases, however, we need to protect reference  * counters first and then protect other parts of a node as read-only data.  * Special additional macros, NODE_STRONGLOCK(), NODE_WEAKLOCK(), etc, are also  * provided for these special cases.  When we can use the efficient backend  * routines, we should only protect the "other members" by NODE_WEAKLOCK(read).  * Otherwise, we should use NODE_STRONGLOCK() to protect the entire critical  * section including the access to the reference counter.  * Note that we cannot use NODE_LOCK()/NODE_UNLOCK() wherever the protected  * section is also protected by NODE_STRONGLOCK().  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_RWLOCK_USEATOMIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|DNS_RBT_USEISCREFCOUNT
argument_list|)
end_if

begin_typedef
typedef|typedef
name|isc_rwlock_t
name|nodelock_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NODE_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_init((l), 0, 0)
end_define

begin_define
define|#
directive|define
name|NODE_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_destroy(l)
end_define

begin_define
define|#
directive|define
name|NODE_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|NODE_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWUNLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|NODE_TRYUPGRADE
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_tryupgrade(l)
end_define

begin_define
define|#
directive|define
name|NODE_STRONGLOCK
parameter_list|(
name|l
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|NODE_STRONGUNLOCK
parameter_list|(
name|l
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|NODE_LOCK(l, t)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKUNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|NODE_UNLOCK(l, t)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKDOWNGRADE
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_downgrade(l)
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|isc_mutex_t
name|nodelock_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NODE_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_mutex_init(l)
end_define

begin_define
define|#
directive|define
name|NODE_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|DESTROYLOCK(l)
end_define

begin_define
define|#
directive|define
name|NODE_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|LOCK(l)
end_define

begin_define
define|#
directive|define
name|NODE_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|UNLOCK(l)
end_define

begin_define
define|#
directive|define
name|NODE_TRYUPGRADE
parameter_list|(
name|l
parameter_list|)
value|ISC_R_SUCCESS
end_define

begin_define
define|#
directive|define
name|NODE_STRONGLOCK
parameter_list|(
name|l
parameter_list|)
value|LOCK(l)
end_define

begin_define
define|#
directive|define
name|NODE_STRONGUNLOCK
parameter_list|(
name|l
parameter_list|)
value|UNLOCK(l)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKUNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|((void)0)
end_define

begin_define
define|#
directive|define
name|NODE_WEAKDOWNGRADE
parameter_list|(
name|l
parameter_list|)
value|((void)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Whether to rate-limit updating the LRU to avoid possible thread contention.  * Our performance measurement has shown the cost is marginal, so it's defined  * to be 0 by default either with or without threads.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_RBTDB_LIMITLRUUPDATE
end_ifndef

begin_define
define|#
directive|define
name|DNS_RBTDB_LIMITLRUUPDATE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow clients with a virtual time of up to 5 minutes in the past to see  * records that would have otherwise have expired.  */
end_comment

begin_define
define|#
directive|define
name|RBTDB_VIRTUAL
value|300
end_define

begin_struct
struct|struct
name|noqname
block|{
name|dns_name_t
name|name
decl_stmt|;
name|void
modifier|*
name|neg
decl_stmt|;
name|void
modifier|*
name|negsig
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|acachectl
name|acachectl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rdatasetheader
block|{
comment|/*% 	 * Locked by the owning node's lock. 	 */
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|dns_ttl_t
name|rdh_ttl
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|;
name|isc_uint16_t
name|attributes
decl_stmt|;
name|dns_trust_t
name|trust
decl_stmt|;
name|struct
name|noqname
modifier|*
name|noqname
decl_stmt|;
name|struct
name|noqname
modifier|*
name|closest
decl_stmt|;
comment|/*%< 	 * We don't use the LIST macros, because the LIST structure has 	 * both head and tail pointers, and is doubly linked. 	 */
name|struct
name|rdatasetheader
modifier|*
name|next
decl_stmt|;
comment|/*%< 	 * If this is the top header for an rdataset, 'next' points 	 * to the top header for the next rdataset (i.e., the next type). 	 * Otherwise, it points up to the header whose down pointer points 	 * at this header. 	 */
name|struct
name|rdatasetheader
modifier|*
name|down
decl_stmt|;
comment|/*%< 	 * Points to the header for the next older version of 	 * this rdataset. 	 */
name|isc_uint32_t
name|count
decl_stmt|;
comment|/*%< 	 * Monotonously increased every time this rdataset is bound so that 	 * it is used as the base of the starting point in DNS responses 	 * when the "cyclic" rrset-order is required.  Since the ordering 	 * should not be so crucial, no lock is set for the counter for 	 * performance reasons. 	 */
name|acachectl_t
modifier|*
name|additional_auth
decl_stmt|;
name|acachectl_t
modifier|*
name|additional_glue
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_stdtime_t
name|last_used
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct rdatasetheader
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|heap_index
decl_stmt|;
comment|/*%< 	 * Used for TTL-based cache cleaning. 	 */
name|isc_stdtime_t
name|resign
decl_stmt|;
block|}
name|rdatasetheader_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rdatasetheader_t
argument_list|)
name|rdatasetheaderlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_rbtnode_t
argument_list|)
name|rbtnodelist_t
expr_stmt|;
end_typedef

begin_define
define|#
directive|define
name|RDATASET_ATTR_NONEXISTENT
value|0x0001
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_STALE
value|0x0002
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_IGNORE
value|0x0004
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_RETAIN
value|0x0008
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_NXDOMAIN
value|0x0010
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_RESIGN
value|0x0020
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_STATCOUNT
value|0x0040
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_OPTOUT
value|0x0080
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_NEGATIVE
value|0x0100
end_define

begin_typedef
typedef|typedef
struct|struct
name|acache_cbarg
block|{
name|dns_rdatasetadditional_t
name|type
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
block|}
name|acache_cbarg_t
typedef|;
end_typedef

begin_struct
struct|struct
name|acachectl
block|{
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|;
name|acache_cbarg_t
modifier|*
name|cbarg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX  * When the cache will pre-expire data (due to memory low or other  * situations) before the rdataset's TTL has expired, it MUST  * respect the RETAIN bit and not expire the data until its TTL is  * expired.  */
end_comment

begin_undef
undef|#
directive|undef
name|IGNORE
end_undef

begin_comment
comment|/* WIN32 winbase.h defines this. */
end_comment

begin_define
define|#
directive|define
name|EXISTS
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NONEXISTENT) == 0)
end_define

begin_define
define|#
directive|define
name|NONEXISTENT
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NONEXISTENT) != 0)
end_define

begin_define
define|#
directive|define
name|IGNORE
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_IGNORE) != 0)
end_define

begin_define
define|#
directive|define
name|RETAIN
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_RETAIN) != 0)
end_define

begin_define
define|#
directive|define
name|NXDOMAIN
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NXDOMAIN) != 0)
end_define

begin_define
define|#
directive|define
name|RESIGN
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_RESIGN) != 0)
end_define

begin_define
define|#
directive|define
name|OPTOUT
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_OPTOUT) != 0)
end_define

begin_define
define|#
directive|define
name|NEGATIVE
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NEGATIVE) != 0)
end_define

begin_define
define|#
directive|define
name|DEFAULT_NODE_LOCK_COUNT
value|7
end_define

begin_comment
comment|/*%< Should be prime. */
end_comment

begin_comment
comment|/*%  * Number of buckets for cache DB entries (locks, LRU lists, TTL heaps).  * There is a tradeoff issue about configuring this value: if this is too  * small, it may cause heavier contention between threads; if this is too large,  * LRU purge algorithm won't work well (entries tend to be purged prematurely).  * The default value should work well for most environments, but this can  * also be configurable at compilation time via the  * DNS_RBTDB_CACHE_NODE_LOCK_COUNT variable.  This value must be larger than  * 1 due to the assumption of overmem_purge().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_CACHE_NODE_LOCK_COUNT
end_ifdef

begin_if
if|#
directive|if
name|DNS_RBTDB_CACHE_NODE_LOCK_COUNT
operator|<=
literal|1
end_if

begin_error
error|#
directive|error
literal|"DNS_RBTDB_CACHE_NODE_LOCK_COUNT must be larger than 1"
end_error

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_CACHE_NODE_LOCK_COUNT
value|DNS_RBTDB_CACHE_NODE_LOCK_COUNT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_CACHE_NODE_LOCK_COUNT
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNS_RBTDB_CACHE_NODE_LOCK_COUNT */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|nodelock_t
name|lock
decl_stmt|;
comment|/* Protected in the refcount routines. */
name|isc_refcount_t
name|references
decl_stmt|;
comment|/* Locked by lock. */
name|isc_boolean_t
name|exiting
decl_stmt|;
block|}
name|rbtdb_nodelock_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_changed
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_boolean_t
name|dirty
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct rbtdb_changed
argument_list|)
name|link
expr_stmt|;
block|}
name|rbtdb_changed_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rbtdb_changed_t
argument_list|)
name|rbtdb_changedlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|dns_db_insecure
block|,
name|dns_db_partial
block|,
name|dns_db_secure
block|}
name|dns_db_secure_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_rbtdb
name|dns_rbtdb_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_version
block|{
comment|/* Not locked */
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
comment|/* 	 * Protected in the refcount routines. 	 * XXXJT: should we change the lock policy based on the refcount 	 * performance? 	 */
name|isc_refcount_t
name|references
decl_stmt|;
comment|/* Locked by database lock. */
name|isc_boolean_t
name|writer
decl_stmt|;
name|isc_boolean_t
name|commit_ok
decl_stmt|;
name|rbtdb_changedlist_t
name|changed_list
decl_stmt|;
name|rdatasetheaderlist_t
name|resigned_list
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct rbtdb_version
argument_list|)
name|link
expr_stmt|;
name|dns_db_secure_t
name|secure
decl_stmt|;
name|isc_boolean_t
name|havensec3
decl_stmt|;
comment|/* NSEC3 parameters */
name|dns_hash_t
name|hash
decl_stmt|;
name|isc_uint8_t
name|flags
decl_stmt|;
name|isc_uint16_t
name|iterations
decl_stmt|;
name|isc_uint8_t
name|salt_length
decl_stmt|;
name|unsigned
name|char
name|salt
index|[
name|DNS_NSEC3_SALTSIZE
index|]
decl_stmt|;
block|}
name|rbtdb_version_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rbtdb_version_t
argument_list|)
name|rbtdb_versionlist_t
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|dns_rbtdb
block|{
comment|/* Unlocked. */
name|dns_db_t
name|common
decl_stmt|;
comment|/* Locks the data in this struct */
if|#
directive|if
name|DNS_RBTDB_USERWLOCK
name|isc_rwlock_t
name|lock
decl_stmt|;
else|#
directive|else
name|isc_mutex_t
name|lock
decl_stmt|;
endif|#
directive|endif
comment|/* Locks the tree structure (prevents nodes appearing/disappearing) */
name|isc_rwlock_t
name|tree_lock
decl_stmt|;
comment|/* Locks for individual tree nodes */
name|unsigned
name|int
name|node_lock_count
decl_stmt|;
name|rbtdb_nodelock_t
modifier|*
name|node_locks
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|origin_node
decl_stmt|;
name|dns_stats_t
modifier|*
name|rrsetstats
decl_stmt|;
comment|/* cache DB only */
comment|/* Locked by lock. */
name|unsigned
name|int
name|active
decl_stmt|;
name|isc_refcount_t
name|references
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|rbtdb_serial_t
name|current_serial
decl_stmt|;
name|rbtdb_serial_t
name|least_serial
decl_stmt|;
name|rbtdb_serial_t
name|next_serial
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|current_version
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|future_version
decl_stmt|;
name|rbtdb_versionlist_t
name|open_versions
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|soanode
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|nsnode
decl_stmt|;
comment|/* 	 * This is a linked list used to implement the LRU cache.  There will 	 * be node_lock_count linked lists here.  Nodes in bucket 1 will be 	 * placed on the linked list rdatasets[1]. 	 */
name|rdatasetheaderlist_t
modifier|*
name|rdatasets
decl_stmt|;
comment|/*% 	 * Temporary storage for stale cache nodes and dynamically deleted 	 * nodes that await being cleaned up. 	 */
name|rbtnodelist_t
modifier|*
name|deadnodes
decl_stmt|;
comment|/* 	 * Heaps.  These are used for TTL based expiry in a cache, 	 * or for zone resigning in a zone DB.  hmctx is the memory 	 * context to use for the heap (which differs from the main 	 * database memory context in the case of a cache). 	 */
name|isc_mem_t
modifier|*
name|hmctx
decl_stmt|;
name|isc_heap_t
modifier|*
modifier|*
name|heaps
decl_stmt|;
comment|/* Locked by tree_lock. */
name|dns_rbt_t
modifier|*
name|tree
decl_stmt|;
name|dns_rbt_t
modifier|*
name|nsec
decl_stmt|;
name|dns_rbt_t
modifier|*
name|nsec3
decl_stmt|;
name|dns_rpz_cidr_t
modifier|*
name|rpz_cidr
decl_stmt|;
comment|/* Unlocked */
name|unsigned
name|int
name|quantum
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RBTDB_ATTR_LOADED
value|0x01
end_define

begin_define
define|#
directive|define
name|RBTDB_ATTR_LOADING
value|0x02
end_define

begin_comment
comment|/*%  * Search Context  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|isc_boolean_t
name|copy_name
decl_stmt|;
name|isc_boolean_t
name|need_cleanup
decl_stmt|;
name|isc_boolean_t
name|wild
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|zonecut
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|zonecut_rdataset
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|zonecut_sigrdataset
decl_stmt|;
name|dns_fixedname_t
name|zonecut_name
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
block|}
name|rbtdb_search_t
typedef|;
end_typedef

begin_comment
comment|/*%  * Load Context  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
block|}
name|rbtdb_load_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_getnoqname
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|neg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|negsig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_getclosest
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|neg
parameter_list|,
name|dns_rdataset_t
modifier|*
name|negsig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_getadditional
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_setadditional
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_putadditional
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|isc_boolean_t
name|need_headerupdate
parameter_list|(
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_header
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_header
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_boolean_t
name|tree_locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overmem_purge
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|unsigned
name|int
name|locknum_start
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|tree_locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|resign_insert
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|int
name|idx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resign_delete
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_tree
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_settrust
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_trust_t
name|trust
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_expire
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_rdatasetmethods_t
name|rdataset_methods
init|=
block|{
name|rdataset_disassociate
block|,
name|rdataset_first
block|,
name|rdataset_next
block|,
name|rdataset_current
block|,
name|rdataset_clone
block|,
name|rdataset_count
block|,
name|NULL
block|,
name|rdataset_getnoqname
block|,
name|NULL
block|,
name|rdataset_getclosest
block|,
name|rdataset_getadditional
block|,
name|rdataset_setadditional
block|,
name|rdataset_putadditional
block|,
name|rdataset_settrust
block|,
name|rdataset_expire
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rdatasetiter_destroy
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdatasetiter_first
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdatasetiter_next
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdatasetiter_current
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_rdatasetitermethods_t
name|rdatasetiter_methods
init|=
block|{
name|rdatasetiter_destroy
block|,
name|rdatasetiter_first
block|,
name|rdatasetiter_next
block|,
name|rdatasetiter_current
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_rdatasetiter
block|{
name|dns_rdatasetiter_t
name|common
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|;
block|}
name|rbtdb_rdatasetiter_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|dbiterator_destroy
parameter_list|(
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_first
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_last
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_seek
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_prev
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_next
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_current
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_pause
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_origin
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_dbiteratormethods_t
name|dbiterator_methods
init|=
block|{
name|dbiterator_destroy
block|,
name|dbiterator_first
block|,
name|dbiterator_last
block|,
name|dbiterator_seek
block|,
name|dbiterator_prev
block|,
name|dbiterator_next
block|,
name|dbiterator_current
block|,
name|dbiterator_pause
block|,
name|dbiterator_origin
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DELETION_BATCH_MAX
value|64
end_define

begin_comment
comment|/*  * If 'paused' is ISC_TRUE, then the tree lock is not being held.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_dbiterator
block|{
name|dns_dbiterator_t
name|common
decl_stmt|;
name|isc_boolean_t
name|paused
decl_stmt|;
name|isc_boolean_t
name|new_origin
decl_stmt|;
name|isc_rwlocktype_t
name|tree_locked
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|name
decl_stmt|;
name|dns_fixedname_t
name|origin
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|dns_rbtnodechain_t
name|nsec3chain
decl_stmt|;
name|dns_rbtnodechain_t
modifier|*
name|current
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|deletions
index|[
name|DELETION_BATCH_MAX
index|]
decl_stmt|;
name|int
name|delete
decl_stmt|;
name|isc_boolean_t
name|nsec3only
decl_stmt|;
name|isc_boolean_t
name|nonsec3
decl_stmt|;
block|}
name|rbtdb_dbiterator_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|IS_STUB
parameter_list|(
name|rbtdb
parameter_list|)
value|(((rbtdb)->common.attributes& DNS_DBATTR_STUB)  != 0)
end_define

begin_define
define|#
directive|define
name|IS_CACHE
parameter_list|(
name|rbtdb
parameter_list|)
value|(((rbtdb)->common.attributes& DNS_DBATTR_CACHE) != 0)
end_define

begin_function_decl
specifier|static
name|void
name|free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_boolean_t
name|log
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|overmem
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|overmem
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function_decl
specifier|static
name|void
name|setnsec3parameters
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * 'init_count' is used to initialize 'newheader->count' which inturn  * is used to determine where in the cycle rrset-order cyclic starts.  * We don't lock this as we don't care about simultaneous updates.  *  * Note:  *      Both init_count and header->count can be ISC_UINT32_MAX.  *      The count on the returned rdataset however can't be as  *      that indicates that the database does not implement cyclic  *      processing.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|init_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locking  *  * If a routine is going to lock more than one lock in this module, then  * the locking must be done in the following order:  *  *      Tree Lock  *  *      Node Lock       (Only one from the set may be locked at one time by  *                       any caller)  *  *      Database Lock  *  * Failure to follow this hierarchy can result in deadlock.  */
end_comment

begin_comment
comment|/*  * Deleting Nodes  *  * For zone databases the node for the origin of the zone MUST NOT be deleted.  */
end_comment

begin_comment
comment|/*  * DB Routines  */
end_comment

begin_function
specifier|static
name|void
name|attach
parameter_list|(
name|dns_db_t
modifier|*
name|source
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|source
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rbtdb_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_rrsetstats
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_boolean_t
name|increment
parameter_list|)
block|{
name|dns_rdatastatstype_t
name|statattributes
init|=
literal|0
decl_stmt|;
name|dns_rdatastatstype_t
name|base
init|=
literal|0
decl_stmt|;
name|dns_rdatastatstype_t
name|type
decl_stmt|;
comment|/* At the moment we count statistics only for cache DB */
name|INSIST
argument_list|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEGATIVE
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|header
argument_list|)
condition|)
name|statattributes
operator|=
name|DNS_RDATASTATSTYPE_ATTR_NXDOMAIN
expr_stmt|;
else|else
block|{
name|statattributes
operator|=
name|DNS_RDATASTATSTYPE_ATTR_NXRRSET
expr_stmt|;
name|base
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|DNS_RDATASTATSTYPE_VALUE
argument_list|(
name|base
argument_list|,
name|statattributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
condition|)
name|dns_rdatasetstats_increment
argument_list|(
name|rbtdb
operator|->
name|rrsetstats
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|dns_rdatasetstats_decrement
argument_list|(
name|rbtdb
operator|->
name|rrsetstats
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_ttl
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|dns_ttl_t
name|newttl
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|isc_heap_t
modifier|*
name|heap
decl_stmt|;
name|dns_ttl_t
name|oldttl
decl_stmt|;
name|oldttl
operator|=
name|header
operator|->
name|rdh_ttl
expr_stmt|;
name|header
operator|->
name|rdh_ttl
operator|=
name|newttl
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
return|return;
comment|/* 	 * It's possible the rbtdb is not a cache.  If this is the case, 	 * we will not have a heap, and we move on.  If we do, though, 	 * we might need to adjust things. 	 */
if|if
condition|(
name|header
operator|->
name|heap_index
operator|==
literal|0
operator|||
name|newttl
operator|==
name|oldttl
condition|)
return|return;
name|idx
operator|=
name|header
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|heaps
operator|==
name|NULL
operator|||
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
return|return;
name|heap
operator|=
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|newttl
operator|<
name|oldttl
condition|)
name|isc_heap_increased
argument_list|(
name|heap
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
else|else
name|isc_heap_decreased
argument_list|(
name|heap
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * These functions allow the heap code to rank the priority of each  * element.  It returns ISC_TRUE if v1 happens "sooner" than v2.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|ttl_sooner
parameter_list|(
name|void
modifier|*
name|v1
parameter_list|,
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|h1
init|=
name|v1
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|h2
init|=
name|v2
decl_stmt|;
if|if
condition|(
name|h1
operator|->
name|rdh_ttl
operator|<
name|h2
operator|->
name|rdh_ttl
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|resign_sooner
parameter_list|(
name|void
modifier|*
name|v1
parameter_list|,
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|h1
init|=
name|v1
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|h2
init|=
name|v2
decl_stmt|;
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|h1
operator|->
name|resign
argument_list|,
name|h2
operator|->
name|resign
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * This function sets the heap index into the header.  */
end_comment

begin_function
specifier|static
name|void
name|set_index
parameter_list|(
name|void
modifier|*
name|what
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|h
init|=
name|what
decl_stmt|;
name|h
operator|->
name|heap_index
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Work out how many nodes can be deleted in the time between two  * requests to the nameserver.  Smooth the resulting number and use it  * as a estimate for the number of nodes to be deleted in the next  * iteration.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|adjust_quantum
parameter_list|(
name|unsigned
name|int
name|old
parameter_list|,
name|isc_time_t
modifier|*
name|start
parameter_list|)
block|{
name|unsigned
name|int
name|pps
init|=
name|dns_pps
decl_stmt|;
comment|/* packets per second */
name|unsigned
name|int
name|interval
decl_stmt|;
name|isc_uint64_t
name|usecs
decl_stmt|;
name|isc_time_t
name|end
decl_stmt|;
name|unsigned
name|int
name|new
decl_stmt|;
if|if
condition|(
name|pps
operator|<
literal|100
condition|)
name|pps
operator|=
literal|100
expr_stmt|;
name|isc_time_now
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
name|interval
operator|=
literal|1000000
operator|/
name|pps
expr_stmt|;
comment|/* interval in usec */
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
name|usecs
operator|=
name|isc_time_microdiff
argument_list|(
operator|&
name|end
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|usecs
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We were unable to measure the amount of time taken. 		 * Double the nodes deleted next time. 		 */
name|old
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|old
operator|>
literal|1000
condition|)
name|old
operator|=
literal|1000
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
name|new
operator|=
name|old
operator|*
name|interval
expr_stmt|;
name|new
operator|/=
operator|(
name|unsigned
name|int
operator|)
name|usecs
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
name|new
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|new
operator|>
literal|1000
condition|)
name|new
operator|=
literal|1000
expr_stmt|;
comment|/* Smooth */
name|new
operator|=
operator|(
name|new
operator|+
name|old
operator|*
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"adjust_quantum -> %d"
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_boolean_t
name|log
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_ondestroy_t
name|ondest
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_rbt_t
modifier|*
modifier|*
name|treep
decl_stmt|;
name|isc_time_t
name|start
decl_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
operator|==
name|dns_rdataclass_in
condition|)
name|overmem
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|(
name|isc_boolean_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|current_version
operator|!=
name|NULL
operator|||
name|EMPTY
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|future_version
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|current_version
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|refs
decl_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|current_version
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|current_version
operator|->
name|references
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtdb_version_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We assume the number of remaining dead nodes is reasonably small; 	 * the overhead of unlinking all nodes here should be negligible. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|i
index|]
argument_list|,
name|node
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
name|node
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
name|rbtdb
operator|->
name|quantum
operator|=
operator|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
operator|)
condition|?
literal|100
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * pick the next tree to (start to) destroy 		 */
name|treep
operator|=
operator|&
name|rbtdb
operator|->
name|tree
expr_stmt|;
if|if
condition|(
operator|*
name|treep
operator|==
name|NULL
condition|)
block|{
name|treep
operator|=
operator|&
name|rbtdb
operator|->
name|nsec
expr_stmt|;
if|if
condition|(
operator|*
name|treep
operator|==
name|NULL
condition|)
block|{
name|treep
operator|=
operator|&
name|rbtdb
operator|->
name|nsec3
expr_stmt|;
comment|/* 				 * we're finished after clear cutting 				 */
if|if
condition|(
operator|*
name|treep
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
name|isc_time_now
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_destroy2
argument_list|(
name|treep
argument_list|,
name|rbtdb
operator|->
name|quantum
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|quantum
operator|!=
literal|0
condition|)
name|rbtdb
operator|->
name|quantum
operator|=
name|adjust_quantum
argument_list|(
name|rbtdb
operator|->
name|quantum
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FREESTORAGE
argument_list|,
name|free_rbtdb_callback
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
continue|continue;
name|isc_task_send
argument_list|(
name|rbtdb
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|*
name|treep
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"done free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
argument_list|)
expr_stmt|;
name|NODE_DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up LRU / re-signing order lists. 	 */
if|if
condition|(
name|rbtdb
operator|->
name|rdatasets
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|rdatasets
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rdatasetheaderlist_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up dead node buckets. 	 */
if|if
condition|(
name|rbtdb
operator|->
name|deadnodes
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|deadnodes
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtnodelist_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up heap objects. 	 */
if|if
condition|(
name|rbtdb
operator|->
name|heaps
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|isc_heap_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|hmctx
argument_list|,
name|rbtdb
operator|->
name|heaps
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|isc_heap_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbtdb
operator|->
name|rrsetstats
operator|!=
name|NULL
condition|)
name|dns_stats_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|rrsetstats
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|rbtdb
operator|->
name|rpz_cidr
operator|!=
name|NULL
condition|)
name|dns_rpz_cidr_free
argument_list|(
operator|&
name|rbtdb
operator|->
name|rpz_cidr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_locks
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_rwlock_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
name|RBTDB_DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|ondest
operator|=
name|rbtdb
operator|->
name|common
operator|.
name|ondest
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|hmctx
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_ondestroy_notify
argument_list|(
operator|&
name|ondest
argument_list|,
name|rbtdb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|maybe_free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|)
block|{
name|isc_boolean_t
name|want_free
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|inactive
init|=
literal|0
decl_stmt|;
comment|/* XXX check for open versions here */
if|if
condition|(
name|rbtdb
operator|->
name|soanode
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|soanode
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|nsnode
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|nsnode
argument_list|)
expr_stmt|;
comment|/* 	 * Even though there are no external direct references, there still 	 * may be nodes in use. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_refcount_current
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inactive
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inactive
operator|!=
literal|0
condition|)
block|{
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|active
operator|-=
name|inactive
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|active
operator|==
literal|0
condition|)
name|want_free
operator|=
name|ISC_TRUE
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_free
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"calling free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|detach
parameter_list|(
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
operator|*
name|dbp
operator|)
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
name|maybe_free_rbtdb
argument_list|(
name|rbtdb
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|currentversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|version
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|version
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
operator|*
name|versionp
operator|=
operator|(
name|dns_dbversion_t
operator|*
operator|)
name|version
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|rbtdb_version_t
modifier|*
name|allocate_version
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|,
name|unsigned
name|int
name|references
parameter_list|,
name|isc_boolean_t
name|writer
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|version
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|version
operator|->
name|serial
operator|=
name|serial
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|version
operator|->
name|references
argument_list|,
name|references
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|version
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|version
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|version
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
name|version
operator|->
name|commit_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|resigned_list
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|newversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|versionp
operator|!=
name|NULL
operator|&&
operator|*
name|versionp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|future_version
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|rbtdb
operator|->
name|next_serial
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Error? */
name|version
operator|=
name|allocate_version
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|next_serial
argument_list|,
literal|1
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|version
operator|->
name|rbtdb
operator|=
name|rbtdb
expr_stmt|;
name|version
operator|->
name|commit_ok
operator|=
name|ISC_TRUE
expr_stmt|;
name|version
operator|->
name|secure
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|secure
expr_stmt|;
name|version
operator|->
name|havensec3
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|havensec3
expr_stmt|;
if|if
condition|(
name|version
operator|->
name|havensec3
condition|)
block|{
name|version
operator|->
name|flags
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|flags
expr_stmt|;
name|version
operator|->
name|iterations
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|iterations
expr_stmt|;
name|version
operator|->
name|hash
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|hash
expr_stmt|;
name|version
operator|->
name|salt_length
operator|=
name|rbtdb
operator|->
name|current_version
operator|->
name|salt_length
expr_stmt|;
name|memmove
argument_list|(
name|version
operator|->
name|salt
argument_list|,
name|rbtdb
operator|->
name|current_version
operator|->
name|salt
argument_list|,
name|version
operator|->
name|salt_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|version
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|version
operator|->
name|iterations
operator|=
literal|0
expr_stmt|;
name|version
operator|->
name|hash
operator|=
literal|0
expr_stmt|;
name|version
operator|->
name|salt_length
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|version
operator|->
name|salt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|version
operator|->
name|salt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rbtdb
operator|->
name|next_serial
operator|++
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|version
expr_stmt|;
block|}
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|*
name|versionp
operator|=
name|version
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attachversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|source
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|source
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|!=
name|NULL
operator|&&
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|rbtversion
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|>
literal|1
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|rbtversion
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rbtdb_changed_t
modifier|*
name|add_changed
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock if its reference must be 	 * protected by the lock. 	 */
name|changed
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|changed
argument_list|)
argument_list|)
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|version
operator|->
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
block|{
name|dns_rbtnode_refincrement
argument_list|(
name|node
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|changed
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|changed
operator|->
name|dirty
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|version
operator|->
name|commit_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_acachearray
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|acachectl_t
modifier|*
name|array
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
comment|/* 	 * The caller must be holding the corresponding node lock. 	 */
if|if
condition|(
name|array
operator|==
name|NULL
condition|)
return|return;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Sanity check: since an additional cache entry has a reference to 	 * the original DB node (in the callback arg), there should be no 	 * acache entries when the node can be freed. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|INSIST
argument_list|(
name|array
index|[
name|i
index|]
operator|.
name|entry
operator|==
name|NULL
operator|&&
name|array
index|[
name|i
index|]
operator|.
name|cbarg
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|array
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|acachectl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_noqname
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|struct
name|noqname
modifier|*
modifier|*
name|noqname
parameter_list|)
block|{
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
operator|(
operator|*
name|noqname
operator|)
operator|->
name|name
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
operator|(
operator|*
name|noqname
operator|)
operator|->
name|name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|neg
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|(
operator|*
name|noqname
operator|)
operator|->
name|neg
argument_list|,
name|dns_rdataslab_size
argument_list|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|neg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|negsig
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|(
operator|*
name|noqname
operator|)
operator|->
name|negsig
argument_list|,
name|dns_rdataslab_size
argument_list|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|negsig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|*
name|noqname
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|noqname
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|init_rdataset
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|h
parameter_list|)
block|{
name|ISC_LINK_INIT
argument_list|(
name|h
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|h
operator|->
name|heap_index
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|TRACE_HEADER
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
operator|==
name|dns_rdataclass_in
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"initialized header: %p\n"
argument_list|,
name|h
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|rbtdb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|rdatasetheader_t
modifier|*
name|new_rdataset
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
name|TRACE_HEADER
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
operator|==
name|dns_rdataclass_in
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocated header: %p\n"
argument_list|,
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_rdataset
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|EXISTS
argument_list|(
name|rdataset
argument_list|)
operator|&&
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|RDATASET_ATTR_STATCOUNT
operator|)
operator|!=
literal|0
condition|)
block|{
name|update_rrsetstats
argument_list|(
name|rbtdb
argument_list|,
name|rdataset
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|rdataset
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|idx
index|]
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|->
name|heap_index
operator|!=
literal|0
condition|)
name|isc_heap_delete
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
argument_list|,
name|rdataset
operator|->
name|heap_index
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|heap_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|noqname
operator|!=
name|NULL
condition|)
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|rdataset
operator|->
name|noqname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|closest
operator|!=
name|NULL
condition|)
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|rdataset
operator|->
name|closest
argument_list|)
expr_stmt|;
name|free_acachearray
argument_list|(
name|mctx
argument_list|,
name|rdataset
argument_list|,
name|rdataset
operator|->
name|additional_auth
argument_list|)
expr_stmt|;
name|free_acachearray
argument_list|(
name|mctx
argument_list|,
name|rdataset
argument_list|,
name|rdataset
operator|->
name|additional_glue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|RDATASET_ATTR_NONEXISTENT
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|dns_rdataslab_size
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rdataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdataset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rollback_node
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|dcurrent
decl_stmt|;
name|isc_boolean_t
name|make_dirty
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * Caller must hold the node lock. 	 */
comment|/* 	 * We set the IGNORE attribute on rdatasets with serial number 	 * 'serial'.  When the reference count goes to zero, these rdatasets 	 * will be cleaned up; until that time, they will be ignored. 	 */
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|==
name|serial
condition|)
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_IGNORE
expr_stmt|;
name|make_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
for|for
control|(
name|dcurrent
operator|=
name|header
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|dcurrent
operator|->
name|down
control|)
block|{
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|==
name|serial
condition|)
block|{
name|dcurrent
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_IGNORE
expr_stmt|;
name|make_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|make_dirty
condition|)
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clean_stale_headers
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|top
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|d
decl_stmt|,
modifier|*
name|down_next
decl_stmt|;
for|for
control|(
name|d
operator|=
name|top
operator|->
name|down
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|down_next
control|)
block|{
name|down_next
operator|=
name|d
operator|->
name|down
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|top
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clean_cache_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|top_prev
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|top_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|current
operator|=
name|node
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|/* 		 * If current is nonexistent or stale, we can clean it up. 		 */
if|if
condition|(
operator|(
name|current
operator|->
name|attributes
operator|&
operator|(
name|RDATASET_ATTR_NONEXISTENT
operator||
name|RDATASET_ATTR_STALE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
else|else
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
name|node
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clean_zone_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|least_serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|dcurrent
decl_stmt|,
modifier|*
name|down_next
decl_stmt|,
modifier|*
name|dparent
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|top_prev
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
name|isc_boolean_t
name|still_dirty
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|REQUIRE
argument_list|(
name|least_serial
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|top_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|current
operator|=
name|node
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
comment|/* 		 * First, we clean up any instances of multiple rdatasets 		 * with the same serial number, or that have the IGNORE 		 * attribute. 		 */
name|dparent
operator|=
name|current
expr_stmt|;
for|for
control|(
name|dcurrent
operator|=
name|current
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|down_next
control|)
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
name|INSIST
argument_list|(
name|dcurrent
operator|->
name|serial
operator|<=
name|dparent
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|==
name|dparent
operator|->
name|serial
operator|||
name|IGNORE
argument_list|(
name|dcurrent
argument_list|)
condition|)
block|{
if|if
condition|(
name|down_next
operator|!=
name|NULL
condition|)
name|down_next
operator|->
name|next
operator|=
name|dparent
expr_stmt|;
name|dparent
operator|->
name|down
operator|=
name|down_next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|dcurrent
argument_list|)
expr_stmt|;
block|}
else|else
name|dparent
operator|=
name|dcurrent
expr_stmt|;
block|}
comment|/* 		 * We've now eliminated all IGNORE datasets with the possible 		 * exception of current, which we now check. 		 */
if|if
condition|(
name|IGNORE
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|down_next
operator|=
name|current
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|down_next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|/* 				 * current no longer exists, so we can 				 * just continue with the loop. 				 */
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Pull up current->down, making it the new 				 * current. 				 */
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|down_next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|down_next
expr_stmt|;
name|down_next
operator|->
name|next
operator|=
name|top_next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|down_next
expr_stmt|;
block|}
block|}
comment|/* 		 * We now try to find the first down node less than the 		 * least serial. 		 */
name|dparent
operator|=
name|current
expr_stmt|;
for|for
control|(
name|dcurrent
operator|=
name|current
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|down_next
control|)
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|<
name|least_serial
condition|)
break|break;
name|dparent
operator|=
name|dcurrent
expr_stmt|;
block|}
comment|/* 		 * If there is a such an rdataset, delete it and any older 		 * versions. 		 */
if|if
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
name|INSIST
argument_list|(
name|dcurrent
operator|->
name|serial
operator|<=
name|least_serial
argument_list|)
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|dcurrent
argument_list|)
expr_stmt|;
name|dcurrent
operator|=
name|down_next
expr_stmt|;
block|}
do|while
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
do|;
name|dparent
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Note.  The serial number of 'current' might be less than 		 * least_serial too, but we cannot delete it because it is 		 * the most recent version, unless it is a NONEXISTENT 		 * rdataset. 		 */
if|if
condition|(
name|current
operator|->
name|down
operator|!=
name|NULL
condition|)
block|{
name|still_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this is a NONEXISTENT rdataset, we can delete it. 			 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|current
argument_list|)
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
else|else
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|still_dirty
condition|)
name|node
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|nsecnode
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_UNEXPECTED
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|node
operator|->
name|nsec
condition|)
block|{
case|case
name|DNS_RBT_NSEC_NORMAL
case|:
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|rbtdb
operator|->
name|rpz_cidr
operator|!=
name|NULL
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_rbt_fullnamefromnode
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dns_rpz_cidr_deleteip
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RBT_NSEC_HAS_NSEC
case|:
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_rbt_fullnamefromnode
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Delete the corresponding node from the auxiliary NSEC 		 * tree before deleting from the main tree. 		 */
name|nsecnode
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|nsec
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsecnode
argument_list|,
name|NULL
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"delete_node: "
literal|"dns_rbt_findnode(nsec): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|nsec
argument_list|,
name|nsecnode
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"delete_node(): "
literal|"dns_rbt_deletenode(nsecnode): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|rbtdb
operator|->
name|rpz_cidr
operator|!=
name|NULL
condition|)
name|dns_rpz_cidr_deleteip
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RBT_NSEC_NSEC
case|:
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|nsec
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RBT_NSEC_NSEC3
case|:
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"delete_cnode(): "
literal|"dns_rbt_deletenode: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*%  * Clean up dead nodes.  These are nodes which have no references, and  * have no data.  They are dead but we could not or chose not to delete  * them when we deleted all the data at that node because we did not want  * to wait for the tree write lock.  *  * The caller must hold a tree write lock and bucketnum'th node (write) lock.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_dead_nodes
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|int
name|bucketnum
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|int
name|count
init|=
literal|10
decl_stmt|;
comment|/* XXXJT: should be adjustable */
name|node
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|bucketnum
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|bucketnum
index|]
argument_list|,
name|node
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
comment|/* 		 * Since we're holding a tree write lock, it should be 		 * impossible for this node to be referenced by others. 		 */
name|INSIST
argument_list|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|&&
name|node
operator|->
name|data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|delete_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|bucketnum
index|]
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Caller must be holding the node lock.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|new_reference
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|int
name|lockrefs
decl_stmt|,
name|noderefs
decl_stmt|;
name|isc_refcount_t
modifier|*
name|lockref
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbtnode_refincrement0
argument_list|(
name|node
argument_list|,
operator|&
name|noderefs
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderefs
operator|==
literal|1
condition|)
block|{
comment|/* this is the first reference to the node */
name|lockref
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|references
expr_stmt|;
name|isc_refcount_increment0
argument_list|(
name|lockref
argument_list|,
operator|&
name|lockrefs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|lockrefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|noderefs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is assumed to be called when a node is newly referenced  * and can be in the deadnode list.  In that case the node must be retrieved  * from the list because it is going to be used.  In addition, if the caller  * happens to hold a write lock on the tree, it's a good chance to purge dead  * nodes.  * Note: while a new reference is gained in multiple places, there are only very  * few cases where the node can be in the deadnode list (only empty nodes can  * have been added to the list).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reactivate_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|isc_rwlocktype_t
name|treelocktype
parameter_list|)
block|{
name|isc_rwlocktype_t
name|locktype
init|=
name|isc_rwlocktype_read
decl_stmt|;
name|nodelock_t
modifier|*
name|nodelock
init|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
decl_stmt|;
name|isc_boolean_t
name|maybe_cleanup
init|=
name|ISC_FALSE
decl_stmt|;
name|POST
argument_list|(
name|locktype
argument_list|)
expr_stmt|;
name|NODE_STRONGLOCK
argument_list|(
name|nodelock
argument_list|)
expr_stmt|;
name|NODE_WEAKLOCK
argument_list|(
name|nodelock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we can possibly cleanup the dead node.  If so, upgrade 	 * the node lock below to perform the cleanup. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|node
operator|->
name|locknum
index|]
argument_list|)
operator|&&
name|treelocktype
operator|==
name|isc_rwlocktype_write
condition|)
block|{
name|maybe_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
operator|||
name|maybe_cleanup
condition|)
block|{
comment|/* 		 * Upgrade the lock and test if we still need to unlink. 		 */
name|NODE_WEAKUNLOCK
argument_list|(
name|nodelock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|POST
argument_list|(
name|locktype
argument_list|)
expr_stmt|;
name|NODE_WEAKLOCK
argument_list|(
name|nodelock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|node
operator|->
name|locknum
index|]
argument_list|,
name|node
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|maybe_cleanup
condition|)
name|cleanup_dead_nodes
argument_list|(
name|rbtdb
argument_list|,
name|node
operator|->
name|locknum
argument_list|)
expr_stmt|;
block|}
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|NODE_WEAKUNLOCK
argument_list|(
name|nodelock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
name|nodelock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Caller must be holding the node lock; either the "strong", read or write  * lock.  Note that the lock must be held even when node references are  * atomically modified; in that case the decrement operation itself does not  * have to be protected, but we must avoid a race condition where multiple  * threads are decreasing the reference to zero simultaneously and at least  * one of them is going to free the node.  * This function returns ISC_TRUE if and only if the node reference decreases  * to zero.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|decrement_reference
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|least_serial
parameter_list|,
name|isc_rwlocktype_t
name|nlock
parameter_list|,
name|isc_rwlocktype_t
name|tlock
parameter_list|,
name|isc_boolean_t
name|pruning
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|write_locked
decl_stmt|;
name|rbtdb_nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|,
name|nrefs
decl_stmt|;
name|int
name|bucket
init|=
name|node
operator|->
name|locknum
decl_stmt|;
name|isc_boolean_t
name|no_reference
init|=
name|ISC_TRUE
decl_stmt|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|bucket
index|]
expr_stmt|;
define|#
directive|define
name|KEEP_NODE
parameter_list|(
name|n
parameter_list|,
name|r
parameter_list|)
define|\
value|((n)->data != NULL || (n)->down != NULL || (n) == (r)->origin_node)
comment|/* Handle easy and typical case first. */
if|if
condition|(
operator|!
name|node
operator|->
name|dirty
operator|&&
name|KEEP_NODE
argument_list|(
name|node
argument_list|,
name|rbtdb
argument_list|)
condition|)
block|{
name|dns_rbtnode_refdecrement
argument_list|(
name|node
argument_list|,
operator|&
name|nrefs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|int
operator|)
name|nrefs
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrefs
operator|==
literal|0
condition|)
block|{
name|isc_refcount_decrement
argument_list|(
operator|&
name|nodelock
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|int
operator|)
name|refs
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|nrefs
operator|==
literal|0
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* Upgrade the lock? */
if|if
condition|(
name|nlock
operator|==
name|isc_rwlocktype_read
condition|)
block|{
name|NODE_WEAKUNLOCK
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|NODE_WEAKLOCK
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
name|dns_rbtnode_refdecrement
argument_list|(
name|node
argument_list|,
operator|&
name|nrefs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|int
operator|)
name|nrefs
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrefs
operator|>
literal|0
condition|)
block|{
comment|/* Restore the lock? */
if|if
condition|(
name|nlock
operator|==
name|isc_rwlocktype_read
condition|)
name|NODE_WEAKDOWNGRADE
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|node
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|clean_cache_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|least_serial
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Caller doesn't know the least serial. 				 * Get it. 				 */
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|least_serial
operator|=
name|rbtdb
operator|->
name|least_serial
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
name|clean_zone_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|least_serial
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Attempt to switch to a write lock on the tree.  If this fails, 	 * we will add this node to a linked list of nodes in this locking 	 * bucket which we will free later. 	 */
if|if
condition|(
name|tlock
operator|!=
name|isc_rwlocktype_write
condition|)
block|{
comment|/* 		 * Locking hierarchy notwithstanding, we don't need to free 		 * the node lock before acquiring the tree write lock because 		 * we only do a trylock. 		 */
if|if
condition|(
name|tlock
operator|==
name|isc_rwlocktype_read
condition|)
name|result
operator|=
name|isc_rwlock_tryupgrade
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|isc_rwlock_trylock
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_LOCKBUSY
argument_list|)
expr_stmt|;
name|write_locked
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
name|write_locked
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|nodelock
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|int
operator|)
name|refs
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|KEEP_NODE
argument_list|(
name|node
argument_list|,
name|rbtdb
argument_list|)
condition|)
goto|goto
name|restore_locks
goto|;
undef|#
directive|undef
name|KEEP_NODE
if|if
condition|(
name|write_locked
condition|)
block|{
comment|/* 		 * We can now delete the node. 		 */
comment|/* 		 * If this node is the only one in the level it's in, deleting 		 * this node may recursively make its parent the only node in 		 * the parent level; if so, and if no one is currently using 		 * the parent node, this is almost the only opportunity to 		 * clean it up.  But the recursive cleanup is not that trivial 		 * since the child and parent may be in different lock buckets, 		 * which would cause a lock order reversal problem.  To avoid 		 * the trouble, we'll dispatch a separate event for batch 		 * cleaning.  We need to check whether we're deleting the node 		 * as a result of pruning to avoid infinite dispatching. 		 * Note: pruning happens only when a task has been set for the 		 * rbtdb.  If the user of the rbtdb chooses not to set a task, 		 * it's their responsibility to purge stale leaves (e.g. by 		 * periodic walk-through). 		 */
if|if
condition|(
operator|!
name|pruning
operator|&&
name|node
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|parent
operator|->
name|down
operator|==
name|node
operator|&&
name|node
operator|->
name|left
operator|==
name|NULL
operator|&&
name|node
operator|->
name|right
operator|==
name|NULL
operator|&&
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
block|{
name|isc_event_t
modifier|*
name|ev
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|ev
operator|=
name|isc_event_allocate
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_RBTPRUNE
argument_list|,
name|prune_tree
argument_list|,
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|attach
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|ev
operator|->
name|ev_sender
operator|=
name|db
expr_stmt|;
name|isc_task_send
argument_list|(
name|rbtdb
operator|->
name|task
argument_list|,
operator|&
name|ev
argument_list|)
expr_stmt|;
name|no_reference
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX: this is a weird situation.  We could 				 * ignore this error case, but then the stale 				 * node will unlikely be purged except via a 				 * rare condition such as manual cleanup.  So 				 * we queue it in the deadnodes list, hoping 				 * the memory shortage is temporary and the node 				 * will be deleted later. 				 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"decrement_reference: failed to "
literal|"allocate pruning event"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|bucket
index|]
argument_list|,
name|node
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"decrement_reference: "
literal|"delete from rbt: %p %s"
argument_list|,
name|node
argument_list|,
name|dns_rbt_formatnodename
argument_list|(
name|node
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delete_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|node
operator|->
name|data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|bucket
index|]
argument_list|,
name|node
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
block|}
name|restore_locks
label|:
comment|/* Restore the lock? */
if|if
condition|(
name|nlock
operator|==
name|isc_rwlocktype_read
condition|)
name|NODE_WEAKDOWNGRADE
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Relock a read lock, or unlock the write lock if no lock was held. 	 */
if|if
condition|(
name|tlock
operator|==
name|isc_rwlocktype_none
condition|)
if|if
condition|(
name|write_locked
condition|)
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlock
operator|==
name|isc_rwlocktype_read
condition|)
if|if
condition|(
name|write_locked
condition|)
name|isc_rwlock_downgrade
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_reference
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prune the tree by recursively cleaning-up single leaves.  In the worst  * case, the number of iteration is the number of tree levels, which is at  * most the maximum number of domain name labels, i.e, 127.  In practice, this  * should be much smaller (only a few times), and even the worst case would be  * acceptable for a single event.  */
end_comment

begin_function
specifier|static
name|void
name|prune_tree
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|event
operator|->
name|ev_sender
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|parent
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|locknum
operator|=
name|node
operator|->
name|locknum
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
do|do
block|{
name|parent
operator|=
name|node
operator|->
name|parent
expr_stmt|;
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_write
argument_list|,
name|isc_rwlocktype_write
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
operator|&&
name|parent
operator|->
name|down
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * node was the only down child of the parent and has 			 * just been removed.  We'll then need to examine the 			 * parent.  Keep the lock if possible; otherwise, 			 * release the old lock and acquire one for the parent. 			 */
if|if
condition|(
name|parent
operator|->
name|locknum
operator|!=
name|locknum
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|locknum
operator|=
name|parent
operator|->
name|locknum
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We need to gain a reference to the node before 			 * decrementing it in the next iteration.  In addition, 			 * if the node is in the dead-nodes list, extract it 			 * from the list beforehand as we do in 			 * reactivate_node(). 			 */
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|parent
argument_list|,
name|deadlink
argument_list|)
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|locknum
index|]
argument_list|,
name|parent
argument_list|,
name|deadlink
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|=
name|parent
expr_stmt|;
block|}
do|while
condition|(
name|node
operator|!=
name|NULL
condition|)
do|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|detach
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|*
operator|)
operator|&
name|rbtdb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|make_least_version
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rbtdb_changedlist_t
modifier|*
name|cleanup_list
parameter_list|)
block|{
comment|/* 	 * Caller must be holding the database lock. 	 */
name|rbtdb
operator|->
name|least_serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
operator|*
name|cleanup_list
operator|=
name|version
operator|->
name|changed_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cleanup_nondirty
parameter_list|(
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rbtdb_changedlist_t
modifier|*
name|cleanup_list
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|,
modifier|*
name|next_changed
decl_stmt|;
comment|/* 	 * If the changed record is dirty, then 	 * an update created multiple versions of 	 * a given rdataset.  We keep this list 	 * until we're the least open version, at 	 * which point it's safe to get rid of any 	 * older versions. 	 * 	 * If the changed record isn't dirty, then 	 * we don't need it anymore since we're 	 * committing and not rolling back. 	 * 	 * The caller must be holding the database lock. 	 */
for|for
control|(
name|changed
operator|=
name|HEAD
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
init|;
name|changed
operator|!=
name|NULL
condition|;
name|changed
operator|=
name|next_changed
control|)
block|{
name|next_changed
operator|=
name|NEXT
argument_list|(
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
operator|->
name|dirty
condition|)
block|{
name|UNLINK
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
operator|*
name|cleanup_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iszonesecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|origin
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BIND9
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|origin
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|dns_rdataset_t
name|keyset
decl_stmt|;
name|dns_rdataset_t
name|nsecset
decl_stmt|,
name|signsecset
decl_stmt|;
name|isc_boolean_t
name|haszonekey
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|hasnsec
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|origin
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|keyset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_t
name|keyrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|keyset
argument_list|,
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zonekey_iszonekey
argument_list|(
operator|&
name|keyrdata
argument_list|)
condition|)
block|{
name|haszonekey
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|haszonekey
condition|)
block|{
name|version
operator|->
name|secure
operator|=
name|dns_db_insecure
expr_stmt|;
name|version
operator|->
name|havensec3
operator|=
name|ISC_FALSE
expr_stmt|;
return|return;
block|}
name|dns_rdataset_init
argument_list|(
operator|&
name|nsecset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|signsecset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|origin
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nsecset
argument_list|,
operator|&
name|signsecset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|signsecset
argument_list|)
condition|)
block|{
name|hasnsec
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|signsecset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsecset
argument_list|)
expr_stmt|;
block|}
name|setnsec3parameters
argument_list|(
name|db
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|/* 	 * Do we have a valid NSEC/NSEC3 chain? 	 */
if|if
condition|(
name|version
operator|->
name|havensec3
operator|||
name|hasnsec
condition|)
name|version
operator|->
name|secure
operator|=
name|dns_db_secure
expr_stmt|;
else|else
name|version
operator|->
name|secure
operator|=
name|dns_db_insecure
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*%<  * Walk the origin node looking for NSEC3PARAM records.  * Cache the nsec3 parameters.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
specifier|static
name|void
name|setnsec3parameters
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rdata_nsec3param_t
name|nsec3param
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|count
decl_stmt|,
name|length
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|version
operator|->
name|havensec3
operator|=
name|ISC_FALSE
expr_stmt|;
name|node
operator|=
name|rbtdb
operator|->
name|origin_node
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|version
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
operator|&&
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3param
operator|)
condition|)
block|{
comment|/* 			 * Find A NSEC3PARAM with a supported algorithm. 			 */
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
comment|/* count */
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
name|count
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
operator|>
literal|0U
condition|)
block|{
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|region
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|region
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|raw
operator|+=
name|length
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
operator|&
name|rdata
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
name|dns_rdatatype_nsec3param
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3param
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3param
operator|.
name|hash
operator|!=
name|DNS_NSEC3_UNKNOWNALG
operator|&&
operator|!
name|dns_nsec3_supportedhash
argument_list|(
name|nsec3param
operator|.
name|hash
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|nsec3param
operator|.
name|flags
operator|!=
literal|0
condition|)
continue|continue;
name|memmove
argument_list|(
name|version
operator|->
name|salt
argument_list|,
name|nsec3param
operator|.
name|salt
argument_list|,
name|nsec3param
operator|.
name|salt_length
argument_list|)
expr_stmt|;
name|version
operator|->
name|hash
operator|=
name|nsec3param
operator|.
name|hash
expr_stmt|;
name|version
operator|->
name|salt_length
operator|=
name|nsec3param
operator|.
name|salt_length
expr_stmt|;
name|version
operator|->
name|iterations
operator|=
name|nsec3param
operator|.
name|iterations
expr_stmt|;
name|version
operator|->
name|flags
operator|=
name|nsec3param
operator|.
name|flags
expr_stmt|;
name|version
operator|->
name|havensec3
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * Look for a better algorithm than the 				 * unknown test algorithm. 				 */
if|if
condition|(
name|nsec3param
operator|.
name|hash
operator|!=
name|DNS_NSEC3_UNKNOWNALG
condition|)
goto|goto
name|unlock
goto|;
block|}
block|}
block|}
name|unlock
label|:
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|cleanup_dead_nodes_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|again
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
for|for
control|(
name|locknum
operator|=
literal|0
init|;
name|locknum
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|locknum
operator|++
control|)
block|{
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|cleanup_dead_nodes
argument_list|(
name|rbtdb
argument_list|,
name|locknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|locknum
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|again
operator|=
name|ISC_TRUE
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|again
condition|)
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
else|else
block|{
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
name|maybe_free_rbtdb
argument_list|(
name|rbtdb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|closeversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
name|commit
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|,
modifier|*
name|cleanup_version
decl_stmt|,
modifier|*
name|least_greater
decl_stmt|;
name|isc_boolean_t
name|rollback
init|=
name|ISC_FALSE
decl_stmt|;
name|rbtdb_changedlist_t
name|cleanup_list
decl_stmt|;
name|rdatasetheaderlist_t
name|resigned_list
decl_stmt|;
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|,
modifier|*
name|next_changed
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|,
name|least_serial
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_boolean_t
name|writer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|version
operator|=
operator|(
name|rbtdb_version_t
operator|*
operator|)
operator|*
name|versionp
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|cleanup_version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|cleanup_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|resigned_list
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|version
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|>
literal|0
condition|)
block|{
comment|/* typical and easy case first */
if|if
condition|(
name|commit
condition|)
block|{
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|version
operator|->
name|writer
argument_list|)
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
goto|goto
name|end
goto|;
block|}
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
name|writer
operator|=
name|version
operator|->
name|writer
expr_stmt|;
if|if
condition|(
name|version
operator|->
name|writer
condition|)
block|{
if|if
condition|(
name|commit
condition|)
block|{
name|unsigned
name|cur_ref
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|cur_version
decl_stmt|;
name|INSIST
argument_list|(
name|version
operator|->
name|commit_ok
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|==
name|rbtdb
operator|->
name|future_version
argument_list|)
expr_stmt|;
comment|/* 			 * The current version is going to be replaced. 			 * Release the (likely last) reference to it from the 			 * DB itself and unlink it from the open list. 			 */
name|cur_version
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|cur_version
operator|->
name|references
argument_list|,
operator|&
name|cur_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_ref
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cur_version
operator|->
name|serial
operator|==
name|rbtdb
operator|->
name|least_serial
condition|)
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|cur_version
operator|->
name|changed_list
argument_list|)
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|cur_version
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EMPTY
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
condition|)
block|{
comment|/* 				 * We're going to become the least open 				 * version. 				 */
name|make_least_version
argument_list|(
name|rbtdb
argument_list|,
name|version
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Some other open version is the 				 * least version.  We can't cleanup 				 * records that were changed in this 				 * version because the older versions 				 * may still be in use by an open 				 * version. 				 * 				 * We can, however, discard the 				 * changed records for things that 				 * we've added that didn't exist in 				 * prior versions. 				 */
name|cleanup_nondirty
argument_list|(
name|version
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the (soon to be former) current version 			 * isn't being used by anyone, we can clean 			 * it up. 			 */
if|if
condition|(
name|cur_ref
operator|==
literal|0
condition|)
block|{
name|cleanup_version
operator|=
name|cur_version
expr_stmt|;
name|APPENDLIST
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|cleanup_version
operator|->
name|changed_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Become the current version. 			 */
name|version
operator|->
name|writer
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|=
name|version
expr_stmt|;
name|rbtdb
operator|->
name|current_serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Keep the current version in the open list, and 			 * gain a reference for the DB itself (see the DB 			 * creation function below).  This must be the only 			 * case where we need to increment the counter from 			 * zero and need to use isc_refcount_increment0(). 			 */
name|isc_refcount_increment0
argument_list|(
operator|&
name|version
operator|->
name|references
argument_list|,
operator|&
name|cur_ref
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|cur_ref
operator|==
literal|1
argument_list|)
expr_stmt|;
name|PREPEND
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|resigned_list
operator|=
name|version
operator|->
name|resigned_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|resigned_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're rolling back this transaction. 			 */
name|cleanup_list
operator|=
name|version
operator|->
name|changed_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
name|resigned_list
operator|=
name|version
operator|->
name|resigned_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|resigned_list
argument_list|)
expr_stmt|;
name|rollback
operator|=
name|ISC_TRUE
expr_stmt|;
name|cleanup_version
operator|=
name|version
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|version
operator|!=
name|rbtdb
operator|->
name|current_version
condition|)
block|{
comment|/* 			 * There are no external or internal references 			 * to this version and it can be cleaned up. 			 */
name|cleanup_version
operator|=
name|version
expr_stmt|;
comment|/* 			 * Find the version with the least serial 			 * number greater than ours. 			 */
name|least_greater
operator|=
name|PREV
argument_list|(
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_greater
operator|==
name|NULL
condition|)
name|least_greater
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|->
name|serial
operator|<
name|least_greater
operator|->
name|serial
argument_list|)
expr_stmt|;
comment|/* 			 * Is this the least open version? 			 */
if|if
condition|(
name|version
operator|->
name|serial
operator|==
name|rbtdb
operator|->
name|least_serial
condition|)
block|{
comment|/* 				 * Yes.  Install the new least open 				 * version. 				 */
name|make_least_version
argument_list|(
name|rbtdb
argument_list|,
name|least_greater
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Add any unexecuted cleanups to 				 * those of the least greater version. 				 */
name|APPENDLIST
argument_list|(
name|least_greater
operator|->
name|changed_list
argument_list|,
name|version
operator|->
name|changed_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|->
name|serial
operator|==
name|rbtdb
operator|->
name|least_serial
condition|)
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|least_serial
operator|=
name|rbtdb
operator|->
name|least_serial
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status. 	 */
if|if
condition|(
name|writer
operator|&&
name|commit
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_version
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|cleanup_version
operator|->
name|changed_list
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|cleanup_version
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cleanup_version
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Commit/rollback re-signed headers. 	 */
for|for
control|(
name|header
operator|=
name|HEAD
argument_list|(
name|resigned_list
argument_list|)
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|HEAD
argument_list|(
name|resigned_list
argument_list|)
control|)
block|{
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|resigned_list
argument_list|,
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|rollback
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|resign_insert
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
operator|->
name|locknum
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ZONE
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"Unable to reinsert header to "
literal|"re-signing heap: %s\n"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
argument_list|,
name|least_serial
argument_list|,
name|isc_rwlocktype_write
argument_list|,
name|isc_rwlocktype_none
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|cleanup_list
argument_list|)
condition|)
block|{
name|isc_event_t
modifier|*
name|event
init|=
name|NULL
decl_stmt|;
name|isc_rwlocktype_t
name|tlock
init|=
name|isc_rwlocktype_none
decl_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_RBTDEADNODES
argument_list|,
name|cleanup_dead_nodes_callback
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We acquire a tree write lock here in order to make 			 * sure that stale nodes will be removed in 			 * decrement_reference().  If we didn't have the lock, 			 * those nodes could miss the chance to be removed 			 * until the server stops.  The write lock is 			 * expensive, but this event should be rare enough 			 * to justify the cost. 			 */
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|tlock
operator|=
name|isc_rwlocktype_write
expr_stmt|;
block|}
for|for
control|(
name|changed
operator|=
name|HEAD
argument_list|(
name|cleanup_list
argument_list|)
init|;
name|changed
operator|!=
name|NULL
condition|;
name|changed
operator|=
name|next_changed
control|)
block|{
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|next_changed
operator|=
name|NEXT
argument_list|(
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rbtnode
operator|=
name|changed
operator|->
name|node
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 			 * This is a good opportunity to purge any dead nodes, 			 * so use it. 			 */
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
name|cleanup_dead_nodes
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
operator|->
name|locknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rollback
condition|)
name|rollback_node
argument_list|(
name|rbtnode
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|least_serial
argument_list|,
name|isc_rwlocktype_write
argument_list|,
name|tlock
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|changed
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|changed
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
block|{
name|isc_refcount_increment
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|rbtdb
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
name|end
label|:
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the necessary magic for the wildcard name 'name'  * to be found in 'rbtdb'.  *  * In order for wildcard matching to work correctly in  * zone_find(), we must ensure that a node for the wildcarding  * level exists in the database, and has its 'find_callback'  * and 'wild' bits set.  *  * E.g. if the wildcard name is "*.sub.example." then we  * must ensure that "sub.example." exists and is marked as  * a wildcard level.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|add_wildcard_magic
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|foundname
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NORMAL
expr_stmt|;
name|node
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|wild
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_empty_wildcards
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
expr_stmt|;
name|i
operator|=
name|l
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* dummy */
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|n
operator|-
name|i
argument_list|,
name|i
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
operator|&
name|foundname
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|foundname
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NORMAL
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|findnodeintree
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbt_t
modifier|*
name|tree
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_name_t
name|nodename
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
init|=
name|isc_rwlocktype_read
decl_stmt|;
name|INSIST
argument_list|(
name|tree
operator|==
name|rbtdb
operator|->
name|tree
operator|||
name|tree
operator|==
name|rbtdb
operator|->
name|nsec3
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|nodename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|tree
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|create
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 		 * It would be nice to try to upgrade the lock instead of 		 * unlocking then relocking. 		 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|tree
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|tree
operator|==
name|rbtdb
operator|->
name|tree
operator|&&
name|rbtdb
operator|->
name|rpz_cidr
operator|!=
name|NULL
condition|)
block|{
name|dns_fixedname_t
name|fnamef
decl_stmt|;
name|dns_name_t
modifier|*
name|fname
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnamef
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnamef
argument_list|)
expr_stmt|;
name|dns_rbt_fullnamefromnode
argument_list|(
name|node
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dns_rpz_cidr_addip
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|node
operator|->
name|locknum
operator|=
name|node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|nodename
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tree
operator|==
name|rbtdb
operator|->
name|tree
condition|)
block|{
name|add_empty_wildcards
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|tree
operator|==
name|rbtdb
operator|->
name|nsec3
condition|)
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NSEC3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tree
operator|==
name|rbtdb
operator|->
name|nsec3
condition|)
name|INSIST
argument_list|(
name|node
operator|->
name|nsec
operator|==
name|DNS_RBT_NSEC_NSEC3
argument_list|)
expr_stmt|;
name|reactivate_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
operator|(
name|dns_dbnode_t
operator|*
operator|)
name|node
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|findnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|findnodeintree
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|create
argument_list|,
name|nodep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|findnsec3node
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|findnodeintree
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|create
argument_list|,
name|nodep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_zonecut_callback
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rbtdb_search_t
modifier|*
name|search
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|dname_header
decl_stmt|,
modifier|*
name|sigdname_header
decl_stmt|,
modifier|*
name|ns_header
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|onode
decl_stmt|;
comment|/* 	 * We only want to remember the topmost zone cut, since it's the one 	 * that counts, so we'll just continue if we've already found a 	 * zonecut. 	 */
if|if
condition|(
name|search
operator|->
name|zonecut
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
name|found
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|onode
operator|=
name|search
operator|->
name|rbtdb
operator|->
name|origin_node
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an NS or DNAME rdataset active in our version. 	 */
name|ns_header
operator|=
name|NULL
expr_stmt|;
name|dname_header
operator|=
name|NULL
expr_stmt|;
name|sigdname_header
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
operator|||
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
condition|)
block|{
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
condition|)
name|dname_header
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
condition|)
name|sigdname_header
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|!=
name|onode
operator|||
name|IS_STUB
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|)
condition|)
block|{
comment|/* 					 * We've found an NS rdataset that 					 * isn't at the origin node.  We check 					 * that they're not at the origin node, 					 * because otherwise we'd erroneously 					 * treat the zone top as if it were 					 * a delegation. 					 */
name|ns_header
operator|=
name|header
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Did we find anything? 	 */
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|)
operator|&&
operator|!
name|IS_STUB
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|)
operator|&&
name|ns_header
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Note that NS has precedence over DNAME if both exist 		 * in a zone.  Otherwise DNAME take precedence over NS. 		 */
name|found
operator|=
name|ns_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dname_header
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|dname_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|sigdname_header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ns_header
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ns_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We increment the reference count on node to ensure that 		 * search->zonecut_rdataset will still be valid later. 		 */
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|search
operator|->
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|zonecut_rdataset
operator|=
name|found
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Since we've found a zonecut, anything beneath it is 		 * glue and is not subject to wildcard matching, so we 		 * may clear search->wild. 		 */
name|search
operator|->
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the caller does not want to find glue, then 			 * this is the best answer and the search should 			 * stop now. 			 */
name|result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
block|}
else|else
block|{
name|dns_name_t
modifier|*
name|zcname
decl_stmt|;
comment|/* 			 * The search will continue beneath the zone cut. 			 * This may or may not be the best match.  In case it 			 * is, we need to remember the node name. 			 */
name|zcname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|search
operator|->
name|zonecut_name
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|zcname
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|search
operator|->
name|copy_name
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * There is no zonecut at this node which is active in this 		 * version. 		 * 		 * If this is a "wild" node and the caller hasn't disabled 		 * wildcard matching, remember that we've seen a wild node 		 * in case we need to go searching for wildcard matches 		 * later on. 		 */
if|if
condition|(
name|node
operator|->
name|wild
operator|&&
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_NOWILD
operator|)
operator|==
literal|0
condition|)
name|search
operator|->
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bind_rdataset
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
comment|/* 	 * Caller must be holding the node reader lock. 	 * XXXJT: technically, we need a writer lock, since we'll increment 	 * the header count below.  However, since the actual counter value 	 * doesn't matter, we prioritize performance here.  (We may want to 	 * use atomic increment when available). 	 */
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
return|return;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|->
name|methods
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must be disassociated. */
name|rdataset
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|rdataset
operator|->
name|rdclass
operator|=
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
expr_stmt|;
name|rdataset
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|ttl
operator|=
name|header
operator|->
name|rdh_ttl
operator|-
name|now
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|header
operator|->
name|trust
expr_stmt|;
if|if
condition|(
name|NEGATIVE
argument_list|(
name|header
argument_list|)
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NEGATIVE
expr_stmt|;
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|header
argument_list|)
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NXDOMAIN
expr_stmt|;
if|if
condition|(
name|OPTOUT
argument_list|(
name|header
argument_list|)
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_OPTOUT
expr_stmt|;
name|rdataset
operator|->
name|private1
operator|=
name|rbtdb
expr_stmt|;
name|rdataset
operator|->
name|private2
operator|=
name|node
expr_stmt|;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|private3
operator|=
name|raw
expr_stmt|;
name|rdataset
operator|->
name|count
operator|=
name|header
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|count
operator|==
name|ISC_UINT32_MAX
condition|)
name|rdataset
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|rdataset
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Add noqname proof. 	 */
name|rdataset
operator|->
name|private6
operator|=
name|header
operator|->
name|noqname
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|private6
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NOQNAME
expr_stmt|;
name|rdataset
operator|->
name|private7
operator|=
name|header
operator|->
name|closest
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|private7
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_CLOSEST
expr_stmt|;
comment|/* 	 * Copy out re-signing information. 	 */
if|if
condition|(
name|RESIGN
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_RESIGN
expr_stmt|;
name|rdataset
operator|->
name|resign
operator|=
name|header
operator|->
name|resign
expr_stmt|;
block|}
else|else
name|rdataset
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|setup_delegation
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|zcname
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
comment|/* 	 * The caller MUST NOT be holding any node locks. 	 */
name|node
operator|=
name|search
operator|->
name|zonecut
expr_stmt|;
name|type
operator|=
name|search
operator|->
name|zonecut_rdataset
operator|->
name|type
expr_stmt|;
comment|/* 	 * If we have to set foundname, we do it before anything else. 	 * If we were to set foundname after we had set nodep or bound the 	 * rdataset, then we'd have to undo that work if dns_name_copy() 	 * failed.  By setting foundname first, there's nothing to undo if 	 * we have trouble. 	 */
if|if
condition|(
name|foundname
operator|!=
name|NULL
operator|&&
name|search
operator|->
name|copy_name
condition|)
block|{
name|zcname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|search
operator|->
name|zonecut_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|zcname
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Note that we don't have to increment the node's reference 		 * count here because we're going to use the reference we 		 * already have in the search block. 		 */
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|search
operator|->
name|zonecut_rdataset
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|search
operator|->
name|zonecut_sigrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|search
operator|->
name|zonecut_sigrdataset
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
condition|)
return|return
operator|(
name|DNS_R_DNAME
operator|)
return|;
return|return
operator|(
name|DNS_R_DELEGATION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|valid_glue
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|rbtdb_rdatatype_t
name|type
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|count
decl_stmt|,
name|size
decl_stmt|;
name|dns_name_t
name|ns_name
decl_stmt|;
name|isc_boolean_t
name|valid
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
comment|/* 	 * No additional locking is required. 	 */
comment|/* 	 * Valid glue types are A, AAAA, A6.  NS is also a valid glue type 	 * if it occurs at a zone cut, but is not valid below it. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|search
operator|->
name|zonecut
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_a
operator|&&
name|type
operator|!=
name|dns_rdatatype_aaaa
operator|&&
name|type
operator|!=
name|dns_rdatatype_a6
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|header
operator|=
name|search
operator|->
name|zonecut_rdataset
expr_stmt|;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|2
operator|+
operator|(
literal|4
operator|*
name|count
operator|)
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|size
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|region
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|region
operator|.
name|length
operator|=
name|size
expr_stmt|;
name|raw
operator|+=
name|size
expr_stmt|;
comment|/* 		 * XXX Until we have rdata structures, we have no choice but 		 * to directly access the rdata format. 		 */
name|dns_name_init
argument_list|(
operator|&
name|ns_name
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
operator|&
name|ns_name
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_compare
argument_list|(
operator|&
name|ns_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|valid
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|activeempty
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_fixedname_t
name|fnext
decl_stmt|;
name|dns_fixedname_t
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|next
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
name|prefix
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|next
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
operator|&
name|prefix
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|prefix
argument_list|,
name|origin
argument_list|,
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|dns_name_issubdomain
argument_list|(
name|next
argument_list|,
name|name
argument_list|)
condition|)
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|activeemtpynode
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|wname
parameter_list|)
block|{
name|dns_fixedname_t
name|fnext
decl_stmt|;
name|dns_fixedname_t
name|forigin
decl_stmt|;
name|dns_fixedname_t
name|fprev
decl_stmt|;
name|dns_name_t
modifier|*
name|next
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
modifier|*
name|prev
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_name_t
name|rname
decl_stmt|;
name|dns_name_t
name|tname
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|isc_boolean_t
name|check_next
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|check_prev
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|next
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fprev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fprev
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
comment|/* 	 * Find if qname is at or below a empty node. 	 * Use our own copy of the chain. 	 */
name|chain
operator|=
name|search
operator|->
name|chain
expr_stmt|;
do|do
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
do|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|name
argument_list|,
name|origin
argument_list|,
name|prev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|check_prev
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|name
argument_list|,
name|origin
argument_list|,
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|check_next
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_name_clone
argument_list|(
name|qname
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the wildcard label to find the terminal name. 	 */
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|wname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|wname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|check_prev
operator|&&
name|dns_name_issubdomain
argument_list|(
name|prev
argument_list|,
operator|&
name|rname
argument_list|)
operator|)
operator|||
operator|(
name|check_next
operator|&&
name|dns_name_issubdomain
argument_list|(
name|next
argument_list|,
operator|&
name|rname
argument_list|)
operator|)
condition|)
block|{
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Remove the left hand label. 		 */
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|rname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|rname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|rname
argument_list|,
operator|&
name|tname
argument_list|)
condition|)
do|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_wildcard
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|level_node
decl_stmt|,
modifier|*
name|wnode
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_name_t
modifier|*
name|wname
decl_stmt|;
name|dns_fixedname_t
name|fwname
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|,
name|wild
decl_stmt|,
name|active
decl_stmt|;
name|dns_rbtnodechain_t
name|wchain
decl_stmt|;
comment|/* 	 * Caller must be holding the tree lock and MUST NOT be holding 	 * any node locks. 	 */
comment|/* 	 * Examine each ancestor level.  If the level's wild bit 	 * is set, then construct the corresponding wildcard name and 	 * search for it.  If the wildcard node exists, and is active in 	 * this version, we're done.  If not, then we next check to see 	 * if the ancestor is active in this version.  If so, then there 	 * can be no possible wildcard match and again we're done.  If not, 	 * continue the search. 	 */
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|i
operator|=
name|search
operator|->
name|chain
operator|.
name|level_matches
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
do|do
block|{
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 		 * First we try to figure out if this node is active in 		 * the search's version.  We do this now, even though we 		 * may not need the information, because it simplifies the 		 * locking and code flow. 		 */
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|active
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|active
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|wild
condition|)
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|wild
condition|)
block|{
comment|/* 			 * Construct the wildcard name for this level. 			 */
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fwname
argument_list|)
expr_stmt|;
name|wname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fwname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
operator|&
name|name
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|j
operator|!=
literal|0
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|level_node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|j
index|]
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|level_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|wname
argument_list|,
operator|&
name|name
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|wnode
operator|=
name|NULL
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|wchain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|,
operator|&
name|wnode
argument_list|,
operator|&
name|wchain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
comment|/* 				 * We have found the wildcard node.  If it 				 * is active in the search's version, we're 				 * done. 				 */
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|wnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|wnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
operator|||
name|activeempty
argument_list|(
name|search
argument_list|,
operator|&
name|wchain
argument_list|,
name|wname
argument_list|)
condition|)
block|{
if|if
condition|(
name|activeemtpynode
argument_list|(
name|search
argument_list|,
name|qname
argument_list|,
name|wname
argument_list|)
condition|)
block|{
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
comment|/* 					 * The wildcard node is active! 					 * 					 * Note: result is still ISC_R_SUCCESS 					 * so we don't have to set it. 					 */
operator|*
name|nodep
operator|=
name|wnode
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
operator|&&
name|result
operator|!=
name|DNS_R_PARTIALMATCH
condition|)
block|{
comment|/* 				 * An error has occurred.  Bail out. 				 */
break|break;
block|}
block|}
if|if
condition|(
name|active
condition|)
block|{
comment|/* 			 * The level node is active.  Any wildcarding 			 * present at higher levels has no 			 * effect and we're done. 			 */
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|matchparams
parameter_list|(
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|rbtdb_search_t
modifier|*
name|search
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_nsec3_t
name|nsec3
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|rdlen
decl_stmt|,
name|count
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
argument_list|)
expr_stmt|;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
comment|/* count */
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
name|count
operator|*
literal|4
operator|+
literal|2
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|rdlen
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|region
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|region
operator|.
name|length
operator|=
name|rdlen
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
operator|&
name|rdata
argument_list|,
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
name|dns_rdatatype_nsec3
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|raw
operator|+=
name|rdlen
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|nsec3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsec3
operator|.
name|hash
operator|==
name|search
operator|->
name|rbtversion
operator|->
name|hash
operator|&&
name|nsec3
operator|.
name|iterations
operator|==
name|search
operator|->
name|rbtversion
operator|->
name|iterations
operator|&&
name|nsec3
operator|.
name|salt_length
operator|==
name|search
operator|->
name|rbtversion
operator|->
name|salt_length
operator|&&
name|memcmp
argument_list|(
name|nsec3
operator|.
name|salt
argument_list|,
name|search
operator|->
name|rbtversion
operator|->
name|salt
argument_list|,
name|nsec3
operator|.
name|salt_length
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find node of the NSEC/NSEC3 record that is 'name'.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|previous_closest_nsec
parameter_list|(
name|dns_rdatatype_t
name|type
parameter_list|,
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_rbtnodechain_t
modifier|*
name|nsecchain
parameter_list|,
name|isc_boolean_t
modifier|*
name|firstp
parameter_list|)
block|{
name|dns_fixedname_t
name|ftarget
decl_stmt|;
name|dns_name_t
modifier|*
name|target
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|nsecnode
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|nodep
operator|!=
name|NULL
operator|&&
operator|*
name|nodep
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_NEWORIGIN
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|ftarget
argument_list|)
expr_stmt|;
name|target
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ftarget
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|firstp
condition|)
block|{
comment|/* 			 * Construct the name of the second node to check. 			 * It is the first node sought in the NSEC tree. 			 */
operator|*
name|firstp
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
name|nsecchain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|nsecnode
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|->
name|rbtdb
operator|->
name|nsec
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
operator|&
name|nsecnode
argument_list|,
name|nsecchain
argument_list|,
name|DNS_RBTFIND_NOOPTIONS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * Since this was the first loop, finding the 				 * name in the NSEC tree implies that the first 				 * node checked in the main tree had an 				 * unacceptable NSEC record. 				 * Try the previous node in the NSEC tree. 				 */
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
name|nsecchain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|nsecchain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * This is a second or later trip through the auxiliary 			 * tree for the name of a third or earlier NSEC node in 			 * the main tree.  Previous trips through the NSEC tree 			 * must have found nodes in the main tree with NSEC 			 * records.  Perhaps they lacked signature records. 			 */
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
name|nsecchain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 		 * Construct the name to seek in the main tree. 		 */
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|->
name|rbtdb
operator|->
name|tree
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|nodep
argument_list|,
operator|&
name|search
operator|->
name|chain
argument_list|,
name|DNS_RBTFIND_NOOPTIONS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 		 * There should always be a node in the main tree with the 		 * same name as the node in the auxiliary NSEC tree, except for 		 * nodes in the auxiliary tree that are awaiting deletion. 		 */
if|if
condition|(
name|result
operator|!=
name|DNS_R_PARTIALMATCH
operator|&&
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"previous_closest_nsec(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_BADDB
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Find the NSEC/NSEC3 which is or before the current point on the  * search chain.  For NSEC3 records only NSEC3 records that match the  * current NSEC3PARAM record are considered.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_closest_nsec
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|dns_rbt_t
modifier|*
name|tree
parameter_list|,
name|dns_db_secure_t
name|secure
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|prevnode
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|dns_rbtnodechain_t
name|nsecchain
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|,
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|rbtdb_rdatatype_t
name|sigtype
decl_stmt|;
name|isc_boolean_t
name|wraps
decl_stmt|;
name|isc_boolean_t
name|first
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|need_sig
init|=
name|ISC_TF
argument_list|(
name|secure
operator|==
name|dns_db_secure
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|search
operator|->
name|rbtdb
operator|->
name|nsec3
condition|)
block|{
name|type
operator|=
name|dns_rdatatype_nsec3
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_SIGNSEC3
expr_stmt|;
name|wraps
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dns_rdatatype_nsec
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_SIGNSEC
expr_stmt|;
name|wraps
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Use the auxiliary tree only starting with the second node in the 	 * hope that the original node will be right much of the time. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|again
label|:
name|node
operator|=
name|NULL
expr_stmt|;
name|prevnode
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
do|do
block|{
name|NODE_LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 			 * Look for an active, extant NSEC or RRSIG NSEC. 			 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * We now know that there is at least one 				 * active rdataset at this node. 				 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigtype
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|empty_node
condition|)
block|{
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
name|search
operator|->
name|rbtversion
operator|->
name|havensec3
operator|&&
name|found
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|&&
operator|!
name|matchparams
argument_list|(
name|found
argument_list|,
name|search
argument_list|)
condition|)
block|{
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|previous_closest_nsec
argument_list|(
name|type
argument_list|,
name|search
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|prevnode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
operator|(
name|foundsig
operator|!=
name|NULL
operator|||
operator|!
name|need_sig
operator|)
condition|)
block|{
comment|/* 				 * We've found the right NSEC/NSEC3 record. 				 * 				 * Note: for this to really be the right 				 * NSEC record, it's essential that the NSEC 				 * records of any nodes obscured by a zone 				 * cut have been removed; we assume this is 				 * the case. 				 */
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|found
operator|==
name|NULL
operator|&&
name|foundsig
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * This node is active, but has no NSEC or 				 * RRSIG NSEC.  That means it's glue or 				 * other obscured zone data that isn't 				 * relevant for our search.  Treat the 				 * node as if it were empty and keep looking. 				 */
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|previous_closest_nsec
argument_list|(
name|type
argument_list|,
name|search
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|prevnode
argument_list|,
operator|&
name|nsecchain
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We found an active node, but either the 				 * NSEC or the RRSIG NSEC is missing.  This 				 * shouldn't happen. 				 */
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * This node isn't active.  We've got to keep 			 * looking. 			 */
name|result
operator|=
name|previous_closest_nsec
argument_list|(
name|type
argument_list|,
name|search
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|prevnode
argument_list|,
operator|&
name|nsecchain
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|node
operator|=
name|prevnode
expr_stmt|;
name|prevnode
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|empty_node
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
if|if
condition|(
operator|!
name|first
condition|)
name|dns_rbtnodechain_invalidate
argument_list|(
operator|&
name|nsecchain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
name|wraps
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_last
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|tree
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|wraps
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 	 * If the result is ISC_R_NOMORE, then we got to the beginning of 	 * the database and didn't find a NSEC record.  This shouldn't 	 * happen. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_find
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|isc_boolean_t
name|cname_ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|close_version
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|maybe_zonecut
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|at_zonecut
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|wild
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|nsecheader
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|foundsig
decl_stmt|,
modifier|*
name|cnamesig
decl_stmt|,
modifier|*
name|nsecsig
decl_stmt|;
name|rbtdb_rdatatype_t
name|sigtype
decl_stmt|;
name|isc_boolean_t
name|active
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|dns_rbt_t
modifier|*
name|tree
decl_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|==
name|NULL
operator|||
operator|(
operator|(
name|rbtdb_version_t
operator|*
operator|)
name|version
operator|)
operator|->
name|rbtdb
operator|==
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * We don't care about 'now'. 	 */
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * If the caller didn't supply a version, attach to the current 	 * version. 	 */
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|close_version
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|search
operator|.
name|rbtversion
operator|=
name|version
expr_stmt|;
name|search
operator|.
name|serial
operator|=
name|search
operator|.
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
literal|0
expr_stmt|;
comment|/* 	 * 'wild' will be true iff. we've matched a wildcard. 	 */
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree.  If, while going down, we 	 * encounter a callback node, zone_zonecut_callback() will search the 	 * rdatasets at the zone cut for active DNAME or NS rdatasets. 	 */
name|tree
operator|=
operator|(
name|options
operator|&
name|DNS_DBFIND_FORCENSEC3
operator|)
operator|!=
literal|0
condition|?
name|search
operator|.
name|rbtdb
operator|->
name|nsec3
else|:
name|search
operator|.
name|rbtdb
operator|->
name|tree
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|zone_zonecut_callback
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|partial_match
label|:
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
name|search
operator|.
name|wild
condition|)
block|{
comment|/* 			 * At least one of the levels in the search chain 			 * potentially has a wildcard.  For each such level, 			 * we must see if there's a matching wildcard active 			 * in the current version. 			 */
name|result
operator|=
name|find_wildcard
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|tree_exit
goto|;
block|}
name|chain
operator|=
name|search
operator|.
name|chain
expr_stmt|;
name|active
operator|=
name|activeempty
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|chain
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * If we're here, then the name does not exist, is not 		 * beneath a zonecut, and there's no matching wildcard. 		 */
if|if
condition|(
operator|(
name|search
operator|.
name|rbtversion
operator|->
name|secure
operator|==
name|dns_db_secure
operator|&&
operator|!
name|search
operator|.
name|rbtversion
operator|->
name|havensec3
operator|)
operator|||
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
operator|||
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC3
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|find_closest_nsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|tree
argument_list|,
name|search
operator|.
name|rbtversion
operator|->
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|active
condition|?
name|DNS_R_EMPTYNAME
else|:
name|DNS_R_NXDOMAIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|active
condition|?
name|DNS_R_EMPTYNAME
else|:
name|DNS_R_NXDOMAIN
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
name|found
label|:
comment|/* 	 * We have found a node whose name is the desired name, or we 	 * have matched a wildcard. 	 */
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're beneath a zone cut, we don't want to look for 		 * CNAMEs because they're not legitimate zone glue. 		 */
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The node may be a zone cut itself.  If it might be one, 		 * make sure we check for it later. 		 * 		 * DS records live above the zone cut in ordinary zone so 		 * we want to ignore any referral. 		 * 		 * Stub zones don't have anything "above" the delgation so 		 * we always return a referral. 		 */
if|if
condition|(
name|node
operator|->
name|find_callback
operator|&&
operator|(
operator|(
name|node
operator|!=
name|search
operator|.
name|rbtdb
operator|->
name|origin_node
operator|&&
operator|!
name|dns_rdatatype_atparent
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|IS_STUB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
operator|)
condition|)
name|maybe_zonecut
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * Certain DNSSEC types are not subject to CNAME matching 	 * (RFC4035, section 2.5 and RFC3007). 	 * 	 * We don't check for RRSIG, because we don't store RRSIG records 	 * directly. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We now go looking for rdata... 	 */
name|lock
operator|=
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|nsecheader
operator|=
name|NULL
expr_stmt|;
name|nsecsig
operator|=
name|NULL
expr_stmt|;
name|cnamesig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 		 * Look for an active, extant rdataset. 		 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|.
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't 				 * exist" record? 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We now know that there is at least one active 			 * rdataset at this node. 			 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 			 * Do special zone cut handling, if requested. 			 */
if|if
condition|(
name|maybe_zonecut
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * We increment the reference count on node to 				 * ensure that search->zonecut_rdataset will 				 * still be valid later. 				 */
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|.
name|zonecut_rdataset
operator|=
name|header
expr_stmt|;
name|search
operator|.
name|zonecut_sigrdataset
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
name|maybe_zonecut
operator|=
name|ISC_FALSE
expr_stmt|;
name|at_zonecut
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * It is not clear if KEY should still be 				 * allowed at the parent side of the zone 				 * cut or not.  It is needed for RFC3007 				 * validated updates. 				 */
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|dns_rdatatype_nsec
operator|&&
name|type
operator|!=
name|dns_rdatatype_key
condition|)
block|{
comment|/* 					 * Glue is not OK, but any answer we 					 * could return would be glue.  Return 					 * the delegation. 					 */
name|found
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 			 * If the NSEC3 record doesn't match the chain 			 * we are using behave as if it isn't here. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|&&
operator|!
name|matchparams
argument_list|(
name|header
argument_list|,
operator|&
name|search
argument_list|)
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|partial_match
goto|;
block|}
comment|/* 			 * If we found a type we were looking for, 			 * remember it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
operator|||
name|type
operator|==
name|dns_rdatatype_any
operator|||
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
operator|)
condition|)
block|{
comment|/* 				 * We've found the answer! 				 */
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
condition|)
block|{
comment|/* 					 * We may be finding a CNAME instead 					 * of the desired type. 					 * 					 * If we've already got the CNAME RRSIG, 					 * use it, otherwise change sigtype 					 * so that we find it. 					 */
if|if
condition|(
name|cnamesig
operator|!=
name|NULL
condition|)
name|foundsig
operator|=
name|cnamesig
expr_stmt|;
else|else
name|sigtype
operator|=
name|RBTDB_RDATATYPE_SIGCNAME
expr_stmt|;
block|}
comment|/* 				 * If we've got all we need, end the search. 				 */
if|if
condition|(
operator|!
name|maybe_zonecut
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigtype
condition|)
block|{
comment|/* 				 * We've found the RRSIG rdataset for our 				 * target type.  Remember it. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
comment|/* 				 * If we've got all we need, end the search. 				 */
if|if
condition|(
operator|!
name|maybe_zonecut
operator|&&
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
operator|&&
operator|!
name|search
operator|.
name|rbtversion
operator|->
name|havensec3
condition|)
block|{
comment|/* 				 * Remember a NSEC rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|nsecheader
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNSEC
operator|&&
operator|!
name|search
operator|.
name|rbtversion
operator|->
name|havensec3
condition|)
block|{
comment|/* 				 * If we need the NSEC rdataset, we'll also 				 * need its signature. 				 */
name|nsecsig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGCNAME
condition|)
block|{
comment|/* 				 * If we get a CNAME match, we'll also need 				 * its signature. 				 */
name|cnamesig
operator|=
name|header
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|empty_node
condition|)
block|{
comment|/* 		 * We have an exact match for the name, but there are no 		 * active rdatasets in the desired version.  That means that 		 * this node doesn't exist in the desired version, and that 		 * we really have a partial match. 		 */
if|if
condition|(
operator|!
name|wild
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|partial_match
goto|;
block|}
block|}
comment|/* 	 * If we didn't find what we were looking for... 	 */
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We were trying to find glue at a node beneath a 			 * zone cut, but didn't. 			 * 			 * Return the delegation. 			 */
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
comment|/* 		 * The desired type doesn't exist. 		 */
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
if|if
condition|(
name|search
operator|.
name|rbtversion
operator|->
name|secure
operator|==
name|dns_db_secure
operator|&&
operator|!
name|search
operator|.
name|rbtversion
operator|->
name|havensec3
operator|&&
operator|(
name|nsecheader
operator|==
name|NULL
operator|||
name|nsecsig
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * The zone is secure but there's no NSEC, 			 * or the NSEC has no signature! 			 */
if|if
condition|(
operator|!
name|wild
condition|)
block|{
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|find_closest_nsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|search
operator|.
name|rbtversion
operator|->
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_EMPTYWILD
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
operator|&&
name|nsecheader
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There's no NSEC record, and we were told 			 * to find one. 			 */
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|search
operator|.
name|rbtversion
operator|->
name|secure
operator|==
name|dns_db_secure
operator|&&
operator|!
name|search
operator|.
name|rbtversion
operator|->
name|havensec3
operator|)
operator|||
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsecheader
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsecsig
argument_list|,
literal|0
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wild
condition|)
name|foundname
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_WILDCARD
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
comment|/* 	 * We found what we were looking for, or we found a CNAME. 	 */
if|if
condition|(
name|type
operator|!=
name|found
operator|->
name|type
operator|&&
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|found
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 		 * We weren't doing an ANY query and we found a CNAME instead 		 * of the type we were looking for, so we need to indicate 		 * that result to the caller. 		 */
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're beneath a zone cut, we must indicate that the 		 * result is glue, unless we're actually at the zone cut 		 * and the type is NSEC or KEY. 		 */
if|if
condition|(
name|search
operator|.
name|zonecut
operator|==
name|node
condition|)
block|{
comment|/* 			 * It is not clear if KEY should still be 			 * allowed at the parent side of the zone 			 * cut or not.  It is needed for RFC3007 			 * validated updates. 			 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|type
operator|==
name|dns_rdatatype_key
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
name|result
operator|=
name|DNS_R_ZONECUT
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_GLUE
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_GLUE
expr_stmt|;
comment|/* 		 * We might have found data that isn't glue, but was occluded 		 * by a dynamic update.  If the caller cares about this, they 		 * will have told us to validate glue. 		 * 		 * XXX We should cache the glue validity state! 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_GLUE
operator|&&
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_VALIDATEGLUE
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|valid_glue
argument_list|(
operator|&
name|search
argument_list|,
name|foundname
argument_list|,
name|type
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * An ordinary successful query! 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|at_zonecut
condition|)
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_any
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
literal|0
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wild
condition|)
name|foundname
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_WILDCARD
expr_stmt|;
name|node_exit
label|:
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * If we found a zonecut but aren't going to use it, we have to 	 * let go of it. 	 */
if|if
condition|(
name|search
operator|.
name|need_cleanup
condition|)
block|{
name|node
operator|=
name|search
operator|.
name|zonecut
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_read
argument_list|,
name|isc_rwlocktype_none
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close_version
condition|)
name|closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_findzonecut
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|nodep
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|foundname
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"zone_findzonecut() called!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_zonecut_callback
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rbtdb_search_t
modifier|*
name|search
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|dname_header
decl_stmt|,
modifier|*
name|sigdname_header
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
comment|/* XXX comment */
name|REQUIRE
argument_list|(
name|search
operator|->
name|zonecut
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Keep compiler silent. 	 */
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
comment|/* 	 * Look for a DNAME or RRSIG DNAME rdataset. 	 */
name|dname_header
operator|=
name|NULL
expr_stmt|;
name|sigdname_header
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|search
operator|->
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is 			 * using the node, we can clean it up right 			 * now, otherwise we mark it as stale, and 			 * the node as dirty, so it will get cleaned 			 * up later. 			 */
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|search
operator|->
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 				 * We update the node's status only when we 				 * can get write access; otherwise, we leave 				 * others to this work.  Periodical cleaning 				 * will eventually take the job as the last 				 * resort. 				 * We won't downgrade the lock, since other 				 * rdatasets are probably stale, too. 				 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 					 * header->down can be non-NULL if the 					 * refcount has just decremented to 0 					 * but decrement_reference() has not 					 * performed clean_cache_node(), in 					 * which case we need to purge the 					 * stale headers first. 					 */
name|mctx
operator|=
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|mctx
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|dname_header
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|sigdname_header
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|dname_header
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|DNS_TRUST_PENDING
argument_list|(
name|dname_header
operator|->
name|trust
argument_list|)
operator|||
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_PENDINGOK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We increment the reference count on node to ensure that 		 * search->zonecut_rdataset will still be valid later. 		 */
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
name|search
operator|->
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|zonecut_rdataset
operator|=
name|dname_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|sigdname_header
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_deepest_zonecut
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|level_node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
comment|/* 	 * Caller must be holding the tree lock. 	 */
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|i
operator|=
name|search
operator|->
name|chain
operator|.
name|level_matches
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
do|do
block|{
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
comment|/* 		 * Look for NS and RRSIG NS rdatasets. 		 */
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|search
operator|->
name|now
condition|)
block|{
comment|/* 				 * This rdataset is stale.  If no one else is 				 * using the node, we can clean it up right 				 * now, otherwise we mark it as stale, and 				 * the node as dirty, so it will get cleaned 				 * up later. 				 */
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|search
operator|->
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 					 * We update the node's status only 					 * when we can get write access. 					 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_mem_t
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|mctx
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|m
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|m
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * We've found an extant rdataset.  See if 				 * we're interested in it. 				 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If we have to set foundname, we do it before 			 * anything else.  If we were to set foundname after 			 * we had set nodep or bound the rdataset, then we'd 			 * have to undo that work if dns_name_concatenate() 			 * failed.  By setting foundname first, there's 			 * nothing to undo if we have trouble. 			 */
if|if
condition|(
name|foundname
operator|!=
name|NULL
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
operator|&
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|level_node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|level_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|foundname
argument_list|,
operator|&
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
block|}
name|result
operator|=
name|DNS_R_DELEGATION
expr_stmt|;
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|)
operator|||
operator|(
name|foundsig
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|locktype
operator|!=
name|isc_rwlocktype_write
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|POST
argument_list|(
name|locktype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_headerupdate
argument_list|(
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|)
condition|)
name|update_header
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|)
condition|)
block|{
name|update_header
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|node_exit
label|:
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|find_coveringnsec
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|,
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_nsec
argument_list|)
expr_stmt|;
do|do
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
condition|)
block|{
comment|/* 				 * This rdataset is stale.  If no one else is 				 * using the node, we can clean it up right 				 * now, otherwise we mark it as stale, and the 				 * node as dirty, so it will get cleaned up 				 * later. 				 */
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 					 * We update the node's status only 					 * when we can get write access. 					 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_mem_t
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|mctx
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|m
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|m
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
operator|||
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|header_prev
operator|=
name|header
expr_stmt|;
continue|continue;
block|}
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
name|foundsig
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock_node
goto|;
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
name|result
operator|=
name|DNS_R_COVERINGNSEC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|empty_node
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
else|else
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unlock_node
label|:
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|empty_node
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark a database for response policy rewriting  * or find which RPZ data is available.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
specifier|static
name|isc_result_t
name|rpz_enabled
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
block|{
name|dns_rpz_enabled_get
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|dns_rpz_new_cidr
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
operator|&
name|rbtdb
operator|->
name|rpz_cidr
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search the CDIR block tree of a response policy tree of trees for all of  * the IP addresses in an A or AAAA rdataset.  * Among the policies for all IPv4 and IPv6 addresses for a name, choose  *	the earliest configured policy,  *	QNAME over IP over NSDNAME over NSIP,  *	the longest prefix,  *	the lexically smallest address.  * The caller must have already checked that any existing policy was not  * configured earlier than this policy zone and does not have a higher  * precedence type.  */
end_comment

begin_function
specifier|static
name|void
name|rpz_findips
parameter_list|(
name|dns_rpz_zone_t
modifier|*
name|rpz
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|,
name|dns_name_t
modifier|*
name|query_qname
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|struct
name|in6_addr
name|in6a
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|dns_fixedname_t
name|selfnamef
decl_stmt|,
name|qnamef
decl_stmt|;
name|dns_name_t
modifier|*
name|selfname
decl_stmt|,
modifier|*
name|qname
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rdataset_t
name|zrdataset
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|prefix
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rpz_policy_t
name|rpz_policy
decl_stmt|;
name|dns_ttl_t
name|ttl
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|rpz_cidr
operator|==
name|NULL
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|selfnamef
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|qnamef
argument_list|)
expr_stmt|;
name|selfname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|selfnamef
argument_list|)
expr_stmt|;
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|qnamef
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|ardataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|ardataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|ardataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rdata
operator|.
name|type
condition|)
block|{
case|case
name|dns_rdatatype_a
case|:
name|INSIST
argument_list|(
name|rdata
operator|.
name|length
operator|==
literal|4
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|ina
operator|.
name|s_addr
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|ina
argument_list|)
expr_stmt|;
break|break;
case|case
name|dns_rdatatype_aaaa
case|:
name|INSIST
argument_list|(
name|rdata
operator|.
name|length
operator|==
literal|16
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|in6a
operator|.
name|s6_addr
argument_list|,
name|rdata
operator|.
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|isc_netaddr_fromin6
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|in6a
argument_list|)
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|result
operator|=
name|dns_rpz_cidr_find
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
operator|&
name|netaddr
argument_list|,
name|rpz_type
argument_list|,
name|selfname
argument_list|,
name|qname
argument_list|,
operator|&
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
continue|continue;
comment|/* 		 * If we already have a rule, discard this new rule if 		 * is not better. 		 * The caller has checked that st->m.rpz->num> rpz->num 		 * or st->m.rpz->num == rpz->num and st->m.type>= rpz_type 		 */
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|policy
operator|!=
name|DNS_RPZ_POLICY_MISS
operator|&&
name|st
operator|->
name|m
operator|.
name|rpz
operator|->
name|num
operator|==
name|rpz
operator|->
name|num
operator|&&
operator|(
name|st
operator|->
name|m
operator|.
name|type
operator|<
name|rpz_type
operator|||
operator|(
name|st
operator|->
name|m
operator|.
name|type
operator|==
name|rpz_type
operator|&&
operator|(
name|st
operator|->
name|m
operator|.
name|prefix
operator|>
name|prefix
operator|||
operator|(
name|st
operator|->
name|m
operator|.
name|prefix
operator|==
name|prefix
operator|&&
literal|0
operator|>
name|dns_name_rdatacompare
argument_list|(
name|st
operator|->
name|qname
argument_list|,
name|qname
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
continue|continue;
comment|/* 		 * We have rpz_st an entry with a prefix at least as long as 		 * the prefix of the entry we had before.  Find the node 		 * corresponding to CDIR tree entry. 		 */
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|qname
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|qname
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|DNS_LOGMODULE_RBTDB
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
literal|"rpz_findips findnode(%s) failed: %s"
argument_list|,
name|namebuf
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * First look for a simple rewrite of the IP address. 		 * If that fails, look for a CNAME.  If we cannot find 		 * a CNAME or the CNAME is neither of the special forms 		 * "*" or ".", treat it like a real CNAME. 		 */
name|dns_rdataset_init
argument_list|(
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|ardataset
operator|->
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zrdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|dns_rdatatype_cname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zrdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|zrdataset
operator|.
name|type
operator|!=
name|dns_rdatatype_cname
condition|)
block|{
name|rpz_policy
operator|=
name|DNS_RPZ_POLICY_RECORD
expr_stmt|;
block|}
else|else
block|{
name|rpz_policy
operator|=
name|dns_rpz_decode_cname
argument_list|(
name|rpz
argument_list|,
operator|&
name|zrdataset
argument_list|,
name|selfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpz_policy
operator|==
name|DNS_RPZ_POLICY_RECORD
operator|||
name|rpz_policy
operator|==
name|DNS_RPZ_POLICY_WILDCNAME
condition|)
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
name|ttl
operator|=
name|zrdataset
operator|.
name|ttl
expr_stmt|;
block|}
else|else
block|{
name|rpz_policy
operator|=
name|DNS_RPZ_POLICY_RECORD
expr_stmt|;
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
name|ttl
operator|=
name|DNS_RPZ_TTL_DEFAULT
expr_stmt|;
block|}
comment|/* 		 * Use an overriding action specified in the configuration file 		 */
if|if
condition|(
name|rpz
operator|->
name|policy
operator|!=
name|DNS_RPZ_POLICY_GIVEN
condition|)
block|{
comment|/* 			 * only log DNS_RPZ_POLICY_DISABLED hits 			 */
if|if
condition|(
name|rpz
operator|->
name|policy
operator|==
name|DNS_RPZ_POLICY_DISABLED
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RPZ_INFO_LEVEL
argument_list|)
condition|)
block|{
name|char
name|qname_buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|rpz_qname_buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|query_qname
argument_list|,
name|qname_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|qname_buf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|qname
argument_list|,
name|rpz_qname_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpz_qname_buf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|DNS_LOGMODULE_RBTDB
argument_list|,
name|DNS_RPZ_INFO_LEVEL
argument_list|,
literal|"disabled rpz %s %s rewrite"
literal|" %s via %s"
argument_list|,
name|dns_rpz_type2str
argument_list|(
name|rpz_type
argument_list|)
argument_list|,
name|dns_rpz_policy2str
argument_list|(
name|rpz_policy
argument_list|)
argument_list|,
name|qname_buf
argument_list|,
name|rpz_qname_buf
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|rpz_policy
operator|=
name|rpz
operator|->
name|policy
expr_stmt|;
block|}
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
name|st
operator|->
name|m
operator|.
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
name|st
operator|->
name|m
operator|.
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|node
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
name|st
operator|->
name|m
operator|.
name|db
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|st
operator|->
name|m
operator|.
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|m
operator|.
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|st
operator|->
name|m
operator|.
name|zone
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|rpz
operator|=
name|rpz
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|type
operator|=
name|rpz_type
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|policy
operator|=
name|rpz_policy
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|ttl
operator|=
name|ISC_MIN
argument_list|(
name|ttl
argument_list|,
name|rpz
operator|->
name|max_policy_ttl
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|result
operator|=
name|result
expr_stmt|;
name|dns_name_copy
argument_list|(
name|qname
argument_list|,
name|st
operator|->
name|qname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpz_policy
operator|==
name|DNS_RPZ_POLICY_RECORD
operator|||
name|rpz_policy
operator|==
name|DNS_RPZ_POLICY_WILDCNAME
operator|)
operator|&&
name|result
operator|!=
name|DNS_R_NXRRSET
condition|)
block|{
name|dns_rdataset_clone
argument_list|(
operator|&
name|zrdataset
argument_list|,
name|st
operator|->
name|m
operator|.
name|rdataset
argument_list|)
expr_stmt|;
name|dns_db_attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|node
argument_list|)
expr_stmt|;
block|}
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|db
argument_list|)
expr_stmt|;
name|st
operator|->
name|m
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|dns_zone_attach
argument_list|(
name|zone
argument_list|,
operator|&
name|st
operator|->
name|m
operator|.
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|zrdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|zrdataset
argument_list|)
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|cache_find
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|isc_boolean_t
name|cname_ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|nsheader
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|foundsig
decl_stmt|,
modifier|*
name|nssig
decl_stmt|,
modifier|*
name|cnamesig
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|update
decl_stmt|,
modifier|*
name|updatesig
decl_stmt|;
name|rbtdb_rdatatype_t
name|sigtype
decl_stmt|,
name|negtype
decl_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|version
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtversion
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|serial
operator|=
literal|1
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
name|now
expr_stmt|;
name|update
operator|=
name|NULL
expr_stmt|;
name|updatesig
operator|=
name|NULL
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree.  If, while going down, we 	 * encounter a callback node, cache_zonecut_callback() will search the 	 * rdatasets at the zone cut for a DNAME rdataset. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|cache_zonecut_callback
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_COVERINGNSEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|find_coveringnsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|now
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_COVERINGNSEC
condition|)
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
else|else
block|{
name|find_ns
label|:
name|result
operator|=
name|find_deepest_zonecut
argument_list|(
operator|&
name|search
argument_list|,
name|node
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
comment|/* 	 * Certain DNSSEC types are not subject to CNAME matching 	 * (RFC4035, section 2.5 and RFC3007). 	 * 	 * We don't check for RRSIG, because we don't store RRSIG records 	 * directly. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We now go looking for rdata... 	 */
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|nsheader
operator|=
name|NULL
expr_stmt|;
name|nssig
operator|=
name|NULL
expr_stmt|;
name|cnamesig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is using the 			 * node, we can clean it up right now, otherwise we 			 * mark it as stale, and the node as dirty, so it will 			 * get cleaned up later. 			 */
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 				 * We update the node's status only when we 				 * can get write access. 				 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|mctx
operator|=
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 			 * We now know that there is at least one active 			 * non-stale rdataset at this node. 			 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 			 * If we found a type we were looking for, remember 			 * it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
operator|||
operator|(
name|type
operator|==
name|dns_rdatatype_any
operator|&&
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|)
condition|)
block|{
comment|/* 				 * We've found the answer. 				 */
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
operator|&&
name|cnamesig
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * If we've already got the 					 * CNAME RRSIG, use it. 					 */
name|foundsig
operator|=
name|cnamesig
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigtype
condition|)
block|{
comment|/* 				 * We've found the RRSIG rdataset for our 				 * target type.  Remember it. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
operator|||
name|header
operator|->
name|type
operator|==
name|negtype
condition|)
block|{
comment|/* 				 * We've found a negative cache entry. 				 */
name|found
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * Remember a NS rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|nsheader
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
comment|/* 				 * If we need the NS rdataset, we'll also 				 * need its signature. 				 */
name|nssig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGCNAME
condition|)
block|{
comment|/* 				 * If we get a CNAME match, we'll also need 				 * its signature. 				 */
name|cnamesig
operator|=
name|header
expr_stmt|;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|empty_node
condition|)
block|{
comment|/* 		 * We have an exact match for the name, but there are no 		 * extant rdatasets.  That means that this node doesn't 		 * meaningfully exist, and that we really have a partial match. 		 */
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
comment|/* 	 * If we didn't find what we were looking for... 	 */
if|if
condition|(
name|found
operator|==
name|NULL
operator|||
operator|(
name|DNS_TRUST_ADDITIONAL
argument_list|(
name|found
operator|->
name|trust
argument_list|)
operator|&&
operator|(
operator|(
name|options
operator|&
name|DNS_DBFIND_ADDITIONALOK
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|found
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|&&
operator|(
operator|(
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|DNS_TRUST_PENDING
argument_list|(
name|found
operator|->
name|trust
argument_list|)
operator|&&
operator|(
operator|(
name|options
operator|&
name|DNS_DBFIND_PENDINGOK
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If there is an NS rdataset at this node, then this is the 		 * deepest zone cut. 		 */
if|if
condition|(
name|nsheader
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsheader
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|nsheader
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|update
operator|=
name|nsheader
expr_stmt|;
if|if
condition|(
name|nssig
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nssig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|nssig
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|updatesig
operator|=
name|nssig
expr_stmt|;
block|}
name|result
operator|=
name|DNS_R_DELEGATION
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
comment|/* 		 * Go find the deepest zone cut. 		 */
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
comment|/* 	 * We found what we were looking for, or we found a CNAME. 	 */
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|NEGATIVE
argument_list|(
name|found
argument_list|)
condition|)
block|{
comment|/* 		 * We found a negative cache entry. 		 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|found
argument_list|)
condition|)
name|result
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|found
operator|->
name|type
operator|&&
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|found
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 		 * We weren't doing an ANY query and we found a CNAME instead 		 * of the type we were looking for, so we need to indicate 		 * that result to the caller. 		 */
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * An ordinary successful query! 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_any
operator|||
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|update
operator|=
name|found
expr_stmt|;
if|if
condition|(
operator|!
name|NEGATIVE
argument_list|(
name|found
argument_list|)
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|updatesig
operator|=
name|foundsig
expr_stmt|;
block|}
block|}
name|node_exit
label|:
if|if
condition|(
operator|(
name|update
operator|!=
name|NULL
operator|||
name|updatesig
operator|!=
name|NULL
operator|)
operator|&&
name|locktype
operator|!=
name|isc_rwlocktype_write
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|POST
argument_list|(
name|locktype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|update
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|update_header
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|update
argument_list|,
name|search
operator|.
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|updatesig
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|updatesig
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|update_header
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|updatesig
argument_list|,
name|search
operator|.
name|now
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * If we found a zonecut but aren't going to use it, we have to 	 * let go of it. 	 */
if|if
condition|(
name|search
operator|.
name|need_cleanup
condition|)
block|{
name|node
operator|=
name|search
operator|.
name|zonecut
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_read
argument_list|,
name|isc_rwlocktype_none
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_findzonecut
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|unsigned
name|int
name|rbtoptions
init|=
name|DNS_RBTFIND_EMPTYDATA
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtversion
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|serial
operator|=
literal|1
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBFIND_NOEXACT
operator|)
operator|!=
literal|0
condition|)
name|rbtoptions
operator||=
name|DNS_RBTFIND_NOEXACT
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|rbtoptions
argument_list|,
name|NULL
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|find_ns
label|:
name|result
operator|=
name|find_deepest_zonecut
argument_list|(
operator|&
name|search
argument_list|,
name|node
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
comment|/* 	 * We now go looking for an NS rdataset at the node. 	 */
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is using the 			 * node, we can clean it up right now, otherwise we 			 * mark it as stale, and the node as dirty, so it will 			 * get cleaned up later. 			 */
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 				 * We update the node's status only when we 				 * can get write access. 				 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|mctx
operator|=
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
expr_stmt|;
name|clean_stale_headers
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 			 * If we found a type we were looking for, remember 			 * it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * Remember a NS rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|found
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
comment|/* 				 * If we need the NS rdataset, we'll also 				 * need its signature. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No NS records here. 		 */
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|node
argument_list|,
name|deadlink
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_headerupdate
argument_list|(
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|)
operator|||
operator|(
name|foundsig
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|locktype
operator|!=
name|isc_rwlocktype_write
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|POST
argument_list|(
name|locktype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_headerupdate
argument_list|(
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
name|update_header
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
operator|&&
name|need_headerupdate
argument_list|(
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|)
condition|)
block|{
name|update_header
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|)
expr_stmt|;
block|}
block|}
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|search
operator|.
name|need_cleanup
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|source
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|source
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|NODE_STRONGLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dns_rbtnode_refincrement
argument_list|(
name|node
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_boolean_t
name|want_free
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|inactive
init|=
name|ISC_FALSE
decl_stmt|;
name|rbtdb_nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
operator|(
operator|*
name|targetp
operator|)
expr_stmt|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_read
argument_list|,
name|isc_rwlocktype_none
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|isc_refcount_current
argument_list|(
operator|&
name|nodelock
operator|->
name|references
argument_list|)
operator|==
literal|0
operator|&&
name|nodelock
operator|->
name|exiting
condition|)
block|{
name|inactive
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|nodelock
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inactive
condition|)
block|{
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|active
operator|--
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|active
operator|==
literal|0
condition|)
name|want_free
operator|=
name|ISC_TRUE
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_free
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"calling free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|expirenode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_boolean_t
name|force_expire
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * These are the category and module used by the cache cleaner. 	 */
name|isc_boolean_t
name|log
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_logcategory_t
modifier|*
name|category
init|=
name|DNS_LOGCATEGORY_DATABASE
decl_stmt|;
name|isc_logmodule_t
modifier|*
name|module
init|=
name|DNS_LOGMODULE_CACHE
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Caller must hold a tree lock. 	 */
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_mem_isovermem
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|val
decl_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * XXXDCL Could stand to have a better policy, like LRU. 		 */
name|force_expire
operator|=
name|ISC_TF
argument_list|(
name|rbtnode
operator|->
name|down
operator|==
name|NULL
operator|&&
name|val
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Note that 'log' can be true IFF overmem is also true. 		 * overmem can currently only be true for cache 		 * databases -- hence all of the "overmem cache" log strings. 		 */
name|log
operator|=
name|ISC_TF
argument_list|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: %s %s"
argument_list|,
name|force_expire
condition|?
literal|"FORCE"
else|:
literal|"check"
argument_list|,
name|dns_rbt_formatnodename
argument_list|(
name|rbtnode
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We may not need write access, but this code path is not performance 	 * sensitive, so it should be okay to always lock as a writer. 	 */
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<=
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
block|{
comment|/* 			 * We don't check if refcurrent(rbtnode) == 0 and try 			 * to free like we do in cache_find(), because 			 * refcurrent(rbtnode) must be non-zero.  This is so 			 * because 'node' is an argument to the function. 			 */
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: stale %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force_expire
condition|)
block|{
if|if
condition|(
operator|!
name|RETAIN
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|log
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: "
literal|"reprieve by RETAIN() %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isc_mem_isovermem
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
operator|&&
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: saved %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|overmem
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|overmem
parameter_list|)
block|{
comment|/* This is an empty callback.  See adb.c:water() */
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|overmem
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|printnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|node
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"node %p, %u references, locknum = %u\n"
argument_list|,
name|rbtnode
argument_list|,
name|dns_rbtnode_refcurrent
argument_list|(
name|rbtnode
argument_list|)
argument_list|,
name|rbtnode
operator|->
name|locknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtnode
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
for|for
control|(
name|current
operator|=
name|rbtnode
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\ttype %u"
argument_list|,
name|current
operator|->
name|type
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tserial = %lu, ttl = %u, "
literal|"trust = %u, attributes = %u, "
literal|"resign = %u\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|current
operator|->
name|serial
argument_list|,
name|current
operator|->
name|rdh_ttl
argument_list|,
name|current
operator|->
name|trust
argument_list|,
name|current
operator|->
name|attributes
argument_list|,
name|current
operator|->
name|resign
argument_list|)
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(empty)\n"
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|createiterator
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdbiter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|rbtdbiter
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|dbiterator_methods
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
operator|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_DB_RELATIVENAMES
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_DBITERATOR_MAGIC
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|cleaning
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_TRUE
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|rbtdbiter
operator|->
name|delete
operator|=
literal|0
expr_stmt|;
name|rbtdbiter
operator|->
name|nsec3only
operator|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_DB_NSEC3ONLY
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|nonsec3
operator|=
name|ISC_TF
argument_list|(
operator|(
name|options
operator|&
name|DNS_DB_NONSEC3
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rbtdbiter
operator|->
name|deletions
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtdbiter
operator|->
name|deletions
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|db
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|,
name|db
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|nsec3only
condition|)
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
else|else
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
operator|*
name|iteratorp
operator|=
operator|(
name|dns_dbiterator_t
operator|*
operator|)
name|rbtdbiter
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_findrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_boolean_t
name|close_version
init|=
name|ISC_FALSE
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
name|currentversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|)
expr_stmt|;
name|close_version
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
if|if
condition|(
name|covers
operator|==
literal|0
condition|)
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sigmatchtype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't 				 * exist" record? 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have an active, extant rdataset.  If it's a 			 * type we're looking for, remember it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_version
condition|)
name|closeversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_findrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|,
name|negtype
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|locktype
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|covers
operator|==
literal|0
condition|)
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sigmatchtype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
condition|)
block|{
if|if
condition|(
operator|(
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
operator|)
operator|&&
operator|(
name|locktype
operator|==
name|isc_rwlocktype_write
operator|||
name|NODE_TRYUPGRADE
argument_list|(
name|lock
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
comment|/* 				 * We update the node's status only when we 				 * can get write access. 				 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
comment|/* 				 * We don't check if refcurrent(rbtnode) == 0 				 * and try to free like we do in cache_find(), 				 * because refcurrent(rbtnode) must be 				 * non-zero.  This is so because 'node' is an 				 * argument to the function. 				 */
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
operator|||
name|header
operator|->
name|type
operator|==
name|negtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NEGATIVE
argument_list|(
name|found
argument_list|)
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
name|NEGATIVE
argument_list|(
name|found
argument_list|)
condition|)
block|{
comment|/* 		 * We found a negative cache entry. 		 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|found
argument_list|)
condition|)
name|result
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|allrdatasets
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rbtdb_rdatasetiter_t
modifier|*
name|iterator
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
operator|(
name|db
operator|->
name|attributes
operator|&
name|DNS_DBATTR_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|now
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
name|currentversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|refs
decl_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|rbtversion
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|rbtversion
operator|=
name|NULL
expr_stmt|;
block|}
name|iterator
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_RDATASETITER_MAGIC
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|rdatasetiter_methods
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|version
operator|=
operator|(
name|dns_dbversion_t
operator|*
operator|)
name|rbtversion
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|now
operator|=
name|now
expr_stmt|;
name|NODE_STRONGLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dns_rbtnode_refincrement
argument_list|(
name|rbtnode
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
operator|(
name|dns_rdatasetiter_t
operator|*
operator|)
name|iterator
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|cname_and_other_data
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|isc_boolean_t
name|cname
decl_stmt|,
name|other_data
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|;
comment|/* 	 * The caller must hold the node lock. 	 */
comment|/* 	 * Look for CNAME and "other data" rdatasets active in our version. 	 */
name|cname
operator|=
name|ISC_FALSE
expr_stmt|;
name|other_data
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 			 * Look for an active extant CNAME. 			 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|cname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Look for active extant "other data". 			 * 			 * "Other data" is any rdataset whose type is not 			 * KEY, NSEC, SIG or RRSIG. 			 */
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtype
operator|!=
name|dns_rdatatype_key
operator|&&
name|rdtype
operator|!=
name|dns_rdatatype_sig
operator|&&
name|rdtype
operator|!=
name|dns_rdatatype_nsec
operator|&&
name|rdtype
operator|!=
name|dns_rdatatype_rrsig
condition|)
block|{
comment|/* 				 * Is it active and extant? 				 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 						 * Is this a "this rdataset 						 * doesn't exist" record? 						 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|other_data
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cname
operator|&&
name|other_data
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|resign_insert
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|int
name|idx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|newheader
operator|->
name|heap_index
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|newheader
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_heap_insert
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resign_delete
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|)
block|{
comment|/* 	 * Remove the old header from the heap 	 */
if|if
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|header
operator|->
name|heap_index
operator|!=
literal|0
condition|)
block|{
name|isc_heap_delete
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
name|header
operator|->
name|heap_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|version
operator|->
name|resigned_list
argument_list|,
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add32
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|rbtnode
parameter_list|,
name|rbtdb_version_t
modifier|*
name|rbtversion
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_boolean_t
name|loading
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
init|=
name|NULL
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|topheader
decl_stmt|,
modifier|*
name|topheader_prev
decl_stmt|,
modifier|*
name|header
decl_stmt|,
modifier|*
name|sigheader
decl_stmt|;
name|unsigned
name|char
modifier|*
name|merged
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|header_nx
decl_stmt|;
name|isc_boolean_t
name|newheader_nx
decl_stmt|;
name|isc_boolean_t
name|merge
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|,
name|covers
decl_stmt|;
name|rbtdb_rdatatype_t
name|negtype
decl_stmt|,
name|sigtype
decl_stmt|;
name|dns_trust_t
name|trust
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* 	 * Add an rdatasetheader_t to a node. 	 */
comment|/* 	 * Caller must be holding the node lock. 	 */
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_MERGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|REQUIRE
argument_list|(
name|rbtversion
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|merge
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|merge
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_FORCE
operator|)
operator|!=
literal|0
condition|)
name|trust
operator|=
name|dns_trust_ultimate
expr_stmt|;
else|else
name|trust
operator|=
name|newheader
operator|->
name|trust
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
operator|&&
operator|!
name|loading
condition|)
block|{
comment|/* 		 * We always add a changed record, even if no changes end up 		 * being made to this node, because it's harmless and 		 * simplifies the code. 		 */
name|changed
operator|=
name|add_changed
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|rbtnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|==
name|NULL
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
name|newheader_nx
operator|=
name|NONEXISTENT
argument_list|(
name|newheader
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
name|topheader_prev
operator|=
name|NULL
expr_stmt|;
name|sigheader
operator|=
name|NULL
expr_stmt|;
name|negtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
operator|&&
operator|!
name|newheader_nx
condition|)
block|{
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|newheader
operator|->
name|type
argument_list|)
expr_stmt|;
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|newheader
operator|->
name|type
argument_list|)
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|covers
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEGATIVE
argument_list|(
name|newheader
argument_list|)
condition|)
block|{
comment|/* 			 * We're adding a negative cache entry. 			 */
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
comment|/* 				 * If we're adding an negative cache entry 				 * which covers all types (NXDOMAIN, 				 * NODATA(QTYPE=ANY)). 				 * 				 * We make all other data stale so that the 				 * only rdataset that can be found at this 				 * node is the negative cache entry. 				 * 				 * Otherwise look for any RRSIGs of the 				 * given type so they can be marked stale 				 * later. 				 */
if|if
condition|(
name|covers
operator|==
name|dns_rdatatype_any
condition|)
block|{
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|topheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|topheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|sigtype
condition|)
name|sigheader
operator|=
name|topheader
expr_stmt|;
block|}
if|if
condition|(
name|covers
operator|==
name|dns_rdatatype_any
condition|)
goto|goto
name|find_header
goto|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|covers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're adding something that isn't a 			 * negative cache entry.  Look for an extant 			 * non-stale NXDOMAIN/NODATA(QTYPE=ANY) negative 			 * cache entry.  If we're adding an RRSIG, also 			 * check for an extant non-stale NODATA ncache 			 * entry which covers the same type as the RRSIG. 			 */
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|topheader
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
operator|)
operator|||
operator|(
name|newheader
operator|->
name|type
operator|==
name|sigtype
operator|&&
name|topheader
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|covers
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|topheader
operator|!=
name|NULL
operator|&&
name|EXISTS
argument_list|(
name|topheader
argument_list|)
operator|&&
name|topheader
operator|->
name|rdh_ttl
operator|>=
name|now
condition|)
block|{
comment|/* 				 * Found one. 				 */
if|if
condition|(
name|trust
operator|<
name|topheader
operator|->
name|trust
condition|)
block|{
comment|/* 					 * The NXDOMAIN/NODATA(QTYPE=ANY) 					 * is more trusted. 					 */
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|topheader
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 				 * The new rdataset is better.  Expire the 				 * ncache entry. 				 */
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|topheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|topheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|topheader
operator|=
name|NULL
expr_stmt|;
goto|goto
name|find_header
goto|;
block|}
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|newheader
operator|->
name|type
operator|||
name|topheader
operator|->
name|type
operator|==
name|negtype
condition|)
break|break;
name|topheader_prev
operator|=
name|topheader
expr_stmt|;
block|}
name|find_header
label|:
comment|/* 	 * If header isn't NULL, we've found the right type.  There may be 	 * IGNORE rdatasets between the top of the chain and the first real 	 * data.  We skip over them. 	 */
name|header
operator|=
name|topheader
expr_stmt|;
while|while
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
name|header_nx
operator|=
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Deleting an already non-existent rdataset has no effect. 		 */
if|if
condition|(
name|header_nx
operator|&&
name|newheader_nx
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 		 * Trying to add an rdataset with lower trust to a cache DB 		 * has no effect, provided that the cache data isn't stale. 		 */
if|if
condition|(
name|rbtversion
operator|==
name|NULL
operator|&&
name|trust
operator|<
name|header
operator|->
name|trust
operator|&&
operator|(
name|header
operator|->
name|rdh_ttl
operator|>=
name|now
operator|||
name|header_nx
operator|)
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 		 * Don't merge if a nonexistent rdataset is involved. 		 */
if|if
condition|(
name|merge
operator|&&
operator|(
name|header_nx
operator|||
name|newheader_nx
operator|)
condition|)
name|merge
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * If 'merge' is ISC_TRUE, we'll try to create a new rdataset 		 * that is the union of 'newheader' and 'header'. 		 */
if|if
condition|(
name|merge
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|serial
operator|>=
name|header
operator|->
name|serial
argument_list|)
expr_stmt|;
name|merged
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_EXACT
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|DNS_RDATASLAB_EXACT
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_EXACTTTL
operator|)
operator|!=
literal|0
operator|&&
name|newheader
operator|->
name|rdh_ttl
operator|!=
name|header
operator|->
name|rdh_ttl
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
elseif|else
if|if
condition|(
name|newheader
operator|->
name|rdh_ttl
operator|!=
name|header
operator|->
name|rdh_ttl
condition|)
name|flags
operator||=
name|DNS_RDATASLAB_FORCE
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rdataslab_merge
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * If 'header' has the same serial number as 				 * we do, we could clean it up now if we knew 				 * that our caller had no references to it. 				 * We don't know this, however, so we leave it 				 * alone.  It will get cleaned up when 				 * clean_zone_node() runs. 				 */
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|merged
expr_stmt|;
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|loading
operator|&&
name|RESIGN
argument_list|(
name|newheader
argument_list|)
operator|&&
name|RESIGN
argument_list|(
name|header
argument_list|)
operator|&&
name|header
operator|->
name|resign
operator|<
name|newheader
operator|->
name|resign
condition|)
name|newheader
operator|->
name|resign
operator|=
name|header
operator|->
name|resign
expr_stmt|;
block|}
else|else
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* 		 * Don't replace existing NS, A and AAAA RRsets 		 * in the cache if they are already exist.  This 		 * prevents named being locked to old servers. 		 * Don't lower trust of existing record if the 		 * update is forced. 		 */
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|header
operator|->
name|rdh_ttl
operator|>=
name|now
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|!
name|header_nx
operator|&&
operator|!
name|newheader_nx
operator|&&
name|header
operator|->
name|trust
operator|>=
name|newheader
operator|->
name|trust
operator|&&
name|dns_rdataslab_equalx
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 			 * Honour the new ttl if it is less than the 			 * older one. 			 */
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|>
name|newheader
operator|->
name|rdh_ttl
condition|)
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|newheader
operator|->
name|rdh_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|noqname
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|noqname
operator|=
name|newheader
operator|->
name|noqname
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|->
name|closest
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|closest
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|closest
operator|=
name|newheader
operator|->
name|closest
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
block|}
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 		 * If we have will be replacing a NS RRset force its TTL 		 * to be no more than the current NS RRset's TTL.  This 		 * ensures the delegations that are withdrawn are honoured. 		 */
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|header
operator|->
name|rdh_ttl
operator|>=
name|now
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|!
name|header_nx
operator|&&
operator|!
name|newheader_nx
operator|&&
name|header
operator|->
name|trust
operator|<=
name|newheader
operator|->
name|trust
condition|)
block|{
if|if
condition|(
name|newheader
operator|->
name|rdh_ttl
operator|>
name|header
operator|->
name|rdh_ttl
condition|)
block|{
name|newheader
operator|->
name|rdh_ttl
operator|=
name|header
operator|->
name|rdh_ttl
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|header
operator|->
name|rdh_ttl
operator|>=
name|now
operator|&&
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ds
operator|||
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDDS
operator|)
operator|&&
operator|!
name|header_nx
operator|&&
operator|!
name|newheader_nx
operator|&&
name|header
operator|->
name|trust
operator|>=
name|newheader
operator|->
name|trust
operator|&&
name|dns_rdataslab_equal
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 			 * Honour the new ttl if it is less than the 			 * older one. 			 */
if|if
condition|(
name|header
operator|->
name|rdh_ttl
operator|>
name|newheader
operator|->
name|rdh_ttl
condition|)
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|newheader
operator|->
name|rdh_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|noqname
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|noqname
operator|=
name|newheader
operator|->
name|noqname
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|->
name|closest
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|closest
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|closest
operator|=
name|newheader
operator|->
name|closest
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
block|}
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loading
condition|)
block|{
comment|/* 			 * There are no other references to 'header' when 			 * loading, so we MAY clean up 'header' now. 			 * Since we don't generate changed records when 			 * loading, we MUST clean up 'header' now. 			 */
name|newheader
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|idx
operator|=
name|newheader
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|ISC_LIST_PREPEND
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|heaps
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_heap_insert
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RESIGN
argument_list|(
name|newheader
argument_list|)
condition|)
block|{
name|result
operator|=
name|resign_insert
argument_list|(
name|rbtdb
argument_list|,
name|idx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
else|else
block|{
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
if|if
condition|(
name|sigheader
operator|!=
name|NULL
condition|)
block|{
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|sigheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
block|}
block|}
name|idx
operator|=
name|newheader
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|ISC_LIST_PREPEND
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 				 * XXXMLG We don't check the return value 				 * here.  If it fails, we will not do TTL 				 * based expiry on this node.  However, we 				 * will do it on the LRU side, so memory 				 * will not leak... for long. 				 */
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|heaps
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_heap_insert
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RESIGN
argument_list|(
name|newheader
argument_list|)
condition|)
block|{
name|resign_delete
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|result
operator|=
name|resign_insert
argument_list|(
name|rbtdb
argument_list|,
name|idx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * No non-IGNORED rdatasets of the given type exist at 		 * this node. 		 */
comment|/* 		 * If we're trying to delete the type, don't bother. 		 */
if|if
condition|(
name|newheader_nx
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
if|if
condition|(
name|topheader
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have an list of rdatasets of the given type, 			 * but they're all marked IGNORE.  We simply insert 			 * the new rdataset at the head of the list. 			 * 			 * Ignored rdatasets cannot occur during loading, so 			 * we INSIST on it. 			 */
name|INSIST
argument_list|(
operator|!
name|loading
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No rdatasets of the given type exist at the node. 			 */
name|newheader
operator|->
name|next
operator|=
name|rbtnode
operator|->
name|data
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
block|}
name|idx
operator|=
name|newheader
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|ISC_LIST_PREPEND
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_heap_insert
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|idx
index|]
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RESIGN
argument_list|(
name|newheader
argument_list|)
condition|)
block|{
name|resign_delete
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|result
operator|=
name|resign_insert
argument_list|(
name|rbtdb
argument_list|,
name|idx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* 	 * Check if the node now contains CNAME and other data. 	 */
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
operator|&&
name|cname_and_other_data
argument_list|(
name|rbtnode
argument_list|,
name|rbtversion
operator|->
name|serial
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_CNAMEANDOTHER
operator|)
return|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|newheader
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|delegating_type
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_rdatatype_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
operator|||
operator|(
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|(
name|node
operator|!=
name|rbtdb
operator|->
name|origin_node
operator|||
name|IS_STUB
argument_list|(
name|rbtdb
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|addnoqname
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|struct
name|noqname
modifier|*
name|noqname
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rdataset_t
name|neg
decl_stmt|,
name|negsig
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_getnoqname
argument_list|(
name|rdataset
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|neg
argument_list|,
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|noqname
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noqname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|noqname
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|noqname
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
name|noqname
operator|->
name|negsig
operator|=
name|NULL
expr_stmt|;
name|noqname
operator|->
name|type
operator|=
name|neg
operator|.
name|type
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|name
argument_list|,
name|mctx
argument_list|,
operator|&
name|noqname
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|neg
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|noqname
operator|->
name|neg
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|negsig
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|noqname
operator|->
name|negsig
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|noqname
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|!=
name|NULL
condition|)
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|noqname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|addclosest
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|struct
name|noqname
modifier|*
name|closest
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rdataset_t
name|neg
decl_stmt|,
name|negsig
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_getclosest
argument_list|(
name|rdataset
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|neg
argument_list|,
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|closest
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|closest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|closest
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|closest
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|closest
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
name|closest
operator|->
name|negsig
operator|=
name|NULL
expr_stmt|;
name|closest
operator|->
name|type
operator|=
name|neg
operator|.
name|type
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|name
argument_list|,
name|mctx
argument_list|,
operator|&
name|closest
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|neg
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|closest
operator|->
name|neg
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|negsig
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|closest
operator|->
name|negsig
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|closest
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|neg
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|negsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|closest
operator|!=
name|NULL
condition|)
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|closest
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_dbmethods_t
name|zone_methods
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|addrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|delegating
decl_stmt|;
name|isc_boolean_t
name|newnsec
decl_stmt|;
name|isc_boolean_t
name|tree_locked
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|cache_is_overmem
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|==
operator|&
name|zone_methods
condition|)
name|REQUIRE
argument_list|(
operator|(
operator|(
name|rbtnode
operator|->
name|nsec
operator|==
name|DNS_RBT_NSEC_NSEC3
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_nsec3
operator|)
operator|)
operator|||
operator|(
name|rbtnode
operator|->
name|nsec
operator|!=
name|DNS_RBT_NSEC_NSEC3
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec3
operator|&&
name|rdataset
operator|->
name|covers
operator|!=
name|dns_rdatatype_nsec3
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
else|else
name|now
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
operator|->
name|ttl
operator|+
name|now
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|last_used
operator|=
name|now
expr_stmt|;
name|newheader
operator|->
name|node
operator|=
name|rbtnode
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
condition|)
block|{
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_RESIGN
operator|)
operator|!=
literal|0
condition|)
block|{
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_RESIGN
expr_stmt|;
name|newheader
operator|->
name|resign
operator|=
name|rdataset
operator|->
name|resign
expr_stmt|;
block|}
else|else
name|newheader
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newheader
operator|->
name|serial
operator|=
literal|1
expr_stmt|;
name|newheader
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NEGATIVE
operator|)
operator|!=
literal|0
condition|)
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_NEGATIVE
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NXDOMAIN
operator|)
operator|!=
literal|0
condition|)
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_NXDOMAIN
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_OPTOUT
operator|)
operator|!=
literal|0
condition|)
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_OPTOUT
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NOQNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|addnoqname
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_CLOSEST
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|addclosest
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * If we're adding a delegation type (e.g. NS or DNAME for a zone, 	 * just DNAME for the cache), then we need to set the callback bit 	 * on the node. 	 */
if|if
condition|(
name|delegating_type
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
condition|)
name|delegating
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|delegating
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * Add to the auxiliary NSEC tree if we're adding an NSEC record. 	 */
if|if
condition|(
name|rbtnode
operator|->
name|nsec
operator|!=
name|DNS_RBT_NSEC_HAS_NSEC
operator|&&
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|newnsec
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|newnsec
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * If we're adding a delegation type, adding to the auxiliary NSEC tree, 	 * or the DB is a cache in an overmem state, hold an exclusive lock on 	 * the tree.  In the latter case the lock does not necessarily have to 	 * be acquired but it will help purge stale entries more effectively. 	 */
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|isc_mem_isovermem
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
condition|)
name|cache_is_overmem
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|delegating
operator|||
name|newnsec
operator|||
name|cache_is_overmem
condition|)
block|{
name|tree_locked
operator|=
name|ISC_TRUE
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache_is_overmem
condition|)
name|overmem_purge
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
operator|->
name|locknum
argument_list|,
name|now
argument_list|,
name|tree_locked
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|rrsetstats
operator|!=
name|NULL
condition|)
block|{
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STATCOUNT
expr_stmt|;
name|update_rrsetstats
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_locked
condition|)
name|cleanup_dead_nodes
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
operator|->
name|locknum
argument_list|)
expr_stmt|;
name|header
operator|=
name|isc_heap_element
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|rbtnode
operator|->
name|locknum
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|&&
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
name|expire_header
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|tree_locked
argument_list|)
expr_stmt|;
comment|/* 		 * If we've been holding a write lock on the tree just for 		 * cleaning, we can release it now.  However, we still need the 		 * node lock. 		 */
if|if
condition|(
name|tree_locked
operator|&&
operator|!
name|delegating
operator|&&
operator|!
name|newnsec
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|tree_locked
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|newnsec
condition|)
block|{
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|nsecnode
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_rbt_fullnamefromnode
argument_list|(
name|rbtnode
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nsecnode
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|nsec
argument_list|,
name|name
argument_list|,
operator|&
name|nsecnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|nsecnode
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NSEC
expr_stmt|;
name|rbtnode
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_HAS_NSEC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_EXISTS
condition|)
block|{
name|rbtnode
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_HAS_NSEC
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|add32
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rbtversion
argument_list|,
name|newheader
argument_list|,
name|options
argument_list|,
name|ISC_FALSE
argument_list|,
name|addedrdataset
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|delegating
condition|)
name|rbtnode
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_locked
condition|)
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is deferred until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|subtractrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|newrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|topheader
decl_stmt|,
modifier|*
name|topheader_prev
decl_stmt|,
modifier|*
name|header
decl_stmt|,
modifier|*
name|newheader
decl_stmt|;
name|unsigned
name|char
modifier|*
name|subresult
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtversion
operator|!=
name|NULL
operator|&&
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|==
operator|&
name|zone_methods
condition|)
name|REQUIRE
argument_list|(
operator|(
operator|(
name|rbtnode
operator|->
name|nsec
operator|==
name|DNS_RBT_NSEC_NSEC3
operator|&&
operator|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_nsec3
operator|)
operator|)
operator|||
operator|(
name|rbtnode
operator|->
name|nsec
operator|!=
name|DNS_RBT_NSEC_NSEC3
operator|&&
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec3
operator|&&
name|rdataset
operator|->
name|covers
operator|!=
name|dns_rdatatype_nsec3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|last_used
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|node
operator|=
name|rbtnode
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_RESIGN
operator|)
operator|!=
literal|0
condition|)
block|{
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_RESIGN
expr_stmt|;
name|newheader
operator|->
name|resign
operator|=
name|rdataset
operator|->
name|resign
expr_stmt|;
block|}
else|else
name|newheader
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|changed
operator|=
name|add_changed
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|rbtnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|==
name|NULL
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|topheader_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|newheader
operator|->
name|type
condition|)
break|break;
name|topheader_prev
operator|=
name|topheader
expr_stmt|;
block|}
comment|/* 	 * If header isn't NULL, we've found the right type.  There may be 	 * IGNORE rdatasets between the top of the chain and the first real 	 * data.  We skip over them. 	 */
name|header
operator|=
name|topheader
expr_stmt|;
while|while
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|subresult
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBSUB_EXACT
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|DNS_RDATASLAB_EXACT
expr_stmt|;
if|if
condition|(
name|newheader
operator|->
name|rdh_ttl
operator|!=
name|header
operator|->
name|rdh_ttl
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rdataslab_subtract
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|subresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|subresult
expr_stmt|;
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
comment|/* 			 * We have to set the serial since the rdataslab 			 * subtraction routine copies the reserved portion of 			 * header, not newheader. 			 */
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
comment|/* 			 * XXXJT: dns_rdataslab_subtract() copied the pointers 			 * to additional info.  We need to clear these fields 			 * to avoid having duplicated references. 			 */
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
comment|/* 			 * This subtraction would remove all of the rdata; 			 * add a nonexistent header instead. 			 */
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
name|new_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newheader
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|topheader
operator|->
name|type
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
name|RDATASET_ATTR_NONEXISTENT
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|node
operator|=
name|rbtnode
expr_stmt|;
name|newheader
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|last_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 		 * If we're here, we want to link newheader in front of 		 * topheader. 		 */
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
name|resign_delete
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The rdataset doesn't exist, so we don't need to do anything 		 * to satisfy the deletion request. 		 */
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBSUB_EXACT
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_UNCHANGED
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|newrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|newheader
argument_list|,
literal|0
argument_list|,
name|newrdataset
argument_list|)
expr_stmt|;
name|unlock
label|:
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is deferred until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|deleterdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|covers
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|newheader
operator|=
name|new_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newheader
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
name|RDATASET_ATTR_NONEXISTENT
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
condition|)
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
else|else
name|newheader
operator|->
name|serial
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|last_used
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|node
operator|=
name|rbtnode
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|result
operator|=
name|add32
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rbtversion
argument_list|,
name|newheader
argument_list|,
name|DNS_DBADD_FORCE
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is deferred until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * load a non-NSEC3 node in the main tree and optionally to the auxiliary NSEC  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|loadnode
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|isc_boolean_t
name|hasnsec
parameter_list|)
block|{
name|isc_result_t
name|noderesult
decl_stmt|,
name|nsecresult
decl_stmt|,
name|tmpresult
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|nsecnode
init|=
name|NULL
decl_stmt|,
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|noderesult
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasnsec
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|noderesult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
comment|/* 		 * Add a node to the auxiliary NSEC tree for an old node 		 * just now getting an NSEC record. 		 */
if|if
condition|(
name|node
operator|->
name|nsec
operator|==
name|DNS_RBT_NSEC_HAS_NSEC
condition|)
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|noderesult
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Build the auxiliary tree for NSECs as we go. 	 * This tree speeds searches for closest NSECs that would otherwise 	 * need to examine many irrelevant nodes in large TLDs. 	 * 	 * Add nodes to the auxiliary tree after corresponding nodes have 	 * been added to the main tree. 	 */
name|nsecresult
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|nsec
argument_list|,
name|name
argument_list|,
operator|&
name|nsecnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|nsecnode
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NSEC
expr_stmt|;
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_HAS_NSEC
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nsecresult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
if|#
directive|if
literal|1
comment|/* 0 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"addnode: NSEC node already exists"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_HAS_NSEC
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|noderesult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * Remove the node we just added above. 		 */
name|tmpresult
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"loading_addrdataset: "
literal|"dns_rbt_deletenode: %s after "
literal|"dns_rbt_addnode(NSEC): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|tmpresult
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|noderesult
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the error condition to be returned. 	 */
name|noderesult
operator|=
name|nsecresult
expr_stmt|;
name|done
label|:
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|noderesult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|rbtdb
operator|->
name|rpz_cidr
operator|!=
name|NULL
condition|)
name|dns_rpz_cidr_addip
argument_list|(
name|rbtdb
operator|->
name|rpz_cidr
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noderesult
operator|==
name|ISC_R_SUCCESS
operator|||
name|noderesult
operator|==
name|ISC_R_EXISTS
condition|)
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
return|return
operator|(
name|noderesult
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|loading_addrdataset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
init|=
name|arg
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|loadctx
operator|->
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
comment|/* 	 * This routine does no node locking.  See comments in 	 * 'load' below for more information on loading and 	 * locking. 	 */
comment|/* 	 * SOA records are only allowed at top of zone. 	 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_NOTZONETOP
operator|)
return|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|!=
name|dns_rdatatype_nsec3
operator|&&
name|rdataset
operator|->
name|covers
operator|!=
name|dns_rdatatype_nsec3
condition|)
name|add_empty_wildcards
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* 		 * NS record owners cannot legally be wild cards. 		 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
return|return
operator|(
name|DNS_R_INVALIDNS
operator|)
return|;
comment|/* 		 * NSEC3 record owners cannot legally be wild cards. 		 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
condition|)
return|return
operator|(
name|DNS_R_INVALIDNSEC3
operator|)
return|;
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec3
operator|||
name|rdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_nsec3
condition|)
block|{
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NSEC3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
name|result
operator|=
name|loadnode
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|loadnode
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|node
operator|->
name|locknum
operator|=
name|node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|foundname
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|init_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
operator|->
name|ttl
operator|+
name|loadctx
operator|->
name|now
argument_list|)
expr_stmt|;
comment|/* XXX overflow check */
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
literal|1
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|closest
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|newheader
operator|->
name|additional_auth
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|additional_glue
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|last_used
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|node
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_RESIGN
operator|)
operator|!=
literal|0
condition|)
block|{
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_RESIGN
expr_stmt|;
name|newheader
operator|->
name|resign
operator|=
name|rdataset
operator|->
name|resign
expr_stmt|;
block|}
else|else
name|newheader
operator|->
name|resign
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|add32
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|newheader
argument_list|,
name|DNS_DBADD_MERGE
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|delegating_type
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
condition|)
name|node
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|beginload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_addrdatasetfunc_t
modifier|*
name|addp
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|loadctx
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loadctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|loadctx
operator|->
name|rbtdb
operator|=
name|rbtdb
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|loadctx
operator|->
name|now
argument_list|)
expr_stmt|;
else|else
name|loadctx
operator|->
name|now
operator|=
literal|0
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
operator|(
name|RBTDB_ATTR_LOADED
operator||
name|RBTDB_ATTR_LOADING
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator||=
name|RBTDB_ATTR_LOADING
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
operator|*
name|addp
operator|=
name|loading_addrdataset
expr_stmt|;
operator|*
name|dbloadp
operator|=
name|loadctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|endload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbloadp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|loadctx
operator|=
operator|*
name|dbloadp
expr_stmt|;
name|REQUIRE
argument_list|(
name|loadctx
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
name|RBTDB_ATTR_LOADING
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
name|RBTDB_ATTR_LOADED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator|&=
operator|~
name|RBTDB_ATTR_LOADING
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator||=
name|RBTDB_ATTR_LOADED
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a KEY rdataset at the zone origin containing a 	 * zone key, we consider the zone secure. 	 */
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
operator|*
name|dbloadp
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|loadctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loadctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dump
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|dns_masterformat_t
name|masterformat
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND9
return|return
operator|(
name|dns_master_dump2
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|dns_master_style_default
argument_list|,
name|filename
argument_list|,
name|masterformat
argument_list|)
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|masterformat
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
comment|/* BIND9 */
block|}
end_function

begin_function
specifier|static
name|void
name|delete_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|current
operator|=
name|data
expr_stmt|;
name|locknum
operator|=
name|current
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|issecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|secure
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|secure
operator|=
name|ISC_TF
argument_list|(
name|rbtdb
operator|->
name|current_version
operator|->
name|secure
operator|==
name|dns_db_secure
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|secure
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|isdnssec
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|dnssec
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|dnssec
operator|=
name|ISC_TF
argument_list|(
name|rbtdb
operator|->
name|current_version
operator|->
name|secure
operator|!=
name|dns_db_insecure
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnssec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|nodecount
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|count
operator|=
name|dns_rbt_nodecount
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|settask
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RBTDB_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
name|RBTDB_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|ispersistent
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|getoriginnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|onode
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nodep
operator|!=
name|NULL
operator|&&
operator|*
name|nodep
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Note that the access to origin_node doesn't require a DB lock */
name|onode
operator|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|rbtdb
operator|->
name|origin_node
expr_stmt|;
if|if
condition|(
name|onode
operator|!=
name|NULL
condition|)
block|{
name|NODE_STRONGLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|onode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|onode
argument_list|)
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|onode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|rbtdb
operator|->
name|origin_node
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|getnsec3parameters
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_hash_t
modifier|*
name|hash
parameter_list|,
name|isc_uint8_t
modifier|*
name|flags
parameter_list|,
name|isc_uint16_t
modifier|*
name|iterations
parameter_list|,
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|size_t
modifier|*
name|salt_length
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
name|rbtversion
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|->
name|havensec3
condition|)
block|{
if|if
condition|(
name|hash
operator|!=
name|NULL
condition|)
operator|*
name|hash
operator|=
name|rbtversion
operator|->
name|hash
expr_stmt|;
if|if
condition|(
name|salt
operator|!=
name|NULL
operator|&&
name|salt_length
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
operator|*
name|salt_length
operator|>=
name|rbtversion
operator|->
name|salt_length
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|salt
argument_list|,
name|rbtversion
operator|->
name|salt
argument_list|,
name|rbtversion
operator|->
name|salt_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|salt_length
operator|!=
name|NULL
condition|)
operator|*
name|salt_length
operator|=
name|rbtversion
operator|->
name|salt_length
expr_stmt|;
if|if
condition|(
name|iterations
operator|!=
name|NULL
condition|)
operator|*
name|iterations
operator|=
name|rbtversion
operator|->
name|iterations
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|NULL
condition|)
operator|*
name|flags
operator|=
name|rbtversion
operator|->
name|flags
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|setsigningtime
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_stdtime_t
name|resign
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|isc_stdtime_t
name|oldresign
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|header
operator|=
name|rdataset
operator|->
name|private3
expr_stmt|;
name|header
operator|--
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|oldresign
operator|=
name|header
operator|->
name|resign
expr_stmt|;
name|header
operator|->
name|resign
operator|=
name|resign
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|heap_index
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|RESIGN
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resign
operator|==
literal|0
condition|)
block|{
name|isc_heap_delete
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
name|header
operator|->
name|heap_index
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resign
operator|<
name|oldresign
condition|)
name|isc_heap_increased
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resign
operator|>
name|oldresign
condition|)
name|isc_heap_decreased
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
operator|->
name|heap_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resign
operator|&&
name|header
operator|->
name|heap_index
operator|==
literal|0
condition|)
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_RESIGN
expr_stmt|;
name|result
operator|=
name|resign_insert
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
operator|->
name|locknum
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|getsigningtime
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
init|=
name|NULL
decl_stmt|,
modifier|*
name|this
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|this
operator|=
name|isc_heap_element
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|==
name|NULL
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
name|header
operator|=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|this
operator|->
name|resign
argument_list|,
name|header
operator|->
name|resign
argument_list|)
condition|)
block|{
name|locknum
operator|=
name|header
operator|->
name|node
operator|->
name|locknum
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|header
operator|=
name|this
expr_stmt|;
block|}
else|else
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
argument_list|,
name|header
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundname
operator|!=
name|NULL
condition|)
name|dns_rbt_fullnamefromnode
argument_list|(
name|header
operator|->
name|node
argument_list|,
name|foundname
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|unlock
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|resigned
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
block|{
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
operator|(
name|rbtdb_version_t
operator|*
operator|)
name|version
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rdataset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rdataset
operator|->
name|methods
operator|==
operator|&
name|rdataset_methods
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|future_version
operator|==
name|rbtversion
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtversion
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtversion
operator|->
name|writer
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtversion
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|node
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|header
operator|=
name|rdataset
operator|->
name|private3
expr_stmt|;
name|INSIST
argument_list|(
name|header
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|header
operator|--
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|heap_index
operator|==
literal|0
condition|)
return|return;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Delete from heap and save to re-signed list so that it can 	 * be restored if we backout of this change. 	 */
name|resign_delete
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dns_stats_t
modifier|*
name|getrrsetstats
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* current restriction */
return|return
operator|(
name|rbtdb
operator|->
name|rrsetstats
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_dbmethods_t
name|zone_methods
init|=
block|{
name|attach
block|,
name|detach
block|,
name|beginload
block|,
name|endload
block|,
name|dump
block|,
name|currentversion
block|,
name|newversion
block|,
name|attachversion
block|,
name|closeversion
block|,
name|findnode
block|,
name|zone_find
block|,
name|zone_findzonecut
block|,
name|attachnode
block|,
name|detachnode
block|,
name|expirenode
block|,
name|printnode
block|,
name|createiterator
block|,
name|zone_findrdataset
block|,
name|allrdatasets
block|,
name|addrdataset
block|,
name|subtractrdataset
block|,
name|deleterdataset
block|,
name|issecure
block|,
name|nodecount
block|,
name|ispersistent
block|,
name|overmem
block|,
name|settask
block|,
name|getoriginnode
block|,
name|NULL
block|,
name|getnsec3parameters
block|,
name|findnsec3node
block|,
name|setsigningtime
block|,
name|getsigningtime
block|,
name|resigned
block|,
name|isdnssec
block|,
name|NULL
block|,
ifdef|#
directive|ifdef
name|BIND9
name|rpz_enabled
block|,
name|rpz_findips
block|,
else|#
directive|else
name|NULL
block|,
name|NULL
block|,
endif|#
directive|endif
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_dbmethods_t
name|cache_methods
init|=
block|{
name|attach
block|,
name|detach
block|,
name|beginload
block|,
name|endload
block|,
name|dump
block|,
name|currentversion
block|,
name|newversion
block|,
name|attachversion
block|,
name|closeversion
block|,
name|findnode
block|,
name|cache_find
block|,
name|cache_findzonecut
block|,
name|attachnode
block|,
name|detachnode
block|,
name|expirenode
block|,
name|printnode
block|,
name|createiterator
block|,
name|cache_findrdataset
block|,
name|allrdatasets
block|,
name|addrdataset
block|,
name|subtractrdataset
block|,
name|deleterdataset
block|,
name|issecure
block|,
name|nodecount
block|,
name|ispersistent
block|,
name|overmem
block|,
name|settask
block|,
name|getoriginnode
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|isdnssec
block|,
name|getrrsetstats
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
name|dns_rbtdb64_create
else|#
directive|else
name|dns_rbtdb_create
endif|#
directive|endif
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_dbtype_t
name|type
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|isc_boolean_t
function_decl|(
modifier|*
name|sooner
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|isc_mem_t
modifier|*
name|hmctx
init|=
name|mctx
decl_stmt|;
comment|/* Keep the compiler happy. */
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
name|rbtdb
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * If argv[0] exists, it points to a memory context to use for heap 	 */
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|hmctx
operator|=
operator|(
name|isc_mem_t
operator|*
operator|)
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|memset
argument_list|(
name|rbtdb
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_dbtype_cache
condition|)
block|{
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|cache_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator||=
name|DNS_DBATTR_CACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_dbtype_stub
condition|)
block|{
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|zone_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator||=
name|DNS_DBATTR_STUB
expr_stmt|;
block|}
else|else
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|zone_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|mctx
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|RBTDB_INITLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_rbtdb
goto|;
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_lock
goto|;
comment|/* 	 * Initialize node_lock_count in a generic way to support future 	 * extension which allows the user to specify this value on creation. 	 * Note that when specified for a cache DB it must be larger than 1 	 * as commented with the definition of DEFAULT_CACHE_NODE_LOCK_COUNT. 	 */
if|if
condition|(
name|rbtdb
operator|->
name|node_lock_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|node_lock_count
operator|=
name|DEFAULT_CACHE_NODE_LOCK_COUNT
expr_stmt|;
else|else
name|rbtdb
operator|->
name|node_lock_count
operator|=
name|DEFAULT_NODE_LOCK_COUNT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbtdb
operator|->
name|node_lock_count
operator|<
literal|2
operator|&&
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup_tree_lock
goto|;
block|}
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|node_lock_count
operator|<
operator|(
literal|1
operator|<<
name|DNS_RBT_LOCKLENGTH
operator|)
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|node_locks
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_tree_lock
goto|;
block|}
name|rbtdb
operator|->
name|rrsetstats
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|result
operator|=
name|dns_rdatasetstats_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|rrsetstats
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_node_locks
goto|;
name|rbtdb
operator|->
name|rdatasets
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rdatasetheaderlist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|rdatasets
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_rrsetstats
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|rbtdb
operator|->
name|rdatasets
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Create the heaps. 	 */
name|rbtdb
operator|->
name|heaps
operator|=
name|isc_mem_get
argument_list|(
name|hmctx
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|isc_heap_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|heaps
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_rdatasets
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|sooner
operator|=
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|?
name|ttl_sooner
else|:
name|resign_sooner
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|isc_heap_create
argument_list|(
name|hmctx
argument_list|,
name|sooner
argument_list|,
name|set_index
argument_list|,
literal|0
argument_list|,
operator|&
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_heaps
goto|;
block|}
comment|/* 	 * Create deadnode lists. 	 */
name|rbtdb
operator|->
name|deadnodes
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtnodelist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|deadnodes
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_heaps
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|rbtdb
operator|->
name|deadnodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|active
operator|=
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|rbtdb
operator|->
name|node_lock_count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|NODE_INITLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|NODE_DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|NODE_DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup_deadnodes
goto|;
block|}
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Attach to the mctx.  The database will persist so long as there 	 * are references to it, and attaching to the mctx ensures that our 	 * mctx won't disappear out from under us. 	 */
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|hmctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|hmctx
argument_list|)
expr_stmt|;
comment|/* 	 * Must be initialized before free_rbtdb() is called. 	 */
name|isc_ondestroy_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|ondest
argument_list|)
expr_stmt|;
comment|/* 	 * Make a copy of the origin name. 	 */
name|result
operator|=
name|dns_name_dupwithoffsets
argument_list|(
name|origin
argument_list|,
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Make the Red-Black Trees. 	 */
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|mctx
argument_list|,
name|delete_callback
argument_list|,
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|mctx
argument_list|,
name|delete_callback
argument_list|,
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|nsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|mctx
argument_list|,
name|delete_callback
argument_list|,
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|nsec3
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * In order to set the node callback bit correctly in zone databases, 	 * we need to know if the node has the origin name of the zone. 	 * In loading_addrdataset() we could simply compare the new name 	 * to the origin name, but this is expensive.  Also, we don't know the 	 * node name in addrdataset(), so we need another way of knowing the 	 * zone's top. 	 * 	 * We now explicitly create a node for the zone's origin, and then 	 * we simply remember the node's address.  This is safe, because 	 * the top-of-zone node can never be deleted, nor can its address 	 * change. 	 */
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|nsec3node
decl_stmt|;
name|rbtdb
operator|->
name|origin_node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
operator|&
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_EXISTS
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rbtdb
operator|->
name|origin_node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NORMAL
expr_stmt|;
comment|/* 		 * We need to give the origin node the right locknum. 		 */
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|rbtdb
operator|->
name|origin_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|rbtdb
operator|->
name|origin_node
operator|->
name|locknum
operator|=
name|rbtdb
operator|->
name|origin_node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|rbtdb
operator|->
name|origin_node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|name
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Add an apex node to the NSEC3 tree so that NSEC3 searches 		 * return partial matches when there is only a single NSEC3 		 * record in the tree. 		 */
name|nsec3node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|nsec3
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
operator|&
name|nsec3node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_EXISTS
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|nsec3node
operator|->
name|nsec
operator|=
name|DNS_RBT_NSEC_NSEC3
expr_stmt|;
comment|/* 		 * We need to give the nsec3 origin node the right locknum. 		 */
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|nsec3node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|nsec3node
operator|->
name|locknum
operator|=
name|nsec3node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|nsec3node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|name
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Misc. Initialization. 	 */
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|rbtdb
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Version Initialization. 	 */
name|rbtdb
operator|->
name|current_serial
operator|=
literal|1
expr_stmt|;
name|rbtdb
operator|->
name|least_serial
operator|=
literal|1
expr_stmt|;
name|rbtdb
operator|->
name|next_serial
operator|=
literal|2
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|=
name|allocate_version
argument_list|(
name|mctx
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|current_version
operator|==
name|NULL
condition|)
block|{
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|rbtdb
operator|->
name|current_version
operator|->
name|rbtdb
operator|=
name|rbtdb
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|secure
operator|=
name|dns_db_insecure
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|havensec3
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|iterations
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|hash
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|->
name|salt_length
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|rbtdb
operator|->
name|current_version
operator|->
name|salt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtdb
operator|->
name|current_version
operator|->
name|salt
argument_list|)
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
expr_stmt|;
comment|/* 	 * Keep the current version in the open list so that list operation 	 * won't happen in normal lookup operations. 	 */
name|PREPEND
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_DB_MAGIC
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|impmagic
operator|=
name|RBTDB_MAGIC
expr_stmt|;
operator|*
name|dbp
operator|=
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_deadnodes
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|deadnodes
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtnodelist_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_heaps
label|:
if|if
condition|(
name|rbtdb
operator|->
name|heaps
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_heap_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|heaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|hmctx
argument_list|,
name|rbtdb
operator|->
name|heaps
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|isc_heap_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cleanup_rdatasets
label|:
if|if
condition|(
name|rbtdb
operator|->
name|rdatasets
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|rdatasets
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rdatasetheaderlist_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_rrsetstats
label|:
if|if
condition|(
name|rbtdb
operator|->
name|rrsetstats
operator|!=
name|NULL
condition|)
name|dns_stats_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|rrsetstats
argument_list|)
expr_stmt|;
name|cleanup_node_locks
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_locks
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_tree_lock
label|:
name|isc_rwlock_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
name|cleanup_lock
label|:
name|RBTDB_DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cleanup_rbtdb
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slabbed Rdataset Methods  */
end_comment

begin_function
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
if|#
directive|if
name|DNS_RDATASET_FIXED
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_LOADORDER
operator|)
operator|==
literal|0
condition|)
name|raw
operator|+=
literal|2
operator|+
operator|(
literal|4
operator|*
name|count
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|raw
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * The privateuint4 field is the number of rdata beyond the 	 * cursor position, so we decrement the total count by one 	 * before storing it. 	 * 	 * If DNS_RDATASETATTR_LOADORDER is not set 'raw' points to the 	 * first record.  If DNS_RDATASETATTR_LOADORDER is set 'raw' points 	 * to the first entry in the offset table. 	 */
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* RDATASLAB */
name|count
operator|=
name|rdataset
operator|->
name|privateuint4
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
comment|/* 	 * Skip forward one record (length + 4) or one offset (4). 	 */
name|raw
operator|=
name|rdataset
operator|->
name|private5
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_LOADORDER
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
name|length
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
block|}
name|rdataset
operator|->
name|private5
operator|=
name|raw
operator|+
literal|4
expr_stmt|;
comment|/* length(2) + order(2) */
else|#
directive|else
name|rdataset
operator|->
name|private5
operator|=
name|raw
operator|+
literal|2
expr_stmt|;
comment|/* length(2) */
endif|#
directive|endif
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private5
decl_stmt|;
comment|/* RDATASLAB */
if|#
directive|if
name|DNS_RDATASET_FIXED
name|unsigned
name|int
name|offset
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|length
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find the start of the record if not already in private5 	 * then skip the length and order fields. 	 */
if|#
directive|if
name|DNS_RDATASET_FIXED
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_LOADORDER
operator|)
operator|!=
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|raw
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|raw
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|raw
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|raw
index|[
literal|3
index|]
expr_stmt|;
name|raw
operator|=
name|rdataset
operator|->
name|private3
expr_stmt|;
name|raw
operator|+=
name|offset
expr_stmt|;
block|}
endif|#
directive|endif
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|#
directive|if
name|DNS_RDATASET_FIXED
name|raw
operator|+=
literal|4
expr_stmt|;
else|#
directive|else
name|raw
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
if|if
condition|(
operator|*
name|raw
operator|&
name|DNS_RDATASLAB_OFFLINE
condition|)
name|flags
operator||=
name|DNS_RDATA_OFFLINE
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|raw
operator|++
expr_stmt|;
block|}
name|r
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|source
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|source
operator|->
name|private2
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|cloned_node
init|=
name|NULL
decl_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|target
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|target
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|target
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_getnoqname
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsec
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsecsig
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|cloned_node
decl_stmt|;
name|struct
name|noqname
modifier|*
name|noqname
init|=
name|rdataset
operator|->
name|private6
decl_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsec
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsec
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsec
operator|->
name|type
operator|=
name|noqname
operator|->
name|type
expr_stmt|;
name|nsec
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsec
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsec
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsec
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsec
operator|->
name|private3
operator|=
name|noqname
operator|->
name|neg
expr_stmt|;
name|nsec
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private7
operator|=
name|NULL
expr_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsecsig
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsecsig
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsecsig
operator|->
name|type
operator|=
name|dns_rdatatype_rrsig
expr_stmt|;
name|nsecsig
operator|->
name|covers
operator|=
name|noqname
operator|->
name|type
expr_stmt|;
name|nsecsig
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsecsig
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsecsig
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsecsig
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsecsig
operator|->
name|private3
operator|=
name|noqname
operator|->
name|negsig
expr_stmt|;
name|nsecsig
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsecsig
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private7
operator|=
name|NULL
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|noqname
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_getclosest
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsec
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsecsig
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|cloned_node
decl_stmt|;
name|struct
name|noqname
modifier|*
name|closest
init|=
name|rdataset
operator|->
name|private7
decl_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsec
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsec
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsec
operator|->
name|type
operator|=
name|closest
operator|->
name|type
expr_stmt|;
name|nsec
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsec
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsec
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsec
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsec
operator|->
name|private3
operator|=
name|closest
operator|->
name|neg
expr_stmt|;
name|nsec
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private7
operator|=
name|NULL
expr_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsecsig
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsecsig
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsecsig
operator|->
name|type
operator|=
name|dns_rdatatype_rrsig
expr_stmt|;
name|nsecsig
operator|->
name|covers
operator|=
name|closest
operator|->
name|type
expr_stmt|;
name|nsecsig
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsecsig
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsecsig
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsecsig
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsecsig
operator|->
name|private3
operator|=
name|closest
operator|->
name|negsig
expr_stmt|;
name|nsecsig
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsecsig
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private7
operator|=
name|NULL
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|closest
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_settrust
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_trust_t
name|trust
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|header
operator|--
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|header
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
operator|=
name|trust
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_expire
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|header
operator|--
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|expire_header
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rdataset Iterator Methods  */
end_comment

begin_function
specifier|static
name|void
name|rdatasetiter_destroy
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
decl_stmt|;
name|rbtiterator
operator|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
operator|(
operator|*
name|iteratorp
operator|)
expr_stmt|;
if|if
condition|(
name|rbtiterator
operator|->
name|common
operator|.
name|version
operator|!=
name|NULL
condition|)
name|closeversion
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|rbtiterator
operator|->
name|common
operator|.
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|detachnode
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|rbtiterator
operator|->
name|common
operator|.
name|node
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|->
name|mctx
argument_list|,
name|rbtiterator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtiterator
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdatasetiter_first
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|serial
operator|=
literal|1
expr_stmt|;
name|now
operator|=
name|rbtiterator
operator|->
name|common
operator|.
name|now
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
block|}
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't exist" 				 * record?  Or is it too old in the cache? 				 * 				 * Note: unlike everywhere else, we 				 * check for now> header->rdh_ttl instead 				 * of now>= header->rdh_ttl.  This allows 				 * ANY and RRSIG queries for 0 TTL 				 * rdatasets to work. 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
operator|||
operator|(
name|now
operator|!=
literal|0
operator|&&
name|now
operator|>
name|header
operator|->
name|rdh_ttl
operator|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtiterator
operator|->
name|current
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdatasetiter_next
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|,
name|negtype
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|,
name|covers
decl_stmt|;
name|header
operator|=
name|rbtiterator
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|serial
operator|=
literal|1
expr_stmt|;
name|now
operator|=
name|rbtiterator
operator|->
name|common
operator|.
name|now
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
block|}
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|->
name|type
expr_stmt|;
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEGATIVE
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|covers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|header
operator|->
name|next
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 		 * If not walking back up the down list. 		 */
if|if
condition|(
name|header
operator|->
name|type
operator|!=
name|type
operator|&&
name|header
operator|->
name|type
operator|!=
name|negtype
condition|)
block|{
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 * 					 * Note: unlike everywhere else, we 					 * check for now> header->ttl instead 					 * of now>= header->ttl.  This allows 					 * ANY and RRSIG queries for 0 TTL 					 * rdatasets to work. 					 */
if|if
condition|(
operator|(
name|header
operator|->
name|attributes
operator|&
name|RDATASET_ATTR_NONEXISTENT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|now
operator|!=
literal|0
operator|&&
name|now
operator|>
name|header
operator|->
name|rdh_ttl
operator|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtiterator
operator|->
name|current
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdatasetiter_current
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|header
operator|=
name|rbtiterator
operator|->
name|current
expr_stmt|;
name|REQUIRE
argument_list|(
name|header
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|rbtiterator
operator|->
name|common
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Database Iterator Methods  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reference_iter_node
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|!=
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|reactivate_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|rbtdbiter
operator|->
name|tree_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dereference_iter_node
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_read
argument_list|,
name|rbtdbiter
operator|->
name|tree_locked
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_deletions
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|isc_boolean_t
name|was_read_locked
init|=
name|ISC_FALSE
decl_stmt|;
name|nodelock_t
modifier|*
name|lock
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|delete
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Note that "%d node of %d in tree" can report things like 		 * "flush_deletions: 59 nodes of 41 in tree".  This means 		 * That some nodes appear on the deletions list more than 		 * once.  Only the last occurence will actually be deleted. 		 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"flush_deletions: %d nodes of %d in tree"
argument_list|,
name|rbtdbiter
operator|->
name|delete
argument_list|,
name|dns_rbt_nodecount
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|was_read_locked
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_write
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdbiter
operator|->
name|delete
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|rbtdbiter
operator|->
name|deletions
index|[
name|i
index|]
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_read
argument_list|,
name|rbtdbiter
operator|->
name|tree_locked
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
block|}
name|rbtdbiter
operator|->
name|delete
operator|=
literal|0
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_read_locked
condition|)
block|{
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_read
expr_stmt|;
block|}
else|else
block|{
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|resume_iteration
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|paused
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbiterator_destroy
parameter_list|(
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
operator|(
operator|*
name|iteratorp
operator|)
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
else|else
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|db
operator|->
name|mctx
argument_list|,
name|rbtdbiter
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdbiter
argument_list|)
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_first
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|nsec3only
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbtdbiter
operator|->
name|nonsec3
operator|&&
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOTFOUND
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
comment|/* The tree is empty. */
block|}
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_last
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|nsec3only
operator|&&
operator|!
name|rbtdbiter
operator|->
name|nonsec3
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_last
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rbtdbiter
operator|->
name|nsec3only
operator|&&
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_last
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOTFOUND
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
comment|/* The tree is empty. */
block|}
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_seek
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|,
name|tresult
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|iname
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOTFOUND
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|iname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|nsec3only
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|,
name|rbtdbiter
operator|->
name|current
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbtdbiter
operator|->
name|nonsec3
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|,
name|rbtdbiter
operator|->
name|current
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Stay on main chain if not found on either chain. 		 */
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|,
name|rbtdbiter
operator|->
name|current
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|iname
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|tresult
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|iname
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|tresult
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
operator|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
operator|)
condition|?
name|ISC_R_SUCCESS
else|:
name|result
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_prev
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
operator|!
name|rbtdbiter
operator|->
name|nsec3only
operator|&&
operator|!
name|rbtdbiter
operator|->
name|nonsec3
operator|&&
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
operator|==
name|rbtdbiter
operator|->
name|current
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|chain
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_last
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
block|}
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|DNS_R_NEWORIGIN
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_next
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
operator|&&
operator|!
name|rbtdbiter
operator|->
name|nsec3only
operator|&&
operator|!
name|rbtdbiter
operator|->
name|nonsec3
operator|&&
operator|&
name|rbtdbiter
operator|->
name|chain
operator|==
name|rbtdbiter
operator|->
name|current
condition|)
block|{
name|rbtdbiter
operator|->
name|current
operator|=
operator|&
name|rbtdbiter
operator|->
name|nsec3chain
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|rbtdb
operator|->
name|nsec3
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
block|}
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|DNS_R_NEWORIGIN
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|rbtdbiter
operator|->
name|current
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_current
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|nodename
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
condition|)
name|origin
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|nodename
argument_list|,
name|origin
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
operator|&&
name|rbtdbiter
operator|->
name|new_origin
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|NODE_STRONGLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|rbtdbiter
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|iterator
operator|->
name|cleaning
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_result_t
name|expire_result
decl_stmt|;
comment|/* 		 * If the deletion array is full, flush it before trying 		 * to expire the current node.  The current node can't 		 * fully deleted while the iteration cursor is still on it. 		 */
if|if
condition|(
name|rbtdbiter
operator|->
name|delete
operator|==
name|DELETION_BATCH_MAX
condition|)
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|expire_result
operator|=
name|expirenode
argument_list|(
name|iterator
operator|->
name|db
argument_list|,
operator|*
name|nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * expirenode() currently always returns success. 		 */
if|if
condition|(
name|expire_result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|node
operator|->
name|down
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|refs
decl_stmt|;
name|rbtdbiter
operator|->
name|deletions
index|[
name|rbtdbiter
operator|->
name|delete
operator|++
index|]
operator|=
name|node
expr_stmt|;
name|NODE_STRONGLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|dns_rbtnode_refincrement
argument_list|(
name|node
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|refs
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|NODE_STRONGUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_pause
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|!=
name|isc_rwlocktype_none
condition|)
block|{
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_origin
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
return|return
operator|(
name|dns_name_copy
argument_list|(
name|origin
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Additional cache routines.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdataset_getadditional
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BIND9
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|versionp
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|nodep
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
else|#
directive|else
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|current_count
init|=
name|rdataset
operator|->
name|privateuint4
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|unsigned
name|int
name|total_count
decl_stmt|;
name|acachectl_t
modifier|*
name|acarray
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
comment|/* we do not use this value at least for now */
name|UNUSED
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|rdatasetheader
operator|*
operator|)
operator|(
name|raw
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|)
expr_stmt|;
name|total_count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|total_count
operator|>
name|current_count
argument_list|)
expr_stmt|;
name|count
operator|=
name|total_count
operator|-
name|current_count
operator|-
literal|1
expr_stmt|;
name|acarray
operator|=
name|NULL
expr_stmt|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|dns_rdatasetadditional_fromauth
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_auth
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromcache
case|:
name|acarray
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromglue
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_glue
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acarray
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|dns_rdatasetadditional_fromcache
condition|)
name|dns_acache_countquerymiss
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|==
name|NULL
condition|)
block|{
name|dns_acache_countquerymiss
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|entry
operator|=
name|NULL
expr_stmt|;
name|dns_acache_attachentry
argument_list|(
name|acarray
index|[
name|count
index|]
operator|.
name|entry
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_acache_getentry
argument_list|(
name|entry
argument_list|,
name|zonep
argument_list|,
name|dbp
argument_list|,
name|versionp
argument_list|,
name|nodep
argument_list|,
name|fname
argument_list|,
name|msg
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acache_callback
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
modifier|*
name|arg
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
decl_stmt|;
name|nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|acachectl_t
modifier|*
name|acarray
init|=
name|NULL
decl_stmt|;
name|acache_cbarg_t
modifier|*
name|cbarg
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|REQUIRE
argument_list|(
name|arg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cbarg
operator|=
operator|*
name|arg
expr_stmt|;
comment|/* 	 * The caller must hold the entry lock. 	 */
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|cbarg
operator|->
name|db
expr_stmt|;
name|rbtnode
operator|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|cbarg
operator|->
name|node
expr_stmt|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cbarg
operator|->
name|type
condition|)
block|{
case|case
name|dns_rdatasetadditional_fromauth
case|:
name|acarray
operator|=
name|cbarg
operator|->
name|header
operator|->
name|additional_auth
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromglue
case|:
name|acarray
operator|=
name|cbarg
operator|->
name|header
operator|->
name|additional_glue
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|cbarg
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|acarray
operator|!=
name|NULL
operator|&&
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|==
name|entry
condition|)
block|{
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
operator|==
name|cbarg
argument_list|)
expr_stmt|;
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|cbarg
argument_list|,
sizeof|sizeof
argument_list|(
name|acache_cbarg_t
argument_list|)
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|(
name|dns_dbnode_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rbtnode
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rbtdb
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* BIND9 */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
specifier|static
name|void
name|acache_cancelentry
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|,
name|acache_cbarg_t
modifier|*
modifier|*
name|cbargp
parameter_list|)
block|{
name|acache_cbarg_t
modifier|*
name|cbarg
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|cbargp
operator|!=
name|NULL
operator|&&
operator|*
name|cbargp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cbarg
operator|=
operator|*
name|cbargp
expr_stmt|;
if|if
condition|(
name|dns_acache_cancelentry
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|cbarg
operator|->
name|db
argument_list|,
operator|&
name|cbarg
operator|->
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|cbarg
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cbarg
argument_list|,
sizeof|sizeof
argument_list|(
name|acache_cbarg_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cbargp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdataset_setadditional
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BIND9
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|zone
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
else|#
directive|else
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|current_count
init|=
name|rdataset
operator|->
name|privateuint4
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|unsigned
name|int
name|total_count
decl_stmt|,
name|count
decl_stmt|;
name|nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|acachectl_t
modifier|*
name|acarray
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|newentry
decl_stmt|,
modifier|*
name|oldentry
init|=
name|NULL
decl_stmt|;
name|acache_cbarg_t
modifier|*
name|newcbarg
decl_stmt|,
modifier|*
name|oldcbarg
init|=
name|NULL
decl_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatasetadditional_fromcache
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|header
operator|=
operator|(
expr|struct
name|rdatasetheader
operator|*
operator|)
operator|(
name|raw
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|)
expr_stmt|;
name|total_count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|total_count
operator|>
name|current_count
argument_list|)
expr_stmt|;
name|count
operator|=
name|total_count
operator|-
name|current_count
operator|-
literal|1
expr_stmt|;
comment|/* should be private data */
name|newcbarg
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newcbarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcbarg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|newcbarg
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|newcbarg
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|newcbarg
operator|->
name|header
operator|=
name|header
expr_stmt|;
name|newcbarg
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|&
name|newcbarg
operator|->
name|db
argument_list|)
expr_stmt|;
name|newcbarg
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_db_attachnode
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|(
name|dns_dbnode_t
operator|*
operator|)
name|rbtnode
argument_list|,
operator|&
name|newcbarg
operator|->
name|node
argument_list|)
expr_stmt|;
name|newentry
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_acache_createentry
argument_list|(
name|acache
argument_list|,
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
name|acache_callback
argument_list|,
name|newcbarg
argument_list|,
operator|&
name|newentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
comment|/* Set cache data in the new entry. */
name|result
operator|=
name|dns_acache_setentry
argument_list|(
name|acache
argument_list|,
name|newentry
argument_list|,
name|zone
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|acarray
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|dns_rdatasetadditional_fromauth
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_auth
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromglue
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_glue
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acarray
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|acarray
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|total_count
operator|*
sizeof|sizeof
argument_list|(
name|acachectl_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|acarray
operator|==
name|NULL
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_count
condition|;
name|i
operator|++
control|)
block|{
name|acarray
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
name|acarray
index|[
name|i
index|]
operator|.
name|cbarg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|dns_rdatasetadditional_fromauth
case|:
name|header
operator|->
name|additional_auth
operator|=
name|acarray
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromglue
case|:
name|header
operator|->
name|additional_glue
operator|=
name|acarray
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Swap the entry.  Delay cleaning-up the old entry since 		 * it would require a node lock. 		 */
name|oldentry
operator|=
name|acarray
index|[
name|count
index|]
operator|.
name|entry
expr_stmt|;
name|INSIST
argument_list|(
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|oldcbarg
operator|=
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
expr_stmt|;
block|}
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|=
name|newentry
expr_stmt|;
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
operator|=
name|newcbarg
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldentry
operator|!=
name|NULL
condition|)
block|{
name|acache_cancelentry
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|oldentry
argument_list|,
operator|&
name|oldcbarg
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|oldentry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|newcbarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|newentry
operator|!=
name|NULL
condition|)
block|{
name|acache_cancelentry
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newentry
argument_list|,
operator|&
name|newcbarg
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|newentry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_db_detachnode
argument_list|(
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
argument_list|,
operator|&
name|newcbarg
operator|->
name|node
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|newcbarg
operator|->
name|db
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newcbarg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newcbarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_putadditional
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdatasetadditional_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|BIND9
name|UNUSED
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
else|#
directive|else
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
comment|/* RDATASLAB */
name|unsigned
name|int
name|current_count
init|=
name|rdataset
operator|->
name|privateuint4
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|nodelock_t
modifier|*
name|nodelock
decl_stmt|;
name|unsigned
name|int
name|total_count
decl_stmt|,
name|count
decl_stmt|;
name|acachectl_t
modifier|*
name|acarray
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|;
name|acache_cbarg_t
modifier|*
name|cbarg
decl_stmt|;
name|UNUSED
argument_list|(
name|qtype
argument_list|)
expr_stmt|;
comment|/* we do not use this value at least for now */
name|UNUSED
argument_list|(
name|acache
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatasetadditional_fromcache
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|header
operator|=
operator|(
expr|struct
name|rdatasetheader
operator|*
operator|)
operator|(
name|raw
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|)
expr_stmt|;
name|total_count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|INSIST
argument_list|(
name|total_count
operator|>
name|current_count
argument_list|)
expr_stmt|;
name|count
operator|=
name|total_count
operator|-
name|current_count
operator|-
literal|1
expr_stmt|;
name|acarray
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|NULL
expr_stmt|;
name|nodelock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|NODE_LOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|dns_rdatasetadditional_fromauth
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_auth
expr_stmt|;
break|break;
case|case
name|dns_rdatasetadditional_fromglue
case|:
name|acarray
operator|=
name|header
operator|->
name|additional_glue
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acarray
operator|==
name|NULL
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|entry
operator|=
name|acarray
index|[
name|count
index|]
operator|.
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|acarray
index|[
name|count
index|]
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
name|cbarg
operator|=
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
expr_stmt|;
name|acarray
index|[
name|count
index|]
operator|.
name|cbarg
operator|=
name|NULL
expr_stmt|;
name|NODE_UNLOCK
argument_list|(
name|nodelock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cbarg
operator|!=
name|NULL
condition|)
name|acache_cancelentry
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|entry
argument_list|,
operator|&
name|cbarg
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*%  * Routines for LRU-based cache management.  */
end_comment

begin_comment
comment|/*%  * See if a given cache entry that is being reused needs to be updated  * in the LRU-list.  From the LRU management point of view, this function is  * expected to return true for almost all cases.  When used with threads,  * however, this may cause a non-negligible performance penalty because a  * writer lock will have to be acquired before updating the list.  * If DNS_RBTDB_LIMITLRUUPDATE is defined to be non 0 at compilation time, this  * function returns true if the entry has not been updated for some period of  * time.  We differentiate the NS or glue address case and the others since  * experiments have shown that the former tends to be accessed relatively  * infrequently and the cost of cache miss is higher (e.g., a missing NS records  * may cause external queries at a higher level zone, involving more  * transactions).  *  * Caller must hold the node (read or write) lock.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|need_headerupdate
parameter_list|(
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
if|if
condition|(
operator|(
name|header
operator|->
name|attributes
operator|&
operator|(
name|RDATASET_ATTR_NONEXISTENT
operator||
name|RDATASET_ATTR_STALE
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|#
directive|if
name|DNS_RBTDB_LIMITLRUUPDATE
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
operator|(
name|header
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|&&
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Glue records are updated if at least 60 seconds have passed 		 * since the previous update time. 		 */
return|return
operator|(
name|header
operator|->
name|last_used
operator|+
literal|60
operator|<=
name|now
operator|)
return|;
block|}
comment|/* Other records are updated if 5 minutes have passed. */
return|return
operator|(
name|header
operator|->
name|last_used
operator|+
literal|300
operator|<=
name|now
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*%  * Update the timestamp of a given cache entry and move it to the head  * of the corresponding LRU list.  *  * Caller must hold the node (write) lock.  *  * Note that the we do NOT touch the heap here, as the TTL has not changed.  */
end_comment

begin_function
specifier|static
name|void
name|update_header
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|INSIST
argument_list|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* To be checked: can we really assume this? XXXMLG */
name|INSIST
argument_list|(
name|ISC_LINK_LINKED
argument_list|(
name|header
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|header
operator|->
name|last_used
operator|=
name|now
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|header
operator|->
name|node
operator|->
name|locknum
index|]
argument_list|,
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Purge some expired and/or stale (i.e. unused for some period) cache entries  * under an overmem condition.  To recover from this condition quickly, up to  * 2 entries will be purged.  This process is triggered while adding a new  * entry, and we specifically avoid purging entries in the same LRU bucket as  * the one to which the new entry will belong.  Otherwise, we might purge  * entries of the same name of different RR types while adding RRsets from a  * single response (consider the case where we're adding A and AAAA glue records  * of the same NS name).  */
end_comment

begin_function
specifier|static
name|void
name|overmem_purge
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|unsigned
name|int
name|locknum_start
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|tree_locked
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|int
name|purgecount
init|=
literal|2
decl_stmt|;
for|for
control|(
name|locknum
operator|=
operator|(
name|locknum_start
operator|+
literal|1
operator|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
init|;
name|locknum
operator|!=
name|locknum_start
operator|&&
name|purgecount
operator|>
literal|0
condition|;
name|locknum
operator|=
operator|(
name|locknum
operator|+
literal|1
operator|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
control|)
block|{
name|NODE_LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|header
operator|=
name|isc_heap_element
argument_list|(
name|rbtdb
operator|->
name|heaps
index|[
name|locknum
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|&&
name|header
operator|->
name|rdh_ttl
operator|<
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
block|{
name|expire_header
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|tree_locked
argument_list|)
expr_stmt|;
name|purgecount
operator|--
expr_stmt|;
block|}
for|for
control|(
name|header
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|locknum
index|]
argument_list|)
init|;
name|header
operator|!=
name|NULL
operator|&&
name|purgecount
operator|>
literal|0
condition|;
name|header
operator|=
name|header_prev
control|)
block|{
name|header_prev
operator|=
name|ISC_LIST_PREV
argument_list|(
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 			 * Unlink the entry at this point to avoid checking it 			 * again even if it's currently used someone else and 			 * cannot be purged at this moment.  This entry won't be 			 * referenced any more (so unlinking is safe) since the 			 * TTL was reset to 0. 			 */
name|ISC_LIST_UNLINK
argument_list|(
name|rbtdb
operator|->
name|rdatasets
index|[
name|locknum
index|]
argument_list|,
name|header
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|expire_header
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
name|tree_locked
argument_list|)
expr_stmt|;
name|purgecount
operator|--
expr_stmt|;
block|}
name|NODE_UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|expire_header
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_boolean_t
name|tree_locked
parameter_list|)
block|{
name|set_ttl
argument_list|(
name|rbtdb
argument_list|,
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|header
operator|->
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Caller must hold the node (write) lock. 	 */
if|if
condition|(
name|dns_rbtnode_refcurrent
argument_list|(
name|header
operator|->
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If no one else is using the node, we can clean it up now. 		 * We first need to gain a new reference to the node to meet a 		 * requirement of decrement_reference(). 		 */
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
argument_list|)
expr_stmt|;
name|decrement_reference
argument_list|(
name|rbtdb
argument_list|,
name|header
operator|->
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_write
argument_list|,
name|tree_locked
condition|?
name|isc_rwlocktype_write
else|:
name|isc_rwlocktype_none
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

