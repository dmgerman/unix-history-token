begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2008  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: rbtdb.c,v 1.168.2.11.2.35 2008/01/24 23:45:27 tbox Exp $ */
end_comment

begin_comment
comment|/*  * Principal Author: Bob Halley  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/refcount.h>
end_include

begin_include
include|#
directive|include
file|<isc/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/masterdump.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataslab.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/zonekey.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_include
include|#
directive|include
file|"rbtdb64.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"rbtdb.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_define
define|#
directive|define
name|RBTDB_MAGIC
value|ISC_MAGIC('R', 'B', 'D', '8')
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RBTDB_MAGIC
value|ISC_MAGIC('R', 'B', 'D', '4')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Note that "impmagic" is not the first four bytes of the struct, so  * ISC_MAGIC_VALID cannot be used.  */
end_comment

begin_define
define|#
directive|define
name|VALID_RBTDB
parameter_list|(
name|rbtdb
parameter_list|)
value|((rbtdb) != NULL&& \ 				 (rbtdb)->common.impmagic == RBTDB_MAGIC)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
end_ifdef

begin_typedef
typedef|typedef
name|isc_uint64_t
name|rbtdb_serial_t
typedef|;
end_typedef

begin_comment
comment|/*  * Make casting easier in symbolic debuggers by using different names  * for the 64 bit version.  */
end_comment

begin_define
define|#
directive|define
name|dns_rbtdb_t
value|dns_rbtdb64_t
end_define

begin_define
define|#
directive|define
name|rdatasetheader_t
value|rdatasetheader64_t
end_define

begin_define
define|#
directive|define
name|rbtdb_version_t
value|rbtdb_version64_t
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|isc_uint32_t
name|rbtdb_serial_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|isc_uint32_t
name|rbtdb_rdatatype_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_BASE
parameter_list|(
name|type
parameter_list|)
value|((dns_rdatatype_t)((type)& 0xFFFF))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_EXT
parameter_list|(
name|type
parameter_list|)
value|((dns_rdatatype_t)((type)>> 16))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_VALUE
parameter_list|(
name|b
parameter_list|,
name|e
parameter_list|)
value|(((e)<< 16) | (b))
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGNSEC
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_nsec)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGNS
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_ns)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGCNAME
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_cname)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_SIGDNAME
define|\
value|RBTDB_RDATATYPE_VALUE(dns_rdatatype_rrsig, dns_rdatatype_dname)
end_define

begin_define
define|#
directive|define
name|RBTDB_RDATATYPE_NCACHEANY
define|\
value|RBTDB_RDATATYPE_VALUE(0, dns_rdatatype_any)
end_define

begin_comment
comment|/*  * Allow clients with a virtual time of upto 5 minutes in the past to see  * records that would have otherwise have expired.  */
end_comment

begin_define
define|#
directive|define
name|RBTDB_VIRTUAL
value|300
end_define

begin_struct
struct|struct
name|noqname
block|{
name|dns_name_t
name|name
decl_stmt|;
name|void
modifier|*
name|nsec
decl_stmt|;
name|void
modifier|*
name|nsecsig
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|rdatasetheader
block|{
comment|/* 	 * Locked by the owning node's lock. 	 */
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|dns_ttl_t
name|ttl
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|;
name|isc_uint16_t
name|attributes
decl_stmt|;
name|dns_trust_t
name|trust
decl_stmt|;
name|struct
name|noqname
modifier|*
name|noqname
decl_stmt|;
comment|/* 	 * We don't use the LIST macros, because the LIST structure has 	 * both head and tail pointers, and is doubly linked. 	 */
name|struct
name|rdatasetheader
modifier|*
name|next
decl_stmt|;
comment|/* 	 * If this is the top header for an rdataset, 'next' points 	 * to the top header for the next rdataset (i.e., the next type). 	 * Otherwise, it points up to the header whose down pointer points 	 * at this header. 	 */
name|struct
name|rdatasetheader
modifier|*
name|down
decl_stmt|;
comment|/* 	 * Points to the header for the next older version of 	 * this rdataset. 	 */
name|isc_uint32_t
name|count
decl_stmt|;
comment|/* 	 * Monotonously increased every time this rdataset is bound so that 	 * it is used as the base of the starting point in DNS responses 	 * when the "cyclic" rrset-order is required.  Since the ordering 	 * should not be so crucial, no lock is set for the counter for 	 * performance reasons. 	 */
block|}
name|rdatasetheader_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RDATASET_ATTR_NONEXISTENT
value|0x0001
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_STALE
value|0x0002
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_IGNORE
value|0x0004
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_RETAIN
value|0x0008
end_define

begin_define
define|#
directive|define
name|RDATASET_ATTR_NXDOMAIN
value|0x0010
end_define

begin_comment
comment|/*  * XXX  * When the cache will pre-expire data (due to memory low or other  * situations) before the rdataset's TTL has expired, it MUST  * respect the RETAIN bit and not expire the data until its TTL is  * expired.  */
end_comment

begin_undef
undef|#
directive|undef
name|IGNORE
end_undef

begin_comment
comment|/* WIN32 winbase.h defines this. */
end_comment

begin_define
define|#
directive|define
name|EXISTS
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NONEXISTENT) == 0)
end_define

begin_define
define|#
directive|define
name|NONEXISTENT
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NONEXISTENT) != 0)
end_define

begin_define
define|#
directive|define
name|IGNORE
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_IGNORE) != 0)
end_define

begin_define
define|#
directive|define
name|RETAIN
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_RETAIN) != 0)
end_define

begin_define
define|#
directive|define
name|NXDOMAIN
parameter_list|(
name|header
parameter_list|)
define|\
value|(((header)->attributes& RDATASET_ATTR_NXDOMAIN) != 0)
end_define

begin_define
define|#
directive|define
name|DEFAULT_NODE_LOCK_COUNT
value|7
end_define

begin_comment
comment|/* Should be prime. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* Locked by lock. */
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_boolean_t
name|exiting
decl_stmt|;
block|}
name|rbtdb_nodelock_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_changed
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_boolean_t
name|dirty
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct rbtdb_changed
argument_list|)
name|link
expr_stmt|;
block|}
name|rbtdb_changed_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rbtdb_changed_t
argument_list|)
name|rbtdb_changedlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_version
block|{
comment|/* Not locked */
name|rbtdb_serial_t
name|serial
decl_stmt|;
comment|/* Locked by database lock. */
name|isc_boolean_t
name|writer
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_boolean_t
name|commit_ok
decl_stmt|;
name|rbtdb_changedlist_t
name|changed_list
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct rbtdb_version
argument_list|)
name|link
expr_stmt|;
block|}
name|rbtdb_version_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|rbtdb_version_t
argument_list|)
name|rbtdb_versionlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Unlocked. */
name|dns_db_t
name|common
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_rwlock_t
name|tree_lock
decl_stmt|;
name|unsigned
name|int
name|node_lock_count
decl_stmt|;
name|rbtdb_nodelock_t
modifier|*
name|node_locks
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|origin_node
decl_stmt|;
comment|/* Locked by lock. */
name|unsigned
name|int
name|active
decl_stmt|;
name|isc_refcount_t
name|references
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|rbtdb_serial_t
name|current_serial
decl_stmt|;
name|rbtdb_serial_t
name|least_serial
decl_stmt|;
name|rbtdb_serial_t
name|next_serial
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|current_version
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|future_version
decl_stmt|;
name|rbtdb_versionlist_t
name|open_versions
decl_stmt|;
name|isc_boolean_t
name|overmem
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
comment|/* Locked by tree_lock. */
name|dns_rbt_t
modifier|*
name|tree
decl_stmt|;
name|isc_boolean_t
name|secure
decl_stmt|;
block|}
name|dns_rbtdb_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|RBTDB_ATTR_LOADED
value|0x01
end_define

begin_define
define|#
directive|define
name|RBTDB_ATTR_LOADING
value|0x02
end_define

begin_comment
comment|/*  * Search Context  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|isc_boolean_t
name|copy_name
decl_stmt|;
name|isc_boolean_t
name|need_cleanup
decl_stmt|;
name|isc_boolean_t
name|wild
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|zonecut
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|zonecut_rdataset
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|zonecut_sigrdataset
decl_stmt|;
name|dns_fixedname_t
name|zonecut_name
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
block|}
name|rbtdb_search_t
typedef|;
end_typedef

begin_comment
comment|/*  * Load Context  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
block|}
name|rbtdb_load_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_getnoqname
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsec
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsecsig
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_rdatasetmethods_t
name|rdataset_methods
init|=
block|{
name|rdataset_disassociate
block|,
name|rdataset_first
block|,
name|rdataset_next
block|,
name|rdataset_current
block|,
name|rdataset_clone
block|,
name|rdataset_count
block|,
name|NULL
block|,
name|rdataset_getnoqname
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rdatasetiter_destroy
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdatasetiter_first
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdatasetiter_next
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdatasetiter_current
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_rdatasetitermethods_t
name|rdatasetiter_methods
init|=
block|{
name|rdatasetiter_destroy
block|,
name|rdatasetiter_first
block|,
name|rdatasetiter_next
block|,
name|rdatasetiter_current
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_rdatasetiter
block|{
name|dns_rdatasetiter_t
name|common
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|;
block|}
name|rbtdb_rdatasetiter_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|dbiterator_destroy
parameter_list|(
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_first
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_last
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_seek
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_prev
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_next
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_current
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_pause
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dbiterator_origin
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dns_dbiteratormethods_t
name|dbiterator_methods
init|=
block|{
name|dbiterator_destroy
block|,
name|dbiterator_first
block|,
name|dbiterator_last
block|,
name|dbiterator_seek
block|,
name|dbiterator_prev
block|,
name|dbiterator_next
block|,
name|dbiterator_current
block|,
name|dbiterator_pause
block|,
name|dbiterator_origin
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DELETION_BATCH_MAX
value|64
end_define

begin_comment
comment|/*  * If 'paused' is ISC_TRUE, then the tree lock is not being held.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rbtdb_dbiterator
block|{
name|dns_dbiterator_t
name|common
decl_stmt|;
name|isc_boolean_t
name|paused
decl_stmt|;
name|isc_boolean_t
name|new_origin
decl_stmt|;
name|isc_rwlocktype_t
name|tree_locked
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|name
decl_stmt|;
name|dns_fixedname_t
name|origin
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|deletions
index|[
name|DELETION_BATCH_MAX
index|]
decl_stmt|;
name|int
name|delete
decl_stmt|;
block|}
name|rbtdb_dbiterator_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|IS_STUB
parameter_list|(
name|rbtdb
parameter_list|)
value|(((rbtdb)->common.attributes& DNS_DBATTR_STUB)  != 0)
end_define

begin_define
define|#
directive|define
name|IS_CACHE
parameter_list|(
name|rbtdb
parameter_list|)
value|(((rbtdb)->common.attributes& DNS_DBATTR_CACHE) != 0)
end_define

begin_function_decl
specifier|static
name|void
name|free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_boolean_t
name|log
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%  * 'init_count' is used to initialize 'newheader->count' which inturn  * is used to determine where in the cycle rrset-order cyclic starts.  * We don't lock this as we don't care about simultanious updates.  *  * Note:  *	Both init_count and header->count can be ISC_UINT32_MAX.  *      The count on the returned rdataset however can't be as  *	that indicates that the database does not implement cyclic  *	processing.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|init_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locking  *  * If a routine is going to lock more than one lock in this module, then  * the locking must be done in the following order:  *  *	Tree Lock  *  *	Node Lock	(Only one from the set may be locked at one time by  *			 any caller)  *  *	Database Lock  *  * Failure to follow this hierarchy can result in deadlock.  */
end_comment

begin_comment
comment|/*  * Deleting Nodes  *  * Currently there is no deletion of nodes from the database, except when  * the database is being destroyed.  *  * If node deletion is added in the future, then for zone databases the node  * for the origin of the zone MUST NOT be deleted.  */
end_comment

begin_comment
comment|/*  * DB Routines  */
end_comment

begin_function
specifier|static
name|void
name|attach
parameter_list|(
name|dns_db_t
modifier|*
name|source
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|source
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rbtdb_callback
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|isc_boolean_t
name|log
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_ondestroy_t
name|ondest
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|EMPTY
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|future_version
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|current_version
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtdb_version_t
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|rbtdb
operator|->
name|tree
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_destroy2
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree
argument_list|,
operator|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
operator|)
condition|?
literal|1000
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_QUOTA
condition|)
block|{
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_FREESTORAGE
argument_list|,
name|free_rbtdb_callback
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
goto|goto
name|again
goto|;
name|isc_task_send
argument_list|(
name|rbtdb
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|rbtdb
operator|->
name|tree
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"done free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_locks
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_rwlock_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|ondest
operator|=
name|rbtdb
operator|->
name|common
operator|.
name|ondest
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_ondestroy_notify
argument_list|(
operator|&
name|ondest
argument_list|,
name|rbtdb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|maybe_free_rbtdb
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|)
block|{
name|isc_boolean_t
name|want_free
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|inactive
init|=
literal|0
decl_stmt|;
comment|/* XXX check for open versions here */
comment|/* 	 * Even though there are no external direct references, there still 	 * may be nodes in use. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdb
operator|->
name|node_lock_count
condition|;
name|i
operator|++
control|)
block|{
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
operator|==
literal|0
condition|)
name|inactive
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inactive
operator|!=
literal|0
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|active
operator|-=
name|inactive
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|active
operator|==
literal|0
condition|)
name|want_free
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_free
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"calling free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|detach
parameter_list|(
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
operator|*
name|dbp
operator|)
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
name|maybe_free_rbtdb
argument_list|(
name|rbtdb
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|currentversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|version
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
if|if
condition|(
name|version
operator|->
name|references
operator|==
literal|0
condition|)
name|PREPEND
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|version
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|versionp
operator|=
operator|(
name|dns_dbversion_t
operator|*
operator|)
name|version
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|rbtdb_version_t
modifier|*
name|allocate_version
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|,
name|unsigned
name|int
name|references
parameter_list|,
name|isc_boolean_t
name|writer
parameter_list|)
block|{
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|version
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|version
operator|->
name|serial
operator|=
name|serial
expr_stmt|;
name|version
operator|->
name|references
operator|=
name|references
expr_stmt|;
name|version
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
name|version
operator|->
name|commit_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|newversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|versionp
operator|!=
name|NULL
operator|&&
operator|*
name|versionp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb
operator|->
name|future_version
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|rbtdb
operator|->
name|next_serial
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Error? */
name|version
operator|=
name|allocate_version
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|next_serial
argument_list|,
literal|1
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|version
operator|->
name|commit_ok
operator|=
name|ISC_TRUE
expr_stmt|;
name|rbtdb
operator|->
name|next_serial
operator|++
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|version
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|*
name|versionp
operator|=
name|version
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attachversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|source
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|source
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rbtversion
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|rbtversion
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rbtdb_changed_t
modifier|*
name|add_changed
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|changed
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|changed
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|version
operator|->
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|changed
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|changed
operator|->
name|dirty
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|version
operator|->
name|commit_ok
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_noqname
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|struct
name|noqname
modifier|*
modifier|*
name|noqname
parameter_list|)
block|{
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
operator|(
operator|*
name|noqname
operator|)
operator|->
name|name
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
operator|(
operator|*
name|noqname
operator|)
operator|->
name|name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsec
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsec
argument_list|,
name|dns_rdataslab_size
argument_list|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsecsig
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsecsig
argument_list|,
name|dns_rdataslab_size
argument_list|(
operator|(
operator|*
name|noqname
operator|)
operator|->
name|nsecsig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
operator|*
name|noqname
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|noqname
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_rdataset
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|rdatasetheader_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|noqname
operator|!=
name|NULL
condition|)
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|rdataset
operator|->
name|noqname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|RDATASET_ATTR_NONEXISTENT
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|dns_rdataslab_size
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rdataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdataset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rollback_node
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|dcurrent
decl_stmt|;
name|isc_boolean_t
name|make_dirty
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * Caller must hold the node lock. 	 */
comment|/* 	 * We set the IGNORE attribute on rdatasets with serial number 	 * 'serial'.  When the reference count goes to zero, these rdatasets 	 * will be cleaned up; until that time, they will be ignored. 	 */
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|==
name|serial
condition|)
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_IGNORE
expr_stmt|;
name|make_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
for|for
control|(
name|dcurrent
operator|=
name|header
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|dcurrent
operator|->
name|down
control|)
block|{
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|==
name|serial
condition|)
block|{
name|dcurrent
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_IGNORE
expr_stmt|;
name|make_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|make_dirty
condition|)
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clean_cache_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|dcurrent
decl_stmt|,
modifier|*
name|top_prev
decl_stmt|,
modifier|*
name|top_next
decl_stmt|,
modifier|*
name|down_next
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|top_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|current
operator|=
name|node
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|dcurrent
operator|=
name|current
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|dcurrent
argument_list|)
expr_stmt|;
name|dcurrent
operator|=
name|down_next
expr_stmt|;
block|}
do|while
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
do|;
name|current
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * If current is nonexistent or stale, we can clean it up. 		 */
if|if
condition|(
operator|(
name|current
operator|->
name|attributes
operator|&
operator|(
name|RDATASET_ATTR_NONEXISTENT
operator||
name|RDATASET_ATTR_STALE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
else|else
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
name|node
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clean_zone_node
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|least_serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|dcurrent
decl_stmt|,
modifier|*
name|down_next
decl_stmt|,
modifier|*
name|dparent
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|top_prev
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
name|isc_boolean_t
name|still_dirty
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|REQUIRE
argument_list|(
name|least_serial
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|top_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|current
operator|=
name|node
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
comment|/* 		 * First, we clean up any instances of multiple rdatasets 		 * with the same serial number, or that have the IGNORE 		 * attribute. 		 */
name|dparent
operator|=
name|current
expr_stmt|;
for|for
control|(
name|dcurrent
operator|=
name|current
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|down_next
control|)
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
name|INSIST
argument_list|(
name|dcurrent
operator|->
name|serial
operator|<=
name|dparent
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|==
name|dparent
operator|->
name|serial
operator|||
name|IGNORE
argument_list|(
name|dcurrent
argument_list|)
condition|)
block|{
if|if
condition|(
name|down_next
operator|!=
name|NULL
condition|)
name|down_next
operator|->
name|next
operator|=
name|dparent
expr_stmt|;
name|dparent
operator|->
name|down
operator|=
name|down_next
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|dcurrent
argument_list|)
expr_stmt|;
block|}
else|else
name|dparent
operator|=
name|dcurrent
expr_stmt|;
block|}
comment|/* 		 * We've now eliminated all IGNORE datasets with the possible 		 * exception of current, which we now check. 		 */
if|if
condition|(
name|IGNORE
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|down_next
operator|=
name|current
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|down_next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|/* 				 * current no longer exists, so we can 				 * just continue with the loop. 				 */
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Pull up current->down, making it the new 				 * current. 				 */
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|down_next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|down_next
expr_stmt|;
name|down_next
operator|->
name|next
operator|=
name|top_next
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|down_next
expr_stmt|;
block|}
block|}
comment|/* 		 * We now try to find the first down node less than the 		 * least serial. 		 */
name|dparent
operator|=
name|current
expr_stmt|;
for|for
control|(
name|dcurrent
operator|=
name|current
operator|->
name|down
init|;
name|dcurrent
operator|!=
name|NULL
condition|;
name|dcurrent
operator|=
name|down_next
control|)
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|dcurrent
operator|->
name|serial
operator|<
name|least_serial
condition|)
break|break;
name|dparent
operator|=
name|dcurrent
expr_stmt|;
block|}
comment|/* 		 * If there is a such an rdataset, delete it and any older 		 * versions. 		 */
if|if
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|down_next
operator|=
name|dcurrent
operator|->
name|down
expr_stmt|;
name|INSIST
argument_list|(
name|dcurrent
operator|->
name|serial
operator|<=
name|least_serial
argument_list|)
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|dcurrent
argument_list|)
expr_stmt|;
name|dcurrent
operator|=
name|down_next
expr_stmt|;
block|}
do|while
condition|(
name|dcurrent
operator|!=
name|NULL
condition|)
do|;
name|dparent
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Note.  The serial number of 'current' might be less than 		 * least_serial too, but we cannot delete it because it is 		 * the most recent version, unless it is a NONEXISTENT 		 * rdataset. 		 */
if|if
condition|(
name|current
operator|->
name|down
operator|!=
name|NULL
condition|)
block|{
name|still_dirty
operator|=
name|ISC_TRUE
expr_stmt|;
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this is a NONEXISTENT rdataset, we can delete it. 			 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|current
argument_list|)
condition|)
block|{
if|if
condition|(
name|top_prev
operator|!=
name|NULL
condition|)
name|top_prev
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
else|else
name|top_prev
operator|=
name|current
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|still_dirty
condition|)
name|node
operator|->
name|dirty
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|new_reference
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|no_references
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|least_serial
parameter_list|,
name|isc_rwlocktype_t
name|lock
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|write_locked
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
name|REQUIRE
argument_list|(
name|node
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|dirty
condition|)
block|{
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|clean_cache_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|least_serial
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Caller doesn't know the least serial. 				 * Get it. 				 */
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|least_serial
operator|=
name|rbtdb
operator|->
name|least_serial
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|clean_zone_node
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|least_serial
argument_list|)
expr_stmt|;
block|}
block|}
name|locknum
operator|=
name|node
operator|->
name|locknum
expr_stmt|;
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|references
operator|--
expr_stmt|;
comment|/* 	 * XXXDCL should this only be done for cache zones? 	 */
if|if
condition|(
name|node
operator|->
name|data
operator|!=
name|NULL
operator|||
name|node
operator|->
name|down
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * XXXDCL need to add a deferred delete method for ISC_R_LOCKBUSY. 	 */
if|if
condition|(
name|lock
operator|!=
name|isc_rwlocktype_write
condition|)
block|{
comment|/* 		 * Locking hierarchy notwithstanding, we don't need to free 		 * the node lock before acquiring the tree write lock because 		 * we only do a trylock. 		 */
if|if
condition|(
name|lock
operator|==
name|isc_rwlocktype_read
condition|)
name|result
operator|=
name|isc_rwlock_tryupgrade
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|isc_rwlock_trylock
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_LOCKBUSY
argument_list|)
expr_stmt|;
name|write_locked
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
name|write_locked
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|write_locked
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"no_references: delete from rbt: %p %s"
argument_list|,
name|node
argument_list|,
name|dns_rbt_formatnodename
argument_list|(
name|node
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|node
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"no_references: dns_rbt_deletenode: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Relock a read lock, or unlock the write lock if no lock was held. 	 */
if|if
condition|(
name|lock
operator|==
name|isc_rwlocktype_none
condition|)
if|if
condition|(
name|write_locked
condition|)
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|==
name|isc_rwlocktype_read
condition|)
if|if
condition|(
name|write_locked
condition|)
name|isc_rwlock_downgrade
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|make_least_version
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rbtdb_changedlist_t
modifier|*
name|cleanup_list
parameter_list|)
block|{
comment|/* 	 * Caller must be holding the database lock. 	 */
name|rbtdb
operator|->
name|least_serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
operator|*
name|cleanup_list
operator|=
name|version
operator|->
name|changed_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|cleanup_nondirty
parameter_list|(
name|rbtdb_version_t
modifier|*
name|version
parameter_list|,
name|rbtdb_changedlist_t
modifier|*
name|cleanup_list
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|,
modifier|*
name|next_changed
decl_stmt|;
comment|/* 	 * If the changed record is dirty, then 	 * an update created multiple versions of 	 * a given rdataset.  We keep this list 	 * until we're the least open version, at 	 * which point it's safe to get rid of any 	 * older versions. 	 * 	 * If the changed record isn't dirty, then 	 * we don't need it anymore since we're 	 * committing and not rolling back. 	 * 	 * The caller must be holding the database lock. 	 */
for|for
control|(
name|changed
operator|=
name|HEAD
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
init|;
name|changed
operator|!=
name|NULL
condition|;
name|changed
operator|=
name|next_changed
control|)
block|{
name|next_changed
operator|=
name|NEXT
argument_list|(
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
operator|->
name|dirty
condition|)
block|{
name|UNLINK
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
operator|*
name|cleanup_list
argument_list|,
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|iszonesecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|origin
parameter_list|)
block|{
name|dns_rdataset_t
name|keyset
decl_stmt|;
name|dns_rdataset_t
name|nsecset
decl_stmt|,
name|signsecset
decl_stmt|;
name|isc_boolean_t
name|haszonekey
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|hasnsec
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|keyset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdata_t
name|keyrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_current
argument_list|(
operator|&
name|keyset
argument_list|,
operator|&
name|keyrdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_zonekey_iszonekey
argument_list|(
operator|&
name|keyrdata
argument_list|)
condition|)
block|{
name|haszonekey
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keyset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|haszonekey
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nsecset
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|signsecset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|,
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|nsecset
argument_list|,
operator|&
name|signsecset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|signsecset
argument_list|)
condition|)
block|{
name|hasnsec
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|signsecset
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsecset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hasnsec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|closeversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
name|commit
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|version
decl_stmt|,
modifier|*
name|cleanup_version
decl_stmt|,
modifier|*
name|least_greater
decl_stmt|;
name|isc_boolean_t
name|rollback
init|=
name|ISC_FALSE
decl_stmt|;
name|rbtdb_changedlist_t
name|cleanup_list
decl_stmt|;
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|,
modifier|*
name|next_changed
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|,
name|least_serial
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|isc_boolean_t
name|writer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|version
operator|=
operator|(
name|rbtdb_version_t
operator|*
operator|)
operator|*
name|versionp
expr_stmt|;
name|cleanup_version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|cleanup_list
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|version
operator|->
name|writer
operator|||
operator|!
operator|(
name|commit
operator|&&
name|version
operator|->
name|references
operator|>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|version
operator|->
name|references
operator|--
expr_stmt|;
name|serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
name|writer
operator|=
name|version
operator|->
name|writer
expr_stmt|;
if|if
condition|(
name|version
operator|->
name|references
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|version
operator|->
name|writer
condition|)
block|{
if|if
condition|(
name|commit
condition|)
block|{
name|INSIST
argument_list|(
name|version
operator|->
name|commit_ok
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|==
name|rbtdb
operator|->
name|future_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
condition|)
block|{
comment|/* 					 * We're going to become the least open 					 * version. 					 */
name|make_least_version
argument_list|(
name|rbtdb
argument_list|,
name|version
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Some other open version is the 					 * least version.  We can't cleanup 					 * records that were changed in this 					 * version because the older versions 					 * may still be in use by an open 					 * version. 					 * 					 * We can, however, discard the 					 * changed records for things that 					 * we've added that didn't exist in 					 * prior versions. 					 */
name|cleanup_nondirty
argument_list|(
name|version
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * If the (soon to be former) current version 				 * isn't being used by anyone, we can clean 				 * it up. 				 */
if|if
condition|(
name|rbtdb
operator|->
name|current_version
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|cleanup_version
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
name|APPENDLIST
argument_list|(
name|version
operator|->
name|changed_list
argument_list|,
name|cleanup_version
operator|->
name|changed_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Become the current version. 				 */
name|version
operator|->
name|writer
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|=
name|version
expr_stmt|;
name|rbtdb
operator|->
name|current_serial
operator|=
name|version
operator|->
name|serial
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We're rolling back this transaction. 				 */
name|cleanup_list
operator|=
name|version
operator|->
name|changed_list
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
expr_stmt|;
name|rollback
operator|=
name|ISC_TRUE
expr_stmt|;
name|cleanup_version
operator|=
name|version
expr_stmt|;
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|version
operator|!=
name|rbtdb
operator|->
name|current_version
condition|)
block|{
comment|/* 				 * There are no external or internal references 				 * to this version and it can be cleaned up. 				 */
name|cleanup_version
operator|=
name|version
expr_stmt|;
comment|/* 				 * Find the version with the least serial 				 * number greater than ours. 				 */
name|least_greater
operator|=
name|PREV
argument_list|(
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_greater
operator|==
name|NULL
condition|)
name|least_greater
operator|=
name|rbtdb
operator|->
name|current_version
expr_stmt|;
name|INSIST
argument_list|(
name|version
operator|->
name|serial
operator|<
name|least_greater
operator|->
name|serial
argument_list|)
expr_stmt|;
comment|/* 				 * Is this the least open version? 				 */
if|if
condition|(
name|version
operator|->
name|serial
operator|==
name|rbtdb
operator|->
name|least_serial
condition|)
block|{
comment|/* 					 * Yes.  Install the new least open 					 * version. 					 */
name|make_least_version
argument_list|(
name|rbtdb
argument_list|,
name|least_greater
argument_list|,
operator|&
name|cleanup_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Add any unexecuted cleanups to 					 * those of the least greater version. 					 */
name|APPENDLIST
argument_list|(
name|least_greater
operator|->
name|changed_list
argument_list|,
name|version
operator|->
name|changed_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|version
operator|->
name|serial
operator|==
name|rbtdb
operator|->
name|least_serial
condition|)
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|version
operator|->
name|changed_list
argument_list|)
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|,
name|version
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|least_serial
operator|=
name|rbtdb
operator|->
name|least_serial
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status. 	 */
if|if
condition|(
name|writer
operator|&&
name|commit
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|secure
operator|=
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_version
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|EMPTY
argument_list|(
name|cleanup_version
operator|->
name|changed_list
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|cleanup_version
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cleanup_version
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|cleanup_list
argument_list|)
condition|)
block|{
for|for
control|(
name|changed
operator|=
name|HEAD
argument_list|(
name|cleanup_list
argument_list|)
init|;
name|changed
operator|!=
name|NULL
condition|;
name|changed
operator|=
name|next_changed
control|)
block|{
name|next_changed
operator|=
name|NEXT
argument_list|(
name|changed
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rbtnode
operator|=
name|changed
operator|->
name|node
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtnode
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rbtnode
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|rollback
condition|)
name|rollback_node
argument_list|(
name|rbtnode
argument_list|,
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtnode
operator|->
name|references
operator|==
literal|0
condition|)
name|no_references
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|least_serial
argument_list|,
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|changed
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|changed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the necessary magic for the wildcard name 'name'  * to be found in 'rbtdb'.  *  * In order for wildcard matching to work correctly in  * zone_find(), we must ensure that a node for the wildcarding  * level exists in the database, and has its 'find_callback'  * and 'wild' bits set.  *  * E.g. if the wildcard name is "*.sub.example." then we  * must ensure that "sub.example." exists and is marked as  * a wildcard level.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|add_wildcard_magic
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|foundname
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|node
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|wild
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add_empty_wildcards
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|,
name|l
decl_stmt|,
name|i
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|l
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
expr_stmt|;
name|i
operator|=
name|l
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* dummy */
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|n
operator|-
name|i
argument_list|,
name|i
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
operator|&
name|foundname
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|foundname
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|findnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_name_t
name|nodename
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_rwlocktype_t
name|locktype
init|=
name|isc_rwlocktype_read
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|nodename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|create
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 		 * It would be nice to try to upgrade the lock instead of 		 * unlocking then relocking. 		 */
name|locktype
operator|=
name|isc_rwlocktype_write
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|node
operator|->
name|locknum
operator|=
name|node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|nodename
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
name|add_empty_wildcards
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
name|locknum
operator|=
name|node
operator|->
name|locknum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|locktype
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
operator|(
name|dns_dbnode_t
operator|*
operator|)
name|node
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_zonecut_callback
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rbtdb_search_t
modifier|*
name|search
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|dname_header
decl_stmt|,
modifier|*
name|sigdname_header
decl_stmt|,
modifier|*
name|ns_header
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|onode
decl_stmt|;
comment|/* 	 * We only want to remember the topmost zone cut, since it's the one 	 * that counts, so we'll just continue if we've already found a 	 * zonecut. 	 */
if|if
condition|(
name|search
operator|->
name|zonecut
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
name|found
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|onode
operator|=
name|search
operator|->
name|rbtdb
operator|->
name|origin_node
expr_stmt|;
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Look for an NS or DNAME rdataset active in our version. 	 */
name|ns_header
operator|=
name|NULL
expr_stmt|;
name|dname_header
operator|=
name|NULL
expr_stmt|;
name|sigdname_header
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
operator|||
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
condition|)
block|{
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
condition|)
name|dname_header
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
condition|)
name|sigdname_header
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|!=
name|onode
operator|||
name|IS_STUB
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|)
condition|)
block|{
comment|/* 					 * We've found an NS rdataset that 					 * isn't at the origin node.  We check 					 * that they're not at the origin node, 					 * because otherwise we'd erroneously 					 * treat the zone top as if it were 					 * a delegation. 					 */
name|ns_header
operator|=
name|header
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Did we find anything? 	 */
if|if
condition|(
name|dname_header
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Note that DNAME has precedence over NS if both exist. 		 */
name|found
operator|=
name|dname_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|sigdname_header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ns_header
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ns_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We increment the reference count on node to ensure that 		 * search->zonecut_rdataset will still be valid later. 		 */
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|search
operator|->
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|zonecut_rdataset
operator|=
name|found
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * Since we've found a zonecut, anything beneath it is 		 * glue and is not subject to wildcard matching, so we 		 * may clear search->wild. 		 */
name|search
operator|->
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the caller does not want to find glue, then 			 * this is the best answer and the search should 			 * stop now. 			 */
name|result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
block|}
else|else
block|{
name|dns_name_t
modifier|*
name|zcname
decl_stmt|;
comment|/* 			 * The search will continue beneath the zone cut. 			 * This may or may not be the best match.  In case it 			 * is, we need to remember the node name. 			 */
name|zcname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|search
operator|->
name|zonecut_name
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|zcname
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|search
operator|->
name|copy_name
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * There is no zonecut at this node which is active in this 		 * version. 		 * 		 * If this is a "wild" node and the caller hasn't disabled 		 * wildcard matching, remember that we've seen a wild node 		 * in case we need to go searching for wildcard matches 		 * later on. 		 */
if|if
condition|(
name|node
operator|->
name|wild
operator|&&
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_NOWILD
operator|)
operator|==
literal|0
condition|)
name|search
operator|->
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bind_rdataset
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rdatasetheader_t
modifier|*
name|header
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
comment|/* 	 * Caller must be holding the node lock. 	 */
if|if
condition|(
name|rdataset
operator|==
name|NULL
condition|)
return|return;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdataset
operator|->
name|methods
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must be disassociated. */
name|rdataset
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|rdataset
operator|->
name|rdclass
operator|=
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
expr_stmt|;
name|rdataset
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|ttl
operator|=
name|header
operator|->
name|ttl
operator|-
name|now
expr_stmt|;
name|rdataset
operator|->
name|trust
operator|=
name|header
operator|->
name|trust
expr_stmt|;
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|header
argument_list|)
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NXDOMAIN
expr_stmt|;
name|rdataset
operator|->
name|private1
operator|=
name|rbtdb
expr_stmt|;
name|rdataset
operator|->
name|private2
operator|=
name|node
expr_stmt|;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|rdataset
operator|->
name|private3
operator|=
name|raw
expr_stmt|;
name|rdataset
operator|->
name|count
operator|=
name|header
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|count
operator|==
name|ISC_UINT32_MAX
condition|)
name|rdataset
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|rdataset
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Add noqname proof. 	 */
name|rdataset
operator|->
name|private6
operator|=
name|header
operator|->
name|noqname
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|private6
operator|!=
name|NULL
condition|)
name|rdataset
operator|->
name|attributes
operator||=
name|DNS_RDATASETATTR_NOQNAME
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|setup_delegation
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|zcname
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
comment|/* 	 * The caller MUST NOT be holding any node locks. 	 */
name|node
operator|=
name|search
operator|->
name|zonecut
expr_stmt|;
name|type
operator|=
name|search
operator|->
name|zonecut_rdataset
operator|->
name|type
expr_stmt|;
comment|/* 	 * If we have to set foundname, we do it before anything else. 	 * If we were to set foundname after we had set nodep or bound the 	 * rdataset, then we'd have to undo that work if dns_name_copy() 	 * failed.  By setting foundname first, there's nothing to undo if 	 * we have trouble. 	 */
if|if
condition|(
name|foundname
operator|!=
name|NULL
operator|&&
name|search
operator|->
name|copy_name
condition|)
block|{
name|zcname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|search
operator|->
name|zonecut_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
name|zcname
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Note that we don't have to increment the node's reference 		 * count here because we're going to use the reference we 		 * already have in the search block. 		 */
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|rdataset
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|search
operator|->
name|zonecut_rdataset
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|!=
name|NULL
operator|&&
name|search
operator|->
name|zonecut_sigrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|search
operator|->
name|zonecut_sigrdataset
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
condition|)
return|return
operator|(
name|DNS_R_DNAME
operator|)
return|;
return|return
operator|(
name|DNS_R_DELEGATION
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|valid_glue
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|rbtdb_rdatatype_t
name|type
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|size
decl_stmt|;
name|dns_name_t
name|ns_name
decl_stmt|;
name|isc_boolean_t
name|valid
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
comment|/* 	 * No additional locking is required. 	 */
comment|/* 	 * Valid glue types are A, AAAA, A6.  NS is also a valid glue type 	 * if it occurs at a zone cut, but is not valid below it. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
if|if
condition|(
name|node
operator|!=
name|search
operator|->
name|zonecut
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_a
operator|&&
name|type
operator|!=
name|dns_rdatatype_aaaa
operator|&&
name|type
operator|!=
name|dns_rdatatype_a6
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|header
operator|=
name|search
operator|->
name|zonecut_rdataset
expr_stmt|;
name|raw
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
expr_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|size
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
name|region
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|region
operator|.
name|length
operator|=
name|size
expr_stmt|;
name|raw
operator|+=
name|size
expr_stmt|;
comment|/* 		 * XXX Until we have rdata structures, we have no choice but 		 * to directly access the rdata format. 		 */
name|dns_name_init
argument_list|(
operator|&
name|ns_name
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
operator|&
name|ns_name
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_compare
argument_list|(
operator|&
name|ns_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|valid
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|activeempty
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_fixedname_t
name|fnext
decl_stmt|;
name|dns_fixedname_t
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|next
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
name|prefix
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|next
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
operator|&
name|prefix
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|prefix
argument_list|,
name|origin
argument_list|,
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|dns_name_issubdomain
argument_list|(
name|next
argument_list|,
name|name
argument_list|)
condition|)
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|activeemtpynode
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_name_t
modifier|*
name|wname
parameter_list|)
block|{
name|dns_fixedname_t
name|fnext
decl_stmt|;
name|dns_fixedname_t
name|forigin
decl_stmt|;
name|dns_fixedname_t
name|fprev
decl_stmt|;
name|dns_name_t
modifier|*
name|next
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
modifier|*
name|prev
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_name_t
name|rname
decl_stmt|;
name|dns_name_t
name|tname
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|isc_boolean_t
name|check_next
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|check_prev
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|answer
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|next
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnext
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fprev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fprev
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
comment|/* 	 * Find if qname is at or below a empty node. 	 * Use our own copy of the chain. 	 */
name|chain
operator|=
name|search
operator|->
name|chain
expr_stmt|;
do|do
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
do|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|name
argument_list|,
name|origin
argument_list|,
name|prev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|check_prev
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|chain
argument_list|,
operator|&
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_name_concatenate
argument_list|(
operator|&
name|name
argument_list|,
name|origin
argument_list|,
name|next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|check_next
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_name_clone
argument_list|(
name|qname
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the wildcard label to find the terminal name. 	 */
name|n
operator|=
name|dns_name_countlabels
argument_list|(
name|wname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|wname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|check_prev
operator|&&
name|dns_name_issubdomain
argument_list|(
name|prev
argument_list|,
operator|&
name|rname
argument_list|)
operator|)
operator|||
operator|(
name|check_next
operator|&&
name|dns_name_issubdomain
argument_list|(
name|next
argument_list|,
operator|&
name|rname
argument_list|)
operator|)
condition|)
block|{
name|answer
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Remove the left hand label. 		 */
name|n
operator|=
name|dns_name_countlabels
argument_list|(
operator|&
name|rname
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
operator|&
name|rname
argument_list|,
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|,
operator|&
name|rname
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|dns_name_equal
argument_list|(
operator|&
name|rname
argument_list|,
operator|&
name|tname
argument_list|)
condition|)
do|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_wildcard
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|level_node
decl_stmt|,
modifier|*
name|wnode
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_name_t
modifier|*
name|wname
decl_stmt|;
name|dns_fixedname_t
name|fwname
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|,
name|wild
decl_stmt|,
name|active
decl_stmt|;
name|dns_rbtnodechain_t
name|wchain
decl_stmt|;
comment|/* 	 * Caller must be holding the tree lock and MUST NOT be holding 	 * any node locks. 	 */
comment|/* 	 * Examine each ancestor level.  If the level's wild bit 	 * is set, then construct the corresponding wildcard name and 	 * search for it.  If the wildcard node exists, and is active in 	 * this version, we're done.  If not, then we next check to see 	 * if the ancestor is active in this version.  If so, then there 	 * can be no possible wildcard match and again we're done.  If not, 	 * continue the search. 	 */
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|i
operator|=
name|search
operator|->
name|chain
operator|.
name|level_matches
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
do|do
block|{
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * First we try to figure out if this node is active in 		 * the search's version.  We do this now, even though we 		 * may not need the information, because it simplifies the 		 * locking and code flow. 		 */
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|active
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|active
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|wild
condition|)
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wild
condition|)
block|{
comment|/* 			 * Construct the wildcard name for this level. 			 */
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fwname
argument_list|)
expr_stmt|;
name|wname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fwname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
operator|&
name|name
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|j
operator|!=
literal|0
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|level_node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|j
index|]
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|level_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|wname
argument_list|,
operator|&
name|name
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|wnode
operator|=
name|NULL
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|wchain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|wname
argument_list|,
name|NULL
argument_list|,
operator|&
name|wnode
argument_list|,
operator|&
name|wchain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 			     * We have found the wildcard node.  If it 			     * is active in the search's version, we're 			     * done. 			     */
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|wnode
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|wnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|wnode
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
operator|||
name|activeempty
argument_list|(
name|search
argument_list|,
operator|&
name|wchain
argument_list|,
name|wname
argument_list|)
condition|)
block|{
if|if
condition|(
name|activeemtpynode
argument_list|(
name|search
argument_list|,
name|qname
argument_list|,
name|wname
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
comment|/* 				     * The wildcard node is active! 				     * 				     * Note: result is still ISC_R_SUCCESS 				     * so we don't have to set it. 				     */
operator|*
name|nodep
operator|=
name|wnode
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
operator|&&
name|result
operator|!=
name|DNS_R_PARTIALMATCH
condition|)
block|{
comment|/* 				 * An error has occurred.  Bail out. 				 */
break|break;
block|}
block|}
if|if
condition|(
name|active
condition|)
block|{
comment|/* 			 * The level node is active.  Any wildcarding 			 * present at higher levels has no 			 * effect and we're done. 			 */
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_closest_nsec
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_boolean_t
name|need_sig
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|,
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
do|do
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 			 * Look for an active, extant NSEC or RRSIG NSEC. 			 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|->
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * We now know that there is at least one 				 * active rdataset at this node. 				 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNSEC
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|empty_node
condition|)
block|{
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
operator|(
name|foundsig
operator|!=
name|NULL
operator|||
operator|!
name|need_sig
operator|)
condition|)
block|{
comment|/* 				 * We've found the right NSEC record. 				 * 				 * Note: for this to really be the right 				 * NSEC record, it's essential that the NSEC 				 * records of any nodes obscured by a zone 				 * cut have been removed; we assume this is 				 * the case. 				 */
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|found
operator|==
name|NULL
operator|&&
name|foundsig
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * This node is active, but has no NSEC or 				 * RRSIG NSEC.  That means it's glue or 				 * other obscured zone data that isn't 				 * relevant for our search.  Treat the 				 * node as if it were empty and keep looking. 				 */
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We found an active node, but either the 				 * NSEC or the RRSIG NSEC is missing.  This 				 * shouldn't happen. 				 */
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * This node isn't active.  We've got to keep 			 * looking. 			 */
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|empty_node
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
comment|/* 	 * If the result is ISC_R_NOMORE, then we got to the beginning of 	 * the database and didn't find a NSEC record.  This shouldn't 	 * happen. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_find
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|isc_boolean_t
name|cname_ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|close_version
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|maybe_zonecut
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|at_zonecut
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|wild
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|nsecheader
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|foundsig
decl_stmt|,
modifier|*
name|cnamesig
decl_stmt|,
modifier|*
name|nsecsig
decl_stmt|;
name|rbtdb_rdatatype_t
name|sigtype
decl_stmt|;
name|isc_boolean_t
name|active
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't care about 'now'. 	 */
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * If the caller didn't supply a version, attach to the current 	 * version. 	 */
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|close_version
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|search
operator|.
name|rbtversion
operator|=
name|version
expr_stmt|;
name|search
operator|.
name|serial
operator|=
name|search
operator|.
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
literal|0
expr_stmt|;
comment|/* 	 * 'wild' will be true iff. we've matched a wildcard. 	 */
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree.  If, while going down, we 	 * encounter a callback node, zone_zonecut_callback() will search the 	 * rdatasets at the zone cut for active DNAME or NS rdatasets. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|zone_zonecut_callback
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|partial_match
label|:
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
name|search
operator|.
name|wild
condition|)
block|{
comment|/* 			 * At least one of the levels in the search chain 			 * potentially has a wildcard.  For each such level, 			 * we must see if there's a matching wildcard active 			 * in the current version. 			 */
name|result
operator|=
name|find_wildcard
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_name_copy
argument_list|(
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
name|wild
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOTFOUND
condition|)
goto|goto
name|tree_exit
goto|;
block|}
name|chain
operator|=
name|search
operator|.
name|chain
expr_stmt|;
name|active
operator|=
name|activeempty
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|chain
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * If we're here, then the name does not exist, is not 		 * beneath a zonecut, and there's no matching wildcard. 		 */
if|if
condition|(
name|search
operator|.
name|rbtdb
operator|->
name|secure
operator|||
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|find_closest_nsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|active
condition|?
name|DNS_R_EMPTYNAME
else|:
name|DNS_R_NXDOMAIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|active
condition|?
name|DNS_R_EMPTYNAME
else|:
name|DNS_R_NXDOMAIN
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
name|found
label|:
comment|/* 	 * We have found a node whose name is the desired name, or we 	 * have matched a wildcard. 	 */
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're beneath a zone cut, we don't want to look for 		 * CNAMEs because they're not legitimate zone glue. 		 */
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The node may be a zone cut itself.  If it might be one, 		 * make sure we check for it later. 		 */
if|if
condition|(
name|node
operator|->
name|find_callback
operator|&&
operator|(
name|node
operator|!=
name|search
operator|.
name|rbtdb
operator|->
name|origin_node
operator|||
name|IS_STUB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
operator|)
operator|&&
operator|!
name|dns_rdatatype_atparent
argument_list|(
name|type
argument_list|)
condition|)
name|maybe_zonecut
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * Certain DNSSEC types are not subject to CNAME matching 	 * (RFC4035, section 2.5 and RFC3007). 	 * 	 * We don't check for RRSIG, because we don't store RRSIG records 	 * directly. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We now go looking for rdata... 	 */
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|nsecheader
operator|=
name|NULL
expr_stmt|;
name|nsecsig
operator|=
name|NULL
expr_stmt|;
name|cnamesig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 		 * Look for an active, extant rdataset. 		 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|search
operator|.
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't 				 * exist" record? 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We now know that there is at least one active 			 * rdataset at this node. 			 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 			 * Do special zone cut handling, if requested. 			 */
if|if
condition|(
name|maybe_zonecut
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * We increment the reference count on node to 				 * ensure that search->zonecut_rdataset will 				 * still be valid later. 				 */
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|.
name|zonecut_rdataset
operator|=
name|header
expr_stmt|;
name|search
operator|.
name|zonecut_sigrdataset
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
name|maybe_zonecut
operator|=
name|ISC_FALSE
expr_stmt|;
name|at_zonecut
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 				 * It is not clear if KEY should still be 				 * allowed at the parent side of the zone 				 * cut or not.  It is needed for RFC3007 				 * validated updates. 				 */
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|dns_rdatatype_nsec
operator|&&
name|type
operator|!=
name|dns_rdatatype_key
condition|)
block|{
comment|/* 					 * Glue is not OK, but any answer we 					 * could return would be glue.  Return 					 * the delegation. 					 */
name|found
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 			 * If we found a type we were looking for, 			 * remember it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
operator|||
name|type
operator|==
name|dns_rdatatype_any
operator|||
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
operator|)
condition|)
block|{
comment|/* 				 * We've found the answer! 				 */
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
condition|)
block|{
comment|/* 					 * We may be finding a CNAME instead 					 * of the desired type. 					 * 					 * If we've already got the CNAME RRSIG, 					 * use it, otherwise change sigtype 					 * so that we find it. 					 */
if|if
condition|(
name|cnamesig
operator|!=
name|NULL
condition|)
name|foundsig
operator|=
name|cnamesig
expr_stmt|;
else|else
name|sigtype
operator|=
name|RBTDB_RDATATYPE_SIGCNAME
expr_stmt|;
block|}
comment|/* 				 * If we've got all we need, end the search. 				 */
if|if
condition|(
operator|!
name|maybe_zonecut
operator|&&
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigtype
condition|)
block|{
comment|/* 				 * We've found the RRSIG rdataset for our 				 * target type.  Remember it. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
comment|/* 				 * If we've got all we need, end the search. 				 */
if|if
condition|(
operator|!
name|maybe_zonecut
operator|&&
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
block|{
comment|/* 				 * Remember a NSEC rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|nsecheader
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNSEC
condition|)
block|{
comment|/* 				 * If we need the NSEC rdataset, we'll also 				 * need its signature. 				 */
name|nsecsig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGCNAME
condition|)
block|{
comment|/* 				 * If we get a CNAME match, we'll also need 				 * its signature. 				 */
name|cnamesig
operator|=
name|header
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|empty_node
condition|)
block|{
comment|/* 		 * We have an exact match for the name, but there are no 		 * active rdatasets in the desired version.  That means that 		 * this node doesn't exist in the desired version, and that 		 * we really have a partial match. 		 */
if|if
condition|(
operator|!
name|wild
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|partial_match
goto|;
block|}
block|}
comment|/* 	 * If we didn't find what we were looking for... 	 */
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * We were trying to find glue at a node beneath a 		     * zone cut, but didn't. 		     * 		     * Return the delegation. 		     */
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
comment|/* 		 * The desired type doesn't exist. 		 */
name|result
operator|=
name|DNS_R_NXRRSET
expr_stmt|;
if|if
condition|(
name|search
operator|.
name|rbtdb
operator|->
name|secure
operator|&&
operator|(
name|nsecheader
operator|==
name|NULL
operator|||
name|nsecsig
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * The zone is secure but there's no NSEC, 			 * or the NSEC has no signature! 			 */
if|if
condition|(
operator|!
name|wild
condition|)
block|{
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|find_closest_nsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|secure
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_EMPTYWILD
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
operator|&&
name|nsecheader
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There's no NSEC record, and we were told 			 * to find one. 			 */
name|result
operator|=
name|DNS_R_BADDB
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|search
operator|.
name|rbtdb
operator|->
name|secure
operator|||
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_FORCENSEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsecheader
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsecsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsecsig
argument_list|,
literal|0
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wild
condition|)
name|foundname
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_WILDCARD
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
comment|/* 	 * We found what we were looking for, or we found a CNAME. 	 */
if|if
condition|(
name|type
operator|!=
name|found
operator|->
name|type
operator|&&
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|found
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 		 * We weren't doing an ANY query and we found a CNAME instead 		 * of the type we were looking for, so we need to indicate 		 * that result to the caller. 		 */
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we're beneath a zone cut, we must indicate that the 		 * result is glue, unless we're actually at the zone cut 		 * and the type is NSEC or KEY. 		 */
if|if
condition|(
name|search
operator|.
name|zonecut
operator|==
name|node
condition|)
block|{
comment|/* 			 * It is not clear if KEY should still be 			 * allowed at the parent side of the zone 			 * cut or not.  It is needed for RFC3007 			 * validated updates. 			 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_nsec
operator|||
name|type
operator|==
name|dns_rdatatype_key
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
name|result
operator|=
name|DNS_R_ZONECUT
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_GLUE
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_GLUE
expr_stmt|;
comment|/* 		 * We might have found data that isn't glue, but was occluded 		 * by a dynamic update.  If the caller cares about this, they 		 * will have told us to validate glue. 		 * 		 * XXX We should cache the glue validity state! 		 */
if|if
condition|(
name|result
operator|==
name|DNS_R_GLUE
operator|&&
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_VALIDATEGLUE
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|valid_glue
argument_list|(
operator|&
name|search
argument_list|,
name|foundname
argument_list|,
name|type
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * An ordinary successful query! 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|at_zonecut
condition|)
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_any
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
literal|0
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
literal|0
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wild
condition|)
name|foundname
operator|->
name|attributes
operator||=
name|DNS_NAMEATTR_WILDCARD
expr_stmt|;
name|node_exit
label|:
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * If we found a zonecut but aren't going to use it, we have to 	 * let go of it. 	 */
if|if
condition|(
name|search
operator|.
name|need_cleanup
condition|)
block|{
name|node
operator|=
name|search
operator|.
name|zonecut
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
name|no_references
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close_version
condition|)
name|closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_findzonecut
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|nodep
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|foundname
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sigrdataset
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"zone_findzonecut() called!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_zonecut_callback
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rbtdb_search_t
modifier|*
name|search
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|dname_header
decl_stmt|,
modifier|*
name|sigdname_header
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* XXX comment */
name|REQUIRE
argument_list|(
name|search
operator|->
name|zonecut
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Keep compiler silent. 	 */
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Look for a DNAME or RRSIG DNAME rdataset. 	 */
name|dname_header
operator|=
name|NULL
expr_stmt|;
name|sigdname_header
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|search
operator|->
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is 			 * using the node, we can clean it up right 			 * now, otherwise we mark it as stale, and 			 * the node as dirty, so it will get cleaned 			 * up later. 			 */
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|header
operator|->
name|down
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_dname
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|dname_header
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGDNAME
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|sigdname_header
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|dname_header
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|DNS_TRUST_PENDING
argument_list|(
name|dname_header
operator|->
name|trust
argument_list|)
operator|||
operator|(
name|search
operator|->
name|options
operator|&
name|DNS_DBFIND_PENDINGOK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We increment the reference count on node to ensure that 		 * search->zonecut_rdataset will still be valid later. 		 */
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|search
operator|->
name|zonecut
operator|=
name|node
expr_stmt|;
name|search
operator|->
name|zonecut_rdataset
operator|=
name|dname_header
expr_stmt|;
name|search
operator|->
name|zonecut_sigrdataset
operator|=
name|sigdname_header
expr_stmt|;
name|search
operator|->
name|need_cleanup
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
block|}
else|else
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|find_deepest_zonecut
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|level_node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_NOTFOUND
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
comment|/* 	 * Caller must be holding the tree lock. 	 */
name|rbtdb
operator|=
name|search
operator|->
name|rbtdb
expr_stmt|;
name|i
operator|=
name|search
operator|->
name|chain
operator|.
name|level_matches
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
do|do
block|{
name|LOCK
argument_list|(
operator|&
operator|(
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Look for NS and RRSIG NS rdatasets. 		 */
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|search
operator|->
name|now
condition|)
block|{
comment|/* 				 * This rdataset is stale.  If no one else is 				 * using the node, we can clean it up right 				 * now, otherwise we mark it as stale, and 				 * the node as dirty, so it will get cleaned 				 * up later. 				 */
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|header
operator|->
name|down
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * We've found an extant rdataset.  See if 				 * we're interested in it. 				 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If we have to set foundname, we do it before 			 * anything else.  If we were to set foundname after 			 * we had set nodep or bound the rdataset, then we'd 			 * have to undo that work if dns_name_concatenate() 			 * failed.  By setting foundname first, there's 			 * nothing to undo if we have trouble. 			 */
if|if
condition|(
name|foundname
operator|!=
name|NULL
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
operator|&
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|level_node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|level_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|foundname
argument_list|,
operator|&
name|name
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
block|}
name|result
operator|=
name|DNS_R_DELEGATION
expr_stmt|;
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|->
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|node_exit
label|:
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|node
operator|=
name|search
operator|->
name|chain
operator|.
name|levels
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|find_coveringnsec
parameter_list|(
name|rbtdb_search_t
modifier|*
name|search
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|,
name|forigin
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_nsec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|dns_rdatatype_nsec
argument_list|)
expr_stmt|;
do|do
block|{
name|node
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|forigin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
condition|)
block|{
comment|/* 				 * This rdataset is stale.  If no one else is 				 * using the node, we can clean it up right 				 * now, otherwise we mark it as stale, and the 				 * node as dirty, so it will get cleaned up 				 * later. 				 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|>
name|search
operator|->
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
name|header_prev
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|header
operator|->
name|down
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
operator|||
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|header_prev
operator|=
name|header
expr_stmt|;
continue|continue;
block|}
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
name|foundsig
operator|=
name|header
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock_node
goto|;
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|search
operator|->
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
name|result
operator|=
name|DNS_R_COVERINGNSEC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|empty_node
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
else|else
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|search
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unlock_node
label|:
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|->
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|empty_node
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_find
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|isc_boolean_t
name|cname_ok
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_boolean_t
name|empty_node
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|nsheader
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|foundsig
decl_stmt|,
modifier|*
name|nssig
decl_stmt|,
modifier|*
name|cnamesig
decl_stmt|;
name|rbtdb_rdatatype_t
name|sigtype
decl_stmt|,
name|negtype
decl_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|version
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtversion
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|serial
operator|=
literal|1
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
name|now
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree.  If, while going down, we 	 * encounter a callback node, cache_zonecut_callback() will search the 	 * rdatasets at the zone cut for a DNAME rdataset. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|cache_zonecut_callback
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
if|if
condition|(
operator|(
name|search
operator|.
name|options
operator|&
name|DNS_DBFIND_COVERINGNSEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|find_coveringnsec
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|now
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_COVERINGNSEC
condition|)
goto|goto
name|tree_exit
goto|;
block|}
if|if
condition|(
name|search
operator|.
name|zonecut
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|setup_delegation
argument_list|(
operator|&
name|search
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
else|else
block|{
name|find_ns
label|:
name|result
operator|=
name|find_deepest_zonecut
argument_list|(
operator|&
name|search
argument_list|,
name|node
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
comment|/* 	 * Certain DNSSEC types are not subject to CNAME matching 	 * (RFC4035, section 2.5 and RFC3007). 	 * 	 * We don't check for RRSIG, because we don't store RRSIG records 	 * directly. 	 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|type
operator|==
name|dns_rdatatype_nsec
condition|)
name|cname_ok
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * We now go looking for rdata... 	 */
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|sigtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|nsheader
operator|=
name|NULL
expr_stmt|;
name|nssig
operator|=
name|NULL
expr_stmt|;
name|cnamesig
operator|=
name|NULL
expr_stmt|;
name|empty_node
operator|=
name|ISC_TRUE
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is using the 			 * node, we can clean it up right now, otherwise we 			 * mark it as stale, and the node as dirty, so it will 			 * get cleaned up later. 			 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|>
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
name|header_prev
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|header
operator|->
name|down
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 			 * We now know that there is at least one active 			 * non-stale rdataset at this node. 			 */
name|empty_node
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 			 * If we found a type we were looking for, remember 			 * it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|type
operator|||
operator|(
name|type
operator|==
name|dns_rdatatype_any
operator|&&
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|)
condition|)
block|{
comment|/* 				 * We've found the answer. 				 */
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
operator|&&
name|cname_ok
operator|&&
name|cnamesig
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * If we've already got the CNAME RRSIG, 					 * use it, otherwise change sigtype 					 * so that we find it. 					 */
if|if
condition|(
name|cnamesig
operator|!=
name|NULL
condition|)
name|foundsig
operator|=
name|cnamesig
expr_stmt|;
else|else
name|sigtype
operator|=
name|RBTDB_RDATATYPE_SIGCNAME
expr_stmt|;
name|foundsig
operator|=
name|cnamesig
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigtype
condition|)
block|{
comment|/* 				 * We've found the RRSIG rdataset for our 				 * target type.  Remember it. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
operator|||
name|header
operator|->
name|type
operator|==
name|negtype
condition|)
block|{
comment|/* 				 * We've found a negative cache entry. 				 */
name|found
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * Remember a NS rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|nsheader
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
comment|/* 				 * If we need the NS rdataset, we'll also 				 * need its signature. 				 */
name|nssig
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cname_ok
operator|&&
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGCNAME
condition|)
block|{
comment|/* 				 * If we get a CNAME match, we'll also need 				 * its signature. 				 */
name|cnamesig
operator|=
name|header
expr_stmt|;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|empty_node
condition|)
block|{
comment|/* 		 * We have an exact match for the name, but there are no 		 * extant rdatasets.  That means that this node doesn't 		 * meaningfully exist, and that we really have a partial match. 		 */
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
comment|/* 	 * If we didn't find what we were looking for... 	 */
if|if
condition|(
name|found
operator|==
name|NULL
operator|||
operator|(
name|found
operator|->
name|trust
operator|==
name|dns_trust_glue
operator|&&
operator|(
operator|(
name|options
operator|&
name|DNS_DBFIND_GLUEOK
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|DNS_TRUST_PENDING
argument_list|(
name|found
operator|->
name|trust
argument_list|)
operator|&&
operator|(
operator|(
name|options
operator|&
name|DNS_DBFIND_PENDINGOK
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If there is an NS rdataset at this node, then this is the 		 * deepest zone cut. 		 */
if|if
condition|(
name|nsheader
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nsheader
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|nssig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|nssig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_DELEGATION
expr_stmt|;
goto|goto
name|node_exit
goto|;
block|}
comment|/* 		 * Go find the deepest zone cut. 		 */
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
comment|/* 	 * We found what we were looking for, or we found a CNAME. 	 */
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|found
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We found a negative cache entry. 		 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|found
argument_list|)
condition|)
name|result
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|found
operator|->
name|type
operator|&&
name|type
operator|!=
name|dns_rdatatype_any
operator|&&
name|found
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 		 * We weren't doing an ANY query and we found a CNAME instead 		 * of the type we were looking for, so we need to indicate 		 * that result to the caller. 		 */
name|result
operator|=
name|DNS_R_CNAME
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * An ordinary successful query! 		 */
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|dns_rdatatype_any
operator|||
name|result
operator|==
name|DNS_R_NCACHENXDOMAIN
operator|||
name|result
operator|==
name|DNS_R_NCACHENXRRSET
condition|)
block|{
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|node_exit
label|:
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * If we found a zonecut but aren't going to use it, we have to 	 * let go of it. 	 */
if|if
condition|(
name|search
operator|.
name|need_cleanup
condition|)
block|{
name|node
operator|=
name|search
operator|.
name|zonecut
expr_stmt|;
name|lock
operator|=
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
expr_stmt|;
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
name|no_references
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_findzonecut
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_search_t
name|search
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_prev
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|unsigned
name|int
name|rbtoptions
init|=
name|DNS_RBTFIND_EMPTYDATA
decl_stmt|;
name|search
operator|.
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|search
operator|.
name|rbtversion
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|serial
operator|=
literal|1
expr_stmt|;
name|search
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|search
operator|.
name|copy_name
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|need_cleanup
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|wild
operator|=
name|ISC_FALSE
expr_stmt|;
name|search
operator|.
name|zonecut
operator|=
name|NULL
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|search
operator|.
name|zonecut_name
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|,
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
name|search
operator|.
name|now
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBFIND_NOEXACT
operator|)
operator|!=
literal|0
condition|)
name|rbtoptions
operator||=
name|DNS_RBTFIND_NOEXACT
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
comment|/* 	 * Search down from the root of the tree. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
operator|&
name|search
operator|.
name|chain
argument_list|,
name|rbtoptions
argument_list|,
name|NULL
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
block|{
name|find_ns
label|:
name|result
operator|=
name|find_deepest_zonecut
argument_list|(
operator|&
name|search
argument_list|,
name|node
argument_list|,
name|nodep
argument_list|,
name|foundname
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
goto|goto
name|tree_exit
goto|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|tree_exit
goto|;
comment|/* 	 * We now go looking for an NS rdataset at the node. 	 */
name|LOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|header_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
condition|)
block|{
comment|/* 			 * This rdataset is stale.  If no one else is using the 			 * node, we can clean it up right now, otherwise we 			 * mark it as stale, and the node as dirty, so it will 			 * get cleaned up later. 			 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|>
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
name|header_prev
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|header
operator|->
name|down
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_prev
operator|!=
name|NULL
condition|)
name|header_prev
operator|->
name|next
operator|=
name|header
operator|->
name|next
expr_stmt|;
else|else
name|node
operator|->
name|data
operator|=
name|header
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|node
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 			 * If we found a type we were looking for, remember 			 * it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
block|{
comment|/* 				 * Remember a NS rdataset even if we're 				 * not specifically looking for it, because 				 * we might need it later. 				 */
name|found
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_SIGNS
condition|)
block|{
comment|/* 				 * If we need the NS rdataset, we'll also 				 * need its signature. 				 */
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
else|else
name|header_prev
operator|=
name|header
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No NS records here. 		 */
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|find_ns
goto|;
block|}
if|if
condition|(
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|new_reference
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
block|}
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|found
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|search
operator|.
name|rbtdb
argument_list|,
name|node
argument_list|,
name|foundsig
argument_list|,
name|search
operator|.
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
operator|(
name|search
operator|.
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
operator|)
argument_list|)
expr_stmt|;
name|tree_exit
label|:
name|RWUNLOCK
argument_list|(
operator|&
name|search
operator|.
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|search
operator|.
name|need_cleanup
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|search
operator|.
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_DELEGATION
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|source
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|source
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Catch overflow. */
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|detachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_boolean_t
name|want_free
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|inactive
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
operator|(
operator|*
name|targetp
operator|)
expr_stmt|;
name|locknum
operator|=
name|node
operator|->
name|locknum
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|no_references
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|references
operator|==
literal|0
operator|&&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|exiting
condition|)
name|inactive
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inactive
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|active
operator|--
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|active
operator|==
literal|0
condition|)
name|want_free
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_free
condition|)
block|{
name|char
name|buf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
name|dns_name_format
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"<UNKNOWN>"
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"calling free_rbtdb(%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|expirenode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|isc_boolean_t
name|force_expire
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* 	 * These are the category and module used by the cache cleaner. 	 */
name|isc_boolean_t
name|log
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_logcategory_t
modifier|*
name|category
init|=
name|DNS_LOGCATEGORY_DATABASE
decl_stmt|;
name|isc_logmodule_t
modifier|*
name|module
init|=
name|DNS_LOGMODULE_CACHE
decl_stmt|;
name|int
name|level
init|=
name|ISC_LOG_DEBUG
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Caller must hold a tree lock. 	 */
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|overmem
condition|)
block|{
name|isc_uint32_t
name|val
decl_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * XXXDCL Could stand to have a better policy, like LRU. 		 */
name|force_expire
operator|=
name|ISC_TF
argument_list|(
name|rbtnode
operator|->
name|down
operator|==
name|NULL
operator|&&
name|val
operator|%
literal|4
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Note that 'log' can be true IFF rbtdb->overmem is also true. 		 * rbtdb->ovemem can currently only be true for cache databases 		 * -- hence all of the "overmem cache" log strings. 		 */
name|log
operator|=
name|ISC_TF
argument_list|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: %s %s"
argument_list|,
name|force_expire
condition|?
literal|"FORCE"
else|:
literal|"check"
argument_list|,
name|dns_rbt_formatnodename
argument_list|(
name|rbtnode
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header
operator|->
name|next
control|)
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
block|{
comment|/* 			 * We don't check if rbtnode->references == 0 and try 			 * to free like we do in cache_find(), because 			 * rbtnode->references must be non-zero.  This is so 			 * because 'node' is an argument to the function. 			 */
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: stale %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force_expire
condition|)
block|{
if|if
condition|(
operator|!
name|RETAIN
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|header
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|log
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: "
literal|"reprieve by RETAIN() %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rbtdb
operator|->
name|overmem
operator|&&
name|log
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"overmem cache: saved %s"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|overmem
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|overmem
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|rbtdb
operator|->
name|overmem
operator|=
name|overmem
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|node
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"node %p, %u references, locknum = %u\n"
argument_list|,
name|rbtnode
argument_list|,
name|rbtnode
operator|->
name|references
argument_list|,
name|rbtnode
operator|->
name|locknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtnode
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
for|for
control|(
name|current
operator|=
name|rbtnode
operator|->
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\ttype %u"
argument_list|,
name|current
operator|->
name|type
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tserial = %lu, ttl = %u, "
literal|"trust = %u, attributes = %u\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|current
operator|->
name|serial
argument_list|,
name|current
operator|->
name|ttl
argument_list|,
name|current
operator|->
name|trust
argument_list|,
name|current
operator|->
name|attributes
argument_list|)
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(empty)\n"
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|createiterator
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|relative_names
parameter_list|,
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdbiter
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|rbtdbiter
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|dbiterator_methods
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
operator|=
name|relative_names
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_DBITERATOR_MAGIC
expr_stmt|;
name|rbtdbiter
operator|->
name|common
operator|.
name|cleaning
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_TRUE
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|rbtdbiter
operator|->
name|delete
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|rbtdbiter
operator|->
name|deletions
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rbtdbiter
operator|->
name|deletions
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|db
operator|->
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
operator|(
name|dns_dbiterator_t
operator|*
operator|)
name|rbtdbiter
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|zone_findrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_boolean_t
name|close_version
init|=
name|ISC_FALSE
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
name|currentversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|)
expr_stmt|;
name|close_version
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
if|if
condition|(
name|covers
operator|==
literal|0
condition|)
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sigmatchtype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't 				 * exist" record? 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have an active, extant rdataset.  If it's a 			 * type we're looking for, remember it. 			 */
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
block|{
name|found
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
block|{
name|foundsig
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_version
condition|)
name|closeversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|cache_findrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|foundsig
decl_stmt|;
name|rbtdb_rdatatype_t
name|matchtype
decl_stmt|,
name|sigmatchtype
decl_stmt|,
name|negtype
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|dns_rdatatype_any
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|foundsig
operator|=
name|NULL
expr_stmt|;
name|matchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|covers
operator|==
literal|0
condition|)
name|sigmatchtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|dns_rdatatype_rrsig
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sigmatchtype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
condition|)
block|{
comment|/* 			 * We don't check if rbtnode->references == 0 and try 			 * to free like we do in cache_find(), because 			 * rbtnode->references must be non-zero.  This is so 			 * because 'node' is an argument to the function. 			 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|<=
name|now
operator|-
name|RBTDB_VIRTUAL
condition|)
block|{
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|matchtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
operator|||
name|header
operator|->
name|type
operator|==
name|negtype
condition|)
name|found
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|sigmatchtype
condition|)
name|foundsig
operator|=
name|header
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|found
argument_list|,
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundsig
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|foundsig
argument_list|,
name|now
argument_list|,
name|sigrdataset
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|found
operator|->
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We found a negative cache entry. 		 */
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|found
argument_list|)
condition|)
name|result
operator|=
name|DNS_R_NCACHENXDOMAIN
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_NCACHENXRRSET
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|allrdatasets
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rbtdb_rdatasetiter_t
modifier|*
name|iterator
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|iterator
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iterator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterator
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
operator|(
name|db
operator|->
name|attributes
operator|&
name|DNS_DBATTR_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|now
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
name|currentversion
argument_list|(
name|db
argument_list|,
operator|(
name|dns_dbversion_t
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|rbtversion
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rbtversion
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|rbtversion
operator|=
name|NULL
expr_stmt|;
block|}
name|iterator
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_RDATASETITER_MAGIC
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|rdatasetiter_methods
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|version
operator|=
operator|(
name|dns_dbversion_t
operator|*
operator|)
name|rbtversion
expr_stmt|;
name|iterator
operator|->
name|common
operator|.
name|now
operator|=
name|now
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtnode
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rbtnode
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|rbtnode
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
operator|(
name|dns_rdatasetiter_t
operator|*
operator|)
name|iterator
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|cname_and_other_data
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_serial_t
name|serial
parameter_list|)
block|{
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|header_next
decl_stmt|;
name|isc_boolean_t
name|cname
decl_stmt|,
name|other_data
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|;
comment|/* 	 * The caller must hold the node lock. 	 */
comment|/* 	 * Look for CNAME and "other data" rdatasets active in our version. 	 */
name|cname
operator|=
name|ISC_FALSE
expr_stmt|;
name|other_data
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|header
operator|=
name|node
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|header_next
control|)
block|{
name|header_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 			 * Look for an active extant CNAME. 			 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|cname
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Look for active extant "other data". 			 * 			 * "Other data" is any rdataset whose type is not 			 * KEY, RRSIG KEY, NSEC, RRSIG NSEC or RRSIG CNAME. 			 */
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtype
operator|==
name|dns_rdatatype_rrsig
operator|||
name|rdtype
operator|==
name|dns_rdatatype_sig
condition|)
name|rdtype
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtype
operator|!=
name|dns_rdatatype_nsec
operator|&&
name|rdtype
operator|!=
name|dns_rdatatype_key
operator|&&
name|rdtype
operator|!=
name|dns_rdatatype_cname
condition|)
block|{
comment|/* 				 * We've found a type that isn't 				 * NSEC, KEY, CNAME, or one of their 				 * signatures.  Is it active and extant? 				 */
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 						 * Is this a "this rdataset 						 * doesn't exist" record? 						 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
name|other_data
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cname
operator|&&
name|other_data
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|add
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|rbtnode
parameter_list|,
name|rbtdb_version_t
modifier|*
name|rbtversion
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_boolean_t
name|loading
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|rbtdb_changed_t
modifier|*
name|changed
init|=
name|NULL
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|topheader
decl_stmt|,
modifier|*
name|topheader_prev
decl_stmt|,
modifier|*
name|header
decl_stmt|;
name|unsigned
name|char
modifier|*
name|merged
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|header_nx
decl_stmt|;
name|isc_boolean_t
name|newheader_nx
decl_stmt|;
name|isc_boolean_t
name|merge
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|,
name|covers
decl_stmt|;
name|rbtdb_rdatatype_t
name|negtype
decl_stmt|;
name|dns_trust_t
name|trust
decl_stmt|;
comment|/* 	 * Add an rdatasetheader_t to a node. 	 */
comment|/* 	 * Caller must be holding the node lock. 	 */
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_MERGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|REQUIRE
argument_list|(
name|rbtversion
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|merge
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|merge
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_FORCE
operator|)
operator|!=
literal|0
condition|)
name|trust
operator|=
name|dns_trust_ultimate
expr_stmt|;
else|else
name|trust
operator|=
name|newheader
operator|->
name|trust
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
operator|&&
operator|!
name|loading
condition|)
block|{
comment|/* 		 * We always add a changed record, even if no changes end up 		 * being made to this node, because it's harmless and 		 * simplifies the code. 		 */
name|changed
operator|=
name|add_changed
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|rbtnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|==
name|NULL
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
name|newheader_nx
operator|=
name|NONEXISTENT
argument_list|(
name|newheader
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
name|topheader_prev
operator|=
name|NULL
expr_stmt|;
name|negtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
operator|&&
operator|!
name|newheader_nx
condition|)
block|{
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|newheader
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtype
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We're adding a negative cache entry. 			 */
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|newheader
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|covers
operator|==
name|dns_rdatatype_any
condition|)
block|{
comment|/* 				 * We're adding an negative cache entry 				 * which covers all types (NXDOMAIN, 				 * NODATA(QTYPE=ANY)). 				 * 				 * We make all other data stale so that the 				 * only rdataset that can be found at this 				 * node is the negative cache entry. 				 */
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
name|topheader
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|topheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
block|}
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
goto|goto
name|find_header
goto|;
block|}
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|covers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We're adding something that isn't a 			 * negative cache entry.  Look for an extant 			 * non-stale NXDOMAIN/NODATA(QTYPE=ANY) negative 			 * cache entry. 			 */
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|RBTDB_RDATATYPE_NCACHEANY
condition|)
break|break;
block|}
if|if
condition|(
name|topheader
operator|!=
name|NULL
operator|&&
name|EXISTS
argument_list|(
name|topheader
argument_list|)
operator|&&
name|topheader
operator|->
name|ttl
operator|>
name|now
condition|)
block|{
comment|/* 				 * Found one. 				 */
if|if
condition|(
name|trust
operator|<
name|topheader
operator|->
name|trust
condition|)
block|{
comment|/* 					 * The NXDOMAIN/NODATA(QTYPE=ANY) 					 * is more trusted. 					 */
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|topheader
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 				 * The new rdataset is better.  Expire the 				 * NXDOMAIN/NODATA(QTYPE=ANY). 				 */
name|topheader
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|topheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|topheader
operator|=
name|NULL
expr_stmt|;
goto|goto
name|find_header
goto|;
block|}
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|newheader
operator|->
name|type
operator|||
name|topheader
operator|->
name|type
operator|==
name|negtype
condition|)
break|break;
name|topheader_prev
operator|=
name|topheader
expr_stmt|;
block|}
name|find_header
label|:
comment|/* 	 * If header isn't NULL, we've found the right type.  There may be 	 * IGNORE rdatasets between the top of the chain and the first real 	 * data.  We skip over them. 	 */
name|header
operator|=
name|topheader
expr_stmt|;
while|while
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
block|{
name|header_nx
operator|=
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * Deleting an already non-existent rdataset has no effect. 		 */
if|if
condition|(
name|header_nx
operator|&&
name|newheader_nx
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 		 * Trying to add an rdataset with lower trust to a cache DB 		 * has no effect, provided that the cache data isn't stale. 		 */
if|if
condition|(
name|rbtversion
operator|==
name|NULL
operator|&&
name|trust
operator|<
name|header
operator|->
name|trust
operator|&&
operator|(
name|header
operator|->
name|ttl
operator|>
name|now
operator|||
name|header_nx
operator|)
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
comment|/* 		 * Don't merge if a nonexistent rdataset is involved. 		 */
if|if
condition|(
name|merge
operator|&&
operator|(
name|header_nx
operator|||
name|newheader_nx
operator|)
condition|)
name|merge
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 		 * If 'merge' is ISC_TRUE, we'll try to create a new rdataset 		 * that is the union of 'newheader' and 'header'. 		 */
if|if
condition|(
name|merge
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|serial
operator|>=
name|header
operator|->
name|serial
argument_list|)
expr_stmt|;
name|merged
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_EXACT
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|DNS_RDATASLAB_EXACT
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBADD_EXACTTTL
operator|)
operator|!=
literal|0
operator|&&
name|newheader
operator|->
name|ttl
operator|!=
name|header
operator|->
name|ttl
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
elseif|else
if|if
condition|(
name|newheader
operator|->
name|ttl
operator|!=
name|header
operator|->
name|ttl
condition|)
name|flags
operator||=
name|DNS_RDATASLAB_FORCE
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rdataslab_merge
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * If 'header' has the same serial number as 				 * we do, we could clean it up now if we knew 				 * that our caller had no references to it. 				 * We don't know this, however, so we leave it 				 * alone.  It will get cleaned up when 				 * clean_zone_node() runs. 				 */
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|merged
expr_stmt|;
block|}
else|else
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* 		 * Don't replace existing NS, A and AAAA RRsets 		 * in the cache if they are already exist.  This 		 * prevents named being locked to old servers. 		 * Don't lower trust of existing record if the 		 * update is forced. 		 */
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|header
operator|->
name|ttl
operator|>
name|now
operator|&&
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|!
name|header_nx
operator|&&
operator|!
name|newheader_nx
operator|&&
name|header
operator|->
name|trust
operator|>=
name|newheader
operator|->
name|trust
operator|&&
name|dns_rdataslab_equalx
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 			 * Honour the new ttl if it is less than the 			 * older one. 			 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|>
name|newheader
operator|->
name|ttl
condition|)
name|header
operator|->
name|ttl
operator|=
name|newheader
operator|->
name|ttl
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|noqname
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|noqname
operator|=
name|newheader
operator|->
name|noqname
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
name|header
operator|->
name|ttl
operator|>
name|now
operator|&&
operator|(
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_a
operator|||
name|header
operator|->
name|type
operator|==
name|dns_rdatatype_aaaa
operator|)
operator|&&
operator|!
name|header_nx
operator|&&
operator|!
name|newheader_nx
operator|&&
name|header
operator|->
name|trust
operator|>=
name|newheader
operator|->
name|trust
operator|&&
name|dns_rdataslab_equal
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 			 * Honour the new ttl if it is less than the 			 * older one. 			 */
if|if
condition|(
name|header
operator|->
name|ttl
operator|>
name|newheader
operator|->
name|ttl
condition|)
name|header
operator|->
name|ttl
operator|=
name|newheader
operator|->
name|ttl
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|noqname
operator|==
name|NULL
operator|&&
name|newheader
operator|->
name|noqname
operator|!=
name|NULL
condition|)
block|{
name|header
operator|->
name|noqname
operator|=
name|newheader
operator|->
name|noqname
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
block|}
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loading
condition|)
block|{
comment|/* 			 * There are no other references to 'header' when 			 * loading, so we MAY clean up 'header' now. 			 * Since we don't generate changed records when 			 * loading, we MUST clean up 'header' now. 			 */
name|newheader
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
name|header
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_STALE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * No non-IGNORED rdatasets of the given type exist at 		 * this node. 		 */
comment|/* 		 * If we're trying to delete the type, don't bother. 		 */
if|if
condition|(
name|newheader_nx
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_UNCHANGED
operator|)
return|;
block|}
if|if
condition|(
name|topheader
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We have an list of rdatasets of the given type, 			 * but they're all marked IGNORE.  We simply insert 			 * the new rdataset at the head of the list. 			 * 			 * Ignored rdatasets cannot occur during loading, so 			 * we INSIST on it. 			 */
name|INSIST
argument_list|(
operator|!
name|loading
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtversion
operator|==
name|NULL
operator|||
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|NULL
condition|)
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No rdatasets of the given type exist at the node. 			 */
name|newheader
operator|->
name|next
operator|=
name|rbtnode
operator|->
name|data
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|NULL
expr_stmt|;
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
block|}
block|}
comment|/* 	 * Check if the node now contains CNAME and other data. 	 */
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
operator|&&
name|cname_and_other_data
argument_list|(
name|rbtnode
argument_list|,
name|rbtversion
operator|->
name|serial
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_CNAMEANDOTHER
operator|)
return|;
if|if
condition|(
name|addedrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|newheader
argument_list|,
name|now
argument_list|,
name|addedrdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|delegating_type
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|rbtdb_rdatatype_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_dname
operator|||
operator|(
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
operator|(
name|node
operator|!=
name|rbtdb
operator|->
name|origin_node
operator|||
name|IS_STUB
argument_list|(
name|rbtdb
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|addnoqname
parameter_list|(
name|dns_rbtdb_t
modifier|*
name|rbtdb
parameter_list|,
name|rdatasetheader_t
modifier|*
name|newheader
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|struct
name|noqname
modifier|*
name|noqname
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|rbtdb
operator|->
name|common
operator|.
name|mctx
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|dns_rdataset_t
name|nsec
decl_stmt|,
name|nsecsig
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|nsecsig
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_getnoqname
argument_list|(
name|rdataset
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|nsec
argument_list|,
operator|&
name|nsecsig
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|noqname
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noqname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noqname
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|noqname
operator|->
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|noqname
operator|->
name|nsec
operator|=
name|NULL
expr_stmt|;
name|noqname
operator|->
name|nsecsig
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
operator|&
name|name
argument_list|,
name|mctx
argument_list|,
operator|&
name|noqname
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|nsec
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|noqname
operator|->
name|nsec
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
operator|&
name|nsecsig
argument_list|,
name|mctx
argument_list|,
operator|&
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|noqname
operator|->
name|nsecsig
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsecsig
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|noqname
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|nsecsig
argument_list|)
expr_stmt|;
name|free_noqname
argument_list|(
name|mctx
argument_list|,
operator|&
name|noqname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|addrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|delegating
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
else|else
name|now
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|newheader
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
operator|+
name|now
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
condition|)
block|{
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newheader
operator|->
name|serial
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NXDOMAIN
operator|)
operator|!=
literal|0
condition|)
name|newheader
operator|->
name|attributes
operator||=
name|RDATASET_ATTR_NXDOMAIN
expr_stmt|;
if|if
condition|(
operator|(
name|rdataset
operator|->
name|attributes
operator|&
name|DNS_RDATASETATTR_NOQNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|addnoqname
argument_list|(
name|rbtdb
argument_list|,
name|newheader
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * If we're adding a delegation type (e.g. NS or DNAME for a zone, 	 * just DNAME for the cache), then we need to set the callback bit 	 * on the node, and to do that we must be holding an exclusive lock 	 * on the tree. 	 */
if|if
condition|(
name|delegating_type
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
condition|)
block|{
name|delegating
operator|=
name|ISC_TRUE
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
block|}
else|else
name|delegating
operator|=
name|ISC_FALSE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|add
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rbtversion
argument_list|,
name|newheader
argument_list|,
name|options
argument_list|,
name|ISC_FALSE
argument_list|,
name|addedrdataset
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|delegating
condition|)
name|rbtnode
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegating
condition|)
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is defered until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|secure
operator|=
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|subtractrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|newrdataset
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|topheader
decl_stmt|,
modifier|*
name|topheader_prev
decl_stmt|,
modifier|*
name|header
decl_stmt|,
modifier|*
name|newheader
decl_stmt|;
name|unsigned
name|char
modifier|*
name|subresult
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_changed_t
modifier|*
name|changed
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|newheader
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|changed
operator|=
name|add_changed
argument_list|(
name|rbtdb
argument_list|,
name|rbtversion
argument_list|,
name|rbtnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
operator|==
name|NULL
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|topheader_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|topheader
operator|=
name|rbtnode
operator|->
name|data
init|;
name|topheader
operator|!=
name|NULL
condition|;
name|topheader
operator|=
name|topheader
operator|->
name|next
control|)
block|{
if|if
condition|(
name|topheader
operator|->
name|type
operator|==
name|newheader
operator|->
name|type
condition|)
break|break;
name|topheader_prev
operator|=
name|topheader
expr_stmt|;
block|}
comment|/* 	 * If header isn't NULL, we've found the right type.  There may be 	 * IGNORE rdatasets between the top of the chain and the first real 	 * data.  We skip over them. 	 */
name|header
operator|=
name|topheader
expr_stmt|;
while|while
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
operator|&&
name|EXISTS
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|subresult
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBSUB_EXACT
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|DNS_RDATASLAB_EXACT
expr_stmt|;
if|if
condition|(
name|newheader
operator|->
name|ttl
operator|!=
name|header
operator|->
name|ttl
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|dns_rdataslab_subtract
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|newheader
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
argument_list|,
operator|(
name|dns_rdatatype_t
operator|)
name|header
operator|->
name|type
argument_list|,
name|flags
argument_list|,
operator|&
name|subresult
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|subresult
expr_stmt|;
comment|/* 			 * We have to set the serial since the rdataslab 			 * subtraction routine copies the reserved portion of 			 * header, not newheader. 			 */
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_NXRRSET
condition|)
block|{
comment|/* 			 * This subtraction would remove all of the rdata; 			 * add a nonexistent header instead. 			 */
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
name|newheader
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newheader
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|newheader
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|topheader
operator|->
name|type
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
name|RDATASET_ATTR_NONEXISTENT
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 		 * If we're here, we want to link newheader in front of 		 * topheader. 		 */
name|INSIST
argument_list|(
name|rbtversion
operator|->
name|serial
operator|>=
name|topheader
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|topheader_prev
operator|!=
name|NULL
condition|)
name|topheader_prev
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
else|else
name|rbtnode
operator|->
name|data
operator|=
name|newheader
expr_stmt|;
name|newheader
operator|->
name|next
operator|=
name|topheader
operator|->
name|next
expr_stmt|;
name|newheader
operator|->
name|down
operator|=
name|topheader
expr_stmt|;
name|topheader
operator|->
name|next
operator|=
name|newheader
expr_stmt|;
name|rbtnode
operator|->
name|dirty
operator|=
literal|1
expr_stmt|;
name|changed
operator|->
name|dirty
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The rdataset doesn't exist, so we don't need to do anything 		 * to satisfy the deletion request. 		 */
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|newheader
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_DBSUB_EXACT
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|DNS_R_NOTEXACT
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_UNCHANGED
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|newrdataset
operator|!=
name|NULL
condition|)
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|newheader
argument_list|,
literal|0
argument_list|,
name|newrdataset
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is defered until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|secure
operator|=
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|deleterdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|version
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_any
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|covers
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|newheader
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newheader
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newheader
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|newheader
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|type
argument_list|,
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
name|RDATASET_ATTR_NONEXISTENT
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rbtversion
operator|!=
name|NULL
condition|)
name|newheader
operator|->
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
else|else
name|newheader
operator|->
name|serial
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|add
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|rbtversion
argument_list|,
name|newheader
argument_list|,
name|DNS_DBADD_FORCE
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Update the zone's secure status.  If version is non-NULL 	 * this is defered until closeversion() is called. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|version
operator|==
name|NULL
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|secure
operator|=
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|loading_addrdataset
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
init|=
name|arg
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|loadctx
operator|->
name|rbtdb
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|newheader
decl_stmt|;
comment|/* 	 * This routine does no node locking.  See comments in 	 * 'load' below for more information on loading and 	 * locking. 	 */
comment|/* 	 * SOA records are only allowed at top of zone. 	 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
operator|&&
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
condition|)
return|return
operator|(
name|DNS_R_NOTZONETOP
operator|)
return|;
name|add_empty_wildcards
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* 		 * NS record owners cannot legally be wild cards. 		 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
return|return
operator|(
name|DNS_R_INVALIDNS
operator|)
return|;
name|result
operator|=
name|add_wildcard_magic
argument_list|(
name|rbtdb
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_EXISTS
condition|)
block|{
name|dns_name_t
name|foundname
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|node
argument_list|,
operator|&
name|foundname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|node
operator|->
name|locknum
operator|=
name|node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|foundname
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
block|}
name|result
operator|=
name|dns_rdataslab_fromrdataset
argument_list|(
name|rdataset
argument_list|,
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
operator|&
name|region
argument_list|,
sizeof|sizeof
argument_list|(
name|rdatasetheader_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|newheader
operator|=
operator|(
name|rdatasetheader_t
operator|*
operator|)
name|region
operator|.
name|base
expr_stmt|;
name|newheader
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
operator|+
name|loadctx
operator|->
name|now
expr_stmt|;
comment|/* XXX overflow check */
name|newheader
operator|->
name|type
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|rdataset
operator|->
name|covers
argument_list|)
expr_stmt|;
name|newheader
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|newheader
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|newheader
operator|->
name|serial
operator|=
literal|1
expr_stmt|;
name|newheader
operator|->
name|noqname
operator|=
name|NULL
expr_stmt|;
name|newheader
operator|->
name|count
operator|=
name|init_count
operator|++
expr_stmt|;
name|result
operator|=
name|add
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|rbtdb
operator|->
name|current_version
argument_list|,
name|newheader
argument_list|,
name|DNS_DBADD_MERGE
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|delegating_type
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
name|rdataset
operator|->
name|type
argument_list|)
condition|)
name|node
operator|->
name|find_callback
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_UNCHANGED
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|beginload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_addrdatasetfunc_t
modifier|*
name|addp
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|loadctx
operator|=
name|isc_mem_get
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loadctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|loadctx
operator|->
name|rbtdb
operator|=
name|rbtdb
expr_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|isc_stdtime_get
argument_list|(
operator|&
name|loadctx
operator|->
name|now
argument_list|)
expr_stmt|;
else|else
name|loadctx
operator|->
name|now
operator|=
literal|0
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
operator|(
name|RBTDB_ATTR_LOADED
operator||
name|RBTDB_ATTR_LOADING
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator||=
name|RBTDB_ATTR_LOADING
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|addp
operator|=
name|loading_addrdataset
expr_stmt|;
operator|*
name|dbloadp
operator|=
name|loadctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|endload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
block|{
name|rbtdb_load_t
modifier|*
name|loadctx
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbloadp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|loadctx
operator|=
operator|*
name|dbloadp
expr_stmt|;
name|REQUIRE
argument_list|(
name|loadctx
operator|->
name|rbtdb
operator|==
name|rbtdb
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
name|RBTDB_ATTR_LOADING
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|rbtdb
operator|->
name|attributes
operator|&
name|RBTDB_ATTR_LOADED
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator|&=
operator|~
name|RBTDB_ATTR_LOADING
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator||=
name|RBTDB_ATTR_LOADED
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a KEY rdataset at the zone origin containing a 	 * zone key, we consider the zone secure. 	 */
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
name|rbtdb
operator|->
name|secure
operator|=
name|iszonesecure
argument_list|(
name|db
argument_list|,
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
operator|*
name|dbloadp
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|loadctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|loadctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dump
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_master_dump
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|dns_master_style_default
argument_list|,
name|filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_callback
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
name|arg
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|current
operator|=
name|data
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|next
control|)
block|{
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|free_rdataset
argument_list|(
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|issecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_boolean_t
name|secure
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|secure
operator|=
name|rbtdb
operator|->
name|secure
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|secure
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|nodecount
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|count
operator|=
name|dns_rbt_nodecount
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|settask
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|rbtdb
operator|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|db
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBTDB
argument_list|(
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|rbtdb
operator|->
name|task
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|ispersistent
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dns_dbmethods_t
name|zone_methods
init|=
block|{
name|attach
block|,
name|detach
block|,
name|beginload
block|,
name|endload
block|,
name|dump
block|,
name|currentversion
block|,
name|newversion
block|,
name|attachversion
block|,
name|closeversion
block|,
name|findnode
block|,
name|zone_find
block|,
name|zone_findzonecut
block|,
name|attachnode
block|,
name|detachnode
block|,
name|expirenode
block|,
name|printnode
block|,
name|createiterator
block|,
name|zone_findrdataset
block|,
name|allrdatasets
block|,
name|addrdataset
block|,
name|subtractrdataset
block|,
name|deleterdataset
block|,
name|issecure
block|,
name|nodecount
block|,
name|ispersistent
block|,
name|overmem
block|,
name|settask
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dns_dbmethods_t
name|cache_methods
init|=
block|{
name|attach
block|,
name|detach
block|,
name|beginload
block|,
name|endload
block|,
name|dump
block|,
name|currentversion
block|,
name|newversion
block|,
name|attachversion
block|,
name|closeversion
block|,
name|findnode
block|,
name|cache_find
block|,
name|cache_findzonecut
block|,
name|attachnode
block|,
name|detachnode
block|,
name|expirenode
block|,
name|printnode
block|,
name|createiterator
block|,
name|cache_findrdataset
block|,
name|allrdatasets
block|,
name|addrdataset
block|,
name|subtractrdataset
block|,
name|deleterdataset
block|,
name|issecure
block|,
name|nodecount
block|,
name|ispersistent
block|,
name|overmem
block|,
name|settask
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|isc_result_t
ifdef|#
directive|ifdef
name|DNS_RBTDB_VERSION64
name|dns_rbtdb64_create
else|#
directive|else
name|dns_rbtdb_create
endif|#
directive|endif
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_dbtype_t
name|type
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
comment|/* Keep the compiler happy. */
name|UNUSED
argument_list|(
name|argc
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|driverarg
argument_list|)
expr_stmt|;
name|rbtdb
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|rbtdb
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|dns_dbtype_cache
condition|)
block|{
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|cache_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator||=
name|DNS_DBATTR_CACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|dns_dbtype_stub
condition|)
block|{
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|zone_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|attributes
operator||=
name|DNS_DBATTR_STUB
expr_stmt|;
block|}
else|else
name|rbtdb
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|zone_methods
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|rdclass
operator|=
name|rdclass
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|mctx
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_rwlock_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_rwlock_init() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|INSIST
argument_list|(
name|rbtdb
operator|->
name|node_lock_count
operator|<
operator|(
literal|1
operator|<<
name|DNS_RBT_LOCKLENGTH
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|node_lock_count
operator|==
literal|0
condition|)
name|rbtdb
operator|->
name|node_lock_count
operator|=
name|DEFAULT_NODE_LOCK_COUNT
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|node_locks
operator|==
name|NULL
condition|)
block|{
name|isc_rwlock_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|rbtdb
operator|->
name|active
operator|=
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|rbtdb
operator|->
name|node_lock_count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|i
operator|--
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
operator|->
name|node_locks
argument_list|,
name|rbtdb
operator|->
name|node_lock_count
operator|*
sizeof|sizeof
argument_list|(
name|rbtdb_nodelock_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_rwlock_destroy
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbtdb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdb
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|references
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|node_locks
index|[
name|i
index|]
operator|.
name|exiting
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Attach to the mctx.  The database will persist so long as there 	 * are references to it, and attaching to the mctx ensures that our 	 * mctx won't disappear out from under us. 	 */
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|mctx
argument_list|)
expr_stmt|;
comment|/* 	 * Must be initalized before free_rbtdb() is called. 	 */
name|isc_ondestroy_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|ondest
argument_list|)
expr_stmt|;
comment|/* 	 * Make a copy of the origin name. 	 */
name|result
operator|=
name|dns_name_dupwithoffsets
argument_list|(
name|origin
argument_list|,
name|mctx
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Make the Red-Black Tree. 	 */
name|result
operator|=
name|dns_rbt_create
argument_list|(
name|mctx
argument_list|,
name|delete_callback
argument_list|,
name|rbtdb
argument_list|,
operator|&
name|rbtdb
operator|->
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * In order to set the node callback bit correctly in zone databases, 	 * we need to know if the node has the origin name of the zone. 	 * In loading_addrdataset() we could simply compare the new name 	 * to the origin name, but this is expensive.  Also, we don't know the 	 * node name in addrdataset(), so we need another way of knowing the 	 * zone's top. 	 * 	 * We now explicitly create a node for the zone's origin, and then 	 * we simply remember the node's address.  This is safe, because 	 * the top-of-zone node can never be deleted, nor can its address 	 * change. 	 */
if|if
condition|(
operator|!
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|rbtdb
operator|->
name|origin_node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
operator|&
name|rbtdb
operator|->
name|common
operator|.
name|origin
argument_list|,
operator|&
name|rbtdb
operator|->
name|origin_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_EXISTS
argument_list|)
expr_stmt|;
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 		 * We need to give the origin node the right locknum. 		 */
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rbt_namefromnode
argument_list|(
name|rbtdb
operator|->
name|origin_node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|rbtdb
operator|->
name|origin_node
operator|->
name|locknum
operator|=
name|rbtdb
operator|->
name|origin_node
operator|->
name|hashval
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
else|#
directive|else
name|rbtdb
operator|->
name|origin_node
operator|->
name|locknum
operator|=
name|dns_name_hash
argument_list|(
operator|&
name|name
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|rbtdb
operator|->
name|node_lock_count
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Misc. Initialization. 	 */
name|isc_refcount_init
argument_list|(
operator|&
name|rbtdb
operator|->
name|references
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|rbtdb
operator|->
name|secure
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdb
operator|->
name|overmem
operator|=
name|ISC_FALSE
expr_stmt|;
name|rbtdb
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Version Initialization. 	 */
name|rbtdb
operator|->
name|current_serial
operator|=
literal|1
expr_stmt|;
name|rbtdb
operator|->
name|least_serial
operator|=
literal|1
expr_stmt|;
name|rbtdb
operator|->
name|next_serial
operator|=
literal|2
expr_stmt|;
name|rbtdb
operator|->
name|current_version
operator|=
name|allocate_version
argument_list|(
name|mctx
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdb
operator|->
name|current_version
operator|==
name|NULL
condition|)
block|{
name|free_rbtdb
argument_list|(
name|rbtdb
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|rbtdb
operator|->
name|future_version
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|rbtdb
operator|->
name|open_versions
argument_list|)
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|magic
operator|=
name|DNS_DB_MAGIC
expr_stmt|;
name|rbtdb
operator|->
name|common
operator|.
name|impmagic
operator|=
name|RBTDB_MAGIC
expr_stmt|;
operator|*
name|dbp
operator|=
operator|(
name|dns_db_t
operator|*
operator|)
name|rbtdb
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slabbed Rdataset Methods  */
end_comment

begin_function
specifier|static
name|void
name|rdataset_disassociate
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_first
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|rdataset
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
name|raw
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * The privateuint4 field is the number of rdata beyond the cursor 	 * position, so we decrement the total count by one before storing 	 * it. 	 */
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_next
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
decl_stmt|;
name|count
operator|=
name|rdataset
operator|->
name|privateuint4
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|count
operator|--
expr_stmt|;
name|rdataset
operator|->
name|privateuint4
operator|=
name|count
expr_stmt|;
name|raw
operator|=
name|rdataset
operator|->
name|private5
expr_stmt|;
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
name|length
operator|+
literal|2
expr_stmt|;
name|rdataset
operator|->
name|private5
operator|=
name|raw
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_current
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private5
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|REQUIRE
argument_list|(
name|raw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
name|raw
operator|+=
literal|2
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|raw
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|rdata
argument_list|,
name|rdataset
operator|->
name|rdclass
argument_list|,
name|rdataset
operator|->
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdataset_clone
parameter_list|(
name|dns_rdataset_t
modifier|*
name|source
parameter_list|,
name|dns_rdataset_t
modifier|*
name|target
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|source
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|source
operator|->
name|private2
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|cloned_node
init|=
name|NULL
decl_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
operator|*
name|source
expr_stmt|;
comment|/* 	 * Reset iterator state. 	 */
name|target
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|rdataset_count
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
name|rdataset
operator|->
name|private3
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|raw
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|raw
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdataset_getnoqname
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsec
parameter_list|,
name|dns_rdataset_t
modifier|*
name|nsecsig
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
init|=
name|rdataset
operator|->
name|private1
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|rdataset
operator|->
name|private2
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|cloned_node
decl_stmt|;
name|struct
name|noqname
modifier|*
name|noqname
init|=
name|rdataset
operator|->
name|private6
decl_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsec
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsec
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsec
operator|->
name|type
operator|=
name|dns_rdatatype_nsec
expr_stmt|;
name|nsec
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsec
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsec
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsec
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsec
operator|->
name|private3
operator|=
name|noqname
operator|->
name|nsec
expr_stmt|;
name|nsec
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsec
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|cloned_node
operator|=
name|NULL
expr_stmt|;
name|attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|cloned_node
argument_list|)
expr_stmt|;
name|nsecsig
operator|->
name|methods
operator|=
operator|&
name|rdataset_methods
expr_stmt|;
name|nsecsig
operator|->
name|rdclass
operator|=
name|db
operator|->
name|rdclass
expr_stmt|;
name|nsecsig
operator|->
name|type
operator|=
name|dns_rdatatype_rrsig
expr_stmt|;
name|nsecsig
operator|->
name|covers
operator|=
name|dns_rdatatype_nsec
expr_stmt|;
name|nsecsig
operator|->
name|ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|nsecsig
operator|->
name|trust
operator|=
name|rdataset
operator|->
name|trust
expr_stmt|;
name|nsecsig
operator|->
name|private1
operator|=
name|rdataset
operator|->
name|private1
expr_stmt|;
name|nsecsig
operator|->
name|private2
operator|=
name|rdataset
operator|->
name|private2
expr_stmt|;
name|nsecsig
operator|->
name|private3
operator|=
name|noqname
operator|->
name|nsecsig
expr_stmt|;
name|nsecsig
operator|->
name|privateuint4
operator|=
literal|0
expr_stmt|;
name|nsecsig
operator|->
name|private5
operator|=
name|NULL
expr_stmt|;
name|nsec
operator|->
name|private6
operator|=
name|NULL
expr_stmt|;
name|dns_name_clone
argument_list|(
operator|&
name|noqname
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rdataset Iterator Methods  */
end_comment

begin_function
specifier|static
name|void
name|rdatasetiter_destroy
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
decl_stmt|;
name|rbtiterator
operator|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
operator|(
operator|*
name|iteratorp
operator|)
expr_stmt|;
if|if
condition|(
name|rbtiterator
operator|->
name|common
operator|.
name|version
operator|!=
name|NULL
condition|)
name|closeversion
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|rbtiterator
operator|->
name|common
operator|.
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|detachnode
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|rbtiterator
operator|->
name|common
operator|.
name|node
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|->
name|mctx
argument_list|,
name|rbtiterator
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtiterator
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdatasetiter_first
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|serial
operator|=
literal|1
expr_stmt|;
name|now
operator|=
name|rbtiterator
operator|->
name|common
operator|.
name|now
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|rbtnode
operator|->
name|data
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 				 * Is this a "this rdataset doesn't exist" 				 * record?  Or is it too old in the cache? 				 * 				 * Note: unlike everywhere else, we 				 * check for now> header->ttl instead 				 * of now>= header->ttl.  This allows 				 * ANY and RRSIG queries for 0 TTL 				 * rdatasets to work. 				 */
if|if
condition|(
name|NONEXISTENT
argument_list|(
name|header
argument_list|)
operator|||
operator|(
name|now
operator|!=
literal|0
operator|&&
name|now
operator|>
name|header
operator|->
name|ttl
operator|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|rbtiterator
operator|->
name|current
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|rdatasetiter_next
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rbtdb_version_t
modifier|*
name|rbtversion
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|version
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|,
modifier|*
name|top_next
decl_stmt|;
name|rbtdb_serial_t
name|serial
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|rbtdb_rdatatype_t
name|type
decl_stmt|,
name|negtype
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|,
name|covers
decl_stmt|;
name|header
operator|=
name|rbtiterator
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
if|if
condition|(
name|IS_CACHE
argument_list|(
name|rbtdb
argument_list|)
condition|)
block|{
name|serial
operator|=
literal|1
expr_stmt|;
name|now
operator|=
name|rbtiterator
operator|->
name|common
operator|.
name|now
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|rbtversion
operator|->
name|serial
expr_stmt|;
name|now
operator|=
literal|0
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|type
operator|=
name|header
operator|->
name|type
expr_stmt|;
name|rdtype
operator|=
name|RBTDB_RDATATYPE_BASE
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdtype
operator|==
literal|0
condition|)
block|{
name|covers
operator|=
name|RBTDB_RDATATYPE_EXT
argument_list|(
name|header
operator|->
name|type
argument_list|)
expr_stmt|;
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
name|covers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|negtype
operator|=
name|RBTDB_RDATATYPE_VALUE
argument_list|(
literal|0
argument_list|,
name|rdtype
argument_list|)
expr_stmt|;
for|for
control|(
name|header
operator|=
name|header
operator|->
name|next
init|;
name|header
operator|!=
name|NULL
condition|;
name|header
operator|=
name|top_next
control|)
block|{
name|top_next
operator|=
name|header
operator|->
name|next
expr_stmt|;
comment|/* 		 * If not walking back up the down list. 		 */
if|if
condition|(
name|header
operator|->
name|type
operator|!=
name|type
operator|&&
name|header
operator|->
name|type
operator|!=
name|negtype
condition|)
block|{
do|do
block|{
if|if
condition|(
name|header
operator|->
name|serial
operator|<=
name|serial
operator|&&
operator|!
name|IGNORE
argument_list|(
name|header
argument_list|)
condition|)
block|{
comment|/* 					 * Is this a "this rdataset doesn't 					 * exist" record? 					 * 					 * Note: unlike everywhere else, we 					 * check for now> header->ttl instead 					 * of now>= header->ttl.  This allows 					 * ANY and RRSIG queries for 0 TTL 					 * rdatasets to work. 					 */
if|if
condition|(
operator|(
name|header
operator|->
name|attributes
operator|&
name|RDATASET_ATTR_NONEXISTENT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|now
operator|!=
literal|0
operator|&&
name|now
operator|>
name|header
operator|->
name|ttl
operator|)
condition|)
name|header
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
name|header
operator|=
name|header
operator|->
name|down
expr_stmt|;
block|}
do|while
condition|(
name|header
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|rbtiterator
operator|->
name|current
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rdatasetiter_current
parameter_list|(
name|dns_rdatasetiter_t
modifier|*
name|iterator
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|)
block|{
name|rbtdb_rdatasetiter_t
modifier|*
name|rbtiterator
init|=
operator|(
name|rbtdb_rdatasetiter_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
operator|(
name|rbtiterator
operator|->
name|common
operator|.
name|db
operator|)
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|rbtnode
init|=
name|rbtiterator
operator|->
name|common
operator|.
name|node
decl_stmt|;
name|rdatasetheader_t
modifier|*
name|header
decl_stmt|;
name|header
operator|=
name|rbtiterator
operator|->
name|current
expr_stmt|;
name|REQUIRE
argument_list|(
name|header
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|bind_rdataset
argument_list|(
name|rbtdb
argument_list|,
name|rbtnode
argument_list|,
name|header
argument_list|,
name|rbtiterator
operator|->
name|common
operator|.
name|now
argument_list|,
name|rdataset
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|rbtnode
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Database Iterator Methods  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reference_iter_node
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|!=
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dereference_iter_node
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|node
operator|->
name|references
operator|==
literal|0
condition|)
name|no_references
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|rbtdbiter
operator|->
name|tree_locked
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_deletions
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|isc_boolean_t
name|was_read_locked
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|delete
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Note that "%d node of %d in tree" can report things like 		 * "flush_deletions: 59 nodes of 41 in tree".  This means 		 * That some nodes appear on the deletions list more than 		 * once.  Only the last occurence will actually be deleted. 		 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_CACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"flush_deletions: %d nodes of %d in tree"
argument_list|,
name|rbtdbiter
operator|->
name|delete
argument_list|,
name|dns_rbt_nodecount
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|was_read_locked
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_write
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbtdbiter
operator|->
name|delete
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|rbtdbiter
operator|->
name|deletions
index|[
name|i
index|]
expr_stmt|;
name|lock
operator|=
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
expr_stmt|;
name|LOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|node
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|references
operator|==
literal|0
condition|)
name|no_references
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
name|rbtdbiter
operator|->
name|tree_locked
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
name|rbtdbiter
operator|->
name|delete
operator|=
literal|0
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_read_locked
condition|)
block|{
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_read
expr_stmt|;
block|}
else|else
block|{
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|resume_iteration
parameter_list|(
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|paused
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|RWLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_read
expr_stmt|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbiterator_destroy
parameter_list|(
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
block|{
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
operator|(
operator|*
name|iteratorp
operator|)
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|rbtdbiter
operator|->
name|common
operator|.
name|db
decl_stmt|;
name|dns_db_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
condition|)
block|{
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
else|else
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_none
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|common
operator|.
name|db
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|db
operator|->
name|mctx
argument_list|,
name|rbtdbiter
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbtdbiter
argument_list|)
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
operator|*
name|iteratorp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_first
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_first
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOTFOUND
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
comment|/* The tree is empty. */
block|}
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_last
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_last
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOTFOUND
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
comment|/* The tree is empty. */
block|}
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_seek
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|dns_name_t
modifier|*
name|iname
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|iname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbtdb
operator|->
name|tree
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|DNS_RBTFIND_EMPTYDATA
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|iname
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_prev
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_prev
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|DNS_R_NEWORIGIN
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_next
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|,
modifier|*
name|origin
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
expr_stmt|;
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_next
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|dereference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
operator|||
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbtdbiter
operator|->
name|new_origin
operator|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|DNS_R_NEWORIGIN
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rbtdbiter
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|reference_iter_node
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_current
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|rbtdbiter
operator|->
name|node
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_name_t
modifier|*
name|nodename
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|name
argument_list|)
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtdbiter
operator|->
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
name|resume_iteration
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
condition|)
name|origin
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|nodename
argument_list|,
name|origin
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|common
operator|.
name|relative_names
operator|&&
name|rbtdbiter
operator|->
name|new_origin
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|new_reference
argument_list|(
name|rbtdb
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|rbtdbiter
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|iterator
operator|->
name|cleaning
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_result_t
name|expire_result
decl_stmt|;
comment|/* 		 * If the deletion array is full, flush it before trying 		 * to expire the current node.  The current node can't 		 * fully deleted while the iteration cursor is still on it. 		 */
if|if
condition|(
name|rbtdbiter
operator|->
name|delete
operator|==
name|DELETION_BATCH_MAX
condition|)
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
name|expire_result
operator|=
name|expirenode
argument_list|(
name|iterator
operator|->
name|db
argument_list|,
operator|*
name|nodep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * expirenode() currently always returns success. 		 */
if|if
condition|(
name|expire_result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|node
operator|->
name|down
operator|==
name|NULL
condition|)
block|{
name|rbtdbiter
operator|->
name|deletions
index|[
name|rbtdbiter
operator|->
name|delete
operator|++
index|]
operator|=
name|node
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|node
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|node_locks
index|[
name|node
operator|->
name|locknum
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_pause
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|)
block|{
name|dns_rbtdb_t
modifier|*
name|rbtdb
init|=
operator|(
name|dns_rbtdb_t
operator|*
operator|)
name|iterator
operator|->
name|db
decl_stmt|;
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
if|if
condition|(
name|rbtdbiter
operator|->
name|paused
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|rbtdbiter
operator|->
name|paused
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|tree_locked
operator|!=
name|isc_rwlocktype_none
condition|)
block|{
name|INSIST
argument_list|(
name|rbtdbiter
operator|->
name|tree_locked
operator|==
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|RWUNLOCK
argument_list|(
operator|&
name|rbtdb
operator|->
name|tree_lock
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|rbtdbiter
operator|->
name|tree_locked
operator|=
name|isc_rwlocktype_none
expr_stmt|;
block|}
name|flush_deletions
argument_list|(
name|rbtdbiter
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dbiterator_origin
parameter_list|(
name|dns_dbiterator_t
modifier|*
name|iterator
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|rbtdb_dbiterator_t
modifier|*
name|rbtdbiter
init|=
operator|(
name|rbtdb_dbiterator_t
operator|*
operator|)
name|iterator
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|rbtdbiter
operator|->
name|origin
argument_list|)
decl_stmt|;
if|if
condition|(
name|rbtdbiter
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|rbtdbiter
operator|->
name|result
operator|)
return|;
return|return
operator|(
name|dns_name_copy
argument_list|(
name|origin
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

