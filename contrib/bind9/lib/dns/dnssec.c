begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * $Id$  */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/diff.h>
end_include

begin_include
include|#
directive|include
file|<dns/dnssec.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyvalues.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/tsig.h>
end_include

begin_comment
comment|/* for DNS_TSIG_FUDGE */
end_comment

begin_include
include|#
directive|include
file|<dst/result.h>
end_include

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
name|isc_stats_t
modifier|*
name|dns_dnssec_stats
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|is_response
parameter_list|(
name|msg
parameter_list|)
value|(msg->flags& DNS_MESSAGEFLAG_QR)
end_define

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|x
parameter_list|)
value|do { \ 	result = (x); \ 	if (result != ISC_R_SUCCESS) \ 		goto failure; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|TYPE_SIGN
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_VERIFY
value|1
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|digest_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_region_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rdata_compare_wrapper
parameter_list|(
specifier|const
name|void
modifier|*
name|rdata1
parameter_list|,
specifier|const
name|void
modifier|*
name|rdata2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|rdataset_to_sortedarray
parameter_list|(
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
modifier|*
name|nrdata
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|isc_result_t
name|digest_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|isc_region_t
modifier|*
name|data
parameter_list|)
block|{
name|dst_context_t
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|inc_stat
parameter_list|(
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
if|if
condition|(
name|dns_dnssec_stats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|dns_dnssec_stats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make qsort happy.  */
end_comment

begin_function
specifier|static
name|int
name|rdata_compare_wrapper
parameter_list|(
specifier|const
name|void
modifier|*
name|rdata1
parameter_list|,
specifier|const
name|void
modifier|*
name|rdata2
parameter_list|)
block|{
return|return
operator|(
name|dns_rdata_compare
argument_list|(
operator|(
specifier|const
name|dns_rdata_t
operator|*
operator|)
name|rdata1
argument_list|,
operator|(
specifier|const
name|dns_rdata_t
operator|*
operator|)
name|rdata2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort the rdataset into an array.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdataset_to_sortedarray
parameter_list|(
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|,
name|int
modifier|*
name|nrdata
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|dns_rdata_t
modifier|*
name|data
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|n
operator|=
name|dns_rdataset_count
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|data
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|set
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|data
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Put them in the array. 	 */
do|do
block|{
name|dns_rdata_init
argument_list|(
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|data
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
comment|/* 	 * Sort the array. 	 */
name|qsort
argument_list|(
name|data
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|,
name|rdata_compare_wrapper
argument_list|)
expr_stmt|;
operator|*
name|rdata
operator|=
name|data
expr_stmt|;
operator|*
name|nrdata
operator|=
name|n
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_keyfromrdata
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|key
parameter_list|)
block|{
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|INSIST
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|*
name|key
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
name|dns_rdata_toregion
argument_list|(
name|rdata
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_key_fromdns
argument_list|(
name|name
argument_list|,
name|rdata
operator|->
name|rdclass
argument_list|,
operator|&
name|b
argument_list|,
name|mctx
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|digest_sig
parameter_list|(
name|dst_context_t
modifier|*
name|ctx
parameter_list|,
name|isc_boolean_t
name|downcase
parameter_list|,
name|dns_rdata_t
modifier|*
name|sigrdata
parameter_list|,
name|dns_rdata_rrsig_t
modifier|*
name|rrsig
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_rdata_toregion
argument_list|(
name|sigrdata
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|r
operator|.
name|length
operator|>=
literal|19
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
literal|18
expr_stmt|;
name|ret
operator|=
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|downcase
condition|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_downcase
argument_list|(
operator|&
name|rrsig
operator|->
name|signer
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|dns_name_toregion
argument_list|(
operator|&
name|rrsig
operator|->
name|signer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_sign
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
modifier|*
name|inception
parameter_list|,
name|isc_stdtime_t
modifier|*
name|expire
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|dns_rdata_t
modifier|*
name|sigrdata
parameter_list|)
block|{
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_rdata_t
name|tmpsigrdata
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdatas
decl_stmt|;
name|int
name|nrdatas
decl_stmt|,
name|i
decl_stmt|;
name|isc_buffer_t
name|sigbuf
decl_stmt|,
name|envbuf
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dst_context_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|isc_buffer_t
modifier|*
name|databuf
init|=
name|NULL
decl_stmt|;
name|char
name|data
index|[
literal|256
operator|+
literal|8
index|]
decl_stmt|;
name|isc_uint32_t
name|flags
decl_stmt|;
name|unsigned
name|int
name|sigsize
decl_stmt|;
name|dns_fixedname_t
name|fnewname
decl_stmt|;
name|dns_fixedname_t
name|fsigner
decl_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|<=
literal|255
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|set
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|inception
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|expire
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sigrdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|inception
operator|>=
operator|*
name|expire
condition|)
return|return
operator|(
name|DNS_R_INVALIDTIME
operator|)
return|;
comment|/* 	 * Is the key allowed to sign data? 	 */
name|flags
operator|=
name|dst_key_flags
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_KEYTYPE_NOAUTH
condition|)
return|return
operator|(
name|DNS_R_KEYUNAUTHORIZED
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_KEYFLAG_OWNERMASK
operator|)
operator|!=
name|DNS_KEYOWNER_ZONE
condition|)
return|return
operator|(
name|DNS_R_KEYUNAUTHORIZED
operator|)
return|;
name|sig
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|sig
operator|.
name|common
operator|.
name|rdclass
operator|=
name|set
operator|->
name|rdclass
expr_stmt|;
name|sig
operator|.
name|common
operator|.
name|rdtype
operator|=
name|dns_rdatatype_rrsig
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|sig
operator|.
name|common
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Downcase signer. 	 */
name|dns_name_init
argument_list|(
operator|&
name|sig
operator|.
name|signer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fsigner
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_downcase
argument_list|(
name|dst_key_name
argument_list|(
name|key
argument_list|)
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fsigner
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fsigner
argument_list|)
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
expr_stmt|;
name|sig
operator|.
name|covered
operator|=
name|set
operator|->
name|type
expr_stmt|;
name|sig
operator|.
name|algorithm
operator|=
name|dst_key_alg
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sig
operator|.
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
name|name
argument_list|)
condition|)
name|sig
operator|.
name|labels
operator|--
expr_stmt|;
name|sig
operator|.
name|originalttl
operator|=
name|set
operator|->
name|ttl
expr_stmt|;
name|sig
operator|.
name|timesigned
operator|=
operator|*
name|inception
expr_stmt|;
name|sig
operator|.
name|timeexpire
operator|=
operator|*
name|expire
expr_stmt|;
name|sig
operator|.
name|keyid
operator|=
name|dst_key_id
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dst_key_sigsize
argument_list|(
name|key
argument_list|,
operator|&
name|sigsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|sig
operator|.
name|siglen
operator|=
name|sigsize
expr_stmt|;
comment|/* 	 * The actual contents of sig.signature are not important yet, since 	 * they're not used in digest_sig(). 	 */
name|sig
operator|.
name|signature
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|signature
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|ret
operator|=
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
operator|&
name|databuf
argument_list|,
name|sigsize
operator|+
literal|256
operator|+
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_signature
goto|;
name|dns_rdata_init
argument_list|(
operator|&
name|tmpsigrdata
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dns_rdata_fromstruct
argument_list|(
operator|&
name|tmpsigrdata
argument_list|,
name|sig
operator|.
name|common
operator|.
name|rdclass
argument_list|,
name|sig
operator|.
name|common
operator|.
name|rdtype
argument_list|,
operator|&
name|sig
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_databuf
goto|;
name|ret
operator|=
name|dst_context_create2
argument_list|(
name|key
argument_list|,
name|mctx
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_databuf
goto|;
comment|/* 	 * Digest the SIG rdata. 	 */
name|ret
operator|=
name|digest_sig
argument_list|(
name|ctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|tmpsigrdata
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_context
goto|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnewname
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_downcase
argument_list|(
name|name
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * Create an envelope for each rdata:<name|type|class|ttl>. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|envbuf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|data
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|envbuf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|envbuf
argument_list|,
name|set
operator|->
name|type
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|envbuf
argument_list|,
name|set
operator|->
name|rdclass
argument_list|)
expr_stmt|;
name|isc_buffer_putuint32
argument_list|(
operator|&
name|envbuf
argument_list|,
name|set
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rdataset_to_sortedarray
argument_list|(
name|set
argument_list|,
name|mctx
argument_list|,
operator|&
name|rdatas
argument_list|,
operator|&
name|nrdatas
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_context
goto|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|envbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrdatas
condition|;
name|i
operator|++
control|)
block|{
name|isc_uint16_t
name|len
decl_stmt|;
name|isc_buffer_t
name|lenbuf
decl_stmt|;
name|isc_region_t
name|lenr
decl_stmt|;
comment|/* 		 * Skip duplicates. 		 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|dns_rdata_compare
argument_list|(
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|,
operator|&
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Digest the envelope. 		 */
name|ret
operator|=
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
comment|/* 		 * Digest the length of the rdata. 		 */
name|isc_buffer_init
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdatas
index|[
name|i
index|]
operator|.
name|length
operator|<
literal|65536
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|rdatas
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|&
name|lenr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|lenr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
comment|/* 		 * Digest the rdata. 		 */
name|ret
operator|=
name|dns_rdata_digest
argument_list|(
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|,
name|digest_callback
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|sigbuf
argument_list|,
name|sig
operator|.
name|signature
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dst_context_sign
argument_list|(
name|ctx
argument_list|,
operator|&
name|sigbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|sigbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|!=
name|sig
operator|.
name|siglen
condition|)
block|{
name|ret
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
goto|goto
name|cleanup_array
goto|;
block|}
name|ret
operator|=
name|dns_rdata_fromstruct
argument_list|(
name|sigrdata
argument_list|,
name|sig
operator|.
name|common
operator|.
name|rdclass
argument_list|,
name|sig
operator|.
name|common
operator|.
name|rdtype
argument_list|,
operator|&
name|sig
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|cleanup_array
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdatas
argument_list|,
name|nrdatas
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_context
label|:
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|cleanup_databuf
label|:
name|isc_buffer_free
argument_list|(
operator|&
name|databuf
argument_list|)
expr_stmt|;
name|cleanup_signature
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|sig
operator|.
name|signature
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_verify2
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_boolean_t
name|ignoretime
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdata_t
modifier|*
name|sigrdata
parameter_list|,
name|dns_name_t
modifier|*
name|wild
parameter_list|)
block|{
return|return
operator|(
name|dns_dnssec_verify3
argument_list|(
name|name
argument_list|,
name|set
argument_list|,
name|key
argument_list|,
name|ignoretime
argument_list|,
literal|0
argument_list|,
name|mctx
argument_list|,
name|sigrdata
argument_list|,
name|wild
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_verify3
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_boolean_t
name|ignoretime
parameter_list|,
name|unsigned
name|int
name|maxbits
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdata_t
modifier|*
name|sigrdata
parameter_list|,
name|dns_name_t
modifier|*
name|wild
parameter_list|)
block|{
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_fixedname_t
name|fnewname
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_t
name|envbuf
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdatas
decl_stmt|;
name|int
name|nrdatas
decl_stmt|,
name|i
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|300
index|]
decl_stmt|;
name|dst_context_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|int
name|labels
init|=
literal|0
decl_stmt|;
name|isc_uint32_t
name|flags
decl_stmt|;
name|isc_boolean_t
name|downcase
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|set
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sigrdata
operator|!=
name|NULL
operator|&&
name|sigrdata
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dns_rdata_tostruct
argument_list|(
name|sigrdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|set
operator|->
name|type
operator|!=
name|sig
operator|.
name|covered
condition|)
return|return
operator|(
name|DNS_R_SIGINVALID
operator|)
return|;
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
name|sig
operator|.
name|timesigned
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGINVALID
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ignoretime
condition|)
block|{
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 		 * Is SIG temporally valid? 		 */
if|if
condition|(
name|isc_serial_lt
argument_list|(
operator|(
name|isc_uint32_t
operator|)
name|now
argument_list|,
name|sig
operator|.
name|timesigned
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGFUTURE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
operator|(
name|isc_uint32_t
operator|)
name|now
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGEXPIRED
operator|)
return|;
block|}
block|}
comment|/* 	 * NS, SOA and DNSSKEY records are signed by their owner. 	 * DS records are signed by the parent. 	 */
switch|switch
condition|(
name|set
operator|->
name|type
condition|)
block|{
case|case
name|dns_rdatatype_ns
case|:
case|case
name|dns_rdatatype_soa
case|:
case|case
name|dns_rdatatype_dnskey
case|:
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGINVALID
operator|)
return|;
block|}
break|break;
case|case
name|dns_rdatatype_ds
case|:
if|if
condition|(
name|dns_name_equal
argument_list|(
name|name
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGINVALID
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
operator|!
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_SIGINVALID
operator|)
return|;
block|}
break|break;
block|}
comment|/* 	 * Is the key allowed to sign data? 	 */
name|flags
operator|=
name|dst_key_flags
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DNS_KEYTYPE_NOAUTH
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_KEYUNAUTHORIZED
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_KEYFLAG_OWNERMASK
operator|)
operator|!=
name|DNS_KEYOWNER_ZONE
condition|)
block|{
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_KEYUNAUTHORIZED
operator|)
return|;
block|}
name|again
label|:
name|ret
operator|=
name|dst_context_create2
argument_list|(
name|key
argument_list|,
name|mctx
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_struct
goto|;
comment|/* 	 * Digest the SIG rdata (not including the signature). 	 */
name|ret
operator|=
name|digest_sig
argument_list|(
name|ctx
argument_list|,
name|downcase
argument_list|,
name|sigrdata
argument_list|,
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_context
goto|;
comment|/* 	 * If the name is an expanded wildcard, use the wildcard name. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fnewname
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_name_downcase
argument_list|(
name|name
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|-
name|sig
operator|.
name|labels
operator|>
literal|0
condition|)
name|dns_name_split
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
name|sig
operator|.
name|labels
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
comment|/* 	 * Create an envelope for each rdata:<name|type|class|ttl>. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|envbuf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|-
name|sig
operator|.
name|labels
operator|>
literal|0
condition|)
block|{
name|isc_buffer_putuint8
argument_list|(
operator|&
name|envbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|envbuf
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|data
operator|+
literal|2
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
name|memmove
argument_list|(
name|data
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|envbuf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|envbuf
argument_list|,
name|set
operator|->
name|type
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|envbuf
argument_list|,
name|set
operator|->
name|rdclass
argument_list|)
expr_stmt|;
name|isc_buffer_putuint32
argument_list|(
operator|&
name|envbuf
argument_list|,
name|sig
operator|.
name|originalttl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rdataset_to_sortedarray
argument_list|(
name|set
argument_list|,
name|mctx
argument_list|,
operator|&
name|rdatas
argument_list|,
operator|&
name|nrdatas
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_context
goto|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|envbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrdatas
condition|;
name|i
operator|++
control|)
block|{
name|isc_uint16_t
name|len
decl_stmt|;
name|isc_buffer_t
name|lenbuf
decl_stmt|;
name|isc_region_t
name|lenr
decl_stmt|;
comment|/* 		 * Skip duplicates. 		 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|dns_rdata_compare
argument_list|(
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|,
operator|&
name|rdatas
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Digest the envelope. 		 */
name|ret
operator|=
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
comment|/* 		 * Digest the rdata length. 		 */
name|isc_buffer_init
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdatas
index|[
name|i
index|]
operator|.
name|length
operator|<
literal|65536
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|rdatas
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|lenbuf
argument_list|,
operator|&
name|lenr
argument_list|)
expr_stmt|;
comment|/* 		 * Digest the rdata. 		 */
name|ret
operator|=
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|lenr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
name|ret
operator|=
name|dns_rdata_digest
argument_list|(
operator|&
name|rdatas
index|[
name|i
index|]
argument_list|,
name|digest_callback
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_array
goto|;
block|}
name|r
operator|.
name|base
operator|=
name|sig
operator|.
name|signature
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|sig
operator|.
name|siglen
expr_stmt|;
name|ret
operator|=
name|dst_context_verify2
argument_list|(
name|ctx
argument_list|,
name|maxbits
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ISC_R_SUCCESS
operator|&&
name|downcase
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|sig
operator|.
name|signer
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
name|DNS_LOGMODULE_DNSSEC
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"successfully validated after lower casing "
literal|"signer '%s'"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|inc_stat
argument_list|(
name|dns_dnssecstats_downcase
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ISC_R_SUCCESS
condition|)
name|inc_stat
argument_list|(
name|dns_dnssecstats_asis
argument_list|)
expr_stmt|;
name|cleanup_array
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdatas
argument_list|,
name|nrdatas
operator|*
sizeof|sizeof
argument_list|(
name|dns_rdata_t
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_context
label|:
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DST_R_VERIFYFAILURE
operator|&&
operator|!
name|downcase
condition|)
block|{
name|downcase
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|cleanup_struct
label|:
name|dns_rdata_freestruct
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|DST_R_VERIFYFAILURE
condition|)
name|ret
operator|=
name|DNS_R_SIGINVALID
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ISC_R_SUCCESS
condition|)
name|inc_stat
argument_list|(
name|dns_dnssecstats_fail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ISC_R_SUCCESS
operator|&&
name|labels
operator|-
name|sig
operator|.
name|labels
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wild
operator|!=
name|NULL
condition|)
name|RUNTIME_CHECK
argument_list|(
name|dns_name_concatenate
argument_list|(
name|dns_wildcardname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
argument_list|,
name|wild
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|inc_stat
argument_list|(
name|dns_dnssecstats_wildcard
argument_list|)
expr_stmt|;
name|ret
operator|=
name|DNS_R_FROMWILDCARD
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_verify
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|set
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_boolean_t
name|ignoretime
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdata_t
modifier|*
name|sigrdata
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_dnssec_verify2
argument_list|(
name|name
argument_list|,
name|set
argument_list|,
name|key
argument_list|,
name|ignoretime
argument_list|,
name|mctx
argument_list|,
name|sigrdata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_FROMWILDCARD
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_dnssec_keyactive
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|publish
decl_stmt|,
name|active
decl_stmt|,
name|revoke
decl_stmt|,
name|inactive
decl_stmt|,
name|delete
decl_stmt|;
name|isc_boolean_t
name|pubset
init|=
name|ISC_FALSE
decl_stmt|,
name|actset
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|revset
init|=
name|ISC_FALSE
decl_stmt|,
name|inactset
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|delset
init|=
name|ISC_FALSE
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
comment|/* Is this an old-style key? */
name|result
operator|=
name|dst_key_getprivateformat
argument_list|(
name|key
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* 	 * Smart signing started with key format 1.3; prior to that, all 	 * keys are assumed active 	 */
if|if
condition|(
name|major
operator|==
literal|1
operator|&&
name|minor
operator|<=
literal|2
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|DST_TIME_PUBLISH
argument_list|,
operator|&
name|publish
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|pubset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|DST_TIME_ACTIVATE
argument_list|,
operator|&
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|actset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|DST_TIME_REVOKE
argument_list|,
operator|&
name|revoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|revset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|DST_TIME_INACTIVE
argument_list|,
operator|&
name|inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|inactset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
argument_list|,
name|DST_TIME_DELETE
argument_list|,
operator|&
name|delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|delset
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|inactset
operator|&&
name|inactive
operator|<=
name|now
operator|)
operator|||
operator|(
name|delset
operator|&&
name|delete
operator|<=
name|now
operator|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|revset
operator|&&
name|revoke
operator|<=
name|now
operator|&&
name|pubset
operator|&&
name|publish
operator|<=
name|now
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|actset
operator|&&
name|active
operator|<=
name|now
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|is_zone_key
parameter_list|(
name|key
parameter_list|)
value|((dst_key_flags(key)& DNS_KEYFLAG_OWNERMASK) \ 			  == DNS_KEYOWNER_ZONE)
end_define

begin_function
name|isc_result_t
name|dns_dnssec_findzonekeys2
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|maxkeys
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
modifier|*
name|nkeys
parameter_list|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dst_key_t
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|nkeys
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|keys
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|*
name|nkeys
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|keys
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|keys
argument_list|)
operator|*
name|maxkeys
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|count
operator|<
name|maxkeys
condition|)
block|{
name|pubkey
operator|=
name|NULL
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
operator|&
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
name|dst_key_setttl
argument_list|(
name|pubkey
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_zone_key
argument_list|(
name|pubkey
argument_list|)
operator|||
operator|(
name|dst_key_flags
argument_list|(
name|pubkey
argument_list|)
operator|&
name|DNS_KEYTYPE_NOAUTH
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|next
goto|;
comment|/* Corrupted .key file? */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|name
argument_list|,
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|)
condition|)
goto|goto
name|next
goto|;
name|keys
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dst_key_fromfile
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|DST_TYPE_PUBLIC
operator||
name|DST_TYPE_PRIVATE
argument_list|,
name|directory
argument_list|,
name|mctx
argument_list|,
operator|&
name|keys
index|[
name|count
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * If the key was revoked and the private file 		 * doesn't exist, maybe it was revoked internally 		 * by named.  Try loading the unrevoked version. 		 */
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
block|{
name|isc_uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|dst_key_flags
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_KEYFLAG_REVOKE
operator|)
operator|!=
literal|0
condition|)
block|{
name|dst_key_setflags
argument_list|(
name|pubkey
argument_list|,
name|flags
operator|&
operator|~
name|DNS_KEYFLAG_REVOKE
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_fromfile
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|DST_TYPE_PUBLIC
operator||
name|DST_TYPE_PRIVATE
argument_list|,
name|directory
argument_list|,
name|mctx
argument_list|,
operator|&
name|keys
index|[
name|count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|dst_key_pubcompare
argument_list|(
name|pubkey
argument_list|,
name|keys
index|[
name|count
index|]
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
name|dst_key_setflags
argument_list|(
name|keys
index|[
name|count
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|dst_key_setflags
argument_list|(
name|pubkey
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|keybuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|algbuf
index|[
name|DNS_SECALG_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|keybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_secalg_format
argument_list|(
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|algbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|algbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_DNSSEC
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"dns_dnssec_findzonekeys2: error "
literal|"reading private key file %s/%s/%d: %s"
argument_list|,
name|keybuf
argument_list|,
name|algbuf
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
operator|||
name|result
operator|==
name|ISC_R_NOPERM
condition|)
block|{
name|keys
index|[
name|count
index|]
operator|=
name|pubkey
expr_stmt|;
name|pubkey
operator|=
name|NULL
expr_stmt|;
name|count
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
comment|/* 		 * If a key is marked inactive, skip it 		 */
if|if
condition|(
operator|!
name|dns_dnssec_keyactive
argument_list|(
name|keys
index|[
name|count
index|]
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|dst_key_setinactive
argument_list|(
name|pubkey
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|keys
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|keys
index|[
name|count
index|]
operator|=
name|pubkey
expr_stmt|;
name|pubkey
operator|=
name|NULL
expr_stmt|;
name|count
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * Whatever the key's default TTL may have 		 * been, the rdataset TTL takes priority. 		 */
name|dst_key_setttl
argument_list|(
name|keys
index|[
name|count
index|]
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_key_flags
argument_list|(
name|keys
index|[
name|count
index|]
argument_list|)
operator|&
name|DNS_KEYTYPE_NOAUTH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We should never get here. */
name|dst_key_free
argument_list|(
operator|&
name|keys
index|[
name|count
index|]
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|count
operator|++
expr_stmt|;
name|next
label|:
if|if
condition|(
name|pubkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|failure
goto|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|rdataset
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|pubkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
while|while
condition|(
name|count
operator|>
literal|0
condition|)
name|dst_key_free
argument_list|(
operator|&
name|keys
index|[
operator|--
name|count
index|]
argument_list|)
expr_stmt|;
operator|*
name|nkeys
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_findzonekeys
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|maxkeys
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|keys
parameter_list|,
name|unsigned
name|int
modifier|*
name|nkeys
parameter_list|)
block|{
return|return
operator|(
name|dns_dnssec_findzonekeys2
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|mctx
argument_list|,
name|maxkeys
argument_list|,
name|keys
argument_list|,
name|nkeys
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_signmessage
parameter_list|(
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|)
block|{
name|dns_rdata_sig_t
name|sig
decl_stmt|;
comment|/* SIG(0) */
name|unsigned
name|char
name|data
index|[
literal|512
index|]
decl_stmt|;
name|unsigned
name|char
name|header
index|[
name|DNS_MESSAGE_HEADERLEN
index|]
decl_stmt|;
name|isc_buffer_t
name|headerbuf
decl_stmt|,
name|databuf
decl_stmt|,
name|sigbuf
decl_stmt|;
name|unsigned
name|int
name|sigsize
decl_stmt|;
name|isc_buffer_t
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|datalist
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|dataset
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dst_context_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|signeedsfree
init|=
name|ISC_TRUE
decl_stmt|;
name|REQUIRE
argument_list|(
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_response
argument_list|(
name|msg
argument_list|)
condition|)
name|REQUIRE
argument_list|(
name|msg
operator|->
name|query
operator|.
name|base
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|msg
operator|->
name|mctx
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|sig
operator|.
name|mctx
operator|=
name|mctx
expr_stmt|;
name|sig
operator|.
name|common
operator|.
name|rdclass
operator|=
name|dns_rdataclass_any
expr_stmt|;
name|sig
operator|.
name|common
operator|.
name|rdtype
operator|=
name|dns_rdatatype_sig
expr_stmt|;
comment|/* SIG(0) */
name|ISC_LINK_INIT
argument_list|(
operator|&
name|sig
operator|.
name|common
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sig
operator|.
name|covered
operator|=
literal|0
expr_stmt|;
name|sig
operator|.
name|algorithm
operator|=
name|dst_key_alg
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sig
operator|.
name|labels
operator|=
literal|0
expr_stmt|;
comment|/* the root name */
name|sig
operator|.
name|originalttl
operator|=
literal|0
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|sig
operator|.
name|timesigned
operator|=
name|now
operator|-
name|DNS_TSIG_FUDGE
expr_stmt|;
name|sig
operator|.
name|timeexpire
operator|=
name|now
operator|+
name|DNS_TSIG_FUDGE
expr_stmt|;
name|sig
operator|.
name|keyid
operator|=
name|dst_key_id
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|sig
operator|.
name|signer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|dst_key_name
argument_list|(
name|key
argument_list|)
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
expr_stmt|;
name|sig
operator|.
name|siglen
operator|=
literal|0
expr_stmt|;
name|sig
operator|.
name|signature
operator|=
name|NULL
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|databuf
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_create2
argument_list|(
name|key
argument_list|,
name|mctx
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
operator|&
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Digest the fields of the SIG - we can cheat and use 	 * dns_rdata_fromstruct.  Since siglen is 0, the digested data 	 * is identical to dns format. 	 */
name|RETERR
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
name|NULL
argument_list|,
name|dns_rdataclass_any
argument_list|,
name|dns_rdatatype_sig
comment|/* SIG(0) */
argument_list|,
operator|&
name|sig
argument_list|,
operator|&
name|databuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|databuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a response, digest the query. 	 */
if|if
condition|(
name|is_response
argument_list|(
name|msg
argument_list|)
condition|)
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|msg
operator|->
name|query
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Digest the header. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|headerbuf
argument_list|,
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|dns_message_renderheader
argument_list|(
name|msg
argument_list|,
operator|&
name|headerbuf
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|headerbuf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Digest the remainder of the message. 	 */
name|isc_buffer_usedregion
argument_list|(
name|msg
operator|->
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|isc_region_consume
argument_list|(
operator|&
name|r
argument_list|,
name|DNS_MESSAGE_HEADERLEN
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_key_sigsize
argument_list|(
name|key
argument_list|,
operator|&
name|sigsize
argument_list|)
argument_list|)
expr_stmt|;
name|sig
operator|.
name|siglen
operator|=
name|sigsize
expr_stmt|;
name|sig
operator|.
name|signature
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|signature
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|sigbuf
argument_list|,
name|sig
operator|.
name|signature
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_sign
argument_list|(
name|ctx
argument_list|,
operator|&
name|sigbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|RETERR
argument_list|(
name|dns_message_gettemprdata
argument_list|(
name|msg
argument_list|,
operator|&
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|isc_buffer_allocate
argument_list|(
name|msg
operator|->
name|mctx
argument_list|,
operator|&
name|dynbuf
argument_list|,
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_rdata_fromstruct
argument_list|(
name|rdata
argument_list|,
name|dns_rdataclass_any
argument_list|,
name|dns_rdatatype_sig
comment|/* SIG(0) */
argument_list|,
operator|&
name|sig
argument_list|,
name|dynbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|sig
operator|.
name|signature
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
name|signeedsfree
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_message_takebuffer
argument_list|(
name|msg
argument_list|,
operator|&
name|dynbuf
argument_list|)
expr_stmt|;
name|datalist
operator|=
name|NULL
expr_stmt|;
name|RETERR
argument_list|(
name|dns_message_gettemprdatalist
argument_list|(
name|msg
argument_list|,
operator|&
name|datalist
argument_list|)
argument_list|)
expr_stmt|;
name|datalist
operator|->
name|rdclass
operator|=
name|dns_rdataclass_any
expr_stmt|;
name|datalist
operator|->
name|type
operator|=
name|dns_rdatatype_sig
expr_stmt|;
comment|/* SIG(0) */
name|datalist
operator|->
name|covers
operator|=
literal|0
expr_stmt|;
name|datalist
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|datalist
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|datalist
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dataset
operator|=
name|NULL
expr_stmt|;
name|RETERR
argument_list|(
name|dns_message_gettemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|dataset
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
name|dataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|datalist
argument_list|,
name|dataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sig0
operator|=
name|dataset
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|isc_buffer_free
argument_list|(
operator|&
name|dynbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|signeedsfree
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|sig
operator|.
name|signature
argument_list|,
name|sig
operator|.
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnssec_verifymessage
parameter_list|(
name|isc_buffer_t
modifier|*
name|source
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|dst_key_t
modifier|*
name|key
parameter_list|)
block|{
name|dns_rdata_sig_t
name|sig
decl_stmt|;
comment|/* SIG(0) */
name|unsigned
name|char
name|header
index|[
name|DNS_MESSAGE_HEADERLEN
index|]
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|,
name|source_r
decl_stmt|,
name|sig_r
decl_stmt|,
name|header_r
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dst_context_t
modifier|*
name|ctx
init|=
name|NULL
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint16_t
name|addcount
decl_stmt|;
name|isc_boolean_t
name|signeedsfree
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|source
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|msg
operator|->
name|mctx
expr_stmt|;
name|msg
operator|->
name|verify_attempted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|is_response
argument_list|(
name|msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|query
operator|.
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_UNEXPECTEDTSIG
operator|)
return|;
block|}
name|isc_buffer_usedregion
argument_list|(
name|source
argument_list|,
operator|&
name|source_r
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_rdataset_first
argument_list|(
name|msg
operator|->
name|sig0
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|msg
operator|->
name|sig0
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|signeedsfree
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|labels
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|DNS_R_SIGINVALID
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
name|sig
operator|.
name|timesigned
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_SIGINVALID
expr_stmt|;
name|msg
operator|->
name|sig0status
operator|=
name|dns_tsigerror_badtime
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_serial_lt
argument_list|(
operator|(
name|isc_uint32_t
operator|)
name|now
argument_list|,
name|sig
operator|.
name|timesigned
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_SIGFUTURE
expr_stmt|;
name|msg
operator|->
name|sig0status
operator|=
name|dns_tsigerror_badtime
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
elseif|else
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
operator|(
name|isc_uint32_t
operator|)
name|now
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_SIGEXPIRED
expr_stmt|;
name|msg
operator|->
name|sig0status
operator|=
name|dns_tsigerror_badtime
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|dst_key_name
argument_list|(
name|key
argument_list|)
argument_list|,
operator|&
name|sig
operator|.
name|signer
argument_list|)
condition|)
block|{
name|result
operator|=
name|DNS_R_SIGINVALID
expr_stmt|;
name|msg
operator|->
name|sig0status
operator|=
name|dns_tsigerror_badkey
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|RETERR
argument_list|(
name|dst_context_create2
argument_list|(
name|key
argument_list|,
name|mctx
argument_list|,
name|DNS_LOGCATEGORY_DNSSEC
argument_list|,
operator|&
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Digest the SIG(0) record, except for the signature. 	 */
name|dns_rdata_toregion
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|-=
name|sig
operator|.
name|siglen
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a response, digest the query. 	 */
if|if
condition|(
name|is_response
argument_list|(
name|msg
argument_list|)
condition|)
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|msg
operator|->
name|query
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Extract the header. 	 */
name|memmove
argument_list|(
name|header
argument_list|,
name|source_r
operator|.
name|base
argument_list|,
name|DNS_MESSAGE_HEADERLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the additional field counter. 	 */
name|memmove
argument_list|(
operator|&
name|addcount
argument_list|,
operator|&
name|header
index|[
name|DNS_MESSAGE_HEADERLEN
operator|-
literal|2
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|addcount
operator|=
name|htons
argument_list|(
call|(
name|isc_uint16_t
call|)
argument_list|(
name|ntohs
argument_list|(
name|addcount
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|header
index|[
name|DNS_MESSAGE_HEADERLEN
operator|-
literal|2
index|]
argument_list|,
operator|&
name|addcount
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Digest the modified header. 	 */
name|header_r
operator|.
name|base
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|header
expr_stmt|;
name|header_r
operator|.
name|length
operator|=
name|DNS_MESSAGE_HEADERLEN
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|header_r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Digest all non-SIG(0) records. 	 */
name|r
operator|.
name|base
operator|=
name|source_r
operator|.
name|base
operator|+
name|DNS_MESSAGE_HEADERLEN
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|msg
operator|->
name|sigstart
operator|-
name|DNS_MESSAGE_HEADERLEN
expr_stmt|;
name|RETERR
argument_list|(
name|dst_context_adddata
argument_list|(
name|ctx
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|sig_r
operator|.
name|base
operator|=
name|sig
operator|.
name|signature
expr_stmt|;
name|sig_r
operator|.
name|length
operator|=
name|sig
operator|.
name|siglen
expr_stmt|;
name|result
operator|=
name|dst_context_verify
argument_list|(
name|ctx
argument_list|,
operator|&
name|sig_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|msg
operator|->
name|sig0status
operator|=
name|dns_tsigerror_badsig
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|msg
operator|->
name|verified_sig
operator|=
literal|1
expr_stmt|;
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|dns_rdata_freestruct
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
if|if
condition|(
name|signeedsfree
condition|)
name|dns_rdata_freestruct
argument_list|(
operator|&
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
name|NULL
condition|)
name|dst_context_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Does this key ('rdata') self sign the rrset ('rdataset')?  */
end_comment

begin_function
name|isc_boolean_t
name|dns_dnssec_selfsigns
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_boolean_t
name|ignoretime
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|INSIST
argument_list|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_key
operator|||
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
name|dns_rdatatype_key
condition|)
block|{
name|INSIST
argument_list|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_sig
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sigrdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sigrdataset
operator|->
name|covers
operator|==
name|dns_rdatatype_dnskey
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dns_dnssec_signs
argument_list|(
name|rdata
argument_list|,
name|name
argument_list|,
name|rdataset
argument_list|,
name|sigrdataset
argument_list|,
name|ignoretime
argument_list|,
name|mctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_dnssec_signs
parameter_list|(
name|dns_rdata_t
modifier|*
name|rdata
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|,
name|isc_boolean_t
name|ignoretime
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
name|dns_keytag_t
name|keytag
decl_stmt|;
name|dns_rdata_dnskey_t
name|key
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_rdata_t
name|sigrdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|INSIST
argument_list|(
name|sigrdataset
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigrdataset
operator|->
name|covers
operator|!=
name|rdataset
operator|->
name|type
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_dnssec_keyfromrdata
argument_list|(
name|name
argument_list|,
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
name|rdata
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|keytag
operator|=
name|dst_key_id
argument_list|(
name|dstkey
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|sigrdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|sigrdataset
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|sigrdataset
argument_list|,
operator|&
name|sigrdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|sigrdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|algorithm
operator|==
name|key
operator|.
name|algorithm
operator|&&
name|sig
operator|.
name|keyid
operator|==
name|keytag
condition|)
block|{
name|result
operator|=
name|dns_dnssec_verify2
argument_list|(
name|name
argument_list|,
name|rdataset
argument_list|,
name|dstkey
argument_list|,
name|ignoretime
argument_list|,
name|mctx
argument_list|,
operator|&
name|sigrdata
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
block|}
block|}
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dnsseckey_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|dstkey
parameter_list|,
name|dns_dnsseckey_t
modifier|*
modifier|*
name|dkp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dnsseckey_t
modifier|*
name|dk
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|REQUIRE
argument_list|(
name|dkp
operator|!=
name|NULL
operator|&&
operator|*
name|dkp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dk
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dnsseckey_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dk
operator|->
name|key
operator|=
operator|*
name|dstkey
expr_stmt|;
operator|*
name|dstkey
operator|=
name|NULL
expr_stmt|;
name|dk
operator|->
name|force_publish
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|force_sign
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|hint_publish
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|hint_sign
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|hint_remove
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|first_sign
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|is_active
operator|=
name|ISC_FALSE
expr_stmt|;
name|dk
operator|->
name|prepublish
operator|=
literal|0
expr_stmt|;
name|dk
operator|->
name|source
operator|=
name|dns_keysource_unknown
expr_stmt|;
name|dk
operator|->
name|index
operator|=
literal|0
expr_stmt|;
comment|/* KSK or ZSK? */
name|dk
operator|->
name|ksk
operator|=
name|ISC_TF
argument_list|(
operator|(
name|dst_key_flags
argument_list|(
name|dk
operator|->
name|key
argument_list|)
operator|&
name|DNS_KEYFLAG_KSK
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Is this an old-style key? */
name|result
operator|=
name|dst_key_getprivateformat
argument_list|(
name|dk
operator|->
name|key
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Smart signing started with key format 1.3 */
name|dk
operator|->
name|legacy
operator|=
name|ISC_TF
argument_list|(
name|major
operator|==
literal|1
operator|&&
name|minor
operator|<=
literal|2
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|dk
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|dkp
operator|=
name|dk
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dnsseckey_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_dnsseckey_t
modifier|*
modifier|*
name|dkp
parameter_list|)
block|{
name|dns_dnsseckey_t
modifier|*
name|dk
decl_stmt|;
name|REQUIRE
argument_list|(
name|dkp
operator|!=
name|NULL
operator|&&
operator|*
name|dkp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dk
operator|=
operator|*
name|dkp
expr_stmt|;
if|if
condition|(
name|dk
operator|->
name|key
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|dk
operator|->
name|key
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|dk
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dnsseckey_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dkp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_hints
parameter_list|(
name|dns_dnsseckey_t
modifier|*
name|key
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_stdtime_t
name|publish
decl_stmt|,
name|active
decl_stmt|,
name|revoke
decl_stmt|,
name|inactive
decl_stmt|,
name|delete
decl_stmt|;
name|isc_boolean_t
name|pubset
init|=
name|ISC_FALSE
decl_stmt|,
name|actset
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|revset
init|=
name|ISC_FALSE
decl_stmt|,
name|inactset
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|delset
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|key
operator|!=
name|NULL
operator|&&
name|key
operator|->
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_PUBLISH
argument_list|,
operator|&
name|publish
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|pubset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_ACTIVATE
argument_list|,
operator|&
name|active
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|actset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_REVOKE
argument_list|,
operator|&
name|revoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|revset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_INACTIVE
argument_list|,
operator|&
name|inactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|inactset
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|dst_key_gettime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_DELETE
argument_list|,
operator|&
name|delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|delset
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Metadata says publish (but possibly not activate) */
if|if
condition|(
name|pubset
operator|&&
name|publish
operator|<=
name|now
condition|)
name|key
operator|->
name|hint_publish
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Metadata says activate (so we must also publish) */
if|if
condition|(
name|actset
operator|&&
name|active
operator|<=
name|now
condition|)
block|{
name|key
operator|->
name|hint_sign
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* Only publish if publish time has already passed. */
if|if
condition|(
name|pubset
operator|&&
name|publish
operator|<=
name|now
condition|)
name|key
operator|->
name|hint_publish
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * Activation date is set (maybe in the future), but 	 * publication date isn't. Most likely the user wants to 	 * publish now and activate later. 	 */
if|if
condition|(
name|actset
operator|&&
operator|!
name|pubset
condition|)
name|key
operator|->
name|hint_publish
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * If activation date is in the future, make note of how far off 	 */
if|if
condition|(
name|key
operator|->
name|hint_publish
operator|&&
name|actset
operator|&&
name|active
operator|>
name|now
condition|)
block|{
name|key
operator|->
name|prepublish
operator|=
name|active
operator|-
name|now
expr_stmt|;
block|}
comment|/* 	 * Key has been marked inactive: we can continue publishing, 	 * but don't sign. 	 */
if|if
condition|(
name|key
operator|->
name|hint_publish
operator|&&
name|inactset
operator|&&
name|inactive
operator|<=
name|now
condition|)
block|{
name|key
operator|->
name|hint_sign
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
comment|/* 	 * Metadata says revoke.  If the key is published, 	 * we *have to* sign with it per RFC5011--even if it was 	 * not active before. 	 * 	 * If it hasn't already been done, we should also revoke it now. 	 */
if|if
condition|(
name|key
operator|->
name|hint_publish
operator|&&
operator|(
name|revset
operator|&&
name|revoke
operator|<=
name|now
operator|)
condition|)
block|{
name|isc_uint32_t
name|flags
decl_stmt|;
name|key
operator|->
name|hint_sign
operator|=
name|ISC_TRUE
expr_stmt|;
name|flags
operator|=
name|dst_key_flags
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_KEYFLAG_REVOKE
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|DNS_KEYFLAG_REVOKE
expr_stmt|;
name|dst_key_setflags
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Metadata says delete, so don't publish this key or sign with it. 	 */
if|if
condition|(
name|delset
operator|&&
name|delete
operator|<=
name|now
condition|)
block|{
name|key
operator|->
name|hint_publish
operator|=
name|ISC_FALSE
expr_stmt|;
name|key
operator|->
name|hint_sign
operator|=
name|ISC_FALSE
expr_stmt|;
name|key
operator|->
name|hint_remove
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*%  * Get a list of DNSSEC keys from the key repository  */
end_comment

begin_function
name|isc_result_t
name|dns_dnssec_findmatchingkeys
parameter_list|(
name|dns_name_t
modifier|*
name|origin
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_dnsseckeylist_t
modifier|*
name|keylist
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|dir_open
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_dnsseckeylist_t
name|list
decl_stmt|;
name|isc_dir_t
name|dir
decl_stmt|;
name|dns_dnsseckey_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|dst_key_t
modifier|*
name|dstkey
init|=
name|NULL
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|REQUIRE
argument_list|(
name|keylist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|isc_dir_init
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_name_tofilenametext
argument_list|(
name|origin
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|isc_buffer_usedlength
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|namebuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
literal|"."
expr_stmt|;
name|RETERR
argument_list|(
name|isc_dir_open
argument_list|(
operator|&
name|dir
argument_list|,
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|dir_open
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
while|while
condition|(
name|isc_dir_read
argument_list|(
operator|&
name|dir
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|entry
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'K'
operator|||
name|dir
operator|.
name|entry
operator|.
name|length
operator|<
name|len
operator|+
literal|1
operator|||
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|len
operator|+
literal|1
index|]
operator|!=
literal|'+'
operator|||
name|strncasecmp
argument_list|(
name|dir
operator|.
name|entry
operator|.
name|name
operator|+
literal|1
argument_list|,
name|namebuf
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|len
operator|+
literal|1
operator|+
literal|1
init|;
name|i
operator|<
name|dir
operator|.
name|entry
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|len
operator|+
literal|1
operator|+
literal|1
operator|||
name|i
operator|>=
name|dir
operator|.
name|entry
operator|.
name|length
operator|||
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|i
index|]
operator|!=
literal|'+'
condition|)
continue|continue;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|dir
operator|.
name|entry
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|i
index|]
operator|<
literal|'0'
operator|||
name|dir
operator|.
name|entry
operator|.
name|name
index|[
name|i
index|]
operator|>
literal|'9'
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
operator|.
name|entry
operator|.
name|name
operator|+
name|i
argument_list|,
literal|".private"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|dstkey
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dst_key_fromnamedfile
argument_list|(
name|dir
operator|.
name|entry
operator|.
name|name
argument_list|,
name|directory
argument_list|,
name|DST_TYPE_PUBLIC
operator||
name|DST_TYPE_PRIVATE
argument_list|,
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_DNSSEC
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"dns_dnssec_findmatchingkeys: "
literal|"error reading key file %s: %s"
argument_list|,
name|dir
operator|.
name|entry
operator|.
name|name
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RETERR
argument_list|(
name|dns_dnsseckey_create
argument_list|(
name|mctx
argument_list|,
operator|&
name|dstkey
argument_list|,
operator|&
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|source
operator|=
name|dns_keysource_repository
expr_stmt|;
name|get_hints
argument_list|(
name|key
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|legacy
condition|)
block|{
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISC_LIST_APPEND
argument_list|(
name|list
argument_list|,
name|key
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|ISC_LIST_APPENDLIST
argument_list|(
operator|*
name|keylist
argument_list|,
name|list
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dir_open
condition|)
name|isc_dir_close
argument_list|(
operator|&
name|dir
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|key
operator|==
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|list
argument_list|,
name|key
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|key
operator|->
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dst_key_free
argument_list|(
operator|&
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dstkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|dstkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Add 'newkey' to 'keylist' if it's not already there.  *  * If 'savekeys' is ISC_TRUE, then we need to preserve all  * the keys in the keyset, regardless of whether they have  * metadata indicating they should be deactivated or removed.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|addkey
parameter_list|(
name|dns_dnsseckeylist_t
modifier|*
name|keylist
parameter_list|,
name|dst_key_t
modifier|*
modifier|*
name|newkey
parameter_list|,
name|isc_boolean_t
name|savekeys
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_dnsseckey_t
modifier|*
name|key
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* Skip duplicates */
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|keylist
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
operator|==
name|dst_key_id
argument_list|(
operator|*
name|newkey
argument_list|)
operator|&&
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
operator|==
name|dst_key_alg
argument_list|(
operator|*
name|newkey
argument_list|)
operator|&&
name|dns_name_equal
argument_list|(
name|dst_key_name
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|dst_key_name
argument_list|(
operator|*
name|newkey
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Found a match.  If the old key was only public and the 		 * new key is private, replace the old one; otherwise 		 * leave it.  But either way, mark the key as having 		 * been found in the zone. 		 */
if|if
condition|(
name|dst_key_isprivate
argument_list|(
name|key
operator|->
name|key
argument_list|)
condition|)
block|{
name|dst_key_free
argument_list|(
name|newkey
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dst_key_isprivate
argument_list|(
operator|*
name|newkey
argument_list|)
condition|)
block|{
name|dst_key_free
argument_list|(
operator|&
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|key
operator|->
name|key
operator|=
operator|*
name|newkey
expr_stmt|;
block|}
name|key
operator|->
name|source
operator|=
name|dns_keysource_zoneapex
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|result
operator|=
name|dns_dnsseckey_create
argument_list|(
name|mctx
argument_list|,
name|newkey
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|key
operator|->
name|legacy
operator|||
name|savekeys
condition|)
block|{
name|key
operator|->
name|force_publish
operator|=
name|ISC_TRUE
expr_stmt|;
name|key
operator|->
name|force_sign
operator|=
name|dst_key_isprivate
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|source
operator|=
name|dns_keysource_zoneapex
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|keylist
argument_list|,
name|key
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|newkey
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Mark all keys which signed the DNSKEY/SOA RRsets as "active",  * for future reference.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|mark_active_keys
parameter_list|(
name|dns_dnsseckeylist_t
modifier|*
name|keylist
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rrsigs
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_t
name|sigs
decl_stmt|;
name|dns_dnsseckey_t
modifier|*
name|key
decl_stmt|;
name|REQUIRE
argument_list|(
name|rrsigs
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|rrsigs
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|sigs
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|rrsigs
argument_list|,
operator|&
name|sigs
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|keylist
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_uint16_t
name|keyid
decl_stmt|,
name|sigid
decl_stmt|;
name|dns_secalg_t
name|keyalg
decl_stmt|,
name|sigalg
decl_stmt|;
name|keyid
operator|=
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|keyalg
operator|=
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|sigs
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|sigs
argument_list|)
control|)
block|{
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|sigs
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|sigalg
operator|=
name|sig
operator|.
name|algorithm
expr_stmt|;
name|sigid
operator|=
name|sig
operator|.
name|keyid
expr_stmt|;
if|if
condition|(
name|keyid
operator|==
name|sigid
operator|&&
name|keyalg
operator|==
name|sigalg
condition|)
block|{
name|key
operator|->
name|is_active
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|sigs
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|sigs
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Add the contents of a DNSKEY rdataset 'keyset' to 'keylist'.  */
end_comment

begin_function
name|isc_result_t
name|dns_dnssec_keylistfromrdataset
parameter_list|(
name|dns_name_t
modifier|*
name|origin
parameter_list|,
specifier|const
name|char
modifier|*
name|directory
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keyset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|keysigs
parameter_list|,
name|dns_rdataset_t
modifier|*
name|soasigs
parameter_list|,
name|isc_boolean_t
name|savekeys
parameter_list|,
name|isc_boolean_t
name|publickey
parameter_list|,
name|dns_dnsseckeylist_t
modifier|*
name|keylist
parameter_list|)
block|{
name|dns_rdataset_t
name|keys
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dst_key_t
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|,
modifier|*
name|privkey
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|keyset
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|keyset
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|keyset
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|keys
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|keys
argument_list|)
control|)
block|{
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|keys
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_dnssec_keyfromrdata
argument_list|(
name|origin
argument_list|,
operator|&
name|rdata
argument_list|,
name|mctx
argument_list|,
operator|&
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
name|dst_key_setttl
argument_list|(
name|pubkey
argument_list|,
name|keys
operator|.
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_zone_key
argument_list|(
name|pubkey
argument_list|)
operator|||
operator|(
name|dst_key_flags
argument_list|(
name|pubkey
argument_list|)
operator|&
name|DNS_KEYTYPE_NOAUTH
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|skip
goto|;
comment|/* Corrupted .key file? */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|origin
argument_list|,
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|)
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|publickey
condition|)
block|{
name|RETERR
argument_list|(
name|addkey
argument_list|(
name|keylist
argument_list|,
operator|&
name|pubkey
argument_list|,
name|savekeys
argument_list|,
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|result
operator|=
name|dst_key_fromfile
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|DST_TYPE_PUBLIC
operator||
name|DST_TYPE_PRIVATE
argument_list|,
name|directory
argument_list|,
name|mctx
argument_list|,
operator|&
name|privkey
argument_list|)
expr_stmt|;
comment|/* 		 * If the key was revoked and the private file 		 * doesn't exist, maybe it was revoked internally 		 * by named.  Try loading the unrevoked version. 		 */
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
block|{
name|isc_uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|dst_key_flags
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_KEYFLAG_REVOKE
operator|)
operator|!=
literal|0
condition|)
block|{
name|dst_key_setflags
argument_list|(
name|pubkey
argument_list|,
name|flags
operator|&
operator|~
name|DNS_KEYFLAG_REVOKE
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_fromfile
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|DST_TYPE_PUBLIC
operator||
name|DST_TYPE_PRIVATE
argument_list|,
name|directory
argument_list|,
name|mctx
argument_list|,
operator|&
name|privkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|dst_key_pubcompare
argument_list|(
name|pubkey
argument_list|,
name|privkey
argument_list|,
name|ISC_FALSE
argument_list|)
condition|)
block|{
name|dst_key_setflags
argument_list|(
name|privkey
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|dst_key_setflags
argument_list|(
name|pubkey
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|char
name|keybuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|algbuf
index|[
name|DNS_SECALG_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|dst_key_name
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|keybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_secalg_format
argument_list|(
name|dst_key_alg
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|algbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|algbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_DNSSEC
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"dns_dnssec_keylistfromrdataset: error "
literal|"reading private key file %s/%s/%d: %s"
argument_list|,
name|keybuf
argument_list|,
name|algbuf
argument_list|,
name|dst_key_id
argument_list|(
name|pubkey
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
operator|||
name|result
operator|==
name|ISC_R_NOPERM
condition|)
block|{
name|RETERR
argument_list|(
name|addkey
argument_list|(
name|keylist
argument_list|,
operator|&
name|pubkey
argument_list|,
name|savekeys
argument_list|,
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|RETERR
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* This should never happen. */
if|if
condition|(
operator|(
name|dst_key_flags
argument_list|(
name|privkey
argument_list|)
operator|&
name|DNS_KEYTYPE_NOAUTH
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|skip
goto|;
comment|/* 		 * Whatever the key's default TTL may have 		 * been, the rdataset TTL takes priority. 		 */
name|dst_key_setttl
argument_list|(
name|privkey
argument_list|,
name|dst_key_getttl
argument_list|(
name|pubkey
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|addkey
argument_list|(
name|keylist
argument_list|,
operator|&
name|privkey
argument_list|,
name|savekeys
argument_list|,
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
name|pubkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|privkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|privkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
name|RETERR
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|keysigs
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|keysigs
argument_list|)
condition|)
name|RETERR
argument_list|(
name|mark_active_keys
argument_list|(
name|keylist
argument_list|,
name|keysigs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|soasigs
operator|!=
name|NULL
operator|&&
name|dns_rdataset_isassociated
argument_list|(
name|soasigs
argument_list|)
condition|)
name|RETERR
argument_list|(
name|mark_active_keys
argument_list|(
name|keylist
argument_list|,
name|soasigs
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|dns_rdataset_isassociated
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|pubkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|privkey
operator|!=
name|NULL
condition|)
name|dst_key_free
argument_list|(
operator|&
name|privkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|make_dnskey
parameter_list|(
name|dst_key_t
modifier|*
name|key
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|dns_rdata_t
modifier|*
name|target
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|result
operator|=
name|dst_key_todns
argument_list|(
name|key
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|dns_rdata_reset
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_rdata_fromregion
argument_list|(
name|target
argument_list|,
name|dst_key_class
argument_list|(
name|key
argument_list|)
argument_list|,
name|dns_rdatatype_dnskey
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|publish_key
parameter_list|(
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_dnsseckey_t
modifier|*
name|key
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_boolean_t
name|allzsk
parameter_list|,
name|void
function_decl|(
modifier|*
name|report
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DST_KEY_MAXSIZE
index|]
decl_stmt|;
name|dns_rdata_t
name|dnskey
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|char
name|alg
index|[
literal|80
index|]
decl_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|dnskey
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|make_dnskey
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|dnskey
argument_list|)
argument_list|)
expr_stmt|;
name|dns_secalg_format
argument_list|(
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|alg
argument_list|,
sizeof|sizeof
argument_list|(
name|alg
argument_list|)
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"Fetching %s %d/%s from key %s."
argument_list|,
name|key
operator|->
name|ksk
condition|?
operator|(
name|allzsk
condition|?
literal|"KSK/ZSK"
else|:
literal|"KSK"
operator|)
else|:
literal|"ZSK"
argument_list|,
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|alg
argument_list|,
name|key
operator|->
name|source
operator|==
name|dns_keysource_user
condition|?
literal|"file"
else|:
literal|"repository"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|prepublish
operator|&&
name|ttl
operator|>
name|key
operator|->
name|prepublish
condition|)
block|{
name|char
name|keystr
index|[
name|DST_KEY_FORMATSIZE
index|]
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dst_key_format
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|keystr
argument_list|,
sizeof|sizeof
argument_list|(
name|keystr
argument_list|)
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"Key %s: Delaying activation to match the DNSKEY TTL.\n"
argument_list|,
name|keystr
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dst_key_settime
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|DST_TIME_ACTIVATE
argument_list|,
name|now
operator|+
name|ttl
argument_list|)
expr_stmt|;
block|}
comment|/* publish key */
name|RETERR
argument_list|(
name|dns_difftuple_create
argument_list|(
name|mctx
argument_list|,
name|DNS_DIFFOP_ADD
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
operator|&
name|dnskey
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_appendminimal
argument_list|(
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|remove_key
parameter_list|(
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|dns_dnsseckey_t
modifier|*
name|key
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_ttl_t
name|ttl
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|,
name|void
function_decl|(
modifier|*
name|report
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|DST_KEY_MAXSIZE
index|]
decl_stmt|;
name|dns_rdata_t
name|dnskey
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|char
name|alg
index|[
literal|80
index|]
decl_stmt|;
name|dns_secalg_format
argument_list|(
name|dst_key_alg
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|alg
argument_list|,
sizeof|sizeof
argument_list|(
name|alg
argument_list|)
argument_list|)
expr_stmt|;
name|report
argument_list|(
literal|"Removing %s key %d/%s from DNSKEY RRset."
argument_list|,
name|reason
argument_list|,
name|dst_key_id
argument_list|(
name|key
operator|->
name|key
argument_list|)
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|make_dnskey
argument_list|(
name|key
operator|->
name|key
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|dnskey
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_difftuple_create
argument_list|(
name|mctx
argument_list|,
name|DNS_DIFFOP_DEL
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
operator|&
name|dnskey
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_appendminimal
argument_list|(
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update 'keys' with information from 'newkeys'.  *  * If 'removed' is not NULL, any keys that are being removed from  * the zone will be added to the list for post-removal processing.  */
end_comment

begin_function
name|isc_result_t
name|dns_dnssec_updatekeys
parameter_list|(
name|dns_dnsseckeylist_t
modifier|*
name|keys
parameter_list|,
name|dns_dnsseckeylist_t
modifier|*
name|newkeys
parameter_list|,
name|dns_dnsseckeylist_t
modifier|*
name|removed
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_ttl_t
name|hint_ttl
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|,
name|isc_boolean_t
name|allzsk
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|report
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dnsseckey_t
modifier|*
name|key
decl_stmt|,
modifier|*
name|key1
decl_stmt|,
modifier|*
name|key2
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|isc_boolean_t
name|found_ttl
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_ttl_t
name|ttl
init|=
name|hint_ttl
decl_stmt|;
comment|/* 	 * First, look through the existing key list to find keys 	 * supplied from the command line which are not in the zone. 	 * Update the zone to include them. 	 * 	 * Also, if there are keys published in the zone already, 	 * use their TTL for all subsequent published keys. 	 */
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|keys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|key
operator|->
name|source
operator|==
name|dns_keysource_user
operator|&&
operator|(
name|key
operator|->
name|hint_publish
operator|||
name|key
operator|->
name|force_publish
operator|)
condition|)
block|{
name|RETERR
argument_list|(
name|publish_key
argument_list|(
name|diff
argument_list|,
name|key
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|mctx
argument_list|,
name|allzsk
argument_list|,
name|report
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|->
name|source
operator|==
name|dns_keysource_zoneapex
condition|)
block|{
name|ttl
operator|=
name|dst_key_getttl
argument_list|(
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|found_ttl
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
comment|/* 	 * If there were no existing keys, use the smallest nonzero 	 * TTL of the keys found in the repository. 	 */
if|if
condition|(
operator|!
name|found_ttl
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|newkeys
argument_list|)
condition|)
block|{
name|dns_ttl_t
name|shortest
init|=
literal|0
decl_stmt|;
for|for
control|(
name|key
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|newkeys
argument_list|)
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_ttl_t
name|thisttl
init|=
name|dst_key_getttl
argument_list|(
name|key
operator|->
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisttl
operator|!=
literal|0
operator|&&
operator|(
name|shortest
operator|==
literal|0
operator|||
name|thisttl
operator|<
name|shortest
operator|)
condition|)
name|shortest
operator|=
name|thisttl
expr_stmt|;
block|}
if|if
condition|(
name|shortest
operator|!=
literal|0
condition|)
name|ttl
operator|=
name|shortest
expr_stmt|;
block|}
comment|/* 	 * Second, scan the list of newly found keys looking for matches 	 * with known keys, and update accordingly. 	 */
for|for
control|(
name|key1
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|newkeys
argument_list|)
init|;
name|key1
operator|!=
name|NULL
condition|;
name|key1
operator|=
name|next
control|)
block|{
name|isc_boolean_t
name|key_revoked
init|=
name|ISC_FALSE
decl_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|key2
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|keys
argument_list|)
init|;
name|key2
operator|!=
name|NULL
condition|;
name|key2
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|key2
argument_list|,
name|link
argument_list|)
control|)
block|{
name|int
name|f1
init|=
name|dst_key_flags
argument_list|(
name|key1
operator|->
name|key
argument_list|)
decl_stmt|;
name|int
name|f2
init|=
name|dst_key_flags
argument_list|(
name|key2
operator|->
name|key
argument_list|)
decl_stmt|;
name|int
name|nr1
init|=
name|f1
operator|&
operator|~
name|DNS_KEYFLAG_REVOKE
decl_stmt|;
name|int
name|nr2
init|=
name|f2
operator|&
operator|~
name|DNS_KEYFLAG_REVOKE
decl_stmt|;
if|if
condition|(
name|nr1
operator|==
name|nr2
operator|&&
name|dst_key_alg
argument_list|(
name|key1
operator|->
name|key
argument_list|)
operator|==
name|dst_key_alg
argument_list|(
name|key2
operator|->
name|key
argument_list|)
operator|&&
name|dst_key_pubcompare
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|key2
operator|->
name|key
argument_list|,
name|ISC_TRUE
argument_list|)
condition|)
block|{
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|r1
operator|=
name|dst_key_flags
argument_list|(
name|key1
operator|->
name|key
argument_list|)
operator|&
name|DNS_KEYFLAG_REVOKE
expr_stmt|;
name|r2
operator|=
name|dst_key_flags
argument_list|(
name|key2
operator|->
name|key
argument_list|)
operator|&
name|DNS_KEYFLAG_REVOKE
expr_stmt|;
name|key_revoked
operator|=
name|ISC_TF
argument_list|(
name|r1
operator|!=
name|r2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* No match found in keys; add the new key. */
if|if
condition|(
name|key2
operator|==
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|newkeys
argument_list|,
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|keys
argument_list|,
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|key1
operator|->
name|source
operator|!=
name|dns_keysource_zoneapex
operator|&&
operator|(
name|key1
operator|->
name|hint_publish
operator|||
name|key1
operator|->
name|force_publish
operator|)
condition|)
block|{
name|RETERR
argument_list|(
name|publish_key
argument_list|(
name|diff
argument_list|,
name|key1
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|mctx
argument_list|,
name|allzsk
argument_list|,
name|report
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key1
operator|->
name|hint_sign
operator|||
name|key1
operator|->
name|force_sign
condition|)
name|key1
operator|->
name|first_sign
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Match found: remove or update it as needed */
if|if
condition|(
name|key1
operator|->
name|hint_remove
condition|)
block|{
name|RETERR
argument_list|(
name|remove_key
argument_list|(
name|diff
argument_list|,
name|key2
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|mctx
argument_list|,
literal|"expired"
argument_list|,
name|report
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|keys
argument_list|,
name|key2
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|!=
name|NULL
condition|)
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|removed
argument_list|,
name|key2
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key_revoked
operator|&&
operator|(
name|dst_key_flags
argument_list|(
name|key1
operator|->
name|key
argument_list|)
operator|&
name|DNS_KEYFLAG_REVOKE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A previously valid key has been revoked. 			 * We need to remove the old version and pull 			 * in the new one. 			 */
name|RETERR
argument_list|(
name|remove_key
argument_list|(
name|diff
argument_list|,
name|key2
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|mctx
argument_list|,
literal|"revoked"
argument_list|,
name|report
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|keys
argument_list|,
name|key2
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|!=
name|NULL
condition|)
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|removed
argument_list|,
name|key2
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key2
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|publish_key
argument_list|(
name|diff
argument_list|,
name|key1
argument_list|,
name|origin
argument_list|,
name|ttl
argument_list|,
name|mctx
argument_list|,
name|allzsk
argument_list|,
name|report
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|newkeys
argument_list|,
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|keys
argument_list|,
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 			 * XXX: The revoke flag is only defined for trust 			 * anchors.  Setting the flag on a non-KSK is legal, 			 * but not defined in any RFC.  It seems reasonable 			 * to treat it the same as a KSK: keep it in the 			 * zone, sign the DNSKEY set with it, but not 			 * sign other records with it. 			 */
name|key1
operator|->
name|ksk
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|key2
operator|->
name|is_active
operator|&&
operator|(
name|key1
operator|->
name|hint_sign
operator|||
name|key1
operator|->
name|force_sign
operator|)
condition|)
name|key2
operator|->
name|first_sign
operator|=
name|ISC_TRUE
expr_stmt|;
name|key2
operator|->
name|hint_sign
operator|=
name|key1
operator|->
name|hint_sign
expr_stmt|;
name|key2
operator|->
name|hint_publish
operator|=
name|key1
operator|->
name|hint_publish
expr_stmt|;
block|}
block|}
comment|/* Free any leftover keys in newkeys */
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|newkeys
argument_list|)
condition|)
block|{
name|key1
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|newkeys
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|newkeys
argument_list|,
name|key1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_dnsseckey_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|key1
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

