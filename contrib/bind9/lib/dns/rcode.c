begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: rcode.c,v 1.1.4.1 2004/03/12 10:31:25 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/parseint.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/types.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/cert.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyflags.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyvalues.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/secalg.h>
end_include

begin_include
include|#
directive|include
file|<dns/secproto.h>
end_include

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		isc_result_t _r = (x); \ 		if (_r != ISC_R_SUCCESS) \ 			return (_r); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|NUMBERSIZE
value|sizeof("037777777777")
end_define

begin_comment
comment|/* 2^32-1 octal + NUL */
end_comment

begin_define
define|#
directive|define
name|RCODENAMES
define|\
comment|/* standard rcodes */
define|\
value|{ dns_rcode_noerror, "NOERROR", 0}, \ 	{ dns_rcode_formerr, "FORMERR", 0}, \ 	{ dns_rcode_servfail, "SERVFAIL", 0}, \ 	{ dns_rcode_nxdomain, "NXDOMAIN", 0}, \ 	{ dns_rcode_notimp, "NOTIMP", 0}, \ 	{ dns_rcode_refused, "REFUSED", 0}, \ 	{ dns_rcode_yxdomain, "YXDOMAIN", 0}, \ 	{ dns_rcode_yxrrset, "YXRRSET", 0}, \ 	{ dns_rcode_nxrrset, "NXRRSET", 0}, \ 	{ dns_rcode_notauth, "NOTAUTH", 0}, \ 	{ dns_rcode_notzone, "NOTZONE", 0},
end_define

begin_define
define|#
directive|define
name|ERCODENAMES
define|\
comment|/* extended rcodes */
define|\
value|{ dns_rcode_badvers, "BADVERS", 0}, \ 	{ 0, NULL, 0 }
end_define

begin_define
define|#
directive|define
name|TSIGRCODENAMES
define|\
comment|/* extended rcodes */
define|\
value|{ dns_tsigerror_badsig, "BADSIG", 0}, \ 	{ dns_tsigerror_badkey, "BADKEY", 0}, \ 	{ dns_tsigerror_badtime, "BADTIME", 0}, \ 	{ dns_tsigerror_badmode, "BADMODE", 0}, \ 	{ dns_tsigerror_badname, "BADNAME", 0}, \ 	{ dns_tsigerror_badalg, "BADALG", 0}, \ 	{ 0, NULL, 0 }
end_define

begin_comment
comment|/* RFC2538 section 2.1 */
end_comment

begin_define
define|#
directive|define
name|CERTNAMES
define|\
value|{ 1, "PKIX", 0}, \ 	{ 2, "SPKI", 0}, \ 	{ 3, "PGP", 0}, \ 	{ 253, "URI", 0}, \ 	{ 254, "OID", 0}, \ 	{ 0, NULL, 0}
end_define

begin_comment
comment|/* RFC2535 section 7, RFC3110 */
end_comment

begin_define
define|#
directive|define
name|SECALGNAMES
define|\
value|{ DNS_KEYALG_RSAMD5, "RSAMD5", 0 }, \ 	{ DNS_KEYALG_RSAMD5, "RSA", 0 }, \ 	{ DNS_KEYALG_DH, "DH", 0 }, \ 	{ DNS_KEYALG_DSA, "DSA", 0 }, \ 	{ DNS_KEYALG_ECC, "ECC", 0 }, \ 	{ DNS_KEYALG_RSASHA1, "RSASHA1", 0 }, \ 	{ DNS_KEYALG_INDIRECT, "INDIRECT", 0 }, \ 	{ DNS_KEYALG_PRIVATEDNS, "PRIVATEDNS", 0 }, \ 	{ DNS_KEYALG_PRIVATEOID, "PRIVATEOID", 0 }, \ 	{ 0, NULL, 0}
end_define

begin_comment
comment|/* RFC2535 section 7.1 */
end_comment

begin_define
define|#
directive|define
name|SECPROTONAMES
define|\
value|{   0,    "NONE", 0 }, \ 	{   1,    "TLS", 0 }, \ 	{   2,    "EMAIL", 0 }, \ 	{   3,    "DNSSEC", 0 }, \ 	{   4,    "IPSEC", 0 }, \ 	{ 255,    "ALL", 0 }, \ 	{ 0, NULL, 0}
end_define

begin_struct
struct|struct
name|tbl
block|{
name|unsigned
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tbl
name|rcodes
index|[]
init|=
block|{
name|RCODENAMES
name|ERCODENAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tbl
name|tsigrcodes
index|[]
init|=
block|{
name|RCODENAMES
name|TSIGRCODENAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tbl
name|certs
index|[]
init|=
block|{
name|CERTNAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tbl
name|secalgs
index|[]
init|=
block|{
name|SECALGNAMES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tbl
name|secprotos
index|[]
init|=
block|{
name|SECPROTONAMES
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|keyflag
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
block|}
name|keyflags
index|[]
init|=
block|{
block|{
literal|"NOCONF"
block|,
literal|0x4000
block|,
literal|0xC000
block|}
block|,
block|{
literal|"NOAUTH"
block|,
literal|0x8000
block|,
literal|0xC000
block|}
block|,
block|{
literal|"NOKEY"
block|,
literal|0xC000
block|,
literal|0xC000
block|}
block|,
block|{
literal|"FLAG2"
block|,
literal|0x2000
block|,
literal|0x2000
block|}
block|,
block|{
literal|"EXTEND"
block|,
literal|0x1000
block|,
literal|0x1000
block|}
block|,
block|{
literal|"FLAG4"
block|,
literal|0x0800
block|,
literal|0x0800
block|}
block|,
block|{
literal|"FLAG5"
block|,
literal|0x0400
block|,
literal|0x0400
block|}
block|,
block|{
literal|"USER"
block|,
literal|0x0000
block|,
literal|0x0300
block|}
block|,
block|{
literal|"ZONE"
block|,
literal|0x0100
block|,
literal|0x0300
block|}
block|,
block|{
literal|"HOST"
block|,
literal|0x0200
block|,
literal|0x0300
block|}
block|,
block|{
literal|"NTYP3"
block|,
literal|0x0300
block|,
literal|0x0300
block|}
block|,
block|{
literal|"FLAG8"
block|,
literal|0x0080
block|,
literal|0x0080
block|}
block|,
block|{
literal|"FLAG9"
block|,
literal|0x0040
block|,
literal|0x0040
block|}
block|,
block|{
literal|"FLAG10"
block|,
literal|0x0020
block|,
literal|0x0020
block|}
block|,
block|{
literal|"FLAG11"
block|,
literal|0x0010
block|,
literal|0x0010
block|}
block|,
block|{
literal|"SIG0"
block|,
literal|0x0000
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG1"
block|,
literal|0x0001
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG2"
block|,
literal|0x0002
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG3"
block|,
literal|0x0003
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG4"
block|,
literal|0x0004
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG5"
block|,
literal|0x0005
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG6"
block|,
literal|0x0006
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG7"
block|,
literal|0x0007
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG8"
block|,
literal|0x0008
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG9"
block|,
literal|0x0009
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG10"
block|,
literal|0x000A
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG11"
block|,
literal|0x000B
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG12"
block|,
literal|0x000C
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG13"
block|,
literal|0x000D
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG14"
block|,
literal|0x000E
block|,
literal|0x000F
block|}
block|,
block|{
literal|"SIG15"
block|,
literal|0x000F
block|,
literal|0x000F
block|}
block|,
block|{
literal|"KSK"
block|,
name|DNS_KEYFLAG_KSK
block|,
name|DNS_KEYFLAG_KSK
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|isc_result_t
name|str_totext
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|int
name|l
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|region
operator|.
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
name|region
operator|.
name|base
argument_list|,
name|source
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|maybe_numeric
parameter_list|(
name|unsigned
name|int
modifier|*
name|valuep
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|,
name|isc_boolean_t
name|hex_allowed
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|n
decl_stmt|;
name|char
name|buffer
index|[
name|NUMBERSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|source
operator|->
name|base
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
operator|||
name|source
operator|->
name|length
operator|>
name|NUMBERSIZE
operator|-
literal|1
condition|)
return|return
operator|(
name|ISC_R_BADNUMBER
operator|)
return|;
comment|/* 	 * We have a potential number.  Try to parse it with 	 * isc_parse_uint32().  isc_parse_uint32() requires 	 * null termination, so we must make a copy. 	 */
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|source
operator|->
name|base
argument_list|,
name|NUMBERSIZE
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|buffer
index|[
name|source
operator|->
name|length
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_parse_uint32
argument_list|(
operator|&
name|n
argument_list|,
name|buffer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_BADNUMBER
operator|&&
name|hex_allowed
condition|)
name|result
operator|=
name|isc_parse_uint32
argument_list|(
operator|&
name|n
argument_list|,
name|buffer
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|n
operator|>
name|max
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
operator|*
name|valuep
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_mnemonic_fromtext
parameter_list|(
name|unsigned
name|int
modifier|*
name|valuep
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|struct
name|tbl
modifier|*
name|table
parameter_list|,
name|unsigned
name|int
name|max
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
name|result
operator|=
name|maybe_numeric
argument_list|(
name|valuep
argument_list|,
name|source
argument_list|,
name|max
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_BADNUMBER
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|source
operator|->
name|length
operator|&&
name|strncasecmp
argument_list|(
name|source
operator|->
name|base
argument_list|,
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|valuep
operator|=
name|table
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|DNS_R_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_mnemonic_totext
parameter_list|(
name|unsigned
name|int
name|value
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|,
name|struct
name|tbl
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"4294967296"
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|value
operator|==
name|value
condition|)
block|{
return|return
operator|(
name|str_totext
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|str_totext
argument_list|(
name|buf
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rcode_fromtext
parameter_list|(
name|dns_rcode_t
modifier|*
name|rcodep
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|value
decl_stmt|;
name|RETERR
argument_list|(
name|dns_mnemonic_fromtext
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
name|rcodes
argument_list|,
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rcode_totext
parameter_list|(
name|dns_rcode_t
name|rcode
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_mnemonic_totext
argument_list|(
name|rcode
argument_list|,
name|target
argument_list|,
name|rcodes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_tsigrcode_fromtext
parameter_list|(
name|dns_rcode_t
modifier|*
name|rcodep
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|value
decl_stmt|;
name|RETERR
argument_list|(
name|dns_mnemonic_fromtext
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
name|tsigrcodes
argument_list|,
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_tsigrcode_totext
parameter_list|(
name|dns_rcode_t
name|rcode
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_mnemonic_totext
argument_list|(
name|rcode
argument_list|,
name|target
argument_list|,
name|tsigrcodes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cert_fromtext
parameter_list|(
name|dns_cert_t
modifier|*
name|certp
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|value
decl_stmt|;
name|RETERR
argument_list|(
name|dns_mnemonic_fromtext
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
name|certs
argument_list|,
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|certp
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_cert_totext
parameter_list|(
name|dns_cert_t
name|cert
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_mnemonic_totext
argument_list|(
name|cert
argument_list|,
name|target
argument_list|,
name|certs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_secalg_fromtext
parameter_list|(
name|dns_secalg_t
modifier|*
name|secalgp
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|value
decl_stmt|;
name|RETERR
argument_list|(
name|dns_mnemonic_fromtext
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
name|secalgs
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|secalgp
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_secalg_totext
parameter_list|(
name|dns_secalg_t
name|secalg
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_mnemonic_totext
argument_list|(
name|secalg
argument_list|,
name|target
argument_list|,
name|secalgs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_secproto_fromtext
parameter_list|(
name|dns_secproto_t
modifier|*
name|secprotop
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|unsigned
name|int
name|value
decl_stmt|;
name|RETERR
argument_list|(
name|dns_mnemonic_fromtext
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
name|secprotos
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|secprotop
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_secproto_totext
parameter_list|(
name|dns_secproto_t
name|secproto
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
return|return
operator|(
name|dns_mnemonic_totext
argument_list|(
name|secproto
argument_list|,
name|target
argument_list|,
name|secprotos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_keyflags_fromtext
parameter_list|(
name|dns_keyflags_t
modifier|*
name|flagsp
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|,
name|mask
decl_stmt|;
name|result
operator|=
name|maybe_numeric
argument_list|(
operator|&
name|value
argument_list|,
name|source
argument_list|,
literal|0xffff
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|flagsp
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_BADNUMBER
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|text
operator|=
name|source
operator|->
name|base
expr_stmt|;
name|end
operator|=
name|source
operator|->
name|base
operator|+
name|source
operator|->
name|length
expr_stmt|;
name|value
operator|=
name|mask
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|text
operator|<
name|end
condition|)
block|{
name|struct
name|keyflag
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|delim
init|=
name|memchr
argument_list|(
name|text
argument_list|,
literal|'|'
argument_list|,
name|end
operator|-
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|delim
operator|!=
name|NULL
condition|)
name|len
operator|=
name|delim
operator|-
name|text
expr_stmt|;
else|else
name|len
operator|=
name|end
operator|-
name|text
expr_stmt|;
for|for
control|(
name|p
operator|=
name|keyflags
init|;
name|p
operator|->
name|name
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_R_UNKNOWNFLAG
operator|)
return|;
name|value
operator||=
name|p
operator|->
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|mask
operator|&
name|p
operator|->
name|mask
operator|)
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"overlapping key flags"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mask
operator||=
name|p
operator|->
name|mask
expr_stmt|;
name|text
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|delim
operator|!=
name|NULL
condition|)
name|text
operator|++
expr_stmt|;
comment|/* Skip "|" */
block|}
operator|*
name|flagsp
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This uses lots of hard coded values, but how often do we actually  * add classes?  */
end_comment

begin_function
name|isc_result_t
name|dns_rdataclass_fromtext
parameter_list|(
name|dns_rdataclass_t
modifier|*
name|classp
parameter_list|,
name|isc_textregion_t
modifier|*
name|source
parameter_list|)
block|{
define|#
directive|define
name|COMPARE
parameter_list|(
name|string
parameter_list|,
name|rdclass
parameter_list|)
define|\
value|if (((sizeof(string) - 1) == source->length) \&& (strncasecmp(source->base, string, source->length) == 0)) { \ 		*classp = rdclass; \ 		return (ISC_R_SUCCESS); \ 	}
switch|switch
condition|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|source
operator|->
name|base
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|COMPARE
argument_list|(
literal|"any"
argument_list|,
name|dns_rdataclass_any
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* 		 * RFC1035 says the mnemonic for the CHAOS class is CH, 		 * but historical BIND practice is to call it CHAOS. 		 * We will accept both forms, but only generate CH. 		 */
name|COMPARE
argument_list|(
literal|"ch"
argument_list|,
name|dns_rdataclass_chaos
argument_list|)
expr_stmt|;
name|COMPARE
argument_list|(
literal|"chaos"
argument_list|,
name|dns_rdataclass_chaos
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|length
operator|>
literal|5
operator|&&
name|source
operator|->
name|length
operator|<
operator|(
literal|5
operator|+
sizeof|sizeof
argument_list|(
literal|"65000"
argument_list|)
operator|)
operator|&&
name|strncasecmp
argument_list|(
literal|"class"
argument_list|,
name|source
operator|->
name|base
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"65000"
argument_list|)
index|]
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|source
operator|->
name|base
operator|+
literal|5
argument_list|,
name|source
operator|->
name|length
operator|-
literal|5
argument_list|)
expr_stmt|;
name|buf
index|[
name|source
operator|->
name|length
operator|-
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'\0'
operator|&&
name|val
operator|<=
literal|0xffff
condition|)
block|{
operator|*
name|classp
operator|=
operator|(
name|dns_rdataclass_t
operator|)
name|val
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
name|COMPARE
argument_list|(
literal|"hs"
argument_list|,
name|dns_rdataclass_hs
argument_list|)
expr_stmt|;
name|COMPARE
argument_list|(
literal|"hesiod"
argument_list|,
name|dns_rdataclass_hs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|COMPARE
argument_list|(
literal|"in"
argument_list|,
name|dns_rdataclass_in
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|COMPARE
argument_list|(
literal|"none"
argument_list|,
name|dns_rdataclass_none
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|COMPARE
argument_list|(
literal|"reserved0"
argument_list|,
name|dns_rdataclass_reserved0
argument_list|)
expr_stmt|;
break|break;
block|}
undef|#
directive|undef
name|COMPARE
return|return
operator|(
name|DNS_R_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataclass_totext
parameter_list|(
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"CLASS65535"
argument_list|)
index|]
decl_stmt|;
switch|switch
condition|(
name|rdclass
condition|)
block|{
case|case
name|dns_rdataclass_any
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"ANY"
argument_list|,
name|target
argument_list|)
operator|)
return|;
case|case
name|dns_rdataclass_chaos
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"CH"
argument_list|,
name|target
argument_list|)
operator|)
return|;
case|case
name|dns_rdataclass_hs
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"HS"
argument_list|,
name|target
argument_list|)
operator|)
return|;
case|case
name|dns_rdataclass_in
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"IN"
argument_list|,
name|target
argument_list|)
operator|)
return|;
case|case
name|dns_rdataclass_none
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"NONE"
argument_list|,
name|target
argument_list|)
operator|)
return|;
case|case
name|dns_rdataclass_reserved0
case|:
return|return
operator|(
name|str_totext
argument_list|(
literal|"RESERVED0"
argument_list|,
name|target
argument_list|)
operator|)
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"CLASS%u"
argument_list|,
name|rdclass
argument_list|)
expr_stmt|;
return|return
operator|(
name|str_totext
argument_list|(
name|buf
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|dns_rdataclass_format
parameter_list|(
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|char
modifier|*
name|array
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buf
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|array
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataclass_totext
argument_list|(
name|rdclass
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* 	 * Null terminate. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buf
argument_list|)
operator|>=
literal|1
condition|)
name|isc_buffer_putuint8
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|snprintf
argument_list|(
name|array
argument_list|,
name|size
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|array
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

end_unit

