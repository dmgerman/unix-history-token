begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2001  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: ttl.c,v 1.21.12.5 2004/03/08 09:04:32 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/parseint.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/ttl.h>
end_include

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|x
parameter_list|)
value|do { \ 	isc_result_t _r = (x); \ 	if (_r != ISC_R_SUCCESS) \ 		return (_r); \ 	} while (0)
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|bind_ttl
parameter_list|(
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helper for dns_ttl_totext().  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|ttlfmt
parameter_list|(
name|unsigned
name|int
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|isc_boolean_t
name|verbose
parameter_list|,
name|isc_boolean_t
name|space
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|60
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|len
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%s%u %s%s"
argument_list|,
name|space
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|t
argument_list|,
name|s
argument_list|,
name|t
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%u%c"
argument_list|,
name|t
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|len
operator|+
literal|1
operator|<=
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|region
operator|.
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
name|region
operator|.
name|base
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Derived from bind8 ns_format_ttl().  */
end_comment

begin_function
name|isc_result_t
name|dns_ttl_totext
parameter_list|(
name|isc_uint32_t
name|src
parameter_list|,
name|isc_boolean_t
name|verbose
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|secs
decl_stmt|,
name|mins
decl_stmt|,
name|hours
decl_stmt|,
name|days
decl_stmt|,
name|weeks
decl_stmt|,
name|x
decl_stmt|;
name|secs
operator|=
name|src
operator|%
literal|60
expr_stmt|;
name|src
operator|/=
literal|60
expr_stmt|;
name|mins
operator|=
name|src
operator|%
literal|60
expr_stmt|;
name|src
operator|/=
literal|60
expr_stmt|;
name|hours
operator|=
name|src
operator|%
literal|24
expr_stmt|;
name|src
operator|/=
literal|24
expr_stmt|;
name|days
operator|=
name|src
operator|%
literal|7
expr_stmt|;
name|src
operator|/=
literal|7
expr_stmt|;
name|weeks
operator|=
name|src
expr_stmt|;
name|src
operator|=
literal|0
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|weeks
operator|!=
literal|0
condition|)
block|{
name|RETERR
argument_list|(
name|ttlfmt
argument_list|(
name|weeks
argument_list|,
literal|"week"
argument_list|,
name|verbose
argument_list|,
name|ISC_TF
argument_list|(
name|x
operator|>
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|days
operator|!=
literal|0
condition|)
block|{
name|RETERR
argument_list|(
name|ttlfmt
argument_list|(
name|days
argument_list|,
literal|"day"
argument_list|,
name|verbose
argument_list|,
name|ISC_TF
argument_list|(
name|x
operator|>
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hours
operator|!=
literal|0
condition|)
block|{
name|RETERR
argument_list|(
name|ttlfmt
argument_list|(
name|hours
argument_list|,
literal|"hour"
argument_list|,
name|verbose
argument_list|,
name|ISC_TF
argument_list|(
name|x
operator|>
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mins
operator|!=
literal|0
condition|)
block|{
name|RETERR
argument_list|(
name|ttlfmt
argument_list|(
name|mins
argument_list|,
literal|"minute"
argument_list|,
name|verbose
argument_list|,
name|ISC_TF
argument_list|(
name|x
operator|>
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|secs
operator|!=
literal|0
operator|||
operator|(
name|weeks
operator|==
literal|0
operator|&&
name|days
operator|==
literal|0
operator|&&
name|hours
operator|==
literal|0
operator|&&
name|mins
operator|==
literal|0
operator|)
condition|)
block|{
name|RETERR
argument_list|(
name|ttlfmt
argument_list|(
name|secs
argument_list|,
literal|"second"
argument_list|,
name|verbose
argument_list|,
name|ISC_TF
argument_list|(
name|x
operator|>
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|++
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|x
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If only a single unit letter is printed, print it 	 * in upper case. (Why?  Because BIND 8 does that. 	 * Presumably it has a reason.) 	 */
if|if
condition|(
name|x
operator|==
literal|1
operator|&&
operator|!
name|verbose
condition|)
block|{
name|isc_region_t
name|region
decl_stmt|;
comment|/* 		 * The unit letter is the last character in the 		 * used region of the buffer. 		 * 		 * toupper() does not need its argument to be masked of cast 		 * here because region.base is type unsigned char *. 		 */
name|isc_buffer_usedregion
argument_list|(
name|target
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|region
operator|.
name|base
index|[
name|region
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|toupper
argument_list|(
name|region
operator|.
name|base
index|[
name|region
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_counter_fromtext
parameter_list|(
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|)
block|{
return|return
operator|(
name|bind_ttl
argument_list|(
name|source
argument_list|,
name|ttl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_ttl_fromtext
parameter_list|(
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|bind_ttl
argument_list|(
name|source
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_BADTTL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|bind_ttl
parameter_list|(
name|isc_textregion_t
modifier|*
name|source
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|)
block|{
name|isc_uint32_t
name|tmp
init|=
literal|0
decl_stmt|;
name|isc_uint32_t
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|char
name|nbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* Number buffer */
comment|/* 	 * Copy the buffer as it may not be NULL terminated. 	 * No legal counter / ttl is longer that 63 characters. 	 */
if|if
condition|(
name|source
operator|->
name|length
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
condition|)
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|source
operator|->
name|base
argument_list|,
name|source
operator|->
name|length
argument_list|)
expr_stmt|;
name|buf
index|[
name|source
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
do|do
block|{
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|np
init|=
name|nbuf
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|np
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|INSIST
argument_list|(
name|np
operator|-
name|nbuf
operator|<=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_parse_uint32
argument_list|(
operator|&
name|n
argument_list|,
name|nbuf
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|tmp
operator|+=
name|n
operator|*
literal|7
operator|*
literal|24
operator|*
literal|3600
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|tmp
operator|+=
name|n
operator|*
literal|24
operator|*
literal|3600
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|tmp
operator|+=
name|n
operator|*
literal|3600
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|tmp
operator|+=
name|n
operator|*
literal|60
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|tmp
operator|+=
name|n
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* Plain number? */
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
name|tmp
operator|=
name|n
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|ttl
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

