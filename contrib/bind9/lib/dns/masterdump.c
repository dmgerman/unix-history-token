begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2006, 2008  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: masterdump.c,v 1.56.2.5.2.17 2008/08/13 23:45:33 tbox Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/masterdump.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/time.h>
end_include

begin_include
include|#
directive|include
file|<dns/ttl.h>
end_include

begin_define
define|#
directive|define
name|DNS_DCTX_MAGIC
value|ISC_MAGIC('D', 'c', 't', 'x')
end_define

begin_define
define|#
directive|define
name|DNS_DCTX_VALID
parameter_list|(
name|d
parameter_list|)
value|ISC_MAGIC_VALID(d, DNS_DCTX_MAGIC)
end_define

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|x
parameter_list|)
value|do { \ 	isc_result_t _r = (x); \ 	if (_r != ISC_R_SUCCESS) \ 		return (_r); \ 	} while (0)
end_define

begin_struct
struct|struct
name|dns_master_style
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
comment|/* DNS_STYLEFLAG_* */
name|unsigned
name|int
name|ttl_column
decl_stmt|;
name|unsigned
name|int
name|class_column
decl_stmt|;
name|unsigned
name|int
name|type_column
decl_stmt|;
name|unsigned
name|int
name|rdata_column
decl_stmt|;
name|unsigned
name|int
name|line_length
decl_stmt|;
name|unsigned
name|int
name|tab_width
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The maximum length of the newline+indentation that is output  * when inserting a line break in an RR.  This effectively puts an  * upper limits on the value of "rdata_column", because if it is  * very large, the tabs and spaces needed to reach it will not fit.  */
end_comment

begin_define
define|#
directive|define
name|DNS_TOTEXT_LINEBREAK_MAXLEN
value|100
end_define

begin_comment
comment|/*  * Context structure for a masterfile dump in progress.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dns_totext_ctx
block|{
name|dns_master_style_t
name|style
decl_stmt|;
name|isc_boolean_t
name|class_printed
decl_stmt|;
name|char
modifier|*
name|linebreak
decl_stmt|;
name|char
name|linebreak_buf
index|[
name|DNS_TOTEXT_LINEBREAK_MAXLEN
index|]
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
modifier|*
name|neworigin
decl_stmt|;
name|dns_fixedname_t
name|origin_fixname
decl_stmt|;
name|isc_uint32_t
name|current_ttl
decl_stmt|;
name|isc_boolean_t
name|current_ttl_valid
decl_stmt|;
block|}
name|dns_totext_ctx_t
typedef|;
end_typedef

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_default
init|=
block|{
name|DNS_STYLEFLAG_OMIT_OWNER
operator||
name|DNS_STYLEFLAG_OMIT_CLASS
operator||
name|DNS_STYLEFLAG_REL_OWNER
operator||
name|DNS_STYLEFLAG_REL_DATA
operator||
name|DNS_STYLEFLAG_OMIT_TTL
operator||
name|DNS_STYLEFLAG_TTL
operator||
name|DNS_STYLEFLAG_COMMENT
operator||
name|DNS_STYLEFLAG_MULTILINE
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|32
block|,
literal|80
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_full
init|=
block|{
name|DNS_STYLEFLAG_COMMENT
block|,
literal|46
block|,
literal|46
block|,
literal|46
block|,
literal|64
block|,
literal|120
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_explicitttl
init|=
block|{
name|DNS_STYLEFLAG_OMIT_OWNER
operator||
name|DNS_STYLEFLAG_OMIT_CLASS
operator||
name|DNS_STYLEFLAG_REL_OWNER
operator||
name|DNS_STYLEFLAG_REL_DATA
operator||
name|DNS_STYLEFLAG_COMMENT
operator||
name|DNS_STYLEFLAG_MULTILINE
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|40
block|,
literal|80
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_cache
init|=
block|{
name|DNS_STYLEFLAG_OMIT_OWNER
operator||
name|DNS_STYLEFLAG_OMIT_CLASS
operator||
name|DNS_STYLEFLAG_MULTILINE
operator||
name|DNS_STYLEFLAG_TRUST
operator||
name|DNS_STYLEFLAG_NCACHE
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|40
block|,
literal|80
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_simple
init|=
block|{
literal|0
block|,
literal|24
block|,
literal|32
block|,
literal|32
block|,
literal|40
block|,
literal|80
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A style suitable for dns_rdataset_totext().  */
end_comment

begin_decl_stmt
name|LIBDNS_EXTERNAL_DATA
specifier|const
name|dns_master_style_t
name|dns_master_style_debug
init|=
block|{
name|DNS_STYLEFLAG_REL_OWNER
block|,
literal|24
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|80
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_SPACES
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|spaces
index|[
name|N_SPACES
operator|+
literal|1
index|]
init|=
literal|"          "
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_TABS
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|tabs
index|[
name|N_TABS
operator|+
literal|1
index|]
init|=
literal|"\t\t\t\t\t\t\t\t\t\t"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dns_dumpctx
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|isc_boolean_t
name|canceled
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
name|isc_boolean_t
name|do_date
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbiter
decl_stmt|;
name|dns_totext_ctx_t
name|tctx
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|dns_dumpdonefunc_t
name|done
decl_stmt|;
name|void
modifier|*
name|done_arg
decl_stmt|;
name|unsigned
name|int
name|nodes
decl_stmt|;
comment|/* dns_master_dumpinc() */
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|tmpfile
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NXDOMAIN
parameter_list|(
name|x
parameter_list|)
value|(((x)->attributes& DNS_RDATASETATTR_NXDOMAIN) != 0)
end_define

begin_comment
comment|/*  * Output tabs and spaces to go from column '*current' to  * column 'to', and update '*current' to reflect the new  * current column.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|indent
parameter_list|(
name|unsigned
name|int
modifier|*
name|current
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|int
name|tabwidth
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|from
decl_stmt|;
name|int
name|ntabs
decl_stmt|,
name|nspaces
decl_stmt|,
name|t
decl_stmt|;
name|from
operator|=
operator|*
name|current
expr_stmt|;
if|if
condition|(
name|to
operator|<
name|from
operator|+
literal|1
condition|)
name|to
operator|=
name|from
operator|+
literal|1
expr_stmt|;
name|ntabs
operator|=
name|to
operator|/
name|tabwidth
operator|-
name|from
operator|/
name|tabwidth
expr_stmt|;
if|if
condition|(
name|ntabs
operator|<
literal|0
condition|)
name|ntabs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntabs
operator|>
literal|0
condition|)
block|{
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
operator|(
name|unsigned
operator|)
name|ntabs
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|p
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|t
operator|=
name|ntabs
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|int
name|n
init|=
name|t
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|N_TABS
condition|)
name|n
operator|=
name|N_TABS
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|tabs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|t
operator|-=
name|n
expr_stmt|;
block|}
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|ntabs
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|to
operator|/
name|tabwidth
operator|)
operator|*
name|tabwidth
expr_stmt|;
block|}
name|nspaces
operator|=
name|to
operator|-
name|from
expr_stmt|;
name|INSIST
argument_list|(
name|nspaces
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
operator|(
name|unsigned
operator|)
name|nspaces
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|p
operator|=
name|r
operator|.
name|base
expr_stmt|;
name|t
operator|=
name|nspaces
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|int
name|n
init|=
name|t
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|N_SPACES
condition|)
name|n
operator|=
name|N_SPACES
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|spaces
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|t
operator|-=
name|n
expr_stmt|;
block|}
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|nspaces
argument_list|)
expr_stmt|;
operator|*
name|current
operator|=
name|to
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|totext_ctx_init
parameter_list|(
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|dns_totext_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|style
operator|->
name|tab_width
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|style
operator|=
operator|*
name|style
expr_stmt|;
name|ctx
operator|->
name|class_printed
operator|=
name|ISC_FALSE
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ctx
operator|->
name|origin_fixname
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the line break string if needed. 	 */
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_MULTILINE
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_buffer_t
name|buf
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|unsigned
name|int
name|col
init|=
literal|0
decl_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|ctx
operator|->
name|linebreak_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|linebreak_buf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|1
condition|)
return|return
operator|(
name|DNS_R_TEXTTOOLONG
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|indent
argument_list|(
operator|&
name|col
argument_list|,
name|ctx
operator|->
name|style
operator|.
name|rdata_column
argument_list|,
name|ctx
operator|->
name|style
operator|.
name|tab_width
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* 		 * Do not return ISC_R_NOSPACE if the line break string 		 * buffer is too small, because that would just make 		 * dump_rdataset() retry indenfinitely with ever 		 * bigger target buffers.  That's a different buffer, 		 * so it won't help.  Use DNS_R_TEXTTOOLONG as a substitute. 		 */
if|if
condition|(
name|result
operator|==
name|ISC_R_NOSPACE
condition|)
return|return
operator|(
name|DNS_R_TEXTTOOLONG
operator|)
return|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_buffer_availableregion
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|1
condition|)
return|return
operator|(
name|DNS_R_TEXTTOOLONG
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|linebreak
operator|=
name|ctx
operator|->
name|linebreak_buf
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|linebreak
operator|=
name|NULL
expr_stmt|;
block|}
name|ctx
operator|->
name|origin
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|neworigin
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|current_ttl
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|current_ttl_valid
operator|=
name|ISC_FALSE
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|INDENT_TO
parameter_list|(
name|col
parameter_list|)
define|\
value|do { \ 		 if ((result = indent(&column, ctx->style.col, \ 				      ctx->style.tab_width, target)) \ 		     != ISC_R_SUCCESS) \ 			    return (result); \ 	} while (0)
end_define

begin_function
specifier|static
name|isc_result_t
name|str_totext
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|int
name|l
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|region
operator|.
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
name|region
operator|.
name|base
argument_list|,
name|source
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert 'rdataset' to master file text format according to 'ctx',  * storing the result in 'target'.  If 'owner_name' is NULL, it  * is omitted; otherwise 'owner_name' must be valid and have at least  * one label.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|rdataset_totext
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|owner_name
parameter_list|,
name|dns_totext_ctx_t
modifier|*
name|ctx
parameter_list|,
name|isc_boolean_t
name|omit_final_dot
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|isc_boolean_t
name|first
init|=
name|ISC_TRUE
decl_stmt|;
name|isc_uint32_t
name|current_ttl
decl_stmt|;
name|isc_boolean_t
name|current_ttl_valid
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RDATASET_VALID
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|current_ttl
operator|=
name|ctx
operator|->
name|current_ttl
expr_stmt|;
name|current_ttl_valid
operator|=
name|ctx
operator|->
name|current_ttl_valid
expr_stmt|;
do|do
block|{
name|column
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Owner name. 		 */
if|if
condition|(
name|owner_name
operator|!=
name|NULL
operator|&&
operator|!
operator|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_OMIT_OWNER
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|first
operator|)
condition|)
block|{
name|unsigned
name|int
name|name_start
init|=
name|target
operator|->
name|used
decl_stmt|;
name|RETERR
argument_list|(
name|dns_name_totext
argument_list|(
name|owner_name
argument_list|,
name|omit_final_dot
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|column
operator|+=
name|target
operator|->
name|used
operator|-
name|name_start
expr_stmt|;
block|}
comment|/* 		 * TTL. 		 */
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_NO_TTL
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_OMIT_TTL
operator|)
operator|!=
literal|0
operator|&&
name|current_ttl_valid
operator|&&
name|rdataset
operator|->
name|ttl
operator|==
name|current_ttl
operator|)
condition|)
block|{
name|char
name|ttlbuf
index|[
literal|64
index|]
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|INDENT_TO
argument_list|(
name|ttl_column
argument_list|)
expr_stmt|;
name|length
operator|=
name|snprintf
argument_list|(
name|ttlbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ttlbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|rdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|length
operator|<=
sizeof|sizeof
argument_list|(
name|ttlbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
name|length
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|memcpy
argument_list|(
name|r
operator|.
name|base
argument_list|,
name|ttlbuf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|column
operator|+=
name|length
expr_stmt|;
comment|/* 			 * If the $TTL directive is not in use, the TTL we 			 * just printed becomes the default for subsequent RRs. 			 */
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_TTL
operator|)
operator|==
literal|0
condition|)
block|{
name|current_ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|current_ttl_valid
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
comment|/* 		 * Class. 		 */
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_NO_CLASS
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_OMIT_CLASS
operator|)
operator|==
literal|0
operator|||
name|ctx
operator|->
name|class_printed
operator|==
name|ISC_FALSE
operator|)
condition|)
block|{
name|unsigned
name|int
name|class_start
decl_stmt|;
name|INDENT_TO
argument_list|(
name|class_column
argument_list|)
expr_stmt|;
name|class_start
operator|=
name|target
operator|->
name|used
expr_stmt|;
name|result
operator|=
name|dns_rdataclass_totext
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|column
operator|+=
operator|(
name|target
operator|->
name|used
operator|-
name|class_start
operator|)
expr_stmt|;
block|}
comment|/* 		 * Type. 		 */
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|rdataset
operator|->
name|covers
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|rdataset
operator|->
name|type
expr_stmt|;
block|}
block|{
name|unsigned
name|int
name|type_start
decl_stmt|;
name|INDENT_TO
argument_list|(
name|type_column
argument_list|)
expr_stmt|;
name|type_start
operator|=
name|target
operator|->
name|used
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
literal|0
condition|)
name|RETERR
argument_list|(
name|str_totext
argument_list|(
literal|"\\-"
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatatype_totext
argument_list|(
name|type
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|column
operator|+=
operator|(
name|target
operator|->
name|used
operator|-
name|type_start
operator|)
expr_stmt|;
block|}
comment|/* 		 * Rdata. 		 */
name|INDENT_TO
argument_list|(
name|rdata_column
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdataset
operator|->
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|NXDOMAIN
argument_list|(
name|rdataset
argument_list|)
condition|)
name|RETERR
argument_list|(
name|str_totext
argument_list|(
literal|";-$NXDOMAIN\n"
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|RETERR
argument_list|(
name|str_totext
argument_list|(
literal|";-$NXRRSET\n"
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_rdata_tofmttext
argument_list|(
operator|&
name|rdata
argument_list|,
name|ctx
operator|->
name|origin
argument_list|,
name|ctx
operator|->
name|style
operator|.
name|flags
argument_list|,
name|ctx
operator|->
name|style
operator|.
name|line_length
operator|-
name|ctx
operator|->
name|style
operator|.
name|rdata_column
argument_list|,
name|ctx
operator|->
name|linebreak
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|1
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
do|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Update the ctx state to reflect what we just printed. 	 * This is done last, only when we are sure we will return 	 * success, because this function may be called multiple 	 * times with increasing buffer sizes until it succeeds, 	 * and failed attempts must not update the state prematurely. 	 */
name|ctx
operator|->
name|class_printed
operator|=
name|ISC_TRUE
expr_stmt|;
name|ctx
operator|->
name|current_ttl
operator|=
name|current_ttl
expr_stmt|;
name|ctx
operator|->
name|current_ttl_valid
operator|=
name|current_ttl_valid
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the name, type, and class of an empty rdataset,  * such as those used to represent the question section  * of a DNS message.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|question_totext
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|owner_name
parameter_list|,
name|dns_totext_ctx_t
modifier|*
name|ctx
parameter_list|,
name|isc_boolean_t
name|omit_final_dot
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|unsigned
name|int
name|column
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RDATASET_VALID
argument_list|(
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|result
operator|==
name|ISC_R_NOMORE
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
comment|/* Owner name */
block|{
name|unsigned
name|int
name|name_start
init|=
name|target
operator|->
name|used
decl_stmt|;
name|RETERR
argument_list|(
name|dns_name_totext
argument_list|(
name|owner_name
argument_list|,
name|omit_final_dot
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|column
operator|+=
name|target
operator|->
name|used
operator|-
name|name_start
expr_stmt|;
block|}
comment|/* Class */
block|{
name|unsigned
name|int
name|class_start
decl_stmt|;
name|INDENT_TO
argument_list|(
name|class_column
argument_list|)
expr_stmt|;
name|class_start
operator|=
name|target
operator|->
name|used
expr_stmt|;
name|result
operator|=
name|dns_rdataclass_totext
argument_list|(
name|rdataset
operator|->
name|rdclass
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|column
operator|+=
operator|(
name|target
operator|->
name|used
operator|-
name|class_start
operator|)
expr_stmt|;
block|}
comment|/* Type */
block|{
name|unsigned
name|int
name|type_start
decl_stmt|;
name|INDENT_TO
argument_list|(
name|type_column
argument_list|)
expr_stmt|;
name|type_start
operator|=
name|target
operator|->
name|used
expr_stmt|;
name|result
operator|=
name|dns_rdatatype_totext
argument_list|(
name|rdataset
operator|->
name|type
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|column
operator|+=
operator|(
name|target
operator|->
name|used
operator|-
name|type_start
operator|)
expr_stmt|;
block|}
name|isc_buffer_availableregion
argument_list|(
name|target
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|.
name|length
operator|<
literal|1
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rdataset_totext
parameter_list|(
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|owner_name
parameter_list|,
name|isc_boolean_t
name|omit_final_dot
parameter_list|,
name|isc_boolean_t
name|question
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|dns_totext_ctx_t
name|ctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|totext_ctx_init
argument_list|(
operator|&
name|dns_master_style_debug
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"could not set master file style"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
comment|/* 	 * The caller might want to give us an empty owner 	 * name (e.g. if they are outputting into a master 	 * file and this rdataset has the same name as the 	 * previous one.) 	 */
if|if
condition|(
name|dns_name_countlabels
argument_list|(
name|owner_name
argument_list|)
operator|==
literal|0
condition|)
name|owner_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|question
condition|)
return|return
operator|(
name|question_totext
argument_list|(
name|rdataset
argument_list|,
name|owner_name
argument_list|,
operator|&
name|ctx
argument_list|,
name|omit_final_dot
argument_list|,
name|target
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rdataset_totext
argument_list|(
name|rdataset
argument_list|,
name|owner_name
argument_list|,
operator|&
name|ctx
argument_list|,
name|omit_final_dot
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_rdatasettotext
parameter_list|(
name|dns_name_t
modifier|*
name|owner_name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|dns_totext_ctx_t
name|ctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|totext_ctx_init
argument_list|(
name|style
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"could not set master file style"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|rdataset_totext
argument_list|(
name|rdataset
argument_list|,
name|owner_name
argument_list|,
operator|&
name|ctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_questiontotext
parameter_list|(
name|dns_name_t
modifier|*
name|owner_name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|isc_buffer_t
modifier|*
name|target
parameter_list|)
block|{
name|dns_totext_ctx_t
name|ctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|totext_ctx_init
argument_list|(
name|style
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"could not set master file style"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|question_totext
argument_list|(
name|rdataset
argument_list|,
name|owner_name
argument_list|,
operator|&
name|ctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print an rdataset.  'buffer' is a scratch buffer, which must have been  * dynamically allocated by the caller.  It must be large enough to  * hold the result from dns_ttl_totext().  If more than that is needed,  * the buffer will be grown automatically.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dump_rdataset
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_totext_ctx_t
modifier|*
name|ctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|buffer
operator|->
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Output a $TTL directive if needed. 	 */
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_TTL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|current_ttl_valid
operator|==
name|ISC_FALSE
operator|||
name|ctx
operator|->
name|current_ttl
operator|!=
name|rdataset
operator|->
name|ttl
condition|)
block|{
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_ttl_totext
argument_list|(
name|rdataset
operator|->
name|ttl
argument_list|,
name|ISC_TRUE
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"$TTL %u\t; %.*s\n"
argument_list|,
name|rdataset
operator|->
name|ttl
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"$TTL %u\n"
argument_list|,
name|rdataset
operator|->
name|ttl
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|current_ttl
operator|=
name|rdataset
operator|->
name|ttl
expr_stmt|;
name|ctx
operator|->
name|current_ttl_valid
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
name|isc_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* 	 * Generate the text representation of the rdataset into 	 * the buffer.  If the buffer is too small, grow it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|newlength
decl_stmt|;
name|void
modifier|*
name|newmem
decl_stmt|;
name|result
operator|=
name|rdataset_totext
argument_list|(
name|rdataset
argument_list|,
name|name
argument_list|,
name|ctx
argument_list|,
name|ISC_FALSE
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOSPACE
condition|)
break|break;
name|newlength
operator|=
name|buffer
operator|->
name|length
operator|*
literal|2
expr_stmt|;
name|newmem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buffer
operator|->
name|base
argument_list|,
name|buffer
operator|->
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
name|buffer
argument_list|,
name|newmem
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Write the buffer contents to the master file. 	 */
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_write
argument_list|(
name|r
operator|.
name|base
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|r
operator|.
name|length
argument_list|,
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"master file write failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define the order in which rdatasets should be printed in zone  * files.  We will print SOA and NS records before others, SIGs  * immediately following the things they sign, and order everything  * else by RR number.  This is all just for aesthetics and  * compatibility with buggy software that expects the SOA to be first;  * the DNS specifications allow any order.  */
end_comment

begin_function
specifier|static
name|int
name|dump_order
parameter_list|(
specifier|const
name|dns_rdataset_t
modifier|*
name|rds
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|int
name|sig
decl_stmt|;
if|if
condition|(
name|rds
operator|->
name|type
operator|==
name|dns_rdatatype_rrsig
condition|)
block|{
name|t
operator|=
name|rds
operator|->
name|covers
expr_stmt|;
name|sig
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|rds
operator|->
name|type
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|dns_rdatatype_soa
case|:
name|t
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|dns_rdatatype_ns
case|:
name|t
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|t
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|t
operator|<<
literal|1
operator|)
operator|+
name|sig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_order_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|dump_order
argument_list|(
operator|*
operator|(
operator|(
specifier|const
name|dns_rdataset_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
argument_list|)
operator|-
name|dump_order
argument_list|(
operator|*
operator|(
operator|(
specifier|const
name|dns_rdataset_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump all the rdatasets of a domain name to a master file.  We make  * a "best effort" attempt to sort the RRsets in a nice order, but if  * there are more than MAXSORT RRsets, we punt and only sort them in  * groups of MAXSORT.  This is not expected to ever happen in practice  * since much less than 64 RR types have been registered with the  * IANA, so far, and the output will be correct (though not  * aesthetically pleasing) even if it does happen.  */
end_comment

begin_define
define|#
directive|define
name|MAXSORT
value|64
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|trustnames
index|[]
init|=
block|{
literal|"none"
block|,
literal|"pending"
block|,
literal|"additional"
block|,
literal|"glue"
block|,
literal|"answer"
block|,
literal|"authauthority"
block|,
literal|"authanswer"
block|,
literal|"secure"
block|,
literal|"local"
comment|/* aka ultimate */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|dump_rdatasets
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
parameter_list|,
name|dns_totext_ctx_t
modifier|*
name|ctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|isc_result_t
name|itresult
decl_stmt|,
name|dumpresult
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_rdataset_t
name|rdatasets
index|[
name|MAXSORT
index|]
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|sorted
index|[
name|MAXSORT
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|itresult
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsiter
argument_list|)
expr_stmt|;
name|dumpresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|itresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|ctx
operator|->
name|neworigin
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_clear
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|itresult
operator|=
name|dns_name_totext
argument_list|(
name|ctx
operator|->
name|neworigin
argument_list|,
name|ISC_FALSE
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|itresult
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"$ORIGIN %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|neworigin
operator|=
name|NULL
expr_stmt|;
block|}
name|again
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|itresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|i
operator|<
name|MAXSORT
condition|;
name|itresult
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsiter
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|rdatasets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_current
argument_list|(
name|rdsiter
argument_list|,
operator|&
name|rdatasets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sorted
index|[
name|i
index|]
operator|=
operator|&
name|rdatasets
index|[
name|i
index|]
expr_stmt|;
block|}
name|n
operator|=
name|i
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|<=
name|MAXSORT
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sorted
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|sorted
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|dump_order_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|dns_rdataset_t
modifier|*
name|rds
init|=
name|sorted
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_TRUST
condition|)
block|{
name|unsigned
name|int
name|trust
init|=
name|rds
operator|->
name|trust
decl_stmt|;
name|INSIST
argument_list|(
name|trust
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|trustnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|trustnames
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; %s\n"
argument_list|,
name|trustnames
index|[
name|trust
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rds
operator|->
name|type
operator|==
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_NCACHE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Omit negative cache entries */
block|}
else|else
block|{
name|isc_result_t
name|result
init|=
name|dump_rdataset
argument_list|(
name|mctx
argument_list|,
name|name
argument_list|,
name|rds
argument_list|,
name|ctx
argument_list|,
name|buffer
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|dumpresult
operator|=
name|result
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_OMIT_OWNER
operator|)
operator|!=
literal|0
condition|)
name|name
operator|=
name|NULL
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
name|rds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dumpresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|dumpresult
operator|)
return|;
comment|/* 	 * If we got more data than could be sorted at once, 	 * go handle the rest. 	 */
if|if
condition|(
name|itresult
operator|==
name|ISC_R_SUCCESS
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|itresult
operator|==
name|ISC_R_NOMORE
condition|)
name|itresult
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|itresult
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initial size of text conversion buffer.  The buffer is used  * for several purposes: converting origin names, rdatasets,  * $DATE timestamps, and comment strings for $TTL directives.  *  * When converting rdatasets, it is dynamically resized, but  * when converting origins, timestamps, etc it is not.  Therefore,  * the  initial size must large enough to hold the longest possible  * text representation of any domain name (for $ORIGIN).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|initial_buffer_length
init|=
literal|1200
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|isc_result_t
name|dumptostreaminc
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dumpctx_destroy
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|dctx
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|version
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
operator|&
name|dctx
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dctx
operator|->
name|dbiter
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|dctx
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|dctx
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|file
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|dctx
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|tmpfile
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|dctx
operator|->
name|tmpfile
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|dctx
operator|->
name|mctx
argument_list|,
name|dctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dumpctx_attach
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|source
parameter_list|,
name|dns_dumpctx_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Overflow? */
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dumpctx_detach
parameter_list|(
name|dns_dumpctx_t
modifier|*
modifier|*
name|dctxp
parameter_list|)
block|{
name|dns_dumpctx_t
modifier|*
name|dctx
decl_stmt|;
name|isc_boolean_t
name|need_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|dctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dctx
operator|=
operator|*
name|dctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dctxp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dctx
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|references
operator|==
literal|0
condition|)
name|need_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
name|dumpctx_destroy
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_dbversion_t
modifier|*
name|dns_dumpctx_version
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dctx
operator|->
name|version
operator|)
return|;
block|}
end_function

begin_function
name|dns_db_t
modifier|*
name|dns_dumpctx_db
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dctx
operator|->
name|db
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dumpctx_cancel
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|canceled
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|closeandrename
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|isc_result_t
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|temp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_boolean_t
name|logit
init|=
name|ISC_TF
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_stdio_sync
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|logit
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping master file: %s: fsync: %s"
argument_list|,
name|temp
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|logit
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|tresult
operator|=
name|isc_stdio_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|logit
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping master file: %s: fclose: %s"
argument_list|,
name|temp
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|logit
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|isc_file_rename
argument_list|(
name|temp
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|isc_file_remove
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|logit
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping master file: rename: %s: %s"
argument_list|,
name|file
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_quantum
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|dns_dumpctx_t
modifier|*
name|dctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DCTX_VALID
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|canceled
condition|)
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
else|else
name|result
operator|=
name|dumptostreaminc
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_CONTINUE
condition|)
block|{
name|event
operator|->
name|ev_arg
operator|=
name|dctx
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dctx
operator|->
name|file
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|closeandrename
argument_list|(
name|dctx
operator|->
name|f
argument_list|,
name|result
argument_list|,
name|dctx
operator|->
name|tmpfile
argument_list|,
name|dctx
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
call|(
name|dctx
operator|->
name|done
call|)
argument_list|(
name|dctx
operator|->
name|done_arg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_dumpctx_detach
argument_list|(
operator|&
name|dctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|task_send
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DUMPQUANTUM
argument_list|,
name|dump_quantum
argument_list|,
name|dctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_task_send
argument_list|(
name|dctx
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dumpctx_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|dns_dumpctx_t
modifier|*
modifier|*
name|dctxp
parameter_list|)
block|{
name|dns_dumpctx_t
modifier|*
name|dctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|relative
decl_stmt|;
name|dctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dctx
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|f
operator|=
name|f
expr_stmt|;
name|dctx
operator|->
name|dbiter
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|done
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|done_arg
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|nodes
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|dctx
operator|->
name|canceled
operator|=
name|ISC_FALSE
expr_stmt|;
name|dctx
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|tmpfile
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|totext_ctx_init
argument_list|(
name|style
argument_list|,
operator|&
name|dctx
operator|->
name|tctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"could not set master file style"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|dctx
operator|->
name|now
argument_list|)
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|dctx
operator|->
name|db
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|do_date
operator|=
name|dns_db_iscache
argument_list|(
name|dctx
operator|->
name|db
argument_list|)
expr_stmt|;
name|relative
operator|=
operator|(
operator|(
name|dctx
operator|->
name|tctx
operator|.
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_REL_OWNER
operator|)
operator|!=
literal|0
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
name|relative
argument_list|,
operator|&
name|dctx
operator|->
name|dbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|dctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
name|dns_db_attachversion
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|dctx
operator|->
name|version
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|dns_db_iscache
argument_list|(
name|db
argument_list|)
condition|)
name|dns_db_currentversion
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
operator|&
name|dctx
operator|->
name|version
argument_list|)
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|dctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|references
operator|=
literal|1
expr_stmt|;
name|dctx
operator|->
name|magic
operator|=
name|DNS_DCTX_MAGIC
expr_stmt|;
operator|*
name|dctxp
operator|=
name|dctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|dctx
operator|->
name|dbiter
operator|!=
name|NULL
condition|)
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dctx
operator|->
name|dbiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|dctx
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|dctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dumptostreaminc
parameter_list|(
name|dns_dumpctx_t
modifier|*
name|dctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|char
modifier|*
name|bufmem
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|dns_fixedname_t
name|fixname
decl_stmt|;
name|unsigned
name|int
name|nodes
decl_stmt|;
name|bufmem
operator|=
name|isc_mem_get
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|initial_buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufmem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|bufmem
argument_list|,
name|initial_buffer_length
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|first
condition|)
block|{
comment|/* 		 * If the database has cache semantics, output an RFC2540 		 * $DATE directive so that the TTLs can be adjusted when 		 * it is reloaded.  For zones it is not really needed, and 		 * it would make the file incompatible with pre-RFC2540 		 * software, so we omit it in the zone case. 		 */
if|if
condition|(
name|dctx
operator|->
name|do_date
condition|)
block|{
name|result
operator|=
name|dns_time32_totext
argument_list|(
name|dctx
operator|->
name|now
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dctx
operator|->
name|f
argument_list|,
literal|"$DATE %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|r
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|dns_dbiterator_first
argument_list|(
name|dctx
operator|->
name|dbiter
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|nodes
operator|=
name|dctx
operator|->
name|nodes
expr_stmt|;
while|while
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|(
name|dctx
operator|->
name|nodes
operator|==
literal|0
operator|||
name|nodes
operator|--
operator|)
condition|)
block|{
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
init|=
name|NULL
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|dctx
operator|->
name|dbiter
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_NEWORIGIN
condition|)
break|break;
if|if
condition|(
name|result
operator|==
name|DNS_R_NEWORIGIN
condition|)
block|{
name|dns_name_t
modifier|*
name|origin
init|=
name|dns_fixedname_name
argument_list|(
operator|&
name|dctx
operator|->
name|tctx
operator|.
name|origin_fixname
argument_list|)
decl_stmt|;
name|result
operator|=
name|dns_dbiterator_origin
argument_list|(
name|dctx
operator|->
name|dbiter
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dctx
operator|->
name|tctx
operator|.
name|style
operator|.
name|flags
operator|&
name|DNS_STYLEFLAG_REL_DATA
operator|)
operator|!=
literal|0
condition|)
name|dctx
operator|->
name|tctx
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
name|dctx
operator|->
name|tctx
operator|.
name|neworigin
operator|=
name|origin
expr_stmt|;
block|}
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
name|node
argument_list|,
name|dctx
operator|->
name|version
argument_list|,
name|dctx
operator|->
name|now
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|dump_rdatasets
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|name
argument_list|,
name|rdsiter
argument_list|,
operator|&
name|dctx
operator|->
name|tctx
argument_list|,
operator|&
name|buffer
argument_list|,
name|dctx
operator|->
name|f
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_db_detachnode
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|dns_db_detachnode
argument_list|(
name|dctx
operator|->
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dbiterator_next
argument_list|(
name|dctx
operator|->
name|dbiter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dctx
operator|->
name|nodes
operator|!=
literal|0
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|fail
label|:
name|RUNTIME_CHECK
argument_list|(
name|dns_dbiterator_pause
argument_list|(
name|dctx
operator|->
name|dbiter
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|dctx
operator|->
name|mctx
argument_list|,
name|buffer
operator|.
name|base
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_dumptostreaminc
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_dumpdonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_dumpctx_t
modifier|*
modifier|*
name|dctxp
parameter_list|)
block|{
name|dns_dumpctx_t
modifier|*
name|dctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|f
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dumpctx_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|style
argument_list|,
name|f
argument_list|,
operator|&
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|dctx
operator|->
name|task
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|done
operator|=
name|done
expr_stmt|;
name|dctx
operator|->
name|done_arg
operator|=
name|done_arg
expr_stmt|;
name|dctx
operator|->
name|nodes
operator|=
literal|100
expr_stmt|;
name|result
operator|=
name|task_send
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_dumpctx_attach
argument_list|(
name|dctx
argument_list|,
name|dctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|dns_dumpctx_detach
argument_list|(
operator|&
name|dctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump an entire database into a master file.  */
end_comment

begin_function
name|isc_result_t
name|dns_master_dumptostream
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|dns_dumpctx_t
modifier|*
name|dctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dumpctx_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|style
argument_list|,
name|f
argument_list|,
operator|&
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dumptostreaminc
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|dns_dumpctx_detach
argument_list|(
operator|&
name|dctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|opentmp
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|tempp
parameter_list|,
name|FILE
modifier|*
modifier|*
name|fp
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|tempname
init|=
name|NULL
decl_stmt|;
name|int
name|tempnamelen
decl_stmt|;
name|tempnamelen
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|20
expr_stmt|;
name|tempname
operator|=
name|isc_mem_allocate
argument_list|(
name|mctx
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempname
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|isc_file_mktemplate
argument_list|(
name|file
argument_list|,
name|tempname
argument_list|,
name|tempnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_file_openunique
argument_list|(
name|tempname
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping master file: %s: open: %s"
argument_list|,
name|tempname
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
operator|*
name|tempp
operator|=
name|tempname
expr_stmt|;
operator|*
name|fp
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_dumpinc
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_dumpdonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_dumpctx_t
modifier|*
modifier|*
name|dctxp
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|tempname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|dns_dumpctx_t
modifier|*
name|dctx
init|=
name|NULL
decl_stmt|;
name|file
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|opentmp
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
operator|&
name|tempname
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dumpctx_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|style
argument_list|,
name|f
argument_list|,
operator|&
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|isc_stdio_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_file_remove
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|dctx
operator|->
name|task
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|done
operator|=
name|done
expr_stmt|;
name|dctx
operator|->
name|done_arg
operator|=
name|done_arg
expr_stmt|;
name|dctx
operator|->
name|nodes
operator|=
literal|100
expr_stmt|;
name|dctx
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|tmpfile
operator|=
name|tempname
expr_stmt|;
name|tempname
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|task_send
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_dumpctx_attach
argument_list|(
name|dctx
argument_list|,
name|dctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|cleanup
label|:
if|if
condition|(
name|dctx
operator|!=
name|NULL
condition|)
name|dns_dumpctx_detach
argument_list|(
operator|&
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempname
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_dump
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|dns_dumpctx_t
modifier|*
name|dctx
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|opentmp
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
operator|&
name|tempname
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dumpctx_create
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|style
argument_list|,
name|f
argument_list|,
operator|&
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|dumptostreaminc
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|dns_dumpctx_detach
argument_list|(
operator|&
name|dctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|closeandrename
argument_list|(
name|f
argument_list|,
name|result
argument_list|,
name|tempname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump a database node into a master file.  */
end_comment

begin_function
name|isc_result_t
name|dns_master_dumpnodetostream
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|char
modifier|*
name|bufmem
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|dns_totext_ctx_t
name|ctx
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|totext_ctx_init
argument_list|(
name|style
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"could not set master file style"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|bufmem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|initial_buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufmem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|bufmem
argument_list|,
name|initial_buffer_length
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|version
argument_list|,
name|now
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|result
operator|=
name|dump_rdatasets
argument_list|(
name|mctx
argument_list|,
name|name
argument_list|,
name|rdsiter
argument_list|,
operator|&
name|ctx
argument_list|,
operator|&
name|buffer
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|failure
goto|;
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buffer
operator|.
name|base
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_dumpnode
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|dns_master_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping node to file: %s: open: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|dns_master_dumpnodetostream
argument_list|(
name|mctx
argument_list|,
name|db
argument_list|,
name|version
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|style
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_MASTERDUMP
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dumping master file: %s: close: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_stylecreate
parameter_list|(
name|dns_master_style_t
modifier|*
modifier|*
name|stylep
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|unsigned
name|int
name|ttl_column
parameter_list|,
name|unsigned
name|int
name|class_column
parameter_list|,
name|unsigned
name|int
name|type_column
parameter_list|,
name|unsigned
name|int
name|rdata_column
parameter_list|,
name|unsigned
name|int
name|line_length
parameter_list|,
name|unsigned
name|int
name|tab_width
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_master_style_t
modifier|*
name|style
decl_stmt|;
name|REQUIRE
argument_list|(
name|stylep
operator|!=
name|NULL
operator|&&
operator|*
name|stylep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|style
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|style
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|style
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|style
operator|->
name|ttl_column
operator|=
name|ttl_column
expr_stmt|;
name|style
operator|->
name|class_column
operator|=
name|class_column
expr_stmt|;
name|style
operator|->
name|type_column
operator|=
name|type_column
expr_stmt|;
name|style
operator|->
name|rdata_column
operator|=
name|rdata_column
expr_stmt|;
name|style
operator|->
name|line_length
operator|=
name|line_length
expr_stmt|;
name|style
operator|->
name|tab_width
operator|=
name|tab_width
expr_stmt|;
operator|*
name|stylep
operator|=
name|style
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_master_styledestroy
parameter_list|(
name|dns_master_style_t
modifier|*
modifier|*
name|stylep
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_master_style_t
modifier|*
name|style
decl_stmt|;
name|REQUIRE
argument_list|(
name|stylep
operator|!=
name|NULL
operator|&&
operator|*
name|stylep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|style
operator|=
operator|*
name|stylep
expr_stmt|;
operator|*
name|stylep
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|style
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|style
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

