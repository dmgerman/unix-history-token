begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: rbt.c,v 1.115.2.2.2.13 2005/06/18 01:03:24 marka Exp $ */
end_comment

begin_comment
comment|/* Principal Authors: DCL */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_comment
comment|/*  * This define is so dns/name.h (included by dns/fixedname.h) uses more  * efficient macro calls instead of functions for a few operations.  */
end_comment

begin_define
define|#
directive|define
name|DNS_NAME_USEINLINE
value|1
end_define

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/rbt.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_define
define|#
directive|define
name|RBT_MAGIC
value|ISC_MAGIC('R', 'B', 'T', '+')
end_define

begin_define
define|#
directive|define
name|VALID_RBT
parameter_list|(
name|rbt
parameter_list|)
value|ISC_MAGIC_VALID(rbt, RBT_MAGIC)
end_define

begin_comment
comment|/*  * XXXDCL Since parent pointers were added in again, I could remove all of the  * chain junk, and replace with dns_rbt_firstnode, _previousnode, _nextnode,  * _lastnode.  This would involve pretty major change to the API.  */
end_comment

begin_define
define|#
directive|define
name|CHAIN_MAGIC
value|ISC_MAGIC('0', '-', '0', '-')
end_define

begin_define
define|#
directive|define
name|VALID_CHAIN
parameter_list|(
name|chain
parameter_list|)
value|ISC_MAGIC_VALID(chain, CHAIN_MAGIC)
end_define

begin_define
define|#
directive|define
name|RBT_HASH_SIZE
value|64
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|RBT_MEM_TEST
end_ifdef

begin_undef
undef|#
directive|undef
name|RBT_HASH_SIZE
end_undef

begin_define
define|#
directive|define
name|RBT_HASH_SIZE
value|2
end_define

begin_comment
comment|/* To give the reallocation code a workout. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|dns_rbt
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|root
decl_stmt|;
name|void
function_decl|(
modifier|*
name|data_deleter
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|deleter_arg
decl_stmt|;
name|unsigned
name|int
name|nodecount
decl_stmt|;
name|unsigned
name|int
name|hashsize
decl_stmt|;
name|dns_rbtnode_t
modifier|*
modifier|*
name|hashtable
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RED
value|0
end_define

begin_define
define|#
directive|define
name|BLACK
value|1
end_define

begin_comment
comment|/*  * Elements of the rbtnode structure.  */
end_comment

begin_define
define|#
directive|define
name|PARENT
parameter_list|(
name|node
parameter_list|)
value|((node)->parent)
end_define

begin_define
define|#
directive|define
name|LEFT
parameter_list|(
name|node
parameter_list|)
value|((node)->left)
end_define

begin_define
define|#
directive|define
name|RIGHT
parameter_list|(
name|node
parameter_list|)
value|((node)->right)
end_define

begin_define
define|#
directive|define
name|DOWN
parameter_list|(
name|node
parameter_list|)
value|((node)->down)
end_define

begin_define
define|#
directive|define
name|DATA
parameter_list|(
name|node
parameter_list|)
value|((node)->data)
end_define

begin_define
define|#
directive|define
name|HASHNEXT
parameter_list|(
name|node
parameter_list|)
value|((node)->hashnext)
end_define

begin_define
define|#
directive|define
name|HASHVAL
parameter_list|(
name|node
parameter_list|)
value|((node)->hashval)
end_define

begin_define
define|#
directive|define
name|COLOR
parameter_list|(
name|node
parameter_list|)
value|((node)->color)
end_define

begin_define
define|#
directive|define
name|NAMELEN
parameter_list|(
name|node
parameter_list|)
value|((node)->namelen)
end_define

begin_define
define|#
directive|define
name|OFFSETLEN
parameter_list|(
name|node
parameter_list|)
value|((node)->offsetlen)
end_define

begin_define
define|#
directive|define
name|ATTRS
parameter_list|(
name|node
parameter_list|)
value|((node)->attributes)
end_define

begin_define
define|#
directive|define
name|PADBYTES
parameter_list|(
name|node
parameter_list|)
value|((node)->padbytes)
end_define

begin_define
define|#
directive|define
name|IS_ROOT
parameter_list|(
name|node
parameter_list|)
value|ISC_TF((node)->is_root == 1)
end_define

begin_define
define|#
directive|define
name|FINDCALLBACK
parameter_list|(
name|node
parameter_list|)
value|ISC_TF((node)->find_callback == 1)
end_define

begin_comment
comment|/*  * Structure elements from the rbtdb.c, not  * used as part of the rbt.c algorithms.  */
end_comment

begin_define
define|#
directive|define
name|DIRTY
parameter_list|(
name|node
parameter_list|)
value|((node)->dirty)
end_define

begin_define
define|#
directive|define
name|WILD
parameter_list|(
name|node
parameter_list|)
value|((node)->wild)
end_define

begin_define
define|#
directive|define
name|LOCKNUM
parameter_list|(
name|node
parameter_list|)
value|((node)->locknum)
end_define

begin_define
define|#
directive|define
name|REFS
parameter_list|(
name|node
parameter_list|)
value|((node)->references)
end_define

begin_comment
comment|/*  * The variable length stuff stored after the node.  */
end_comment

begin_define
define|#
directive|define
name|NAME
parameter_list|(
name|node
parameter_list|)
value|((unsigned char *)((node) + 1))
end_define

begin_define
define|#
directive|define
name|OFFSETS
parameter_list|(
name|node
parameter_list|)
value|(NAME(node) + NAMELEN(node))
end_define

begin_define
define|#
directive|define
name|NODE_SIZE
parameter_list|(
name|node
parameter_list|)
value|(sizeof(*node) + \ 			 NAMELEN(node) + OFFSETLEN(node) + PADBYTES(node))
end_define

begin_comment
comment|/*  * Color management.  */
end_comment

begin_define
define|#
directive|define
name|IS_RED
parameter_list|(
name|node
parameter_list|)
value|((node) != NULL&& (node)->color == RED)
end_define

begin_define
define|#
directive|define
name|IS_BLACK
parameter_list|(
name|node
parameter_list|)
value|((node) == NULL || (node)->color == BLACK)
end_define

begin_define
define|#
directive|define
name|MAKE_RED
parameter_list|(
name|node
parameter_list|)
value|((node)->color = RED)
end_define

begin_define
define|#
directive|define
name|MAKE_BLACK
parameter_list|(
name|node
parameter_list|)
value|((node)->color = BLACK)
end_define

begin_comment
comment|/*  * Chain management.  *  * The "ancestors" member of chains were removed, with their job now  * being wholy handled by parent pointers (which didn't exist, because  * of memory concerns, when chains were first implemented).  */
end_comment

begin_define
define|#
directive|define
name|ADD_LEVEL
parameter_list|(
name|chain
parameter_list|,
name|node
parameter_list|)
define|\
value|(chain)->levels[(chain)->level_count++] = (node)
end_define

begin_comment
comment|/*  * The following macros directly access normally private name variables.  * These macros are used to avoid a lot of function calls in the critical  * path of the tree traversal code.  */
end_comment

begin_define
define|#
directive|define
name|NODENAME
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
define|\
value|do { \ 	(name)->length = NAMELEN(node); \ 	(name)->labels = OFFSETLEN(node); \ 	(name)->ndata = NAME(node); \ 	(name)->offsets = OFFSETS(node); \ 	(name)->attributes = ATTRS(node); \ 	(name)->attributes |= DNS_NAMEATTR_READONLY; \ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
end_ifdef

begin_function_decl
specifier|static
name|isc_result_t
name|inithash
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|inline
end_define

begin_comment
comment|/*  * A little something to help out in GDB.  */
end_comment

begin_function_decl
name|dns_name_t
name|Name
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|dns_name_t
name|Name
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|dns_name_t
name|name
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|NODENAME
argument_list|(
name|node
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|dns_rbt_printnodename
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|dns_rbtnode_t
modifier|*
name|find_up
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|root
decl_stmt|;
comment|/* 	 * Return the node in the level above the argument node that points 	 * to the level the argument node is in.  If the argument node is in 	 * the top level, the return value is NULL. 	 */
for|for
control|(
name|root
operator|=
name|node
init|;
operator|!
name|IS_ROOT
argument_list|(
name|root
argument_list|)
condition|;
name|root
operator|=
name|PARENT
argument_list|(
name|root
argument_list|)
control|)
empty_stmt|;
comment|/* Nothing. */
return|return
operator|(
name|PARENT
argument_list|(
name|root
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|create_node
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
end_ifdef

begin_function_decl
specifier|static
specifier|inline
name|void
name|hash_node
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|unhash_node
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hash_node
parameter_list|(
name|rbt
parameter_list|,
name|node
parameter_list|,
name|name
parameter_list|)
value|(ISC_R_SUCCESS)
end_define

begin_define
define|#
directive|define
name|unhash_node
parameter_list|(
name|rbt
parameter_list|,
name|node
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|rotate_left
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|rotate_right
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dns_rbt_addonlevel
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|current
parameter_list|,
name|int
name|order
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dns_rbt_deletefromlevel
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|delete
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dns_rbt_deletetree
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dns_rbt_deletetreeflat
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|unsigned
name|int
name|quantum
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize a red/black tree of trees.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|void
function_decl|(
modifier|*
name|deleter
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|deleter_arg
parameter_list|,
name|dns_rbt_t
modifier|*
modifier|*
name|rbtp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|isc_result_t
name|result
decl_stmt|;
endif|#
directive|endif
name|dns_rbt_t
modifier|*
name|rbt
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rbtp
operator|!=
name|NULL
operator|&&
operator|*
name|rbtp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|deleter
operator|==
name|NULL
condition|?
name|deleter_arg
operator|==
name|NULL
else|:
literal|1
argument_list|)
expr_stmt|;
name|rbt
operator|=
operator|(
name|dns_rbt_t
operator|*
operator|)
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|rbt
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|rbt
operator|->
name|data_deleter
operator|=
name|deleter
expr_stmt|;
name|rbt
operator|->
name|deleter_arg
operator|=
name|deleter_arg
expr_stmt|;
name|rbt
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|=
literal|0
expr_stmt|;
name|rbt
operator|->
name|hashtable
operator|=
name|NULL
expr_stmt|;
name|rbt
operator|->
name|hashsize
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|result
operator|=
name|inithash
argument_list|(
name|rbt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rbt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
endif|#
directive|endif
name|rbt
operator|->
name|magic
operator|=
name|RBT_MAGIC
expr_stmt|;
operator|*
name|rbtp
operator|=
name|rbt
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a red/black tree of trees.  */
end_comment

begin_function
name|void
name|dns_rbt_destroy
parameter_list|(
name|dns_rbt_t
modifier|*
modifier|*
name|rbtp
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|dns_rbt_destroy2
argument_list|(
name|rbtp
argument_list|,
literal|0
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbt_destroy2
parameter_list|(
name|dns_rbt_t
modifier|*
modifier|*
name|rbtp
parameter_list|,
name|unsigned
name|int
name|quantum
parameter_list|)
block|{
name|dns_rbt_t
modifier|*
name|rbt
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtp
operator|!=
name|NULL
operator|&&
name|VALID_RBT
argument_list|(
operator|*
name|rbtp
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|=
operator|*
name|rbtp
expr_stmt|;
name|dns_rbt_deletetreeflat
argument_list|(
name|rbt
argument_list|,
name|quantum
argument_list|,
operator|&
name|rbt
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|root
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_R_QUOTA
operator|)
return|;
name|INSIST
argument_list|(
name|rbt
operator|->
name|nodecount
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|hashtable
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|rbt
operator|->
name|hashtable
argument_list|,
name|rbt
operator|->
name|hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dns_rbtnode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|rbt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rbtp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_rbt_nodecount
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rbt
operator|->
name|nodecount
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|chain_name
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|include_chain_end
parameter_list|)
block|{
name|dns_name_t
name|nodename
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|nodename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_chain_end
operator|&&
name|chain
operator|->
name|end
operator|!=
name|NULL
condition|)
block|{
name|NODENAME
argument_list|(
name|chain
operator|->
name|end
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_copy
argument_list|(
operator|&
name|nodename
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
name|dns_name_reset
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|chain
operator|->
name|level_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|NODENAME
argument_list|(
name|chain
operator|->
name|levels
index|[
name|i
index|]
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
operator|&
name|nodename
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|move_chain_to_last
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
do|do
block|{
comment|/* 		 * Go as far right and then down as much as possible, 		 * as long as the rightmost node has a down pointer. 		 */
while|while
condition|(
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
name|node
operator|=
name|RIGHT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOWN
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|ADD_LEVEL
argument_list|(
name|chain
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|DOWN
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|chain
operator|->
name|end
operator|=
name|node
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add 'name' to tree, initializing its data pointer with 'data'.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_addnode
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
comment|/* 	 * Does this thing have too many variables or what? 	 */
name|dns_rbtnode_t
modifier|*
modifier|*
name|root
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|child
decl_stmt|,
modifier|*
name|current
decl_stmt|,
modifier|*
name|new_current
decl_stmt|;
name|dns_name_t
modifier|*
name|add_name
decl_stmt|,
modifier|*
name|new_name
decl_stmt|,
name|current_name
decl_stmt|,
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|dns_fixedname_t
name|fixedcopy
decl_stmt|,
name|fixedprefix
decl_stmt|,
name|fixedsuffix
decl_stmt|,
name|fnewname
decl_stmt|;
name|dns_offsets_t
name|current_offsets
decl_stmt|;
name|dns_namereln_t
name|compared
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_rbtnodechain_t
name|chain
decl_stmt|;
name|unsigned
name|int
name|common_labels
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|,
name|hlabels
decl_stmt|;
name|int
name|order
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nodep
operator|!=
name|NULL
operator|&&
operator|*
name|nodep
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create a copy of the name so the original name structure is 	 * not modified. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedcopy
argument_list|)
expr_stmt|;
name|add_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedcopy
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|name
argument_list|,
name|add_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|root
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|create_node
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|add_name
argument_list|,
operator|&
name|new_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|rbt
operator|->
name|nodecount
operator|++
expr_stmt|;
name|new_current
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|rbt
operator|->
name|root
operator|=
name|new_current
expr_stmt|;
operator|*
name|nodep
operator|=
name|new_current
expr_stmt|;
name|hash_node
argument_list|(
name|rbt
argument_list|,
name|new_current
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_rbtnodechain_init
argument_list|(
operator|&
name|chain
argument_list|,
name|rbt
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedprefix
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedsuffix
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedprefix
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedsuffix
argument_list|)
expr_stmt|;
name|root
operator|=
operator|&
name|rbt
operator|->
name|root
expr_stmt|;
name|INSIST
argument_list|(
name|IS_ROOT
argument_list|(
operator|*
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|=
name|NULL
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
name|child
operator|=
operator|*
name|root
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|current_name
argument_list|,
name|current_offsets
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fnewname
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fnewname
argument_list|)
expr_stmt|;
name|nlabels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hlabels
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|current
operator|=
name|child
expr_stmt|;
name|NODENAME
argument_list|(
name|current
argument_list|,
operator|&
name|current_name
argument_list|)
expr_stmt|;
name|compared
operator|=
name|dns_name_fullcompare
argument_list|(
name|add_name
argument_list|,
operator|&
name|current_name
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|common_labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|compared
operator|==
name|dns_namereln_equal
condition|)
block|{
operator|*
name|nodep
operator|=
name|current
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|compared
operator|==
name|dns_namereln_none
condition|)
block|{
if|if
condition|(
name|order
operator|<
literal|0
condition|)
block|{
name|parent
operator|=
name|current
expr_stmt|;
name|child
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|current
expr_stmt|;
name|child
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * This name has some suffix in common with the 			 * name at the current node.  If the name at 			 * the current node is shorter, that means the 			 * new name should be in a subtree.  If the 			 * name at the current node is longer, that means 			 * the down pointer to this tree should point 			 * to a new tree that has the common suffix, and 			 * the non-common parts of these two names should 			 * start a new tree. 			 */
name|hlabels
operator|+=
name|common_labels
expr_stmt|;
if|if
condition|(
name|compared
operator|==
name|dns_namereln_subdomain
condition|)
block|{
comment|/* 				 * All of the existing labels are in common, 				 * so the new name is in a subtree. 				 * Whack off the common labels for the 				 * not-in-common part to be searched for 				 * in the next level. 				 */
name|dns_name_split
argument_list|(
name|add_name
argument_list|,
name|common_labels
argument_list|,
name|add_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * Follow the down pointer (possibly NULL). 				 */
name|root
operator|=
operator|&
name|DOWN
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|*
name|root
operator|==
name|NULL
operator|||
operator|(
name|IS_ROOT
argument_list|(
operator|*
name|root
argument_list|)
operator|&&
name|PARENT
argument_list|(
operator|*
name|root
argument_list|)
operator|==
name|current
operator|)
argument_list|)
expr_stmt|;
name|parent
operator|=
name|NULL
expr_stmt|;
name|child
operator|=
name|DOWN
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|ADD_LEVEL
argument_list|(
operator|&
name|chain
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The number of labels in common is fewer 				 * than the number of labels at the current 				 * node, so the current node must be adjusted 				 * to have just the common suffix, and a down 				 * pointer made to a new tree. 				 */
name|INSIST
argument_list|(
name|compared
operator|==
name|dns_namereln_commonancestor
operator|||
name|compared
operator|==
name|dns_namereln_contains
argument_list|)
expr_stmt|;
comment|/* 				 * Ensure the number of levels in the tree 				 * does not exceed the number of logical 				 * levels allowed by DNSSEC. 				 * 				 * XXXDCL need a better error result? 				 * 				 * XXXDCL Since chain ancestors were removed, 				 * no longer used by dns_rbt_addonlevel(), 				 * this is the only real use of chains in the 				 * function.  It could be done instead with 				 * a simple integer variable, but I am pressed 				 * for time. 				 */
if|if
condition|(
name|chain
operator|.
name|level_count
operator|==
operator|(
sizeof|sizeof
argument_list|(
name|chain
operator|.
name|levels
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|chain
operator|.
name|levels
argument_list|)
operator|)
condition|)
block|{
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
break|break;
block|}
comment|/* 				 * Split the name into two parts, a prefix 				 * which is the not-in-common parts of the 				 * two names and a suffix that is the common 				 * parts of them. 				 */
name|dns_name_split
argument_list|(
operator|&
name|current_name
argument_list|,
name|common_labels
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|result
operator|=
name|create_node
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|suffix
argument_list|,
operator|&
name|new_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
comment|/* 				 * Reproduce the tree attributes of the 				 * current node. 				 */
name|new_current
operator|->
name|is_root
operator|=
name|current
operator|->
name|is_root
expr_stmt|;
name|PARENT
argument_list|(
name|new_current
argument_list|)
operator|=
name|PARENT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|LEFT
argument_list|(
name|new_current
argument_list|)
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|RIGHT
argument_list|(
name|new_current
argument_list|)
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|COLOR
argument_list|(
name|new_current
argument_list|)
operator|=
name|COLOR
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* 				 * Fix pointers that were to the current node. 				 */
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LEFT
argument_list|(
name|parent
argument_list|)
operator|==
name|current
condition|)
name|LEFT
argument_list|(
name|parent
argument_list|)
operator|=
name|new_current
expr_stmt|;
else|else
name|RIGHT
argument_list|(
name|parent
argument_list|)
operator|=
name|new_current
expr_stmt|;
block|}
if|if
condition|(
name|LEFT
argument_list|(
name|new_current
argument_list|)
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|LEFT
argument_list|(
name|new_current
argument_list|)
argument_list|)
operator|=
name|new_current
expr_stmt|;
if|if
condition|(
name|RIGHT
argument_list|(
name|new_current
argument_list|)
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|RIGHT
argument_list|(
name|new_current
argument_list|)
argument_list|)
operator|=
name|new_current
expr_stmt|;
if|if
condition|(
operator|*
name|root
operator|==
name|current
condition|)
operator|*
name|root
operator|=
name|new_current
expr_stmt|;
name|NAMELEN
argument_list|(
name|current
argument_list|)
operator|=
name|prefix
operator|->
name|length
expr_stmt|;
name|OFFSETLEN
argument_list|(
name|current
argument_list|)
operator|=
name|prefix
operator|->
name|labels
expr_stmt|;
name|memcpy
argument_list|(
name|OFFSETS
argument_list|(
name|current
argument_list|)
argument_list|,
name|prefix
operator|->
name|offsets
argument_list|,
name|prefix
operator|->
name|labels
argument_list|)
expr_stmt|;
name|PADBYTES
argument_list|(
name|current
argument_list|)
operator|+=
operator|(
name|current_name
operator|.
name|length
operator|-
name|prefix
operator|->
name|length
operator|)
operator|+
operator|(
name|current_name
operator|.
name|labels
operator|-
name|prefix
operator|->
name|labels
operator|)
expr_stmt|;
comment|/* 				 * Set up the new root of the next level. 				 * By definition it will not be the top 				 * level tree, so clear DNS_NAMEATTR_ABSOLUTE. 				 */
name|current
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|PARENT
argument_list|(
name|current
argument_list|)
operator|=
name|new_current
expr_stmt|;
name|DOWN
argument_list|(
name|new_current
argument_list|)
operator|=
name|current
expr_stmt|;
name|root
operator|=
operator|&
name|DOWN
argument_list|(
name|new_current
argument_list|)
expr_stmt|;
name|ADD_LEVEL
argument_list|(
operator|&
name|chain
argument_list|,
name|new_current
argument_list|)
expr_stmt|;
name|LEFT
argument_list|(
name|current
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|ATTRS
argument_list|(
name|current
argument_list|)
operator|&=
operator|~
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|++
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|nlabels
operator|-
name|hlabels
argument_list|,
name|hlabels
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|hash_node
argument_list|(
name|rbt
argument_list|,
name|new_current
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|common_labels
operator|==
name|dns_name_countlabels
argument_list|(
name|add_name
argument_list|)
condition|)
block|{
comment|/* 					 * The name has been added by pushing 					 * the not-in-common parts down to 					 * a new level. 					 */
operator|*
name|nodep
operator|=
name|new_current
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 					 * The current node has no data, 					 * because it is just a placeholder. 					 * Its data pointer is already NULL 					 * from create_node()), so there's 					 * nothing more to do to it. 					 */
comment|/* 					 * The not-in-common parts of the new 					 * name will be inserted into the new 					 * level following this loop (unless 					 * result != ISC_R_SUCCESS, which 					 * is tested after the loop ends). 					 */
name|dns_name_split
argument_list|(
name|add_name
argument_list|,
name|common_labels
argument_list|,
name|add_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
do|while
condition|(
name|child
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|create_node
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|add_name
argument_list|,
operator|&
name|new_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rbt_addonlevel
argument_list|(
name|new_current
argument_list|,
name|current
argument_list|,
name|order
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|++
expr_stmt|;
operator|*
name|nodep
operator|=
name|new_current
expr_stmt|;
name|hash_node
argument_list|(
name|rbt
argument_list|,
name|new_current
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the tree of trees, associating it with some data.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_addname
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_rbt_addnode
argument_list|(
name|rbt
argument_list|,
name|name
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * dns_rbt_addnode will report the node exists even when 	 * it does not have data associated with it, but the 	 * dns_rbt_*name functions all behave depending on whether 	 * there is data associated with a node. 	 */
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
operator|(
name|result
operator|==
name|ISC_R_EXISTS
operator|&&
name|DATA
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|DATA
argument_list|(
name|node
argument_list|)
operator|=
name|data
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the node for "name" in the tree of trees.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_findnode
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|node
parameter_list|,
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rbtfindcallback_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|last_compared
decl_stmt|,
modifier|*
name|current_root
decl_stmt|;
name|dns_rbtnodechain_t
name|localchain
decl_stmt|;
name|dns_name_t
modifier|*
name|search_name
decl_stmt|,
name|current_name
decl_stmt|,
modifier|*
name|callback_name
decl_stmt|;
name|dns_fixedname_t
name|fixedcallbackname
decl_stmt|,
name|fixedsearchname
decl_stmt|;
name|dns_namereln_t
name|compared
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|saved_result
decl_stmt|;
name|unsigned
name|int
name|common_labels
decl_stmt|;
name|unsigned
name|int
name|hlabels
init|=
literal|0
decl_stmt|;
name|int
name|order
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|node
operator|!=
name|NULL
operator|&&
operator|*
name|node
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|options
operator|&
operator|(
name|DNS_RBTFIND_NOEXACT
operator||
name|DNS_RBTFIND_NOPREDECESSOR
operator|)
operator|)
operator|!=
operator|(
name|DNS_RBTFIND_NOEXACT
operator||
name|DNS_RBTFIND_NOPREDECESSOR
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is a chain it needs to appear to be in a sane state, 	 * otherwise a chain is still needed to generate foundname and 	 * callback_name. 	 */
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
block|{
name|options
operator||=
name|DNS_RBTFIND_NOPREDECESSOR
expr_stmt|;
name|chain
operator|=
operator|&
name|localchain
expr_stmt|;
name|dns_rbtnodechain_init
argument_list|(
name|chain
argument_list|,
name|rbt
operator|->
name|mctx
argument_list|)
expr_stmt|;
block|}
else|else
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|root
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
else|else
block|{
comment|/* 		 * Appease GCC about variables it incorrectly thinks are 		 * possibly used uninitialized. 		 */
name|compared
operator|=
name|dns_namereln_none
expr_stmt|;
name|last_compared
operator|=
name|NULL
expr_stmt|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedcallbackname
argument_list|)
expr_stmt|;
name|callback_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedcallbackname
argument_list|)
expr_stmt|;
comment|/* 	 * search_name is the name segment being sought in each tree level. 	 * By using a fixedname, the search_name will definitely have offsets 	 * for use by any splitting. 	 * By using dns_name_clone, no name data should be copied thanks to 	 * the lack of bitstring labels. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedsearchname
argument_list|)
expr_stmt|;
name|search_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedsearchname
argument_list|)
expr_stmt|;
name|dns_name_clone
argument_list|(
name|name
argument_list|,
name|search_name
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|current_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|saved_result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|current
operator|=
name|rbt
operator|->
name|root
expr_stmt|;
name|current_root
operator|=
name|rbt
operator|->
name|root
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
name|NODENAME
argument_list|(
name|current
argument_list|,
operator|&
name|current_name
argument_list|)
expr_stmt|;
name|compared
operator|=
name|dns_name_fullcompare
argument_list|(
name|search_name
argument_list|,
operator|&
name|current_name
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|common_labels
argument_list|)
expr_stmt|;
name|last_compared
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|compared
operator|==
name|dns_namereln_equal
condition|)
break|break;
if|if
condition|(
name|compared
operator|==
name|dns_namereln_none
condition|)
block|{
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|dns_name_t
name|hash_name
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|hnode
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|up_current
decl_stmt|;
name|unsigned
name|int
name|nlabels
decl_stmt|;
name|unsigned
name|int
name|tlabels
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
comment|/* 			 * If there is no hash table, hashing can't be done. 			 */
if|if
condition|(
name|rbt
operator|->
name|hashtable
operator|==
name|NULL
condition|)
goto|goto
name|nohash
goto|;
comment|/* 			 * The case of current != current_root, that 			 * means a left or right pointer was followed, 			 * only happens when the algorithm fell through to 			 * the traditional binary search because of a 			 * bitstring label.  Since we dropped the bitstring 			 * support, this should not happen. 			 */
name|INSIST
argument_list|(
name|current
operator|==
name|current_root
argument_list|)
expr_stmt|;
name|nlabels
operator|=
name|dns_name_countlabels
argument_list|(
name|search_name
argument_list|)
expr_stmt|;
comment|/* 			 * current_root is the root of the current level, so 			 * it's parent is the same as it's "up" pointer. 			 */
name|up_current
operator|=
name|PARENT
argument_list|(
name|current_root
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|hash_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hashagain
label|:
comment|/*  			 * Hash includes tail. 			 */
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
name|nlabels
operator|-
name|tlabels
argument_list|,
name|hlabels
operator|+
name|tlabels
argument_list|,
operator|&
name|hash_name
argument_list|)
expr_stmt|;
name|hash
operator|=
name|dns_name_fullhash
argument_list|(
operator|&
name|hash_name
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|search_name
argument_list|,
name|nlabels
operator|-
name|tlabels
argument_list|,
name|tlabels
argument_list|,
operator|&
name|hash_name
argument_list|)
expr_stmt|;
for|for
control|(
name|hnode
operator|=
name|rbt
operator|->
name|hashtable
index|[
name|hash
operator|%
name|rbt
operator|->
name|hashsize
index|]
init|;
name|hnode
operator|!=
name|NULL
condition|;
name|hnode
operator|=
name|hnode
operator|->
name|hashnext
control|)
block|{
name|dns_name_t
name|hnode_name
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
name|HASHVAL
argument_list|(
name|hnode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|find_up
argument_list|(
name|hnode
argument_list|)
operator|!=
name|up_current
condition|)
continue|continue;
name|dns_name_init
argument_list|(
operator|&
name|hnode_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NODENAME
argument_list|(
name|hnode
argument_list|,
operator|&
name|hnode_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|hnode_name
argument_list|,
operator|&
name|hash_name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|hnode
operator|!=
name|NULL
condition|)
block|{
name|current
operator|=
name|hnode
expr_stmt|;
comment|/* 				 * This is an optimization.  If hashing found 				 * the right node, the next call to 				 * dns_name_fullcompare() would obviously 				 * return _equal or _subdomain.  Determine 				 * which of those would be the case by 				 * checking if the full name was hashed.  Then 				 * make it look like dns_name_fullcompare 				 * was called and jump to the right place. 				 */
if|if
condition|(
name|tlabels
operator|==
name|nlabels
condition|)
block|{
name|compared
operator|=
name|dns_namereln_equal
expr_stmt|;
break|break;
block|}
else|else
block|{
name|common_labels
operator|=
name|tlabels
expr_stmt|;
name|compared
operator|=
name|dns_namereln_subdomain
expr_stmt|;
goto|goto
name|subdomain
goto|;
block|}
block|}
if|if
condition|(
name|tlabels
operator|++
operator|<
name|nlabels
condition|)
goto|goto
name|hashagain
goto|;
comment|/* 			 * All of the labels have been tried against the hash 			 * table.  Since we dropped the support of bitstring 			 * labels, the name isn't in the table. 			 */
name|current
operator|=
name|NULL
expr_stmt|;
continue|continue;
name|nohash
label|:
endif|#
directive|endif
comment|/* DNS_RBT_USEHASH */
comment|/* 			 * Standard binary search tree movement. 			 */
if|if
condition|(
name|order
operator|<
literal|0
condition|)
name|current
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
else|else
name|current
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The names have some common suffix labels. 			 * 			 * If the number in common are equal in length to 			 * the current node's name length, then follow the 			 * down pointer and search in the new tree. 			 */
if|if
condition|(
name|compared
operator|==
name|dns_namereln_subdomain
condition|)
block|{
name|subdomain
label|:
comment|/* 				 * Whack off the current node's common parts 				 * for the name to search in the next level. 				 */
name|dns_name_split
argument_list|(
name|search_name
argument_list|,
name|common_labels
argument_list|,
name|search_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hlabels
operator|+=
name|common_labels
expr_stmt|;
comment|/* 				 * This might be the closest enclosing name. 				 */
if|if
condition|(
name|DATA
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
name|options
operator|&
name|DNS_RBTFIND_EMPTYDATA
operator|)
operator|!=
literal|0
condition|)
operator|*
name|node
operator|=
name|current
expr_stmt|;
comment|/* 				 * Point the chain to the next level.   This 				 * needs to be done before 'current' is pointed 				 * there because the callback in the next 				 * block of code needs the current 'current', 				 * but in the event the callback requests that 				 * the search be stopped then the 				 * DNS_R_PARTIALMATCH code at the end of this 				 * function needs the chain pointed to the 				 * next level. 				 */
name|ADD_LEVEL
argument_list|(
name|chain
argument_list|,
name|current
argument_list|)
expr_stmt|;
comment|/* 				 * The caller may want to interrupt the 				 * downward search when certain special nodes 				 * are traversed.  If this is a special node, 				 * the callback is used to learn what the 				 * caller wants to do. 				 */
if|if
condition|(
name|callback
operator|!=
name|NULL
operator|&&
name|FINDCALLBACK
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|result
operator|=
name|chain_name
argument_list|(
name|chain
argument_list|,
name|callback_name
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
call|(
name|callback
call|)
argument_list|(
name|current
argument_list|,
name|callback_name
argument_list|,
name|callback_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|DNS_R_CONTINUE
condition|)
block|{
name|saved_result
operator|=
name|result
expr_stmt|;
comment|/* 						 * Treat this node as if it 						 * had no down pointer. 						 */
name|current
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
comment|/* 				 * Finally, head to the next tree level. 				 */
name|current
operator|=
name|DOWN
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current_root
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Though there are labels in common, the 				 * entire name at this node is not common 				 * with the search name so the search 				 * name does not exist in the tree. 				 */
name|INSIST
argument_list|(
name|compared
operator|==
name|dns_namereln_commonancestor
operator|||
name|compared
operator|==
name|dns_namereln_contains
argument_list|)
expr_stmt|;
name|current
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If current is not NULL, NOEXACT is not disallowing exact matches, 	 * and either the node has data or an empty node is ok, return 	 * ISC_R_SUCCESS to indicate an exact match. 	 */
if|if
condition|(
name|current
operator|!=
name|NULL
operator|&&
operator|(
name|options
operator|&
name|DNS_RBTFIND_NOEXACT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|DATA
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
name|options
operator|&
name|DNS_RBTFIND_EMPTYDATA
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Found an exact match. 		 */
name|chain
operator|->
name|end
operator|=
name|current
expr_stmt|;
name|chain
operator|->
name|level_matches
operator|=
name|chain
operator|->
name|level_count
expr_stmt|;
if|if
condition|(
name|foundname
operator|!=
name|NULL
condition|)
name|result
operator|=
name|chain_name
argument_list|(
name|chain
argument_list|,
name|foundname
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|node
operator|=
name|current
expr_stmt|;
name|result
operator|=
name|saved_result
expr_stmt|;
block|}
else|else
operator|*
name|node
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Did not find an exact match (or did not want one). 		 */
if|if
condition|(
operator|*
name|node
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * ... but found a partially matching superdomain. 			 * Unwind the chain to the partial match node 			 * to set level_matches to the level above the node, 			 * and then to derive the name. 			 * 			 * chain->level_count is guaranteed to be at least 1 			 * here because by definition of finding a superdomain, 			 * the chain is pointed to at least the first subtree. 			 */
name|chain
operator|->
name|level_matches
operator|=
name|chain
operator|->
name|level_count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|chain
operator|->
name|levels
index|[
name|chain
operator|->
name|level_matches
index|]
operator|!=
operator|*
name|node
condition|)
block|{
name|INSIST
argument_list|(
name|chain
operator|->
name|level_matches
operator|>
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|->
name|level_matches
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|foundname
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|saved_count
init|=
name|chain
operator|->
name|level_count
decl_stmt|;
name|chain
operator|->
name|level_count
operator|=
name|chain
operator|->
name|level_matches
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|chain_name
argument_list|(
name|chain
argument_list|,
name|foundname
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|chain
operator|->
name|level_count
operator|=
name|saved_count
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * There was an exact match but either 			 * DNS_RBTFIND_NOEXACT was set, or 			 * DNS_RBTFIND_EMPTYDATA was set and the node had no 			 * data.  A policy decision was made to set the 			 * chain to the exact match, but this is subject 			 * to change if it becomes apparent that something 			 * else would be more useful.  It is important that 			 * this case is handled here, because the predecessor 			 * setting code below assumes the match was not exact. 			 */
name|INSIST
argument_list|(
operator|(
operator|(
name|options
operator|&
name|DNS_RBTFIND_NOEXACT
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|options
operator|&
name|DNS_RBTFIND_EMPTYDATA
operator|)
operator|==
literal|0
operator|&&
name|DATA
argument_list|(
name|current
argument_list|)
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|options
operator|&
name|DNS_RBTFIND_NOPREDECESSOR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Ensure the chain points nowhere. 			 */
name|chain
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Since there was no exact match, the chain argument 			 * needs to be pointed at the DNSSEC predecessor of 			 * the search name. 			 */
if|if
condition|(
name|compared
operator|==
name|dns_namereln_subdomain
condition|)
block|{
comment|/* 				 * Attempted to follow a down pointer that was 				 * NULL, which means the searched for name was 				 * a subdomain of a terminal name in the tree. 				 * Since there are no existing subdomains to 				 * order against, the terminal name is the 				 * predecessor. 				 */
name|INSIST
argument_list|(
name|chain
operator|->
name|level_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|chain
operator|->
name|level_matches
operator|<
name|chain
operator|->
name|level_count
argument_list|)
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|chain
operator|->
name|levels
index|[
operator|--
name|chain
operator|->
name|level_count
index|]
expr_stmt|;
block|}
else|else
block|{
name|isc_result_t
name|result2
decl_stmt|;
comment|/* 				 * Point current to the node that stopped 				 * the search. 				 * 				 * With the hashing modification that has been 				 * added to the algorithm, the stop node of a 				 * standard binary search is not known.  So it 				 * has to be found.  There is probably a more 				 * clever way of doing this. 				 * 				 * The assignment of current to NULL when 				 * the relationship is *not* dns_namereln_none, 				 * even though it later gets set to the same 				 * last_compared anyway, is simply to not push 				 * the while loop in one more level of 				 * indentation. 				 */
if|if
condition|(
name|compared
operator|==
name|dns_namereln_none
condition|)
name|current
operator|=
name|last_compared
expr_stmt|;
else|else
name|current
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|NULL
condition|)
block|{
name|NODENAME
argument_list|(
name|current
argument_list|,
operator|&
name|current_name
argument_list|)
expr_stmt|;
name|compared
operator|=
name|dns_name_fullcompare
argument_list|(
name|search_name
argument_list|,
operator|&
name|current_name
argument_list|,
operator|&
name|order
argument_list|,
operator|&
name|common_labels
argument_list|)
expr_stmt|;
name|last_compared
operator|=
name|current
expr_stmt|;
comment|/* 					 * Standard binary search movement. 					 */
if|if
condition|(
name|order
operator|<
literal|0
condition|)
name|current
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
else|else
name|current
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
name|current
operator|=
name|last_compared
expr_stmt|;
comment|/* 				 * Reached a point within a level tree that 				 * positively indicates the name is not 				 * present, but the stop node could be either 				 * less than the desired name (order> 0) or 				 * greater than the desired name (order< 0). 				 * 				 * If the stop node is less, it is not 				 * necessarily the predecessor.  If the stop 				 * node has a down pointer, then the real 				 * predecessor is at the end of a level below 				 * (not necessarily the next level). 				 * Move down levels until the rightmost node 				 * does not have a down pointer. 				 * 				 * When the stop node is greater, it is 				 * the successor.  All the logic for finding 				 * the predecessor is handily encapsulated 				 * in dns_rbtnodechain_prev.  In the event 				 * that the search name is less than anything 				 * else in the tree, the chain is reset. 				 * XXX DCL What is the best way for the caller 				 *         to know that the search name has 				 *         no predecessor? 				 */
if|if
condition|(
name|order
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|DOWN
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ADD_LEVEL
argument_list|(
name|chain
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|result2
operator|=
name|move_chain_to_last
argument_list|(
name|chain
argument_list|,
name|DOWN
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result2
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|result2
expr_stmt|;
block|}
else|else
comment|/* 						 * Ah, the pure and simple 						 * case.  The stop node is the 						 * predecessor. 						 */
name|chain
operator|->
name|end
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|order
operator|<
literal|0
argument_list|)
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|current
expr_stmt|;
name|result2
operator|=
name|dns_rbtnodechain_prev
argument_list|(
name|chain
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result2
operator|==
name|ISC_R_SUCCESS
operator|||
name|result2
operator|==
name|DNS_R_NEWORIGIN
condition|)
empty_stmt|;
comment|/* Nothing. */
elseif|else
if|if
condition|(
name|result2
operator|==
name|ISC_R_NOMORE
condition|)
comment|/* 						 * There is no predecessor. 						 */
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|result2
expr_stmt|;
block|}
block|}
block|}
block|}
name|ENSURE
argument_list|(
operator|*
name|node
operator|==
name|NULL
operator|||
name|DNS_RBTNODE_VALID
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the data pointer associated with 'name'.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_findname
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|data
operator|!=
name|NULL
operator|&&
operator|*
name|data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbt
argument_list|,
name|name
argument_list|,
name|foundname
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
operator|&&
operator|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
name|options
operator|&
name|DNS_RBTFIND_EMPTYDATA
operator|)
operator|!=
literal|0
operator|)
condition|)
operator|*
name|data
operator|=
name|DATA
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a name from the tree of trees.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_deletename
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|recurse
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, find the node. 	 * 	 * When searching, the name might not have an exact match: 	 * consider a.b.a.com, b.b.a.com and c.b.a.com as the only 	 * elements of a tree, which would make layer 1 a single 	 * node tree of "b.a.com" and layer 2 a three node tree of 	 * a, b, and c.  Deleting a.com would find only a partial depth 	 * match in the first layer.  Should it be a requirement that 	 * that the name to be deleted have data?  For now, it is. 	 * 	 * ->dirty, ->locknum and ->references are ignored; they are 	 * solely the province of rbtdb.c. 	 */
name|result
operator|=
name|dns_rbt_findnode
argument_list|(
name|rbt
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
name|DNS_RBTFIND_NOOPTIONS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
name|result
operator|=
name|dns_rbt_deletenode
argument_list|(
name|rbt
argument_list|,
name|node
argument_list|,
name|recurse
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|DNS_R_PARTIALMATCH
condition|)
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a node from the tree of trees.  *  * NOTE WELL: deletion is *not* symmetric with addition; that is, reversing  * a sequence of additions to be deletions will not generally get the  * tree back to the state it started in.  For example, if the addition  * of "b.c" caused the node "a.b.c" to be split, pushing "a" to its own level,  * then the subsequent deletion of "b.c" will not cause "a" to be pulled up,  * restoring "a.b.c".  The RBT *used* to do this kind of rejoining, but it  * turned out to be a bad idea because it could corrupt an active nodechain  * that had "b.c" as one of its levels -- and the RBT has no idea what  * nodechains are in use by callers, so it can't even *try* to helpfully  * fix them up (which would probably be doomed to failure anyway).  *  * Similarly, it is possible to leave the tree in a state where a supposedly  * deleted node still exists.  The first case of this is obvious; take  * the tree which has "b.c" on one level, pointing to "a".  Now deleted "b.c".  * It was just established in the previous paragraph why we can't pull "a"  * back up to its parent level.  But what happens when "a" then gets deleted?  * "b.c" is left hanging around without data or children.  This condition  * is actually pretty easy to detect, but ... should it really be removed?  * Is a chain pointing to it?  An iterator?  Who knows!  (Note that the  * references structure member cannot be looked at because it is private to  * rbtdb.)  This is ugly and makes me unhappy, but after hours of trying to  * make it more aesthetically proper and getting nowhere, this is the way it  * is going to stay until such time as it proves to be a *real* problem.  *  * Finally, for reference, note that the original routine that did node  * joining was called join_nodes().  It has been excised, living now only  * in the CVS history, but comments have been left behind that point to it just  * in case someone wants to muck with this some more.  *  * The one positive aspect of all of this is that joining used to have a  * case where it might fail.  Without trying to join, now this function always  * succeeds. It still returns isc_result_t, though, so the API wouldn't change.  */
end_comment

begin_function
name|isc_result_t
name|dns_rbt_deletenode
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|isc_boolean_t
name|recurse
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|parent
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOWN
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|recurse
condition|)
name|RUNTIME_CHECK
argument_list|(
name|dns_rbt_deletetree
argument_list|(
name|rbt
argument_list|,
name|DOWN
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|&&
name|rbt
operator|->
name|data_deleter
operator|!=
name|NULL
condition|)
name|rbt
operator|->
name|data_deleter
argument_list|(
name|DATA
argument_list|(
name|node
argument_list|)
argument_list|,
name|rbt
operator|->
name|deleter_arg
argument_list|)
expr_stmt|;
name|DATA
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Since there is at least one node below this one and 			 * no recursion was requested, the deletion is 			 * complete.  The down node from this node might be all 			 * by itself on a single level, so join_nodes() could 			 * be used to collapse the tree (with all the caveats 			 * of the comment at the start of this function). 			 */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
comment|/* 	 * Note the node that points to the level of the node that is being 	 * deleted.  If the deleted node is the top level, parent will be set 	 * to NULL. 	 */
name|parent
operator|=
name|find_up
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * This node now has no down pointer (either because it didn't 	 * have one to start, or because it was recursively removed). 	 * So now the node needs to be removed from this level. 	 */
name|dns_rbt_deletefromlevel
argument_list|(
name|node
argument_list|,
name|parent
operator|==
name|NULL
condition|?
operator|&
name|rbt
operator|->
name|root
else|:
operator|&
name|DOWN
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|&&
name|rbt
operator|->
name|data_deleter
operator|!=
name|NULL
condition|)
name|rbt
operator|->
name|data_deleter
argument_list|(
name|DATA
argument_list|(
name|node
argument_list|)
argument_list|,
name|rbt
operator|->
name|deleter_arg
argument_list|)
expr_stmt|;
name|unhash_node
argument_list|(
name|rbt
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RBT_USEMAGIC
name|node
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|node
argument_list|,
name|NODE_SIZE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|--
expr_stmt|;
comment|/* 	 * There are now two special cases that can exist that would 	 * not have existed if the tree had been created using only 	 * the names that now exist in it.  (This is all related to 	 * join_nodes() as described in this function's introductory comment.) 	 * Both cases exist when the deleted node's parent (the node 	 * that pointed to the deleted node's level) is not null but 	 * it has no data:  parent != NULL&& DATA(parent) == NULL. 	 * 	 * The first case is that the deleted node was the last on its level: 	 * DOWN(parent) == NULL.  This case can only exist if the parent was 	 * previously deleted -- and so now, apparently, the parent should go 	 * away.  That can't be done though because there might be external 	 * references to it, such as through a nodechain. 	 * 	 * The other case also involves a parent with no data, but with the 	 * deleted node being the next-to-last node instead of the last: 	 * LEFT(DOWN(parent)) == NULL&& RIGHT(DOWN(parent)) == NULL. 	 * Presumably now the remaining node on the level should be joined 	 * with the parent, but it's already been described why that can't be 	 * done. 	 */
comment|/* 	 * This function never fails. 	 */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_rbt_namefromnode
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|offsets
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|NODENAME
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbt_fullnamefromnode
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|dns_name_t
name|current
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|current
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_reset
argument_list|(
name|name
argument_list|)
expr_stmt|;
do|do
block|{
name|INSIST
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|NODENAME
argument_list|(
name|node
argument_list|,
operator|&
name|current
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_concatenate
argument_list|(
name|name
argument_list|,
operator|&
name|current
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
name|node
operator|=
name|find_up
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
condition|)
do|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dns_rbt_formatnodename
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|printname
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|printname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rbt_fullnamefromnode
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|printname
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|printname
argument_list|,
name|size
argument_list|,
literal|"<error building name: %s>"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|printname
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|create_node
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|unsigned
name|int
name|labels
decl_stmt|;
name|REQUIRE
argument_list|(
name|name
operator|->
name|offsets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|name
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|labels
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for the node structure, the name, and the offsets. 	 */
name|node
operator|=
operator|(
name|dns_rbtnode_t
operator|*
operator|)
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
operator|+
name|region
operator|.
name|length
operator|+
name|labels
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|node
operator|->
name|is_root
operator|=
literal|0
expr_stmt|;
name|PARENT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LEFT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DOWN
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DATA
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
name|HASHNEXT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|HASHVAL
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|LOCKNUM
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REFS
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|WILD
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DIRTY
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|find_callback
operator|=
literal|0
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * The following is stored to make reconstructing a name from the 	 * stored value in the node easy:  the length of the name, the number 	 * of labels, whether the name is absolute or not, the name itself, 	 * and the name's offsets table. 	 * 	 * XXX RTH 	 *	The offsets table could be made smaller by eliminating the 	 *	first offset, which is always 0.  This requires changes to 	 * 	lib/dns/name.c. 	 */
name|NAMELEN
argument_list|(
name|node
argument_list|)
operator|=
name|region
operator|.
name|length
expr_stmt|;
name|PADBYTES
argument_list|(
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
name|OFFSETLEN
argument_list|(
name|node
argument_list|)
operator|=
name|labels
expr_stmt|;
name|ATTRS
argument_list|(
name|node
argument_list|)
operator|=
name|name
operator|->
name|attributes
expr_stmt|;
name|memcpy
argument_list|(
name|NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|region
operator|.
name|base
argument_list|,
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|OFFSETS
argument_list|(
name|node
argument_list|)
argument_list|,
name|name
operator|->
name|offsets
argument_list|,
name|labels
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RBT_USEMAGIC
name|node
operator|->
name|magic
operator|=
name|DNS_RBTNODE_MAGIC
expr_stmt|;
endif|#
directive|endif
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DNS_RBT_USEHASH
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|hash_add_node
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|HASHVAL
argument_list|(
name|node
argument_list|)
operator|=
name|dns_name_fullhash
argument_list|(
name|name
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|hash
operator|=
name|HASHVAL
argument_list|(
name|node
argument_list|)
operator|%
name|rbt
operator|->
name|hashsize
expr_stmt|;
name|HASHNEXT
argument_list|(
name|node
argument_list|)
operator|=
name|rbt
operator|->
name|hashtable
index|[
name|hash
index|]
expr_stmt|;
name|rbt
operator|->
name|hashtable
index|[
name|hash
index|]
operator|=
name|node
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|inithash
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|)
block|{
name|unsigned
name|int
name|bytes
decl_stmt|;
name|rbt
operator|->
name|hashsize
operator|=
name|RBT_HASH_SIZE
expr_stmt|;
name|bytes
operator|=
name|rbt
operator|->
name|hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dns_rbtnode_t
operator|*
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|hashtable
operator|=
name|isc_mem_get
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|hashtable
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|rbt
operator|->
name|hashtable
argument_list|,
literal|0
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rehash
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|)
block|{
name|unsigned
name|int
name|oldsize
decl_stmt|;
name|dns_rbtnode_t
modifier|*
modifier|*
name|oldtable
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|oldsize
operator|=
name|rbt
operator|->
name|hashsize
expr_stmt|;
name|oldtable
operator|=
name|rbt
operator|->
name|hashtable
expr_stmt|;
name|rbt
operator|->
name|hashsize
operator|*=
literal|2
operator|+
literal|1
expr_stmt|;
name|rbt
operator|->
name|hashtable
operator|=
name|isc_mem_get
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|rbt
operator|->
name|hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dns_rbtnode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|hashtable
operator|==
name|NULL
condition|)
block|{
name|rbt
operator|->
name|hashtable
operator|=
name|oldtable
expr_stmt|;
name|rbt
operator|->
name|hashsize
operator|=
name|oldsize
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rbt
operator|->
name|hashsize
condition|;
name|i
operator|++
control|)
name|rbt
operator|->
name|hashtable
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|oldtable
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|hash
operator|=
name|HASHVAL
argument_list|(
name|node
argument_list|)
operator|%
name|rbt
operator|->
name|hashsize
expr_stmt|;
name|oldtable
index|[
name|i
index|]
operator|=
name|HASHNEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|HASHNEXT
argument_list|(
name|node
argument_list|)
operator|=
name|rbt
operator|->
name|hashtable
index|[
name|hash
index|]
expr_stmt|;
name|rbt
operator|->
name|hashtable
index|[
name|hash
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|oldtable
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|oldtable
argument_list|,
name|oldsize
operator|*
sizeof|sizeof
argument_list|(
name|dns_rbtnode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hash_node
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|nodecount
operator|>=
operator|(
name|rbt
operator|->
name|hashsize
operator|*
literal|3
operator|)
condition|)
name|rehash
argument_list|(
name|rbt
argument_list|)
expr_stmt|;
name|hash_add_node
argument_list|(
name|rbt
argument_list|,
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unhash_node
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|unsigned
name|int
name|bucket
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|bucket_node
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbt
operator|->
name|hashtable
operator|!=
name|NULL
condition|)
block|{
name|bucket
operator|=
name|HASHVAL
argument_list|(
name|node
argument_list|)
operator|%
name|rbt
operator|->
name|hashsize
expr_stmt|;
name|bucket_node
operator|=
name|rbt
operator|->
name|hashtable
index|[
name|bucket
index|]
expr_stmt|;
if|if
condition|(
name|bucket_node
operator|==
name|node
condition|)
name|rbt
operator|->
name|hashtable
index|[
name|bucket
index|]
operator|=
name|HASHNEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|HASHNEXT
argument_list|(
name|bucket_node
argument_list|)
operator|!=
name|node
condition|)
block|{
name|INSIST
argument_list|(
name|HASHNEXT
argument_list|(
name|bucket_node
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bucket_node
operator|=
name|HASHNEXT
argument_list|(
name|bucket_node
argument_list|)
expr_stmt|;
block|}
name|HASHNEXT
argument_list|(
name|bucket_node
argument_list|)
operator|=
name|HASHNEXT
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNS_RBT_USEHASH */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|rotate_left
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|child
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rootp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|child
operator|=
name|RIGHT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|=
name|LEFT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|child
argument_list|)
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|LEFT
argument_list|(
name|child
argument_list|)
argument_list|)
operator|=
name|node
expr_stmt|;
name|LEFT
argument_list|(
name|child
argument_list|)
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|child
argument_list|)
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ROOT
argument_list|(
name|node
argument_list|)
condition|)
block|{
operator|*
name|rootp
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|is_root
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|node
condition|)
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
else|else
name|RIGHT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
block|}
name|PARENT
argument_list|(
name|node
argument_list|)
operator|=
name|child
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rotate_right
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|child
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|rootp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|child
operator|=
name|LEFT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LEFT
argument_list|(
name|node
argument_list|)
operator|=
name|RIGHT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIGHT
argument_list|(
name|child
argument_list|)
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|RIGHT
argument_list|(
name|child
argument_list|)
argument_list|)
operator|=
name|node
expr_stmt|;
name|RIGHT
argument_list|(
name|child
argument_list|)
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|child
argument_list|)
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ROOT
argument_list|(
name|node
argument_list|)
condition|)
block|{
operator|*
name|rootp
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|is_root
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
name|node
condition|)
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
else|else
name|RIGHT
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
block|}
name|PARENT
argument_list|(
name|node
argument_list|)
operator|=
name|child
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the real workhorse of the insertion code, because it does the  * true red/black tree on a single level.  */
end_comment

begin_function
specifier|static
name|void
name|dns_rbt_addonlevel
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|current
parameter_list|,
name|int
name|order
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|child
decl_stmt|,
modifier|*
name|root
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|grandparent
decl_stmt|;
name|dns_name_t
name|add_name
decl_stmt|,
name|current_name
decl_stmt|;
name|dns_offsets_t
name|add_offsets
decl_stmt|,
name|current_offsets
decl_stmt|;
name|REQUIRE
argument_list|(
name|rootp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_RBTNODE_VALID
argument_list|(
name|node
argument_list|)
operator|&&
name|LEFT
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
operator|&&
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|current
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|root
operator|=
operator|*
name|rootp
expr_stmt|;
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * First node of a level. 		 */
name|MAKE_BLACK
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|PARENT
argument_list|(
name|node
argument_list|)
operator|=
name|current
expr_stmt|;
operator|*
name|rootp
operator|=
name|node
expr_stmt|;
return|return;
block|}
name|child
operator|=
name|root
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|add_name
argument_list|,
name|add_offsets
argument_list|)
expr_stmt|;
name|NODENAME
argument_list|(
name|node
argument_list|,
operator|&
name|add_name
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|current_name
argument_list|,
name|current_offsets
argument_list|)
expr_stmt|;
name|NODENAME
argument_list|(
name|current
argument_list|,
operator|&
name|current_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|<
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|LEFT
argument_list|(
name|current
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LEFT
argument_list|(
name|current
argument_list|)
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|INSIST
argument_list|(
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|=
name|node
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|PARENT
argument_list|(
name|node
argument_list|)
operator|=
name|current
expr_stmt|;
name|MAKE_RED
argument_list|(
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|root
operator|&&
name|IS_RED
argument_list|(
name|PARENT
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * XXXDCL could do away with separate parent and grandparent 		 * variables.  They are vestiges of the days before parent 		 * pointers.  However, they make the code a little clearer. 		 */
name|parent
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|grandparent
operator|=
name|PARENT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|LEFT
argument_list|(
name|grandparent
argument_list|)
condition|)
block|{
name|child
operator|=
name|RIGHT
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
operator|&&
name|IS_RED
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
name|node
operator|=
name|grandparent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|==
name|RIGHT
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|rotate_left
argument_list|(
name|parent
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|grandparent
operator|=
name|PARENT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
name|rotate_right
argument_list|(
name|grandparent
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|child
operator|=
name|LEFT
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
operator|&&
name|IS_RED
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
name|node
operator|=
name|grandparent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|node
operator|==
name|LEFT
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|rotate_right
argument_list|(
name|parent
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|grandparent
operator|=
name|PARENT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|grandparent
argument_list|)
expr_stmt|;
name|rotate_left
argument_list|(
name|grandparent
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|MAKE_BLACK
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ENSURE
argument_list|(
name|IS_ROOT
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rootp
operator|=
name|root
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is the real workhorse of the deletion code, because it does the  * true red/black tree on a single level.  */
end_comment

begin_function
specifier|static
name|void
name|dns_rbt_deletefromlevel
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|delete
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|rootp
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|child
decl_stmt|,
modifier|*
name|sibling
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|successor
decl_stmt|;
name|REQUIRE
argument_list|(
name|delete
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the parent history is (apparently) correct. 	 */
name|INSIST
argument_list|(
operator|(
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
operator|&&
operator|*
name|rootp
operator|==
name|delete
operator|)
operator|||
operator|(
operator|!
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
operator|&&
operator|(
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|==
name|delete
operator|||
name|RIGHT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|==
name|delete
operator|)
operator|)
argument_list|)
expr_stmt|;
name|child
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|delete
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|RIGHT
argument_list|(
name|delete
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
condition|)
block|{
comment|/* 				 * This is the only item in the tree. 				 */
operator|*
name|rootp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* 			 * This node has one child, on the right. 			 */
name|child
operator|=
name|RIGHT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIGHT
argument_list|(
name|delete
argument_list|)
operator|==
name|NULL
condition|)
comment|/* 		 * This node has one child, on the left. 		 */
name|child
operator|=
name|LEFT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
else|else
block|{
name|dns_rbtnode_t
name|holder
decl_stmt|,
modifier|*
name|tmp
init|=
operator|&
name|holder
decl_stmt|;
comment|/* 		 * This node has two children, so it cannot be directly 		 * deleted.  Find its immediate in-order successor and 		 * move it to this location, then do the deletion at the 		 * old site of the successor. 		 */
name|successor
operator|=
name|RIGHT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
while|while
condition|(
name|LEFT
argument_list|(
name|successor
argument_list|)
operator|!=
name|NULL
condition|)
name|successor
operator|=
name|LEFT
argument_list|(
name|successor
argument_list|)
expr_stmt|;
comment|/* 		 * The successor cannot possibly have a left child; 		 * if there is any child, it is on the right. 		 */
if|if
condition|(
name|RIGHT
argument_list|(
name|successor
argument_list|)
operator|!=
name|NULL
condition|)
name|child
operator|=
name|RIGHT
argument_list|(
name|successor
argument_list|)
expr_stmt|;
comment|/* 		 * Swap the two nodes; it would be simpler to just replace 		 * the value being deleted with that of the successor, 		 * but this rigamarole is done so the caller has complete 		 * control over the pointers (and memory allocation) of 		 * all of nodes.  If just the key value were removed from 		 * the tree, the pointer to the node would be unchanged. 		 */
comment|/* 		 * First, put the successor in the tree location of the 		 * node to be deleted.  Save its existing tree pointer 		 * information, which will be needed when linking up 		 * delete to the successor's old location. 		 */
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|successor
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_rbtnode_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
condition|)
block|{
operator|*
name|rootp
operator|=
name|successor
expr_stmt|;
name|successor
operator|->
name|is_root
operator|=
name|ISC_TRUE
expr_stmt|;
name|delete
operator|->
name|is_root
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|==
name|delete
condition|)
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|=
name|successor
expr_stmt|;
else|else
name|RIGHT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|=
name|successor
expr_stmt|;
name|PARENT
argument_list|(
name|successor
argument_list|)
operator|=
name|PARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|LEFT
argument_list|(
name|successor
argument_list|)
operator|=
name|LEFT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|RIGHT
argument_list|(
name|successor
argument_list|)
operator|=
name|RIGHT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|COLOR
argument_list|(
name|successor
argument_list|)
operator|=
name|COLOR
argument_list|(
name|delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|successor
argument_list|)
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|LEFT
argument_list|(
name|successor
argument_list|)
argument_list|)
operator|=
name|successor
expr_stmt|;
if|if
condition|(
name|RIGHT
argument_list|(
name|successor
argument_list|)
operator|!=
name|successor
condition|)
name|PARENT
argument_list|(
name|RIGHT
argument_list|(
name|successor
argument_list|)
argument_list|)
operator|=
name|successor
expr_stmt|;
comment|/* 		 * Now relink the node to be deleted into the 		 * successor's previous tree location.  PARENT(tmp) 		 * is the successor's original parent. 		 */
name|INSIST
argument_list|(
operator|!
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARENT
argument_list|(
name|tmp
argument_list|)
operator|==
name|delete
condition|)
block|{
comment|/* 			 * Node being deleted was successor's parent. 			 */
name|RIGHT
argument_list|(
name|successor
argument_list|)
operator|=
name|delete
expr_stmt|;
name|PARENT
argument_list|(
name|delete
argument_list|)
operator|=
name|successor
expr_stmt|;
block|}
else|else
block|{
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|=
name|delete
expr_stmt|;
name|PARENT
argument_list|(
name|delete
argument_list|)
operator|=
name|PARENT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Original location of successor node has no left. 		 */
name|LEFT
argument_list|(
name|delete
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|RIGHT
argument_list|(
name|delete
argument_list|)
operator|=
name|RIGHT
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|COLOR
argument_list|(
name|delete
argument_list|)
operator|=
name|COLOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the node by removing the links from its parent. 	 */
if|if
condition|(
operator|!
name|IS_ROOT
argument_list|(
name|delete
argument_list|)
condition|)
block|{
if|if
condition|(
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|==
name|delete
condition|)
name|LEFT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
else|else
name|RIGHT
argument_list|(
name|PARENT
argument_list|(
name|delete
argument_list|)
argument_list|)
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|PARENT
argument_list|(
name|child
argument_list|)
operator|=
name|PARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is the root being deleted, and at this point 		 * it is known to have just one child. 		 */
operator|*
name|rootp
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|is_root
operator|=
literal|1
expr_stmt|;
name|PARENT
argument_list|(
name|child
argument_list|)
operator|=
name|PARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fix color violations. 	 */
if|if
condition|(
name|IS_BLACK
argument_list|(
name|delete
argument_list|)
condition|)
block|{
name|parent
operator|=
name|PARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
while|while
condition|(
name|child
operator|!=
operator|*
name|rootp
operator|&&
name|IS_BLACK
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|child
operator|==
name|NULL
operator|||
operator|!
name|IS_ROOT
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|parent
argument_list|)
operator|==
name|child
condition|)
block|{
name|sibling
operator|=
name|RIGHT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RED
argument_list|(
name|sibling
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|rotate_left
argument_list|(
name|parent
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|RIGHT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_BLACK
argument_list|(
name|LEFT
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|&&
name|IS_BLACK
argument_list|(
name|RIGHT
argument_list|(
name|sibling
argument_list|)
argument_list|)
condition|)
block|{
name|MAKE_RED
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|child
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_BLACK
argument_list|(
name|RIGHT
argument_list|(
name|sibling
argument_list|)
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|LEFT
argument_list|(
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|rotate_right
argument_list|(
name|sibling
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|RIGHT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|COLOR
argument_list|(
name|sibling
argument_list|)
operator|=
name|COLOR
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|RIGHT
argument_list|(
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
name|rotate_left
argument_list|(
name|parent
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|child
operator|=
operator|*
name|rootp
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * Child is parent's right child. 				 * Everything is doen the same as above, 				 * except mirrored. 				 */
name|sibling
operator|=
name|LEFT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RED
argument_list|(
name|sibling
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|rotate_right
argument_list|(
name|parent
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|LEFT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_BLACK
argument_list|(
name|LEFT
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|&&
name|IS_BLACK
argument_list|(
name|RIGHT
argument_list|(
name|sibling
argument_list|)
argument_list|)
condition|)
block|{
name|MAKE_RED
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|child
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_BLACK
argument_list|(
name|LEFT
argument_list|(
name|sibling
argument_list|)
argument_list|)
condition|)
block|{
name|MAKE_BLACK
argument_list|(
name|RIGHT
argument_list|(
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
name|MAKE_RED
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
name|rotate_left
argument_list|(
name|sibling
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|sibling
operator|=
name|LEFT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|COLOR
argument_list|(
name|sibling
argument_list|)
operator|=
name|COLOR
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|MAKE_BLACK
argument_list|(
name|LEFT
argument_list|(
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
name|rotate_right
argument_list|(
name|parent
argument_list|,
name|rootp
argument_list|)
expr_stmt|;
name|child
operator|=
operator|*
name|rootp
expr_stmt|;
block|}
block|}
name|parent
operator|=
name|PARENT
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_RED
argument_list|(
name|child
argument_list|)
condition|)
name|MAKE_BLACK
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This should only be used on the root of a tree, because no color fixup  * is done at all.  *  * NOTE: No root pointer maintenance is done, because the function is only  * used for two cases:  * + deleting everything DOWN from a node that is itself being deleted, and  * + deleting the entire tree of trees from dns_rbt_destroy.  * In each case, the root pointer is no longer relevant, so there  * is no need for a root parameter to this function.  *  * If the function is ever intended to be used to delete something where  * a pointer needs to be told that this tree no longer exists,  * this function would need to adjusted accordingly.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dns_rbt_deletetree
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|LEFT
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_deletetree
argument_list|(
name|rbt
argument_list|,
name|LEFT
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|LEFT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_deletetree
argument_list|(
name|rbt
argument_list|,
name|RIGHT
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DOWN
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dns_rbt_deletetree
argument_list|(
name|rbt
argument_list|,
name|DOWN
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|DOWN
argument_list|(
name|node
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|&&
name|rbt
operator|->
name|data_deleter
operator|!=
name|NULL
condition|)
name|rbt
operator|->
name|data_deleter
argument_list|(
name|DATA
argument_list|(
name|node
argument_list|)
argument_list|,
name|rbt
operator|->
name|deleter_arg
argument_list|)
expr_stmt|;
name|unhash_node
argument_list|(
name|rbt
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|#
directive|if
name|DNS_RBT_USEMAGIC
name|node
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|node
argument_list|,
name|NODE_SIZE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|--
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_rbt_deletetreeflat
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|unsigned
name|int
name|quantum
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|parent
decl_stmt|;
name|dns_rbtnode_t
modifier|*
name|node
init|=
operator|*
name|nodep
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|traverse
label|:
if|if
condition|(
name|LEFT
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|LEFT
argument_list|(
name|node
argument_list|)
expr_stmt|;
goto|goto
name|traverse
goto|;
block|}
if|if
condition|(
name|RIGHT
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|RIGHT
argument_list|(
name|node
argument_list|)
expr_stmt|;
goto|goto
name|traverse
goto|;
block|}
if|if
condition|(
name|DOWN
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|DOWN
argument_list|(
name|node
argument_list|)
expr_stmt|;
goto|goto
name|traverse
goto|;
block|}
if|if
condition|(
name|DATA
argument_list|(
name|node
argument_list|)
operator|!=
name|NULL
operator|&&
name|rbt
operator|->
name|data_deleter
operator|!=
name|NULL
condition|)
name|rbt
operator|->
name|data_deleter
argument_list|(
name|DATA
argument_list|(
name|node
argument_list|)
argument_list|,
name|rbt
operator|->
name|deleter_arg
argument_list|)
expr_stmt|;
comment|/* 	 * Note: we don't call unhash_node() here as we are destroying 	 * the complete rbt tree.           */
if|#
directive|if
name|DNS_RBT_USEMAGIC
name|node
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|parent
operator|=
name|PARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LEFT
argument_list|(
name|parent
argument_list|)
operator|==
name|node
condition|)
name|LEFT
argument_list|(
name|parent
argument_list|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|DOWN
argument_list|(
name|parent
argument_list|)
operator|==
name|node
condition|)
name|DOWN
argument_list|(
name|parent
argument_list|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|RIGHT
argument_list|(
name|parent
argument_list|)
operator|==
name|node
condition|)
name|RIGHT
argument_list|(
name|parent
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|rbt
operator|->
name|mctx
argument_list|,
name|node
argument_list|,
name|NODE_SIZE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|rbt
operator|->
name|nodecount
operator|--
expr_stmt|;
name|node
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|quantum
operator|!=
literal|0
operator|&&
operator|--
name|quantum
operator|==
literal|0
condition|)
block|{
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
return|return;
block|}
goto|goto
name|again
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_rbt_indent
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_rbt_printnodename
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|node
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
name|char
name|buffer
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_offsets_t
name|offsets
decl_stmt|;
name|r
operator|.
name|length
operator|=
name|NAMELEN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|r
operator|.
name|base
operator|=
name|NAME
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
operator|&
name|name
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dns_rbt_printtree
parameter_list|(
name|dns_rbtnode_t
modifier|*
name|root
parameter_list|,
name|dns_rbtnode_t
modifier|*
name|parent
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|dns_rbt_indent
argument_list|(
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
block|{
name|dns_rbt_printnodename
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%s"
argument_list|,
name|IS_RED
argument_list|(
name|root
argument_list|)
condition|?
literal|"RED"
else|:
literal|"black"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|printf
argument_list|(
literal|" from "
argument_list|)
expr_stmt|;
name|dns_rbt_printnodename
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|IS_ROOT
argument_list|(
name|root
argument_list|)
operator|&&
name|PARENT
argument_list|(
name|root
argument_list|)
operator|!=
name|parent
operator|)
operator|||
operator|(
name|IS_ROOT
argument_list|(
name|root
argument_list|)
operator|&&
name|depth
operator|>
literal|0
operator|&&
name|DOWN
argument_list|(
name|PARENT
argument_list|(
name|root
argument_list|)
argument_list|)
operator|!=
name|root
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" (BAD parent pointer! -> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|PARENT
argument_list|(
name|root
argument_list|)
operator|!=
name|NULL
condition|)
name|dns_rbt_printnodename
argument_list|(
name|PARENT
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|DOWN
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|dns_rbt_indent
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"++ BEG down from "
argument_list|)
expr_stmt|;
name|dns_rbt_printnodename
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dns_rbt_printtree
argument_list|(
name|DOWN
argument_list|(
name|root
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|dns_rbt_indent
argument_list|(
name|depth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-- END down from "
argument_list|)
expr_stmt|;
name|dns_rbt_printnodename
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_RED
argument_list|(
name|root
argument_list|)
operator|&&
name|IS_RED
argument_list|(
name|LEFT
argument_list|(
name|root
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"** Red/Red color violation on left\n"
argument_list|)
expr_stmt|;
name|dns_rbt_printtree
argument_list|(
name|LEFT
argument_list|(
name|root
argument_list|)
argument_list|,
name|root
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_RED
argument_list|(
name|root
argument_list|)
operator|&&
name|IS_RED
argument_list|(
name|RIGHT
argument_list|(
name|root
argument_list|)
argument_list|)
condition|)
name|printf
argument_list|(
literal|"** Red/Red color violation on right\n"
argument_list|)
expr_stmt|;
name|dns_rbt_printtree
argument_list|(
name|RIGHT
argument_list|(
name|root
argument_list|)
argument_list|,
name|root
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"NULL\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_rbt_printall
parameter_list|(
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbt_printtree
argument_list|(
name|rbt
operator|->
name|root
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Chain Functions  */
end_comment

begin_function
name|void
name|dns_rbtnodechain_init
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
comment|/* 	 * Initialize 'chain'. 	 */
name|REQUIRE
argument_list|(
name|chain
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chain
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
name|chain
operator|->
name|level_count
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|level_matches
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|magic
operator|=
name|CHAIN_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbtnodechain_current
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rbtnode_t
modifier|*
modifier|*
name|node
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
operator|*
name|node
operator|=
name|chain
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|end
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|NODENAME
argument_list|(
name|chain
operator|->
name|end
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|level_count
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Names in the top level tree are all absolute. 			 * Always make 'name' relative. 			 */
name|INSIST
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * This is cheaper than dns_name_getlabelsequence(). 			 */
name|name
operator|->
name|labels
operator|--
expr_stmt|;
name|name
operator|->
name|length
operator|--
expr_stmt|;
name|name
operator|->
name|attributes
operator|&=
operator|~
name|DNS_NAMEATTR_ABSOLUTE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chain
operator|->
name|level_count
operator|>
literal|0
condition|)
name|result
operator|=
name|chain_name
argument_list|(
name|chain
argument_list|,
name|origin
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|dns_name_copy
argument_list|(
name|dns_rootname
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbtnodechain_prev
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|previous
decl_stmt|,
modifier|*
name|predecessor
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|new_origin
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
operator|&&
name|chain
operator|->
name|end
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|predecessor
operator|=
name|NULL
expr_stmt|;
name|current
operator|=
name|chain
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Moving left one then right as far as possible is the 		 * previous node, at least for this level. 		 */
name|current
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
while|while
condition|(
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
name|current
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|predecessor
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No left links, so move toward the root.  If at any point on 		 * the way there the link from parent to child is a right 		 * link, then the parent is the previous node, at least 		 * for this level. 		 */
while|while
condition|(
operator|!
name|IS_ROOT
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|previous
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|PARENT
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|==
name|previous
condition|)
block|{
name|predecessor
operator|=
name|current
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|predecessor
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Found a predecessor node in this level.  It might not 		 * really be the predecessor, however. 		 */
if|if
condition|(
name|DOWN
argument_list|(
name|predecessor
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The predecessor is really down at least one level. 			 * Go down and as far right as possible, and repeat 			 * as long as the rightmost node has a down pointer. 			 */
do|do
block|{
comment|/* 				 * XXX DCL Need to do something about origins 				 * here. See whether to go down, and if so 				 * whether it is truly what Bob calls a 				 * new origin. 				 */
name|ADD_LEVEL
argument_list|(
name|chain
argument_list|,
name|predecessor
argument_list|)
expr_stmt|;
name|predecessor
operator|=
name|DOWN
argument_list|(
name|predecessor
argument_list|)
expr_stmt|;
comment|/* XXX DCL duplicated from above; clever 				 * way to unduplicate? */
while|while
condition|(
name|RIGHT
argument_list|(
name|predecessor
argument_list|)
operator|!=
name|NULL
condition|)
name|predecessor
operator|=
name|RIGHT
argument_list|(
name|predecessor
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|DOWN
argument_list|(
name|predecessor
argument_list|)
operator|!=
name|NULL
condition|)
do|;
comment|/* XXX DCL probably needs work on the concept */
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chain
operator|->
name|level_count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Dang, didn't find a predecessor in this level. 		 * Got to the root of this level without having traversed 		 * any right links.  Ascend the tree one level; the 		 * node that points to this tree is the predecessor. 		 */
name|INSIST
argument_list|(
name|chain
operator|->
name|level_count
operator|>
literal|0
operator|&&
name|IS_ROOT
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|predecessor
operator|=
name|chain
operator|->
name|levels
index|[
operator|--
name|chain
operator|->
name|level_count
index|]
expr_stmt|;
comment|/* XXX DCL probably needs work on the concept */
comment|/* 		 * Don't declare an origin change when the new origin is "." 		 * at the top level tree, because "." is declared as the origin 		 * for the second level tree. 		 */
if|if
condition|(
name|origin
operator|!=
name|NULL
operator|&&
operator|(
name|chain
operator|->
name|level_count
operator|>
literal|0
operator|||
name|OFFSETLEN
argument_list|(
name|predecessor
argument_list|)
operator|>
literal|1
operator|)
condition|)
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|predecessor
operator|!=
name|NULL
condition|)
block|{
name|chain
operator|->
name|end
operator|=
name|predecessor
expr_stmt|;
if|if
condition|(
name|new_origin
condition|)
block|{
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbtnodechain_next
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|)
block|{
name|dns_rbtnode_t
modifier|*
name|current
decl_stmt|,
modifier|*
name|previous
decl_stmt|,
modifier|*
name|successor
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|new_origin
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
operator|&&
name|chain
operator|->
name|end
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|successor
operator|=
name|NULL
expr_stmt|;
name|current
operator|=
name|chain
operator|->
name|end
expr_stmt|;
comment|/* 	 * If there is a level below this node, the next node is the leftmost 	 * node of the next level. 	 */
if|if
condition|(
name|DOWN
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Don't declare an origin change when the new origin is "." 		 * at the second level tree, because "." is already declared 		 * as the origin for the top level tree. 		 */
if|if
condition|(
name|chain
operator|->
name|level_count
operator|>
literal|0
operator|||
name|OFFSETLEN
argument_list|(
name|current
argument_list|)
operator|>
literal|1
condition|)
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
name|ADD_LEVEL
argument_list|(
name|chain
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
name|DOWN
argument_list|(
name|current
argument_list|)
expr_stmt|;
while|while
condition|(
name|LEFT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
name|current
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|successor
operator|=
name|current
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The successor is up, either in this level or a previous one. 		 * Head back toward the root of the tree, looking for any path 		 * that was via a left link; the successor is the node that has 		 * that left link.  In the event the root of the level is 		 * reached without having traversed any left links, ascend one 		 * level and look for either a right link off the point of 		 * ascent, or search for a left link upward again, repeating 		 * ascents until either case is true. 		 */
do|do
block|{
while|while
condition|(
operator|!
name|IS_ROOT
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|previous
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|PARENT
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|LEFT
argument_list|(
name|current
argument_list|)
operator|==
name|previous
condition|)
block|{
name|successor
operator|=
name|current
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|successor
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Reached the root without having traversed 				 * any left pointers, so this level is done. 				 */
if|if
condition|(
name|chain
operator|->
name|level_count
operator|==
literal|0
condition|)
break|break;
name|current
operator|=
name|chain
operator|->
name|levels
index|[
operator|--
name|chain
operator|->
name|level_count
index|]
expr_stmt|;
name|new_origin
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|successor
operator|==
name|NULL
condition|)
do|;
block|}
if|if
condition|(
name|successor
operator|==
name|NULL
operator|&&
name|RIGHT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|current
operator|=
name|RIGHT
argument_list|(
name|current
argument_list|)
expr_stmt|;
while|while
condition|(
name|LEFT
argument_list|(
name|current
argument_list|)
operator|!=
name|NULL
condition|)
name|current
operator|=
name|LEFT
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|successor
operator|=
name|current
expr_stmt|;
block|}
if|if
condition|(
name|successor
operator|!=
name|NULL
condition|)
block|{
name|chain
operator|->
name|end
operator|=
name|successor
expr_stmt|;
comment|/* 		 * It is not necessary to use dns_rbtnodechain_current like 		 * the other functions because this function will never 		 * find a node in the topmost level.  This is because the 		 * root level will never be more than one name, and everything 		 * in the megatree is a successor to that node, down at 		 * the second level or below. 		 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|NODENAME
argument_list|(
name|chain
operator|->
name|end
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_origin
condition|)
block|{
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|result
operator|=
name|chain_name
argument_list|(
name|chain
argument_list|,
name|origin
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
name|result
operator|=
name|ISC_R_NOMORE
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbtnodechain_first
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|rbt
operator|->
name|root
expr_stmt|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rbtnodechain_last
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|,
name|dns_rbt_t
modifier|*
name|rbt
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RBT
argument_list|(
name|rbt
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|result
operator|=
name|move_chain_to_last
argument_list|(
name|chain
argument_list|,
name|rbt
operator|->
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_rbtnodechain_current
argument_list|(
name|chain
argument_list|,
name|name
argument_list|,
name|origin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|DNS_R_NEWORIGIN
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_rbtnodechain_reset
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|)
block|{
comment|/* 	 * Free any dynamic storage associated with 'chain', and then 	 * reinitialize 'chain'. 	 */
name|REQUIRE
argument_list|(
name|VALID_CHAIN
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
name|chain
operator|->
name|level_count
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|level_matches
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_rbtnodechain_invalidate
parameter_list|(
name|dns_rbtnodechain_t
modifier|*
name|chain
parameter_list|)
block|{
comment|/* 	 * Free any dynamic storage associated with 'chain', and then 	 * invalidate 'chain'. 	 */
name|dns_rbtnodechain_reset
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

