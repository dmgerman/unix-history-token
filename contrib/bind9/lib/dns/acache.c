begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2008, 2012, 2013  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: acache.c,v 1.22 2008/02/07 23:46:54 tbox Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/atomic.h>
end_include

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/hash.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/refcount.h>
end_include

begin_include
include|#
directive|include
file|<isc/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/timer.h>
end_include

begin_include
include|#
directive|include
file|<dns/acache.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/zone.h>
end_include

begin_define
define|#
directive|define
name|ACACHE_MAGIC
value|ISC_MAGIC('A', 'C', 'H', 'E')
end_define

begin_define
define|#
directive|define
name|DNS_ACACHE_VALID
parameter_list|(
name|acache
parameter_list|)
value|ISC_MAGIC_VALID(acache, ACACHE_MAGIC)
end_define

begin_define
define|#
directive|define
name|ACACHEENTRY_MAGIC
value|ISC_MAGIC('A', 'C', 'E', 'T')
end_define

begin_define
define|#
directive|define
name|DNS_ACACHEENTRY_VALID
parameter_list|(
name|entry
parameter_list|)
value|ISC_MAGIC_VALID(entry, ACACHEENTRY_MAGIC)
end_define

begin_define
define|#
directive|define
name|DBBUCKETS
value|67
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ATRACE
parameter_list|(
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_DATABASE, \ 				      DNS_LOGMODULE_ACACHE, \ 				      ISC_LOG_DEBUG(3), \ 				      "acache %p: %s", acache, (m))
end_define

begin_define
define|#
directive|define
name|AATRACE
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|)
value|isc_log_write(dns_lctx, \ 				      DNS_LOGCATEGORY_DATABASE, \ 				      DNS_LOGMODULE_ACACHE, \ 				      ISC_LOG_DEBUG(3), \ 				      "acache %p: %s", (a), (m))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATRACE
parameter_list|(
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AATRACE
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following variables control incremental cleaning.  * MINSIZE is how many bytes is the floor for dns_acache_setcachesize().  * CLEANERINCREMENT is how many entries are examined in one pass.  * (XXX simply derived from definitions in cache.c  There may be better  *  constants here.)  */
end_comment

begin_define
define|#
directive|define
name|DNS_ACACHE_MINSIZE
value|2097152U
end_define

begin_comment
comment|/* Bytes.  2097152 = 2 MB */
end_comment

begin_define
define|#
directive|define
name|DNS_ACACHE_CLEANERINCREMENT
value|1000
end_define

begin_comment
comment|/* Number of entries. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
value|1009
end_define

begin_comment
comment|/*%< Should be prime. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_RWLOCK_USEATOMIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEATOMICSTORE
argument_list|)
end_if

begin_define
define|#
directive|define
name|ACACHE_USE_RWLOCK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ACACHE_USE_RWLOCK
end_ifdef

begin_define
define|#
directive|define
name|ACACHE_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_init((l), 0, 0)
end_define

begin_define
define|#
directive|define
name|ACACHE_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_rwlock_destroy(l)
end_define

begin_define
define|#
directive|define
name|ACACHE_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|ACACHE_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|RWUNLOCK((l), (t))
end_define

begin_define
define|#
directive|define
name|acache_storetime
parameter_list|(
name|entry
parameter_list|,
name|t
parameter_list|)
define|\
value|(isc_atomic_store((isc_int32_t *)&(entry)->lastused, (t)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ACACHE_INITLOCK
parameter_list|(
name|l
parameter_list|)
value|isc_mutex_init(l)
end_define

begin_define
define|#
directive|define
name|ACACHE_DESTROYLOCK
parameter_list|(
name|l
parameter_list|)
value|DESTROYLOCK(l)
end_define

begin_define
define|#
directive|define
name|ACACHE_LOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|LOCK(l)
end_define

begin_define
define|#
directive|define
name|ACACHE_UNLOCK
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|)
value|UNLOCK(l)
end_define

begin_define
define|#
directive|define
name|acache_storetime
parameter_list|(
name|entry
parameter_list|,
name|t
parameter_list|)
value|((entry)->lastused = (t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Locked by acache lock */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dbentry
block|{
name|ISC_LINK
argument_list|(
argument|struct dbentry
argument_list|)
name|link
expr_stmt|;
name|dns_db_t
modifier|*
name|db
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|originlist
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|referlist
expr_stmt|;
block|}
name|dbentry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dbentry_t
argument_list|)
name|dbentrylist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|acache_cleaner
name|acache_cleaner_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|cleaner_s_idle
block|,
comment|/* Waiting for cleaning-interval to expire. */
name|cleaner_s_busy
block|,
comment|/* Currently cleaning. */
name|cleaner_s_done
comment|/* Freed enough memory after being overmem. */
block|}
name|cleaner_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * Convenience macros for comprehensive assertion checking.  */
end_comment

begin_define
define|#
directive|define
name|CLEANER_IDLE
parameter_list|(
name|c
parameter_list|)
value|((c)->state == cleaner_s_idle&& \ 			 (c)->resched_event != NULL)
end_define

begin_define
define|#
directive|define
name|CLEANER_BUSY
parameter_list|(
name|c
parameter_list|)
value|((c)->state == cleaner_s_busy&& \ 			 (c)->resched_event == NULL)
end_define

begin_struct
struct|struct
name|acache_cleaner
block|{
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* 	 * Locks overmem_event, overmem.  (See cache.c) 	 */
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|unsigned
name|int
name|cleaning_interval
decl_stmt|;
comment|/* The cleaning-interval 						      from named.conf, 						      in seconds. */
name|isc_stdtime_t
name|last_cleanup_time
decl_stmt|;
comment|/* The time when the last 						      cleanup task completed */
name|isc_timer_t
modifier|*
name|cleaning_timer
decl_stmt|;
name|isc_event_t
modifier|*
name|resched_event
decl_stmt|;
comment|/* Sent by cleaner task to 						   itself to reschedule */
name|isc_event_t
modifier|*
name|overmem_event
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|current_entry
decl_stmt|;
comment|/* The bookmark entry to 						   restart the cleaning. 						   Locked by acache lock. */
name|int
name|increment
decl_stmt|;
comment|/* Number of entries to 						   clean in one increment */
name|unsigned
name|long
name|ncleaned
decl_stmt|;
comment|/* Number of entries cleaned 						   up (for logging purposes) */
name|cleaner_state_t
name|state
decl_stmt|;
comment|/* Idle/Busy/Done. */
name|isc_boolean_t
name|overmem
decl_stmt|;
comment|/* The acache is in an overmem 						   state. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_acachestats
block|{
name|unsigned
name|int
name|hits
decl_stmt|;
name|unsigned
name|int
name|queries
decl_stmt|;
name|unsigned
name|int
name|misses
decl_stmt|;
name|unsigned
name|int
name|adds
decl_stmt|;
name|unsigned
name|int
name|deleted
decl_stmt|;
name|unsigned
name|int
name|cleaned
decl_stmt|;
name|unsigned
name|int
name|cleaner_runs
decl_stmt|;
name|unsigned
name|int
name|overmem
decl_stmt|;
name|unsigned
name|int
name|overmem_nocreates
decl_stmt|;
name|unsigned
name|int
name|nomem
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The actual acache object.  */
end_comment

begin_struct
struct|struct
name|dns_acache
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_refcount_t
name|refs
decl_stmt|;
ifdef|#
directive|ifdef
name|ACACHE_USE_RWLOCK
name|isc_rwlock_t
modifier|*
name|entrylocks
decl_stmt|;
else|#
directive|else
name|isc_mutex_t
modifier|*
name|entrylocks
decl_stmt|;
endif|#
directive|endif
name|isc_mutex_t
name|lock
decl_stmt|;
name|int
name|live_cleaners
decl_stmt|;
name|acache_cleaner_t
name|cleaner
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|entries
expr_stmt|;
name|unsigned
name|int
name|dbentries
decl_stmt|;
name|dbentrylist_t
name|dbbucket
index|[
name|DBBUCKETS
index|]
decl_stmt|;
name|isc_boolean_t
name|shutting_down
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_event_t
name|cevent
decl_stmt|;
name|isc_boolean_t
name|cevent_sent
decl_stmt|;
name|dns_acachestats_t
name|stats
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_acacheentry
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|locknum
decl_stmt|;
name|isc_refcount_t
name|references
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
comment|/* Data for Management of cache entries */
name|ISC_LINK
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|link
expr_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|olink
expr_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_acacheentry_t
argument_list|)
name|rlink
expr_stmt|;
name|dns_db_t
modifier|*
name|origdb
decl_stmt|;
comment|/* reference to the DB 					    holding this entry */
comment|/* Cache data */
name|dns_zone_t
modifier|*
name|zone
decl_stmt|;
comment|/* zone this entry 						   belongs to */
name|dns_db_t
modifier|*
name|db
decl_stmt|;
comment|/* DB this entry belongs to */
name|dns_dbversion_t
modifier|*
name|version
decl_stmt|;
comment|/* the version of the DB */
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
comment|/* node this entry 						   belongs to */
name|dns_name_t
modifier|*
name|foundname
decl_stmt|;
comment|/* corresponding DNS name 						   and rdataset */
comment|/* Callback function and its argument */
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|dns_acacheentry_t
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|cbarg
decl_stmt|;
comment|/* Timestamp of the last time this entry is referred to */
name|isc_stdtime32_t
name|lastused
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *	Internal functions (and prototypes).  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|isc_boolean_t
name|check_noentry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shutdown_entries
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shutdown_buckets
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_entry
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|unlink_dbentries
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|isc_result_t
name|finddbent
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dbentry_t
modifier|*
modifier|*
name|dbentryp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|clear_entry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|acache_cleaner_init
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|acache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acache_cleaning_timer_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acache_incremental_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acache_overmem_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|acache_cleaner_shutdown_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * acache should be locked.  If it is not, the stats can get out of whack,  * which is not a big deal for us since this is for debugging / stats  */
end_comment

begin_function
specifier|static
name|void
name|reset_stats
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|acache
operator|->
name|stats
operator|.
name|hits
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|queries
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|misses
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|adds
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|deleted
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|cleaned
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|overmem
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|overmem_nocreates
operator|=
literal|0
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|nomem
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The acache must be locked before calling.  */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|check_noentry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|acache
operator|->
name|entries
argument_list|)
operator|&&
name|acache
operator|->
name|dbentries
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The acache must be locked before calling.  */
end_comment

begin_function
specifier|static
name|void
name|shutdown_entries
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry_next
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|acache
operator|->
name|shutting_down
argument_list|)
expr_stmt|;
comment|/* 	 * Release the dependency of all entries, and detach them. 	 */
for|for
control|(
name|entry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|acache
operator|->
name|entries
argument_list|)
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|entry_next
control|)
block|{
name|entry_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 		 * If the cleaner holds this entry, it will be unlinked and 		 * freed in the cleaner later. 		 */
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|unlink_dbentries
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
call|(
name|entry
operator|->
name|callback
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|cbarg
argument_list|)
expr_stmt|;
name|entry
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
block|}
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The acache must be locked before calling.  */
end_comment

begin_function
specifier|static
name|void
name|shutdown_buckets
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dbentry_t
modifier|*
name|dbent
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|acache
operator|->
name|shutting_down
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DBBUCKETS
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|dbent
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|dbent
operator|->
name|originlist
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|dbent
operator|->
name|referlist
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|i
index|]
argument_list|,
name|dbent
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|dbent
operator|->
name|db
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|dbent
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbent
argument_list|)
argument_list|)
expr_stmt|;
name|acache
operator|->
name|dbentries
operator|--
expr_stmt|;
block|}
block|}
name|INSIST
argument_list|(
name|acache
operator|->
name|dbentries
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shutdown_task
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|acache
operator|=
name|ev
operator|->
name|ev_arg
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|shutdown_entries
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|shutdown_buckets
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dns_acache_detach
argument_list|(
operator|&
name|acache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The acache and the entry must be locked before calling. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|unlink_dbentries
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|ent
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dbentry_t
modifier|*
name|dbent
decl_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|ent
argument_list|,
name|olink
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|ent
operator|->
name|origdb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dbent
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|ent
operator|->
name|origdb
argument_list|,
operator|&
name|dbent
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|dbent
operator|->
name|originlist
argument_list|,
name|ent
argument_list|,
name|olink
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|ent
argument_list|,
name|rlink
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|ent
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dbent
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|ent
operator|->
name|db
argument_list|,
operator|&
name|dbent
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|dbent
operator|->
name|referlist
argument_list|,
name|ent
argument_list|,
name|rlink
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* There must not be a reference to this entry. */
end_comment

begin_function
specifier|static
name|void
name|destroy_entry
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|acache
operator|=
name|entry
operator|->
name|acache
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since there is no reference to this entry, it is safe to call 	 * clear_entry() here. 	 */
name|clear_entry
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|dns_acache_detach
argument_list|(
operator|&
name|acache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"destroy"
argument_list|)
expr_stmt|;
name|isc_mem_setwater
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|overmem_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|resched_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|resched_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
condition|;
name|i
operator|++
control|)
name|ACACHE_DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|acache
operator|->
name|entrylocks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
operator|->
name|entrylocks
argument_list|)
operator|*
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|acache
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|acache
operator|->
name|mctx
argument_list|,
name|acache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|finddbent
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dbentry_t
modifier|*
modifier|*
name|dbentryp
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|;
name|dbentry_t
modifier|*
name|dbentry
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbentryp
operator|!=
name|NULL
operator|&&
operator|*
name|dbentryp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The caller must be holding the acache lock. 	 */
name|bucket
operator|=
name|isc_hash_calc
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|db
argument_list|,
sizeof|sizeof
argument_list|(
name|db
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|DBBUCKETS
expr_stmt|;
for|for
control|(
name|dbentry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|bucket
index|]
argument_list|)
init|;
name|dbentry
operator|!=
name|NULL
condition|;
name|dbentry
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dbentry
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|dbentry
operator|->
name|db
operator|==
name|db
condition|)
break|break;
block|}
operator|*
name|dbentryp
operator|=
name|dbentry
expr_stmt|;
if|if
condition|(
name|dbentry
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
else|else
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clear_entry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The caller must be holing the entry lock. 	 */
if|if
condition|(
name|entry
operator|->
name|foundname
condition|)
block|{
name|dns_rdataset_t
modifier|*
name|rdataset
decl_stmt|,
modifier|*
name|rdataset_next
decl_stmt|;
for|for
control|(
name|rdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|entry
operator|->
name|foundname
operator|->
name|list
argument_list|)
init|;
name|rdataset
operator|!=
name|NULL
condition|;
name|rdataset
operator|=
name|rdataset_next
control|)
block|{
name|rdataset_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|entry
operator|->
name|foundname
operator|->
name|list
argument_list|,
name|rdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|rdataset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdataset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dns_name_dynamic
argument_list|(
name|entry
operator|->
name|foundname
argument_list|)
condition|)
name|dns_name_free
argument_list|(
name|entry
operator|->
name|foundname
argument_list|,
name|acache
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|entry
operator|->
name|foundname
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|foundname
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|foundname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|node
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|entry
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|entry
operator|->
name|db
argument_list|,
operator|&
name|entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|version
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|entry
operator|->
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_closeversion
argument_list|(
name|entry
operator|->
name|db
argument_list|,
operator|&
name|entry
operator|->
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|db
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|entry
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
operator|&
name|entry
operator|->
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|origdb
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
operator|&
name|entry
operator|->
name|origdb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|acache_cleaner_init
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|,
name|acache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|ATRACE
argument_list|(
literal|"acache cleaner init"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|cleaner
operator|->
name|increment
operator|=
name|DNS_ACACHE_CLEANERINCREMENT
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_idle
expr_stmt|;
name|cleaner
operator|->
name|acache
operator|=
name|acache
expr_stmt|;
name|cleaner
operator|->
name|overmem
operator|=
name|ISC_FALSE
expr_stmt|;
name|cleaner
operator|->
name|cleaning_timer
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|resched_event
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|overmem_event
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|current_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|timermgr
operator|!=
name|NULL
condition|)
block|{
name|cleaner
operator|->
name|acache
operator|->
name|live_cleaners
operator|++
expr_stmt|;
name|result
operator|=
name|isc_task_onshutdown
argument_list|(
name|acache
operator|->
name|task
argument_list|,
name|acache_cleaner_shutdown_action
argument_list|,
name|acache
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"acache cleaner: "
literal|"isc_task_onshutdown() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|cleaning_interval
operator|=
literal|0
expr_stmt|;
comment|/* Initially turned off. */
name|isc_stdtime_get
argument_list|(
operator|&
name|cleaner
operator|->
name|last_cleanup_time
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_create
argument_list|(
name|timermgr
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|acache
operator|->
name|task
argument_list|,
name|acache_cleaning_timer_action
argument_list|,
name|cleaner
argument_list|,
operator|&
name|cleaner
operator|->
name|cleaning_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_timer_create() failed: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|resched_event
operator|=
name|isc_event_allocate
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|cleaner
argument_list|,
name|DNS_EVENT_ACACHECLEAN
argument_list|,
name|acache_incremental_cleaning_action
argument_list|,
name|cleaner
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|resched_event
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|cleaner
operator|->
name|overmem_event
operator|=
name|isc_event_allocate
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|cleaner
argument_list|,
name|DNS_EVENT_ACACHEOVERMEM
argument_list|,
name|acache_overmem_cleaning_action
argument_list|,
name|cleaner
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem_event
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|cleaner
operator|->
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cleaner
operator|->
name|overmem_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|resched_event
operator|!=
name|NULL
condition|)
name|isc_event_free
argument_list|(
operator|&
name|cleaner
operator|->
name|resched_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|cleaning_timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|cleaner
operator|->
name|cleaning_timer
argument_list|)
expr_stmt|;
name|cleaner
operator|->
name|acache
operator|->
name|live_cleaners
operator|--
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|begin_cleaning
parameter_list|(
name|acache_cleaner_t
modifier|*
name|cleaner
parameter_list|)
block|{
name|dns_acacheentry_t
modifier|*
name|head
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
init|=
name|cleaner
operator|->
name|acache
decl_stmt|;
comment|/* 	 * This function does not have to lock the cleaner, since critical 	 * parameters (except current_entry, which is locked by acache lock,) 	 * are only used in a single task context. 	 */
name|REQUIRE
argument_list|(
name|CLEANER_IDLE
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|cleaner
operator|->
name|current_entry
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"begin acache cleaning, mem inuse %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|acache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|head
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|acache
operator|->
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
name|dns_acache_attachentry
argument_list|(
name|head
argument_list|,
operator|&
name|cleaner
operator|->
name|current_entry
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
block|{
name|cleaner
operator|->
name|ncleaned
operator|=
literal|0
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_busy
expr_stmt|;
name|isc_task_send
argument_list|(
name|acache
operator|->
name|task
argument_list|,
operator|&
name|cleaner
operator|->
name|resched_event
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|end_cleaning
parameter_list|(
name|acache_cleaner_t
modifier|*
name|cleaner
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
init|=
name|cleaner
operator|->
name|acache
decl_stmt|;
name|REQUIRE
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|cleaner
operator|->
name|current_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No need to lock the cleaner (see begin_cleaning()). */
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Even if the cleaner has the last reference to the entry, which means 	 * the entry has been unused, it may still be linked if unlinking the 	 * entry has been delayed due to the reference. 	 */
if|if
condition|(
name|isc_refcount_current
argument_list|(
operator|&
name|cleaner
operator|->
name|current_entry
operator|->
name|references
argument_list|)
operator|==
literal|1
condition|)
block|{
name|INSIST
argument_list|(
name|cleaner
operator|->
name|current_entry
operator|->
name|callback
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|cleaner
operator|->
name|current_entry
argument_list|,
name|link
argument_list|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|cleaner
operator|->
name|current_entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|dns_acache_detachentry
argument_list|(
operator|&
name|cleaner
operator|->
name|current_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
name|acache
operator|->
name|stats
operator|.
name|overmem
operator|++
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|cleaned
operator|+=
name|cleaner
operator|->
name|ncleaned
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|cleaner_runs
operator|++
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"acache %p stats: hits=%d misses=%d queries=%d "
literal|"adds=%d deleted=%d "
literal|"cleaned=%d cleaner_runs=%d overmem=%d "
literal|"overmem_nocreates=%d nomem=%d"
argument_list|,
name|acache
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|hits
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|misses
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|queries
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|adds
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|deleted
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|cleaned
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|cleaner_runs
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|overmem
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|overmem_nocreates
argument_list|,
name|acache
operator|->
name|stats
operator|.
name|nomem
argument_list|)
expr_stmt|;
name|reset_stats
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|cleaner
operator|->
name|last_cleanup_time
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dns_acache_setcleaninginterval
argument_list|(
name|cleaner
operator|->
name|acache
argument_list|,
name|cleaner
operator|->
name|cleaning_interval
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"end acache cleaning, "
literal|"%lu entries cleaned, mem inuse %lu"
argument_list|,
name|cleaner
operator|->
name|ncleaned
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|acache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"acache is still in overmem state "
literal|"after cleaning"
argument_list|)
expr_stmt|;
block|}
name|cleaner
operator|->
name|ncleaned
operator|=
literal|0
expr_stmt|;
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_idle
expr_stmt|;
name|cleaner
operator|->
name|resched_event
operator|=
name|event
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is run once for every acache-cleaning-interval as defined  * in named.conf.  */
end_comment

begin_function
specifier|static
name|void
name|acache_cleaning_timer_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|acache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TIMEREVENT_TICK
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"acache cleaning timer fired, "
literal|"cleaner state = %d"
argument_list|,
name|cleaner
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_idle
condition|)
name|begin_cleaning
argument_list|(
name|cleaner
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The caller must hold entry lock. */
end_comment

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|entry_stale
parameter_list|(
name|acache_cleaner_t
modifier|*
name|cleaner
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|,
name|isc_stdtime32_t
name|now32
parameter_list|,
name|unsigned
name|int
name|interval
parameter_list|)
block|{
comment|/* 	 * If the callback has been canceled, we definitely do not need the 	 * entry. 	 */
if|if
condition|(
name|entry
operator|->
name|callback
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|interval
operator|>
name|cleaner
operator|->
name|cleaning_interval
condition|)
name|interval
operator|=
name|cleaner
operator|->
name|cleaning_interval
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lastused
operator|+
name|interval
operator|<
name|now32
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * If the acache is in the overmem state, probabilistically decide if 	 * the entry should be purged, based on the time passed from its last 	 * use and the cleaning interval. 	 */
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
name|unsigned
name|int
name|passed
decl_stmt|;
name|isc_uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|isc_serial_ge
argument_list|(
name|now32
argument_list|,
name|entry
operator|->
name|lastused
argument_list|)
condition|)
name|passed
operator|=
name|now32
operator|-
name|entry
operator|->
name|lastused
expr_stmt|;
comment|/*<= interval */
else|else
name|passed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|passed
operator|>
name|interval
operator|/
literal|2
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|isc_random_get
argument_list|(
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed
operator|>
name|interval
operator|/
literal|4
condition|)
return|return
operator|(
name|ISC_TF
argument_list|(
name|val
operator|%
literal|4
operator|==
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
name|ISC_TF
argument_list|(
name|val
operator|%
literal|8
operator|==
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do incremental cleaning.  */
end_comment

begin_function
specifier|static
name|void
name|acache_incremental_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|acache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
init|=
name|cleaner
operator|->
name|acache
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|int
name|n_entries
decl_stmt|;
name|isc_stdtime32_t
name|now32
decl_stmt|,
name|last32
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|unsigned
name|int
name|interval
decl_stmt|;
name|INSIST
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_ACACHECLEAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_done
condition|)
block|{
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_busy
expr_stmt|;
name|end_cleaning
argument_list|(
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
name|n_entries
operator|=
name|cleaner
operator|->
name|increment
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|isc_stdtime_convert32
argument_list|(
name|now
argument_list|,
operator|&
name|now32
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|entry
operator|=
name|cleaner
operator|->
name|current_entry
expr_stmt|;
name|isc_stdtime_convert32
argument_list|(
name|cleaner
operator|->
name|last_cleanup_time
argument_list|,
operator|&
name|last32
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_serial_ge
argument_list|(
name|now32
argument_list|,
name|last32
argument_list|)
condition|)
name|interval
operator|=
name|now32
operator|-
name|last32
expr_stmt|;
else|else
name|interval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n_entries
operator|--
operator|>
literal|0
condition|)
block|{
name|isc_boolean_t
name|is_stale
init|=
name|ISC_FALSE
decl_stmt|;
name|INSIST
argument_list|(
name|entry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|is_stale
operator|=
name|entry_stale
argument_list|(
name|cleaner
argument_list|,
name|entry
argument_list|,
name|now32
argument_list|,
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_stale
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|unlink_dbentries
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|callback
operator|!=
name|NULL
condition|)
call|(
name|entry
operator|->
name|callback
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|cbarg
argument_list|)
expr_stmt|;
name|entry
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|cleaner
operator|->
name|ncleaned
operator|++
expr_stmt|;
block|}
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_stale
condition|)
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
name|entry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|acache
operator|->
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * If we are still in the overmem 					 * state, keep cleaning.  In case we 					 * exit from the loop immediately after 					 * this, reset next to the head entry 					 * as we'll expect it will be never 					 * NULL. 					 */
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"acache cleaner: "
literal|"still overmem, "
literal|"reset and try again"
argument_list|)
expr_stmt|;
name|next
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|end_cleaning
argument_list|(
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * We have successfully performed a cleaning increment but have 	 * not gone through the entire cache.  Remember the entry that will 	 * be the starting point in the next clean-up, and reschedule another 	 * batch.  If it fails, just try to continue anyway. 	 */
name|INSIST
argument_list|(
name|next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_acache_detachentry
argument_list|(
operator|&
name|cleaner
operator|->
name|current_entry
argument_list|)
expr_stmt|;
name|dns_acache_attachentry
argument_list|(
name|next
argument_list|,
operator|&
name|cleaner
operator|->
name|current_entry
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"acache cleaner: checked %d entries, "
literal|"mem inuse %lu, sleeping"
argument_list|,
name|cleaner
operator|->
name|increment
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|cleaner
operator|->
name|acache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|CLEANER_BUSY
argument_list|(
name|cleaner
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This is called when the acache either surpasses its upper limit  * or shrinks beyond its lower limit.  */
end_comment

begin_function
specifier|static
name|void
name|acache_overmem_cleaning_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|acache_cleaner_t
modifier|*
name|cleaner
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|want_cleaning
init|=
name|ISC_FALSE
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_ACACHEOVERMEM
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|cleaner
operator|->
name|overmem_event
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"overmem_cleaning_action called, "
literal|"overmem = %d, state = %d"
argument_list|,
name|cleaner
operator|->
name|overmem
argument_list|,
name|cleaner
operator|->
name|state
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleaner
operator|->
name|overmem
condition|)
block|{
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_idle
condition|)
name|want_cleaning
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cleaner
operator|->
name|state
operator|==
name|cleaner_s_busy
condition|)
comment|/* 			 * end_cleaning() can't be called here because 			 * then both cleaner->overmem_event and 			 * cleaner->resched_event will point to this 			 * event.  Set the state to done, and then 			 * when the acache_incremental_cleaning_action() event 			 * is posted, it will handle the end_cleaning. 			 */
name|cleaner
operator|->
name|state
operator|=
name|cleaner_s_done
expr_stmt|;
block|}
name|cleaner
operator|->
name|overmem_event
operator|=
name|event
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|cleaner
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_cleaning
condition|)
name|begin_cleaning
argument_list|(
name|cleaner
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|water
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|mark
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
init|=
name|arg
decl_stmt|;
name|isc_boolean_t
name|overmem
init|=
name|ISC_TF
argument_list|(
name|mark
operator|==
name|ISC_MEM_HIWATER
argument_list|)
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"acache memory reaches %s watermark, mem inuse %lu"
argument_list|,
name|overmem
condition|?
literal|"high"
else|:
literal|"low"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isc_mem_inuse
argument_list|(
name|acache
operator|->
name|mctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|overmem
operator|!=
name|overmem
condition|)
block|{
name|acache
operator|->
name|cleaner
operator|.
name|overmem
operator|=
name|overmem
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|overmem_event
operator|!=
name|NULL
condition|)
name|isc_task_send
argument_list|(
name|acache
operator|->
name|task
argument_list|,
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|overmem_event
argument_list|)
expr_stmt|;
name|isc_mem_waterack
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The cleaner task is shutting down; do the necessary cleanup.  */
end_comment

begin_function
specifier|static
name|void
name|acache_cleaner_shutdown_action
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
init|=
name|event
operator|->
name|ev_arg
decl_stmt|;
name|isc_boolean_t
name|should_free
init|=
name|ISC_FALSE
decl_stmt|;
name|INSIST
argument_list|(
name|task
operator|==
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|ISC_TASKEVENT_SHUTDOWN
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"acache cleaner shutdown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLEANER_BUSY
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
argument_list|)
condition|)
name|end_cleaning
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|acache
operator|->
name|live_cleaners
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|acache
operator|->
name|live_cleaners
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_refcount_current
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|check_noentry
argument_list|(
name|acache
argument_list|)
operator|==
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|should_free
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 	 * By detaching the timer in the context of its task, 	 * we are guaranteed that there will be no further timer 	 * events. 	 */
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_timer
operator|!=
name|NULL
condition|)
name|isc_timer_detach
argument_list|(
operator|&
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|)
expr_stmt|;
comment|/* Make sure we don't reschedule anymore. */
operator|(
name|void
operator|)
name|isc_task_purge
argument_list|(
name|task
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_ACACHECLEAN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_free
condition|)
name|destroy
argument_list|(
name|acache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Public functions.  */
end_comment

begin_function
name|isc_result_t
name|dns_acache_create
parameter_list|(
name|dns_acache_t
modifier|*
modifier|*
name|acachep
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_timermgr_t
modifier|*
name|timermgr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|REQUIRE
argument_list|(
name|acachep
operator|!=
name|NULL
operator|&&
operator|*
name|acachep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|taskmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|acache
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|ATRACE
argument_list|(
literal|"create"
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_refcount_decrement
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|acache
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|acache
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|acache
operator|->
name|entries
argument_list|)
expr_stmt|;
name|acache
operator|->
name|shutting_down
operator|=
name|ISC_FALSE
expr_stmt|;
name|acache
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|acache
operator|->
name|entrylocks
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|1
argument_list|,
operator|&
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_task_create() failed(): %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_task_setname
argument_list|(
name|acache
operator|->
name|task
argument_list|,
literal|"acachetask"
argument_list|,
name|acache
argument_list|)
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|acache
operator|->
name|cevent
argument_list|,
sizeof|sizeof
argument_list|(
name|acache
operator|->
name|cevent
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_ACACHECONTROL
argument_list|,
name|shutdown_task
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|acache
operator|->
name|cevent_sent
operator|=
name|ISC_FALSE
expr_stmt|;
name|acache
operator|->
name|dbentries
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DBBUCKETS
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|acache
operator|->
name|entrylocks
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
operator|->
name|entrylocks
argument_list|)
operator|*
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|entrylocks
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|ACACHE_INITLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|ACACHE_DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acache
operator|->
name|entrylocks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
operator|->
name|entrylocks
argument_list|)
operator|*
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
argument_list|)
expr_stmt|;
name|acache
operator|->
name|entrylocks
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|acache
operator|->
name|live_cleaners
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|acache_cleaner_init
argument_list|(
name|acache
argument_list|,
name|timermgr
argument_list|,
operator|&
name|acache
operator|->
name|cleaner
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|acache
operator|->
name|stats
operator|.
name|cleaner_runs
operator|=
literal|0
expr_stmt|;
name|reset_stats
argument_list|(
name|acache
argument_list|)
expr_stmt|;
name|acache
operator|->
name|magic
operator|=
name|ACACHE_MAGIC
expr_stmt|;
operator|*
name|acachep
operator|=
name|acache
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|acache
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_destroy
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|entrylocks
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
condition|;
name|i
operator|++
control|)
name|ACACHE_DESTROYLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acache
operator|->
name|entrylocks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
operator|->
name|entrylocks
argument_list|)
operator|*
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|acache
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_acache_attach
parameter_list|(
name|dns_acache_t
modifier|*
name|source
parameter_list|,
name|dns_acache_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|AATRACE
argument_list|(
name|source
argument_list|,
literal|"attach"
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|source
operator|->
name|refs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_acache_countquerymiss
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|acache
operator|->
name|stats
operator|.
name|misses
operator|++
expr_stmt|;
comment|/* XXXSK danger: unlocked! */
name|acache
operator|->
name|stats
operator|.
name|queries
operator|++
expr_stmt|;
comment|/* XXXSK danger: unlocked! */
block|}
end_function

begin_function
name|void
name|dns_acache_detach
parameter_list|(
name|dns_acache_t
modifier|*
modifier|*
name|acachep
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|isc_boolean_t
name|should_free
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|acachep
operator|!=
name|NULL
operator|&&
name|DNS_ACACHE_VALID
argument_list|(
operator|*
name|acachep
argument_list|)
argument_list|)
expr_stmt|;
name|acache
operator|=
operator|*
name|acachep
expr_stmt|;
name|ATRACE
argument_list|(
literal|"detach"
argument_list|)
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|acache
operator|->
name|refs
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
name|check_noentry
argument_list|(
name|acache
argument_list|)
operator|==
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|should_free
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
operator|*
name|acachep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we're exiting and the cleaner task exists, let it free the cache. 	 */
if|if
condition|(
name|should_free
operator|&&
name|acache
operator|->
name|live_cleaners
operator|>
literal|0
condition|)
block|{
name|isc_task_shutdown
argument_list|(
name|acache
operator|->
name|task
argument_list|)
expr_stmt|;
name|should_free
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|should_free
condition|)
name|destroy
argument_list|(
name|acache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_acache_shutdown
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"shutdown"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acache
operator|->
name|shutting_down
condition|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache_evarg
init|=
name|NULL
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|acache
operator|->
name|cevent_sent
argument_list|)
expr_stmt|;
name|acache
operator|->
name|shutting_down
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_mem_setwater
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Self attach the object in order to prevent it from being 		 * destroyed while waiting for the event. 		 */
name|dns_acache_attach
argument_list|(
name|acache
argument_list|,
operator|&
name|acache_evarg
argument_list|)
expr_stmt|;
name|event
operator|=
operator|&
name|acache
operator|->
name|cevent
expr_stmt|;
name|event
operator|->
name|ev_arg
operator|=
name|acache_evarg
expr_stmt|;
name|isc_task_send
argument_list|(
name|acache
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
name|acache
operator|->
name|cevent_sent
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_acache_setdb
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|;
name|dbentry_t
modifier|*
name|dbentry
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"setdb"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dbentry
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|db
argument_list|,
operator|&
name|dbentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|dbentry
operator|=
name|isc_mem_get
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbentry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbentry
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|dbentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|dbentry
operator|->
name|originlist
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|dbentry
operator|->
name|referlist
argument_list|)
expr_stmt|;
name|dbentry
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|dbentry
operator|->
name|db
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|isc_hash_calc
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|db
argument_list|,
sizeof|sizeof
argument_list|(
name|db
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|DBBUCKETS
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|bucket
index|]
argument_list|,
name|dbentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|acache
operator|->
name|dbentries
operator|++
expr_stmt|;
name|end
label|:
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_acache_putdb
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dbentry_t
modifier|*
name|dbentry
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"putdb"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|dbentry
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|db
argument_list|,
operator|&
name|dbentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * The entry may have not been created due to memory shortage. 		 */
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
comment|/* 	 * Release corresponding cache entries: for each entry, release all 	 * links the entry has, and then callback to the entry holder (if any). 	 * If no other external references exist (this can happen if the 	 * original holder has canceled callback,) destroy it here. 	 */
while|while
condition|(
operator|(
name|entry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dbentry
operator|->
name|originlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 		 * Releasing olink first would avoid finddbent() in 		 * unlink_dbentries(). 		 */
name|ISC_LIST_UNLINK
argument_list|(
name|dbentry
operator|->
name|originlist
argument_list|,
name|entry
argument_list|,
name|olink
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|unlink_dbentries
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|callback
operator|!=
name|NULL
condition|)
call|(
name|entry
operator|->
name|callback
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|cbarg
argument_list|)
expr_stmt|;
name|entry
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|entry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dbentry
operator|->
name|referlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|dbentry
operator|->
name|referlist
argument_list|,
name|entry
argument_list|,
name|rlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|unlink_dbentries
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|callback
operator|!=
name|NULL
condition|)
call|(
name|entry
operator|->
name|callback
call|)
argument_list|(
name|entry
argument_list|,
operator|&
name|entry
operator|->
name|cbarg
argument_list|)
expr_stmt|;
name|entry
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|current_entry
operator|!=
name|entry
condition|)
name|dns_acache_detachentry
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|dbentry
operator|->
name|originlist
argument_list|)
operator|&&
name|ISC_LIST_EMPTY
argument_list|(
name|dbentry
operator|->
name|referlist
argument_list|)
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|isc_hash_calc
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|db
argument_list|,
sizeof|sizeof
argument_list|(
name|db
argument_list|)
argument_list|,
name|ISC_TRUE
argument_list|)
operator|%
name|DBBUCKETS
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|acache
operator|->
name|dbbucket
index|[
name|bucket
index|]
argument_list|,
name|dbentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_db_detach
argument_list|(
operator|&
name|dbentry
operator|->
name|db
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|dbentry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dbentry
argument_list|)
argument_list|)
expr_stmt|;
name|acache
operator|->
name|dbentries
operator|--
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|deleted
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_acache_createentry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_db_t
modifier|*
name|origdb
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|dns_acacheentry_t
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|,
name|dns_acacheentry_t
modifier|*
modifier|*
name|entryp
parameter_list|)
block|{
name|dns_acacheentry_t
modifier|*
name|newentry
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_uint32_t
name|r
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|entryp
operator|!=
name|NULL
operator|&&
operator|*
name|entryp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|origdb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Should we exceed our memory limit for some reason (for 	 * example, if the cleaner does not run aggressively enough), 	 * then we will not create additional entries. 	 * 	 * XXXSK: It might be better to lock the acache->cleaner->lock, 	 * but locking may be an expensive bottleneck. If we misread 	 * the value, we will occasionally refuse to create a few 	 * cache entries, or create a few that we should not. I do not 	 * expect this to happen often, and it will not have very bad 	 * effects when it does. So no lock for now. 	 */
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|overmem
condition|)
block|{
name|acache
operator|->
name|stats
operator|.
name|overmem_nocreates
operator|++
expr_stmt|;
comment|/* XXXSK danger: unlocked! */
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
block|}
name|newentry
operator|=
name|isc_mem_get
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newentry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newentry
operator|==
name|NULL
condition|)
block|{
name|acache
operator|->
name|stats
operator|.
name|nomem
operator|++
expr_stmt|;
comment|/* XXXMLG danger: unlocked! */
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|isc_random_get
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|locknum
operator|=
name|r
operator|%
name|DEFAULT_ACACHE_ENTRY_LOCK_COUNT
expr_stmt|;
name|result
operator|=
name|isc_refcount_init
argument_list|(
operator|&
name|newentry
operator|->
name|references
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|newentry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newentry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
empty_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|newentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|newentry
argument_list|,
name|olink
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|newentry
argument_list|,
name|rlink
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|acache
operator|=
name|NULL
expr_stmt|;
name|dns_acache_attach
argument_list|(
name|acache
argument_list|,
operator|&
name|newentry
operator|->
name|acache
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|zone
operator|=
name|NULL
expr_stmt|;
name|newentry
operator|->
name|db
operator|=
name|NULL
expr_stmt|;
name|newentry
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|newentry
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|newentry
operator|->
name|foundname
operator|=
name|NULL
expr_stmt|;
name|newentry
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|newentry
operator|->
name|cbarg
operator|=
name|cbarg
expr_stmt|;
name|newentry
operator|->
name|origdb
operator|=
name|NULL
expr_stmt|;
name|dns_db_attach
argument_list|(
name|origdb
argument_list|,
operator|&
name|newentry
operator|->
name|origdb
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|newentry
operator|->
name|lastused
argument_list|)
expr_stmt|;
name|newentry
operator|->
name|magic
operator|=
name|ACACHEENTRY_MAGIC
expr_stmt|;
operator|*
name|entryp
operator|=
name|newentry
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_acache_getentry
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|,
name|dns_zone_t
modifier|*
modifier|*
name|zonep
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|,
name|dns_message_t
modifier|*
name|msg
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_rdataset_t
modifier|*
name|erdataset
decl_stmt|;
name|isc_stdtime32_t
name|now32
decl_stmt|;
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|int
name|locknum
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|zonep
operator|==
name|NULL
operator|||
operator|*
name|zonep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dbp
operator|!=
name|NULL
operator|&&
operator|*
name|dbp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|versionp
operator|!=
name|NULL
operator|&&
operator|*
name|versionp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nodep
operator|!=
name|NULL
operator|&&
operator|*
name|nodep
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|fname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|msg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|acache
operator|=
name|entry
operator|->
name|acache
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|locknum
operator|=
name|entry
operator|->
name|locknum
expr_stmt|;
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
name|isc_stdtime_convert32
argument_list|(
name|now
argument_list|,
operator|&
name|now32
argument_list|)
expr_stmt|;
name|acache_storetime
argument_list|(
name|entry
argument_list|,
name|now32
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|zone
operator|!=
name|NULL
operator|&&
name|zonep
operator|!=
name|NULL
condition|)
name|dns_zone_attach
argument_list|(
name|entry
operator|->
name|zone
argument_list|,
name|zonep
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|db
operator|==
name|NULL
condition|)
block|{
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
operator|*
name|versionp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dns_db_attach
argument_list|(
name|entry
operator|->
name|db
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|dns_db_attachversion
argument_list|(
name|entry
operator|->
name|db
argument_list|,
name|entry
operator|->
name|version
argument_list|,
name|versionp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|node
operator|==
name|NULL
condition|)
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|dns_db_attachnode
argument_list|(
name|entry
operator|->
name|db
argument_list|,
name|entry
operator|->
name|node
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|entry
operator|->
name|foundname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|entry
operator|->
name|foundname
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|erdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|entry
operator|->
name|foundname
operator|->
name|list
argument_list|)
init|;
name|erdataset
operator|!=
name|NULL
condition|;
name|erdataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|erdataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|dns_rdataset_t
modifier|*
name|ardataset
decl_stmt|;
name|ardataset
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_message_gettemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|ardataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 			 * XXXJT: if we simply clone the rdataset, we'll get 			 * lost wrt cyclic ordering.  We'll need an additional 			 * trick to get the latest counter from the original 			 * header. 			 */
name|dns_rdataset_init
argument_list|(
name|ardataset
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|erdataset
argument_list|,
name|ardataset
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|ardataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|entry
operator|->
name|acache
operator|->
name|stats
operator|.
name|hits
operator|++
expr_stmt|;
comment|/* XXXMLG danger: unlocked! */
name|entry
operator|->
name|acache
operator|->
name|stats
operator|.
name|queries
operator|++
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|fail
label|:
while|while
condition|(
operator|(
name|erdataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fname
operator|->
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|fname
operator|->
name|list
argument_list|,
name|erdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
name|erdataset
argument_list|)
expr_stmt|;
name|dns_message_puttemprdataset
argument_list|(
name|msg
argument_list|,
operator|&
name|erdataset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nodep
operator|!=
name|NULL
condition|)
name|dns_db_detachnode
argument_list|(
operator|*
name|dbp
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|versionp
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
operator|*
name|dbp
argument_list|,
name|versionp
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dbp
operator|!=
name|NULL
condition|)
name|dns_db_detach
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonep
operator|!=
name|NULL
operator|&&
operator|*
name|zonep
operator|!=
name|NULL
condition|)
name|dns_zone_detach
argument_list|(
name|zonep
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_acache_setentry
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_name_t
modifier|*
name|fname
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dbentry_t
modifier|*
name|odbent
decl_stmt|;
name|dbentry_t
modifier|*
name|rdbent
init|=
name|NULL
decl_stmt|;
name|isc_boolean_t
name|close_version
init|=
name|ISC_FALSE
decl_stmt|;
name|dns_acacheentry_t
modifier|*
name|dummy_entry
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* XXX: need to lock it here for ordering */
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* Set zone */
if|if
condition|(
name|zone
operator|!=
name|NULL
condition|)
name|dns_zone_attach
argument_list|(
name|zone
argument_list|,
operator|&
name|entry
operator|->
name|zone
argument_list|)
expr_stmt|;
comment|/* Set DB */
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
name|dns_db_attach
argument_list|(
name|db
argument_list|,
operator|&
name|entry
operator|->
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * Set DB version.  If the version is not given by the caller, 	 * which is the case for glue or cache DBs, use the current version. 	 */
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|dns_db_currentversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|close_version
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_attachversion
argument_list|(
name|db
argument_list|,
name|version
argument_list|,
operator|&
name|entry
operator|->
name|version
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close_version
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|version
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* Set DB node. */
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dns_db_attachnode
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
operator|&
name|entry
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set list of the corresponding rdatasets, if given. 	 * To minimize the overhead and memory consumption, we'll do this for 	 * positive cache only, in which case the DB node is non NULL. 	 * We do not want to cache incomplete information, so give up the 	 * entire entry when a memory shortage happen during the process. 	 */
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|dns_rdataset_t
modifier|*
name|ardataset
decl_stmt|,
modifier|*
name|crdataset
decl_stmt|;
name|entry
operator|->
name|foundname
operator|=
name|isc_mem_get
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|foundname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|foundname
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|dns_name_init
argument_list|(
name|entry
operator|->
name|foundname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_dup
argument_list|(
name|fname
argument_list|,
name|acache
operator|->
name|mctx
argument_list|,
name|entry
operator|->
name|foundname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|ardataset
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|fname
operator|->
name|list
argument_list|)
init|;
name|ardataset
operator|!=
name|NULL
condition|;
name|ardataset
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ardataset
argument_list|,
name|link
argument_list|)
control|)
block|{
name|crdataset
operator|=
name|isc_mem_get
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|crdataset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crdataset
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|dns_rdataset_init
argument_list|(
name|crdataset
argument_list|)
expr_stmt|;
name|dns_rdataset_clone
argument_list|(
name|ardataset
argument_list|,
name|crdataset
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|entry
operator|->
name|foundname
operator|->
name|list
argument_list|,
name|crdataset
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
name|odbent
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|entry
operator|->
name|origdb
argument_list|,
operator|&
name|odbent
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|rdbent
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|finddbent
argument_list|(
name|acache
argument_list|,
name|db
argument_list|,
operator|&
name|rdbent
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|fail
goto|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|acache
operator|->
name|entries
argument_list|,
name|entry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|odbent
operator|->
name|originlist
argument_list|,
name|entry
argument_list|,
name|olink
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdbent
operator|!=
name|NULL
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|rdbent
operator|->
name|referlist
argument_list|,
name|entry
argument_list|,
name|rlink
argument_list|)
expr_stmt|;
comment|/* 	 * The additional cache needs an implicit reference to entries in its 	 * link. 	 */
name|dns_acache_attachentry
argument_list|(
name|entry
argument_list|,
operator|&
name|dummy_entry
argument_list|)
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|acache
operator|->
name|stats
operator|.
name|adds
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|fail
label|:
name|clear_entry
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|dns_acache_cancelentry
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|entry
parameter_list|)
block|{
name|dns_acache_t
modifier|*
name|acache
decl_stmt|;
name|isc_boolean_t
name|callback_active
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|acache
operator|=
name|entry
operator|->
name|acache
expr_stmt|;
name|callback_active
operator|=
name|ISC_TF
argument_list|(
name|entry
operator|->
name|cbarg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|entry
operator|->
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ACACHE_LOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
comment|/* 	 * Release dependencies stored in this entry as much as possible. 	 * The main link cannot be released, since the acache object has 	 * a reference to this entry; the empty entry will be released in 	 * the next cleaning action. 	 */
name|unlink_dbentries
argument_list|(
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|clear_entry
argument_list|(
name|entry
operator|->
name|acache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|callback
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|cbarg
operator|=
name|NULL
expr_stmt|;
name|ACACHE_UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|entrylocks
index|[
name|entry
operator|->
name|locknum
index|]
argument_list|,
name|isc_rwlocktype_write
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|callback_active
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_acache_attachentry
parameter_list|(
name|dns_acacheentry_t
modifier|*
name|source
parameter_list|,
name|dns_acacheentry_t
modifier|*
modifier|*
name|targetp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_ACACHEENTRY_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|targetp
operator|!=
name|NULL
operator|&&
operator|*
name|targetp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_refcount_increment
argument_list|(
operator|&
name|source
operator|->
name|references
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|targetp
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_acache_detachentry
parameter_list|(
name|dns_acacheentry_t
modifier|*
modifier|*
name|entryp
parameter_list|)
block|{
name|dns_acacheentry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|REQUIRE
argument_list|(
name|entryp
operator|!=
name|NULL
operator|&&
name|DNS_ACACHEENTRY_VALID
argument_list|(
operator|*
name|entryp
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|entryp
expr_stmt|;
name|isc_refcount_decrement
argument_list|(
operator|&
name|entry
operator|->
name|references
argument_list|,
operator|&
name|refs
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no references to the entry, the entry must have been 	 * unlinked and can be destroyed safely. 	 */
if|if
condition|(
name|refs
operator|==
literal|0
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|entry
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|entryp
operator|)
operator|->
name|acache
operator|->
name|stats
operator|.
name|deleted
operator|++
expr_stmt|;
name|destroy_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
operator|*
name|entryp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_acache_setcleaninginterval
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|unsigned
name|int
name|t
parameter_list|)
block|{
name|isc_interval_t
name|interval
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
name|ATRACE
argument_list|(
literal|"dns_acache_setcleaninginterval"
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * It may be the case that the acache has already shut down. 	 * If so, it has no timer.  (Not sure if this can really happen.) 	 */
if|if
condition|(
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_timer
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_interval
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|,
name|isc_timertype_inactive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_interval_set
argument_list|(
operator|&
name|interval
argument_list|,
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_interval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_timer_reset
argument_list|(
name|acache
operator|->
name|cleaner
operator|.
name|cleaning_timer
argument_list|,
name|isc_timertype_ticker
argument_list|,
name|NULL
argument_list|,
operator|&
name|interval
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"could not set acache cleaning interval: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DATABASE
argument_list|,
name|DNS_LOGMODULE_ACACHE
argument_list|,
name|ISC_LOG_NOTICE
argument_list|,
literal|"acache %p cleaning interval set to %d."
argument_list|,
name|acache
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|acache
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function was derived from cache.c:dns_cache_setcachesize().  See the  * function for more details about the logic.  */
end_comment

begin_function
name|void
name|dns_acache_setcachesize
parameter_list|(
name|dns_acache_t
modifier|*
name|acache
parameter_list|,
name|isc_uint32_t
name|size
parameter_list|)
block|{
name|isc_uint32_t
name|lowater
decl_stmt|;
name|isc_uint32_t
name|hiwater
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_ACACHE_VALID
argument_list|(
name|acache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0U
operator|&&
name|size
operator|<
name|DNS_ACACHE_MINSIZE
condition|)
name|size
operator|=
name|DNS_ACACHE_MINSIZE
expr_stmt|;
name|hiwater
operator|=
name|size
operator|-
operator|(
name|size
operator|>>
literal|3
operator|)
expr_stmt|;
name|lowater
operator|=
name|size
operator|-
operator|(
name|size
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0U
operator|||
name|hiwater
operator|==
literal|0U
operator|||
name|lowater
operator|==
literal|0U
condition|)
name|isc_mem_setwater
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|water
argument_list|,
name|acache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|isc_mem_setwater
argument_list|(
name|acache
operator|->
name|mctx
argument_list|,
name|water
argument_list|,
name|acache
argument_list|,
name|hiwater
argument_list|,
name|lowater
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

