begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2013, 2014  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_comment
comment|/*  * Rate limit DNS responses.  */
end_comment

begin_comment
comment|/* #define ISC_LIST_CHECKINIT */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rcode.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/rrl.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_function_decl
specifier|static
name|void
name|log_end
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|isc_boolean_t
name|early
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get a modulus for a hash function that is tolerably likely to be  * relatively prime to most inputs.  Of course, we get a prime for for initial  * values not larger than the square of the last prime.  We often get a prime  * after that.  * This works well in practice for hash tables up to at least 100  * times the square of the last prime and better than a multiplicative hash.  */
end_comment

begin_function
specifier|static
name|int
name|hash_divisor
parameter_list|(
name|unsigned
name|int
name|initial
parameter_list|)
block|{
specifier|static
name|isc_uint16_t
name|primes
index|[]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|29
block|,
literal|31
block|,
literal|37
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|53
block|,
literal|59
block|,
literal|61
block|,
literal|67
block|,
literal|71
block|,
literal|73
block|,
literal|79
block|,
literal|83
block|,
literal|89
block|,
literal|97
block|,
if|#
directive|if
literal|0
block|101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 		163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 		229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 		293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 		373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 		443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 		521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 		601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 		673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 		757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 		839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 		929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997,1009,
endif|#
directive|endif
block|}
decl_stmt|;
name|int
name|divisions
decl_stmt|,
name|tries
decl_stmt|;
name|unsigned
name|int
name|result
decl_stmt|;
name|isc_uint16_t
modifier|*
name|pp
decl_stmt|,
name|p
decl_stmt|;
name|result
operator|=
name|initial
expr_stmt|;
if|if
condition|(
name|primes
index|[
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|primes
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
operator|>=
name|result
condition|)
block|{
name|pp
operator|=
name|primes
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|<
name|result
condition|)
operator|++
name|pp
expr_stmt|;
return|return
operator|(
operator|*
name|pp
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|result
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
operator|++
name|result
expr_stmt|;
name|divisions
operator|=
literal|0
expr_stmt|;
name|tries
operator|=
literal|1
expr_stmt|;
name|pp
operator|=
name|primes
expr_stmt|;
do|do
block|{
name|p
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
operator|++
name|divisions
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|%
name|p
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|tries
expr_stmt|;
name|result
operator|+=
literal|2
expr_stmt|;
name|pp
operator|=
name|primes
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pp
operator|<
operator|&
name|primes
index|[
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|primes
index|[
literal|0
index|]
argument_list|)
index|]
condition|)
do|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|)
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|,
literal|"%d hash_divisor() divisions in %d tries"
literal|" to get %d from %d"
argument_list|,
name|divisions
argument_list|,
name|tries
argument_list|,
name|result
argument_list|,
name|initial
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a timestamp to a number of seconds in the past.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|delta_rrl_time
parameter_list|(
name|isc_stdtime_t
name|ts
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|int
name|delta
decl_stmt|;
name|delta
operator|=
name|now
operator|-
name|ts
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|0
condition|)
return|return
operator|(
name|delta
operator|)
return|;
comment|/* 	 * The timestamp is in the future.  That future might result from 	 * re-ordered requests, because we use timestamps on requests 	 * instead of consulting a clock.  Timestamps in the distant future are 	 * assumed to result from clock changes.  When the clock changes to 	 * the past, make existing timestamps appear to be in the past. 	 */
if|if
condition|(
name|delta
operator|<
operator|-
name|DNS_RRL_MAX_TIME_TRAVEL
condition|)
return|return
operator|(
name|DNS_RRL_FOREVER
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|get_age
parameter_list|(
specifier|const
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
specifier|const
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|ts_valid
condition|)
return|return
operator|(
name|DNS_RRL_FOREVER
operator|)
return|;
return|return
operator|(
name|delta_rrl_time
argument_list|(
name|e
operator|->
name|ts
operator|+
name|rrl
operator|->
name|ts_bases
index|[
name|e
operator|->
name|ts_gen
index|]
argument_list|,
name|now
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_age
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rrl_entry_t
modifier|*
name|e_old
decl_stmt|;
name|unsigned
name|int
name|ts_gen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ts
decl_stmt|;
name|ts_gen
operator|=
name|rrl
operator|->
name|ts_gen
expr_stmt|;
name|ts
operator|=
name|now
operator|-
name|rrl
operator|->
name|ts_bases
index|[
name|ts_gen
index|]
expr_stmt|;
if|if
condition|(
name|ts
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ts
operator|<
operator|-
name|DNS_RRL_MAX_TIME_TRAVEL
condition|)
name|ts
operator|=
name|DNS_RRL_FOREVER
expr_stmt|;
else|else
name|ts
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Make a new timestamp base if the current base is too old. 	 * All entries older than DNS_RRL_MAX_WINDOW seconds are ancient, 	 * useless history.  Their timestamps can be treated as if they are 	 * all the same. 	 * We only do arithmetic on more recent timestamps, so bases for 	 * older timestamps can be recycled provided the old timestamps are 	 * marked as ancient history. 	 * This loop is almost always very short because most entries are 	 * recycled after one second and any entries that need to be marked 	 * are older than (DNS_RRL_TS_BASES)*DNS_RRL_MAX_TS seconds. 	 */
if|if
condition|(
name|ts
operator|>=
name|DNS_RRL_MAX_TS
condition|)
block|{
name|ts_gen
operator|=
operator|(
name|ts_gen
operator|+
literal|1
operator|)
operator|%
name|DNS_RRL_TS_BASES
expr_stmt|;
for|for
control|(
name|e_old
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|rrl
operator|->
name|lru
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|e_old
operator|!=
name|NULL
operator|&&
operator|(
name|e_old
operator|->
name|ts_gen
operator|==
name|ts_gen
operator|||
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|e_old
argument_list|,
name|hlink
argument_list|)
operator|)
condition|;
name|e_old
operator|=
name|ISC_LIST_PREV
argument_list|(
name|e_old
argument_list|,
name|lru
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|e_old
operator|->
name|ts_valid
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG1
argument_list|,
literal|"rrl new time base scanned %d entries"
literal|" at %d for %d %d %d %d"
argument_list|,
name|i
argument_list|,
name|now
argument_list|,
name|rrl
operator|->
name|ts_bases
index|[
name|ts_gen
index|]
argument_list|,
name|rrl
operator|->
name|ts_bases
index|[
operator|(
name|ts_gen
operator|+
literal|1
operator|)
operator|%
name|DNS_RRL_TS_BASES
index|]
argument_list|,
name|rrl
operator|->
name|ts_bases
index|[
operator|(
name|ts_gen
operator|+
literal|2
operator|)
operator|%
name|DNS_RRL_TS_BASES
index|]
argument_list|,
name|rrl
operator|->
name|ts_bases
index|[
operator|(
name|ts_gen
operator|+
literal|3
operator|)
operator|%
name|DNS_RRL_TS_BASES
index|]
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|ts_gen
operator|=
name|ts_gen
expr_stmt|;
name|rrl
operator|->
name|ts_bases
index|[
name|ts_gen
index|]
operator|=
name|now
expr_stmt|;
name|ts
operator|=
literal|0
expr_stmt|;
block|}
name|e
operator|->
name|ts_gen
operator|=
name|ts_gen
expr_stmt|;
name|e
operator|->
name|ts
operator|=
name|ts
expr_stmt|;
name|e
operator|->
name|ts_valid
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|expand_entries
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|unsigned
name|int
name|bsize
decl_stmt|;
name|dns_rrl_block_t
modifier|*
name|b
decl_stmt|;
name|dns_rrl_entry_t
modifier|*
name|e
decl_stmt|;
name|double
name|rate
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rrl
operator|->
name|num_entries
operator|+
name|new
operator|>=
name|rrl
operator|->
name|max_entries
operator|&&
name|rrl
operator|->
name|max_entries
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|rrl
operator|->
name|max_entries
operator|-
name|rrl
operator|->
name|num_entries
expr_stmt|;
if|if
condition|(
name|new
operator|<=
literal|0
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * Log expansions so that the user can tune max-table-size 	 * and min-table-size. 	 */
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|)
operator|&&
name|rrl
operator|->
name|hash
operator|!=
name|NULL
condition|)
block|{
name|rate
operator|=
name|rrl
operator|->
name|probes
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|searches
operator|!=
literal|0
condition|)
name|rate
operator|/=
name|rrl
operator|->
name|searches
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|,
literal|"increase from %d to %d RRL entries with"
literal|" %d bins; average search length %.1f"
argument_list|,
name|rrl
operator|->
name|num_entries
argument_list|,
name|rrl
operator|->
name|num_entries
operator|+
name|new
argument_list|,
name|rrl
operator|->
name|hash
operator|->
name|length
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
name|bsize
operator|=
sizeof|sizeof
argument_list|(
name|dns_rrl_block_t
argument_list|)
operator|+
operator|(
name|new
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dns_rrl_entry_t
argument_list|)
expr_stmt|;
name|b
operator|=
name|isc_mem_get
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_FAIL
argument_list|,
literal|"isc_mem_get(%d) failed for RRL entries"
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|b
operator|->
name|size
operator|=
name|bsize
expr_stmt|;
name|e
operator|=
name|b
operator|->
name|entries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new
condition|;
operator|++
name|i
operator|,
operator|++
name|e
control|)
block|{
name|ISC_LINK_INIT
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|rrl
operator|->
name|lru
argument_list|,
name|e
argument_list|,
name|lru
argument_list|)
expr_stmt|;
block|}
name|rrl
operator|->
name|num_entries
operator|+=
name|new
expr_stmt|;
name|ISC_LIST_INITANDAPPEND
argument_list|(
name|rrl
operator|->
name|blocks
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rrl_bin_t
modifier|*
name|get_bin
parameter_list|(
name|dns_rrl_hash_t
modifier|*
name|hash
parameter_list|,
name|unsigned
name|int
name|hval
parameter_list|)
block|{
name|INSIST
argument_list|(
name|hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|hash
operator|->
name|bins
index|[
name|hval
operator|%
name|hash
operator|->
name|length
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_old_hash
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|)
block|{
name|dns_rrl_hash_t
modifier|*
name|old_hash
decl_stmt|;
name|dns_rrl_bin_t
modifier|*
name|old_bin
decl_stmt|;
name|dns_rrl_entry_t
modifier|*
name|e
decl_stmt|,
modifier|*
name|e_next
decl_stmt|;
name|old_hash
operator|=
name|rrl
operator|->
name|old_hash
expr_stmt|;
for|for
control|(
name|old_bin
operator|=
operator|&
name|old_hash
operator|->
name|bins
index|[
literal|0
index|]
init|;
name|old_bin
operator|<
operator|&
name|old_hash
operator|->
name|bins
index|[
name|old_hash
operator|->
name|length
index|]
condition|;
operator|++
name|old_bin
control|)
block|{
for|for
control|(
name|e
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|old_bin
argument_list|)
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e_next
control|)
block|{
name|e_next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
block|}
block|}
name|isc_mem_put
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|old_hash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|old_hash
argument_list|)
operator|+
operator|(
name|old_hash
operator|->
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|old_hash
operator|->
name|bins
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|old_hash
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|expand_rrl_hash
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
name|dns_rrl_hash_t
modifier|*
name|hash
decl_stmt|;
name|int
name|old_bins
decl_stmt|,
name|new_bins
decl_stmt|,
name|hsize
decl_stmt|;
name|double
name|rate
decl_stmt|;
if|if
condition|(
name|rrl
operator|->
name|old_hash
operator|!=
name|NULL
condition|)
name|free_old_hash
argument_list|(
name|rrl
argument_list|)
expr_stmt|;
comment|/* 	 * Most searches fail and so go to the end of the chain. 	 * Use a small hash table load factor. 	 */
name|old_bins
operator|=
operator|(
name|rrl
operator|->
name|hash
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|rrl
operator|->
name|hash
operator|->
name|length
expr_stmt|;
name|new_bins
operator|=
name|old_bins
operator|/
literal|8
operator|+
name|old_bins
expr_stmt|;
if|if
condition|(
name|new_bins
operator|<
name|rrl
operator|->
name|num_entries
condition|)
name|new_bins
operator|=
name|rrl
operator|->
name|num_entries
expr_stmt|;
name|new_bins
operator|=
name|hash_divisor
argument_list|(
name|new_bins
argument_list|)
expr_stmt|;
name|hsize
operator|=
sizeof|sizeof
argument_list|(
name|dns_rrl_hash_t
argument_list|)
operator|+
operator|(
name|new_bins
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hash
operator|->
name|bins
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hash
operator|=
name|isc_mem_get
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_FAIL
argument_list|,
literal|"isc_mem_get(%d) failed for"
literal|" RRL hash table"
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|hash
operator|->
name|length
operator|=
name|new_bins
expr_stmt|;
name|rrl
operator|->
name|hash_gen
operator|^=
literal|1
expr_stmt|;
name|hash
operator|->
name|gen
operator|=
name|rrl
operator|->
name|hash_gen
expr_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|)
operator|&&
name|old_bins
operator|!=
literal|0
condition|)
block|{
name|rate
operator|=
name|rrl
operator|->
name|probes
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|searches
operator|!=
literal|0
condition|)
name|rate
operator|/=
name|rrl
operator|->
name|searches
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|,
literal|"increase from %d to %d RRL bins for"
literal|" %d entries; average search length %.1f"
argument_list|,
name|old_bins
argument_list|,
name|new_bins
argument_list|,
name|rrl
operator|->
name|num_entries
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
name|rrl
operator|->
name|old_hash
operator|=
name|rrl
operator|->
name|hash
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|old_hash
operator|!=
name|NULL
condition|)
name|rrl
operator|->
name|old_hash
operator|->
name|check_time
operator|=
name|now
expr_stmt|;
name|rrl
operator|->
name|hash
operator|=
name|hash
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ref_entry
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|int
name|probes
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
block|{
comment|/* 	 * Make the entry most recently used. 	 */
if|if
condition|(
name|ISC_LIST_HEAD
argument_list|(
name|rrl
operator|->
name|lru
argument_list|)
operator|!=
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|rrl
operator|->
name|last_logged
condition|)
name|rrl
operator|->
name|last_logged
operator|=
name|ISC_LIST_PREV
argument_list|(
name|e
argument_list|,
name|lru
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|rrl
operator|->
name|lru
argument_list|,
name|e
argument_list|,
name|lru
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|rrl
operator|->
name|lru
argument_list|,
name|e
argument_list|,
name|lru
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Expand the hash table if it is time and necessary. 	 * This will leave the newly referenced entry in a chain in the 	 * old hash table.  It will migrate to the new hash table the next 	 * time it is used or be cut loose when the old hash table is destroyed. 	 */
name|rrl
operator|->
name|probes
operator|+=
name|probes
expr_stmt|;
operator|++
name|rrl
operator|->
name|searches
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|searches
operator|>
literal|100
operator|&&
name|delta_rrl_time
argument_list|(
name|rrl
operator|->
name|hash
operator|->
name|check_time
argument_list|,
name|now
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rrl
operator|->
name|probes
operator|/
name|rrl
operator|->
name|searches
operator|>
literal|2
condition|)
name|expand_rrl_hash
argument_list|(
name|rrl
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|hash
operator|->
name|check_time
operator|=
name|now
expr_stmt|;
name|rrl
operator|->
name|probes
operator|=
literal|0
expr_stmt|;
name|rrl
operator|->
name|searches
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_boolean_t
name|key_cmp
parameter_list|(
specifier|const
name|dns_rrl_key_t
modifier|*
name|a
parameter_list|,
specifier|const
name|dns_rrl_key_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_rrl_key_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_uint32_t
name|hash_key
parameter_list|(
specifier|const
name|dns_rrl_key_t
modifier|*
name|key
parameter_list|)
block|{
name|isc_uint32_t
name|hval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hval
operator|=
name|key
operator|->
name|w
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|key
operator|->
name|w
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|hval
operator|=
name|key
operator|->
name|w
index|[
name|i
index|]
operator|+
operator|(
name|hval
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|hval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the hash table key.  * Use a hash of the DNS query name to save space in the database.  * Collisions result in legitimate rate limiting responses for one  * query name also limiting responses for other names to the  * same client.  This is rare and benign enough given the large  * space costs compared to keeping the entire name in the database  * entry or the time costs of dynamic allocation.  */
end_comment

begin_function
specifier|static
name|void
name|make_key
parameter_list|(
specifier|const
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_key_t
modifier|*
name|key
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|client_addr
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_rdataclass_t
name|qclass
parameter_list|,
name|dns_rrl_rtype_t
name|rtype
parameter_list|)
block|{
name|dns_name_t
name|base
decl_stmt|;
name|dns_offsets_t
name|base_offsets
decl_stmt|;
name|int
name|labels
decl_stmt|,
name|i
decl_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|->
name|s
operator|.
name|rtype
operator|=
name|rtype
expr_stmt|;
if|if
condition|(
name|rtype
operator|==
name|DNS_RRL_RTYPE_QUERY
condition|)
block|{
name|key
operator|->
name|s
operator|.
name|qtype
operator|=
name|qtype
expr_stmt|;
name|key
operator|->
name|s
operator|.
name|qclass
operator|=
name|qclass
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|==
name|DNS_RRL_RTYPE_REFERRAL
operator|||
name|rtype
operator|==
name|DNS_RRL_RTYPE_NODATA
condition|)
block|{
comment|/* 		 * Because there is no qtype in the empty answer sections of 		 * referral and NODATA responses, count them as the same. 		 */
name|key
operator|->
name|s
operator|.
name|qclass
operator|=
name|qclass
operator|&
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|qname
operator|!=
name|NULL
operator|&&
name|qname
operator|->
name|labels
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Ignore the first label of wildcards. 		 */
if|if
condition|(
operator|(
name|qname
operator|->
name|attributes
operator|&
name|DNS_NAMEATTR_WILDCARD
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|qname
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|base
argument_list|,
name|base_offsets
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|qname
argument_list|,
literal|1
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
name|key
operator|->
name|s
operator|.
name|qname_hash
operator|=
name|dns_name_hashbylabel
argument_list|(
operator|&
name|base
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|s
operator|.
name|qname_hash
operator|=
name|dns_name_hashbylabel
argument_list|(
name|qname
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|client_addr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|key
operator|->
name|s
operator|.
name|ip
index|[
literal|0
index|]
operator|=
operator|(
name|client_addr
operator|->
name|type
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|rrl
operator|->
name|ipv4_mask
operator|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|key
operator|->
name|s
operator|.
name|ipv6
operator|=
name|ISC_TRUE
expr_stmt|;
name|memmove
argument_list|(
name|key
operator|->
name|s
operator|.
name|ip
argument_list|,
operator|&
name|client_addr
operator|->
name|type
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|key
operator|->
name|s
operator|.
name|ip
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_RRL_MAX_PREFIX
operator|/
literal|32
condition|;
operator|++
name|i
control|)
name|key
operator|->
name|s
operator|.
name|ip
index|[
name|i
index|]
operator|&=
name|rrl
operator|->
name|ipv6_mask
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rrl_rate_t
modifier|*
name|get_rate
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_rtype_t
name|rtype
parameter_list|)
block|{
switch|switch
condition|(
name|rtype
condition|)
block|{
case|case
name|DNS_RRL_RTYPE_QUERY
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|responses_per_second
operator|)
return|;
case|case
name|DNS_RRL_RTYPE_REFERRAL
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|referrals_per_second
operator|)
return|;
case|case
name|DNS_RRL_RTYPE_NODATA
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|nodata_per_second
operator|)
return|;
case|case
name|DNS_RRL_RTYPE_NXDOMAIN
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|nxdomains_per_second
operator|)
return|;
case|case
name|DNS_RRL_RTYPE_ERROR
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|errors_per_second
operator|)
return|;
case|case
name|DNS_RRL_RTYPE_ALL
case|:
return|return
operator|(
operator|&
name|rrl
operator|->
name|all_per_second
operator|)
return|;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|response_balance
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
specifier|const
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|int
name|age
parameter_list|)
block|{
name|dns_rrl_rate_t
modifier|*
name|ratep
decl_stmt|;
name|int
name|balance
decl_stmt|,
name|rate
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_TCP
condition|)
block|{
name|rate
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ratep
operator|=
name|get_rate
argument_list|(
name|rrl
argument_list|,
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ratep
operator|->
name|scaled
expr_stmt|;
block|}
name|balance
operator|=
name|e
operator|->
name|responses
operator|+
name|age
operator|*
name|rate
expr_stmt|;
if|if
condition|(
name|balance
operator|>
name|rate
condition|)
name|balance
operator|=
name|rate
expr_stmt|;
return|return
operator|(
name|balance
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for an entry for a response and optionally create it.  */
end_comment

begin_function
specifier|static
name|dns_rrl_entry_t
modifier|*
name|get_entry
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|client_addr
parameter_list|,
name|dns_rdataclass_t
name|qclass
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|dns_rrl_rtype_t
name|rtype
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
name|dns_rrl_key_t
name|key
decl_stmt|;
name|isc_uint32_t
name|hval
decl_stmt|;
name|dns_rrl_entry_t
modifier|*
name|e
decl_stmt|;
name|dns_rrl_hash_t
modifier|*
name|hash
decl_stmt|;
name|dns_rrl_bin_t
modifier|*
name|new_bin
decl_stmt|,
modifier|*
name|old_bin
decl_stmt|;
name|int
name|probes
decl_stmt|,
name|age
decl_stmt|;
name|make_key
argument_list|(
name|rrl
argument_list|,
operator|&
name|key
argument_list|,
name|client_addr
argument_list|,
name|qtype
argument_list|,
name|qname
argument_list|,
name|qclass
argument_list|,
name|rtype
argument_list|)
expr_stmt|;
name|hval
operator|=
name|hash_key
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * Look for the entry in the current hash table. 	 */
name|new_bin
operator|=
name|get_bin
argument_list|(
name|rrl
operator|->
name|hash
argument_list|,
name|hval
argument_list|)
expr_stmt|;
name|probes
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|new_bin
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_cmp
argument_list|(
operator|&
name|e
operator|->
name|key
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|ref_entry
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|probes
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
operator|++
name|probes
expr_stmt|;
name|e
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look in the old hash table. 	 */
if|if
condition|(
name|rrl
operator|->
name|old_hash
operator|!=
name|NULL
condition|)
block|{
name|old_bin
operator|=
name|get_bin
argument_list|(
name|rrl
operator|->
name|old_hash
argument_list|,
name|hval
argument_list|)
expr_stmt|;
name|e
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|old_bin
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_cmp
argument_list|(
operator|&
name|e
operator|->
name|key
argument_list|,
operator|&
name|key
argument_list|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|old_bin
argument_list|,
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
operator|*
name|new_bin
argument_list|,
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|e
operator|->
name|hash_gen
operator|=
name|rrl
operator|->
name|hash_gen
expr_stmt|;
name|ref_entry
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|probes
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
name|e
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Discard prevous hash table when all of its entries are old. 		 */
name|age
operator|=
name|delta_rrl_time
argument_list|(
name|rrl
operator|->
name|old_hash
operator|->
name|check_time
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>
name|rrl
operator|->
name|window
condition|)
name|free_old_hash
argument_list|(
name|rrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The entry does not exist, so create it by finding a free entry. 	 * Keep currently penalized and logged entries. 	 * Try to make more entries if none are idle. 	 * Steal the oldest entry if we cannot create more. 	 */
for|for
control|(
name|e
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|rrl
operator|->
name|lru
argument_list|)
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|ISC_LIST_PREV
argument_list|(
name|e
argument_list|,
name|lru
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
condition|)
break|break;
name|age
operator|=
name|get_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|<=
literal|1
condition|)
block|{
name|e
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|logged
operator|&&
name|response_balance
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|age
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|expand_entries
argument_list|(
name|rrl
argument_list|,
name|ISC_MIN
argument_list|(
operator|(
name|rrl
operator|->
name|num_entries
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|rrl
operator|->
name|lru
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|logged
condition|)
name|log_end
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|ISC_TRUE
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|e
argument_list|,
name|hlink
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|hash_gen
operator|==
name|rrl
operator|->
name|hash_gen
condition|)
name|hash
operator|=
name|rrl
operator|->
name|hash
expr_stmt|;
else|else
name|hash
operator|=
name|rrl
operator|->
name|old_hash
expr_stmt|;
name|old_bin
operator|=
name|get_bin
argument_list|(
name|hash
argument_list|,
name|hash_key
argument_list|(
operator|&
name|e
operator|->
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|old_bin
argument_list|,
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
block|}
name|ISC_LIST_PREPEND
argument_list|(
operator|*
name|new_bin
argument_list|,
name|e
argument_list|,
name|hlink
argument_list|)
expr_stmt|;
name|e
operator|->
name|hash_gen
operator|=
name|rrl
operator|->
name|hash_gen
expr_stmt|;
name|e
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|e
operator|->
name|ts_valid
operator|=
name|ISC_FALSE
expr_stmt|;
name|ref_entry
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|probes
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debit_log
parameter_list|(
specifier|const
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|int
name|age
parameter_list|,
specifier|const
name|char
modifier|*
name|action
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"age=12345678"
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|age_str
decl_stmt|;
if|if
condition|(
name|age
operator|==
name|DNS_RRL_FOREVER
condition|)
block|{
name|age_str
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"age=%d"
argument_list|,
name|age
argument_list|)
expr_stmt|;
name|age_str
operator|=
name|buf
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|,
literal|"rrl %08x %6s  responses=%-3d %s"
argument_list|,
name|hash_key
argument_list|(
operator|&
name|e
operator|->
name|key
argument_list|)
argument_list|,
name|age_str
argument_list|,
name|e
operator|->
name|responses
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rrl_result_t
name|debit_rrl_entry
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|double
name|qps
parameter_list|,
name|double
name|scale
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|client_addr
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
name|int
name|rate
decl_stmt|,
name|new_rate
decl_stmt|,
name|slip
decl_stmt|,
name|new_slip
decl_stmt|,
name|age
decl_stmt|,
name|log_secs
decl_stmt|,
name|min
decl_stmt|;
name|dns_rrl_rate_t
modifier|*
name|ratep
decl_stmt|;
name|dns_rrl_entry_t
specifier|const
modifier|*
name|credit_e
decl_stmt|;
comment|/* 	 * Pick the rate counter. 	 * Optionally adjust the rate by the estimated query/second rate. 	 */
name|ratep
operator|=
name|get_rate
argument_list|(
name|rrl
argument_list|,
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ratep
operator|->
name|r
expr_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
if|if
condition|(
name|scale
operator|<
literal|1.0
condition|)
block|{
comment|/* 		 * The limit for clients that have used TCP is not scaled. 		 */
name|credit_e
operator|=
name|get_entry
argument_list|(
name|rrl
argument_list|,
name|client_addr
argument_list|,
literal|0
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
name|DNS_RRL_RTYPE_TCP
argument_list|,
name|now
argument_list|,
name|ISC_FALSE
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|credit_e
operator|!=
name|NULL
condition|)
block|{
name|age
operator|=
name|get_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|<
name|rrl
operator|->
name|window
condition|)
name|scale
operator|=
literal|1.0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scale
operator|<
literal|1.0
condition|)
block|{
name|new_rate
operator|=
call|(
name|int
call|)
argument_list|(
name|rate
operator|*
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rate
operator|<
literal|1
condition|)
name|new_rate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ratep
operator|->
name|scaled
operator|!=
name|new_rate
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG1
argument_list|,
literal|"%d qps scaled %s by %.2f"
literal|" from %d to %d"
argument_list|,
operator|(
name|int
operator|)
name|qps
argument_list|,
name|ratep
operator|->
name|str
argument_list|,
name|scale
argument_list|,
name|rate
argument_list|,
name|new_rate
argument_list|)
expr_stmt|;
name|rate
operator|=
name|new_rate
expr_stmt|;
name|ratep
operator|->
name|scaled
operator|=
name|rate
expr_stmt|;
block|}
block|}
name|min
operator|=
operator|-
name|rrl
operator|->
name|window
operator|*
name|rate
expr_stmt|;
comment|/* 	 * Treat time jumps into the recent past as no time. 	 * Treat entries older than the window as if they were just created 	 * Credit other entries. 	 */
name|age
operator|=
name|get_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Credit tokens earned during elapsed time. 		 */
if|if
condition|(
name|age
operator|>
name|rrl
operator|->
name|window
condition|)
block|{
name|e
operator|->
name|responses
operator|=
name|rate
expr_stmt|;
name|e
operator|->
name|slip_cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|responses
operator|+=
name|rate
operator|*
name|age
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|responses
operator|>
name|rate
condition|)
block|{
name|e
operator|->
name|responses
operator|=
name|rate
expr_stmt|;
name|e
operator|->
name|slip_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Find the seconds since last log message without overflowing 		 * small counter.  This counter is reset when an entry is 		 * created.  It is not necessarily reset when some requests 		 * are answered provided other requests continue to be dropped 		 * or slipped.  This can happen when the request rate is just 		 * at the limit. 		 */
if|if
condition|(
name|e
operator|->
name|logged
condition|)
block|{
name|log_secs
operator|=
name|e
operator|->
name|log_secs
expr_stmt|;
name|log_secs
operator|+=
name|age
expr_stmt|;
if|if
condition|(
name|log_secs
operator|>
name|DNS_RRL_MAX_LOG_SECS
operator|||
name|log_secs
operator|<
literal|0
condition|)
name|log_secs
operator|=
name|DNS_RRL_MAX_LOG_SECS
expr_stmt|;
name|e
operator|->
name|log_secs
operator|=
name|log_secs
expr_stmt|;
block|}
block|}
name|set_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Debit the entry for this response. 	 */
if|if
condition|(
operator|--
name|e
operator|->
name|responses
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|)
condition|)
name|debit_log
argument_list|(
name|e
argument_list|,
name|age
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
block|}
if|if
condition|(
name|e
operator|->
name|responses
operator|<
name|min
condition|)
name|e
operator|->
name|responses
operator|=
name|min
expr_stmt|;
comment|/* 	 * Drop this response unless it should slip or leak. 	 */
name|slip
operator|=
name|rrl
operator|->
name|slip
operator|.
name|r
expr_stmt|;
if|if
condition|(
name|slip
operator|>
literal|2
operator|&&
name|scale
operator|<
literal|1.0
condition|)
block|{
name|new_slip
operator|=
call|(
name|int
call|)
argument_list|(
name|slip
operator|*
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_slip
operator|<
literal|2
condition|)
name|new_slip
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|slip
operator|.
name|scaled
operator|!=
name|new_slip
condition|)
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG1
argument_list|,
literal|"%d qps scaled slip"
literal|" by %.2f from %d to %d"
argument_list|,
operator|(
name|int
operator|)
name|qps
argument_list|,
name|scale
argument_list|,
name|slip
argument_list|,
name|new_slip
argument_list|)
expr_stmt|;
name|slip
operator|=
name|new_slip
expr_stmt|;
name|rrl
operator|->
name|slip
operator|.
name|scaled
operator|=
name|slip
expr_stmt|;
block|}
block|}
if|if
condition|(
name|slip
operator|!=
literal|0
operator|&&
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|!=
name|DNS_RRL_RTYPE_ALL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|slip_cnt
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|e
operator|->
name|slip_cnt
operator|>=
name|slip
condition|)
name|e
operator|->
name|slip_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|)
condition|)
name|debit_log
argument_list|(
name|e
argument_list|,
name|age
argument_list|,
literal|"slip"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_SLIP
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|e
operator|->
name|slip_cnt
operator|>=
name|slip
condition|)
block|{
name|e
operator|->
name|slip_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|)
condition|)
name|debit_log
argument_list|(
name|e
argument_list|,
name|age
argument_list|,
literal|"drop"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_DROP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rrl_qname_buf_t
modifier|*
name|get_qname
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
specifier|const
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|)
block|{
name|dns_rrl_qname_buf_t
modifier|*
name|qbuf
decl_stmt|;
name|qbuf
operator|=
name|rrl
operator|->
name|qnames
index|[
name|e
operator|->
name|log_qname
index|]
expr_stmt|;
if|if
condition|(
name|qbuf
operator|==
name|NULL
operator|||
name|qbuf
operator|->
name|e
operator|!=
name|e
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|qbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_qname
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|)
block|{
name|dns_rrl_qname_buf_t
modifier|*
name|qbuf
decl_stmt|;
name|qbuf
operator|=
name|get_qname
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbuf
operator|!=
name|NULL
condition|)
block|{
name|qbuf
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rrl
operator|->
name|qname_free
argument_list|,
name|qbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_log_str
parameter_list|(
name|isc_buffer_t
modifier|*
name|lb
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|int
name|str_len
parameter_list|)
block|{
name|isc_region_t
name|region
decl_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|lb
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_len
operator|>=
name|region
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|region
operator|.
name|length
operator|<=
literal|0
condition|)
return|return;
name|str_len
operator|=
name|region
operator|.
name|length
expr_stmt|;
block|}
name|memmove
argument_list|(
name|region
operator|.
name|base
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|lb
argument_list|,
name|str_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ADD_LOG_CSTR
parameter_list|(
name|eb
parameter_list|,
name|s
parameter_list|)
value|add_log_str(eb, s, sizeof(s)-1)
end_define

begin_comment
comment|/*  * Build strings for the logs  */
end_comment

begin_function
specifier|static
name|void
name|make_log_buf
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|,
name|isc_boolean_t
name|plural
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|isc_boolean_t
name|save_qname
parameter_list|,
name|dns_rrl_result_t
name|rrl_result
parameter_list|,
name|isc_result_t
name|resp_result
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
name|isc_buffer_t
name|lb
decl_stmt|;
name|dns_rrl_qname_buf_t
modifier|*
name|qbuf
decl_stmt|;
name|isc_netaddr_t
name|cidr
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_MAX
argument_list|(
sizeof|sizeof
argument_list|(
literal|"/123"
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
literal|"  (12345678)"
argument_list|)
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|rstr
decl_stmt|;
name|isc_result_t
name|msg_result
decl_stmt|;
if|if
condition|(
name|log_buf_len
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|log_buf_len
operator|==
literal|1
condition|)
name|log_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|lb
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|str1
operator|!=
name|NULL
condition|)
name|add_log_str
argument_list|(
operator|&
name|lb
argument_list|,
name|str1
argument_list|,
name|strlen
argument_list|(
name|str1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str2
operator|!=
name|NULL
condition|)
name|add_log_str
argument_list|(
operator|&
name|lb
argument_list|,
name|str2
argument_list|,
name|strlen
argument_list|(
name|str2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rrl_result
condition|)
block|{
case|case
name|DNS_RRL_RESULT_OK
case|:
break|break;
case|case
name|DNS_RRL_RESULT_DROP
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"drop "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RRL_RESULT_SLIP
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"slip "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
condition|)
block|{
case|case
name|DNS_RRL_RTYPE_QUERY
case|:
break|break;
case|case
name|DNS_RRL_RTYPE_REFERRAL
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"referral "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RRL_RTYPE_NODATA
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"NODATA "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RRL_RTYPE_NXDOMAIN
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"NXDOMAIN "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNS_RRL_RTYPE_ERROR
case|:
if|if
condition|(
name|resp_result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"error "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rstr
operator|=
name|isc_result_totext
argument_list|(
name|resp_result
argument_list|)
expr_stmt|;
name|add_log_str
argument_list|(
operator|&
name|lb
argument_list|,
name|rstr
argument_list|,
name|strlen
argument_list|(
name|rstr
argument_list|)
argument_list|)
expr_stmt|;
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|" error "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DNS_RRL_RTYPE_ALL
case|:
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"all "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|plural
condition|)
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"responses to "
argument_list|)
expr_stmt|;
else|else
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"response to "
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cidr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|ipv6
condition|)
block|{
name|snprintf
argument_list|(
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|,
literal|"/%d"
argument_list|,
name|rrl
operator|->
name|ipv6_prefixlen
argument_list|)
expr_stmt|;
name|cidr
operator|.
name|family
operator|=
name|AF_INET6
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cidr
operator|.
name|type
operator|.
name|in6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cidr
operator|.
name|type
operator|.
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|cidr
operator|.
name|type
operator|.
name|in6
argument_list|,
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|,
literal|"/%d"
argument_list|,
name|rrl
operator|->
name|ipv4_prefixlen
argument_list|)
expr_stmt|;
name|cidr
operator|.
name|family
operator|=
name|AF_INET
expr_stmt|;
name|cidr
operator|.
name|type
operator|.
name|in
operator|.
name|s_addr
operator|=
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|ip
index|[
literal|0
index|]
expr_stmt|;
block|}
name|msg_result
operator|=
name|isc_netaddr_totext
argument_list|(
operator|&
name|cidr
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|add_log_str
argument_list|(
operator|&
name|lb
argument_list|,
name|strbuf
argument_list|,
name|strlen
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_QUERY
operator|||
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_REFERRAL
operator|||
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_NODATA
operator|||
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_NXDOMAIN
condition|)
block|{
name|qbuf
operator|=
name|get_qname
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_qname
operator|&&
name|qbuf
operator|==
name|NULL
operator|&&
name|qname
operator|!=
name|NULL
operator|&&
name|dns_name_isabsolute
argument_list|(
name|qname
argument_list|)
condition|)
block|{
comment|/* 			 * Capture the qname for the "stop limiting" message. 			 */
name|qbuf
operator|=
name|ISC_LIST_TAIL
argument_list|(
name|rrl
operator|->
name|qname_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbuf
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|rrl
operator|->
name|qname_free
argument_list|,
name|qbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rrl
operator|->
name|num_qnames
operator|<
name|DNS_RRL_QNAMES
condition|)
block|{
name|qbuf
operator|=
name|isc_mem_get
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbuf
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|qbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|qbuf
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qbuf
operator|->
name|index
operator|=
name|rrl
operator|->
name|num_qnames
expr_stmt|;
name|rrl
operator|->
name|qnames
index|[
name|rrl
operator|->
name|num_qnames
operator|++
index|]
operator|=
name|qbuf
expr_stmt|;
block|}
else|else
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_FAIL
argument_list|,
literal|"isc_mem_get(%d)"
literal|" failed for RRL qname"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|qbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qbuf
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|log_qname
operator|=
name|qbuf
operator|->
name|index
expr_stmt|;
name|qbuf
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|qbuf
operator|->
name|qname
argument_list|)
expr_stmt|;
name|dns_name_copy
argument_list|(
name|qname
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|qbuf
operator|->
name|qname
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qbuf
operator|!=
name|NULL
condition|)
name|qname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|qbuf
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|qname
operator|!=
name|NULL
condition|)
block|{
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|" for "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_name_totext
argument_list|(
name|qname
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|" for (?)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|!=
name|DNS_RRL_RTYPE_NXDOMAIN
condition|)
block|{
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdataclass_totext
argument_list|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|qclass
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|rtype
operator|==
name|DNS_RRL_RTYPE_QUERY
condition|)
block|{
name|ADD_LOG_CSTR
argument_list|(
operator|&
name|lb
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdatatype_totext
argument_list|(
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|qtype
argument_list|,
operator|&
name|lb
argument_list|)
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|,
literal|"  (%08x)"
argument_list|,
name|e
operator|->
name|key
operator|.
name|s
operator|.
name|qname_hash
argument_list|)
expr_stmt|;
name|add_log_str
argument_list|(
operator|&
name|lb
argument_list|,
name|strbuf
argument_list|,
name|strlen
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We saved room for '\0'. 	 */
name|log_buf
index|[
name|isc_buffer_usedlength
argument_list|(
operator|&
name|lb
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_end
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|dns_rrl_entry_t
modifier|*
name|e
parameter_list|,
name|isc_boolean_t
name|early
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|logged
condition|)
block|{
name|make_log_buf
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|early
condition|?
literal|"*"
else|:
name|NULL
argument_list|,
name|rrl
operator|->
name|log_only
condition|?
literal|"would stop limiting "
else|:
literal|"stop limiting "
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
name|DNS_RRL_RESULT_OK
argument_list|,
name|ISC_R_SUCCESS
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|,
literal|"%s"
argument_list|,
name|log_buf
argument_list|)
expr_stmt|;
name|free_qname
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|logged
operator|=
name|ISC_FALSE
expr_stmt|;
operator|--
name|rrl
operator|->
name|num_logged
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Log messages for streams that have stopped being rate limited.  */
end_comment

begin_function
specifier|static
name|void
name|log_stops
parameter_list|(
name|dns_rrl_t
modifier|*
name|rrl
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|int
name|limit
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
name|dns_rrl_entry_t
modifier|*
name|e
decl_stmt|;
name|int
name|age
decl_stmt|;
for|for
control|(
name|e
operator|=
name|rrl
operator|->
name|last_logged
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|ISC_LIST_PREV
argument_list|(
name|e
argument_list|,
name|lru
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|logged
condition|)
continue|continue;
if|if
condition|(
name|now
operator|!=
literal|0
condition|)
block|{
name|age
operator|=
name|get_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|age
operator|<
name|DNS_RRL_STOP_LOG_SECS
operator|||
name|response_balance
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|age
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
name|log_end
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
operator|==
literal|0
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|num_logged
operator|<=
literal|0
condition|)
break|break;
comment|/* 		 * Too many messages could stall real work. 		 */
if|if
condition|(
operator|--
name|limit
operator|<
literal|0
condition|)
block|{
name|rrl
operator|->
name|last_logged
operator|=
name|ISC_LIST_PREV
argument_list|(
name|e
argument_list|,
name|lru
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|rrl
operator|->
name|num_logged
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|log_stops_time
operator|=
name|now
expr_stmt|;
block|}
name|rrl
operator|->
name|last_logged
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Main rate limit interface.  */
end_comment

begin_function
name|dns_rrl_result_t
name|dns_rrl
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|,
specifier|const
name|isc_sockaddr_t
modifier|*
name|client_addr
parameter_list|,
name|isc_boolean_t
name|is_tcp
parameter_list|,
name|dns_rdataclass_t
name|qclass
parameter_list|,
name|dns_rdatatype_t
name|qtype
parameter_list|,
name|dns_name_t
modifier|*
name|qname
parameter_list|,
name|isc_result_t
name|resp_result
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|isc_boolean_t
name|wouldlog
parameter_list|,
name|char
modifier|*
name|log_buf
parameter_list|,
name|unsigned
name|int
name|log_buf_len
parameter_list|)
block|{
name|dns_rrl_t
modifier|*
name|rrl
decl_stmt|;
name|dns_rrl_rtype_t
name|rtype
decl_stmt|;
name|dns_rrl_entry_t
modifier|*
name|e
decl_stmt|;
name|isc_netaddr_t
name|netclient
decl_stmt|;
name|int
name|secs
decl_stmt|;
name|double
name|qps
decl_stmt|,
name|scale
decl_stmt|;
name|int
name|exempt_match
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rrl_result_t
name|rrl_result
decl_stmt|;
name|INSIST
argument_list|(
name|log_buf
operator|!=
name|NULL
operator|&&
name|log_buf_len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rrl
operator|=
name|view
operator|->
name|rrl
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|exempt
operator|!=
name|NULL
condition|)
block|{
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netclient
argument_list|,
name|client_addr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_acl_match
argument_list|(
operator|&
name|netclient
argument_list|,
name|NULL
argument_list|,
name|rrl
operator|->
name|exempt
argument_list|,
operator|&
name|view
operator|->
name|aclenv
argument_list|,
operator|&
name|exempt_match
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|exempt_match
operator|>
literal|0
condition|)
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
block|}
name|LOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Estimate total query per second rate when scaling by qps. 	 */
if|if
condition|(
name|rrl
operator|->
name|qps_scale
operator|==
literal|0
condition|)
block|{
name|qps
operator|=
literal|0.0
expr_stmt|;
name|scale
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
operator|++
name|rrl
operator|->
name|qps_responses
expr_stmt|;
name|secs
operator|=
name|delta_rrl_time
argument_list|(
name|rrl
operator|->
name|qps_time
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|secs
operator|<=
literal|0
condition|)
block|{
name|qps
operator|=
name|rrl
operator|->
name|qps
expr_stmt|;
block|}
else|else
block|{
name|qps
operator|=
operator|(
literal|1.0
operator|*
name|rrl
operator|->
name|qps_responses
operator|)
operator|/
name|secs
expr_stmt|;
if|if
condition|(
name|secs
operator|>=
name|rrl
operator|->
name|window
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|)
condition|)
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG3
argument_list|,
literal|"%d responses/%d seconds"
literal|" = %d qps"
argument_list|,
name|rrl
operator|->
name|qps_responses
argument_list|,
name|secs
argument_list|,
operator|(
name|int
operator|)
name|qps
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|qps
operator|=
name|qps
expr_stmt|;
name|rrl
operator|->
name|qps_responses
operator|=
literal|0
expr_stmt|;
name|rrl
operator|->
name|qps_time
operator|=
name|now
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qps
operator|<
name|rrl
operator|->
name|qps
condition|)
block|{
name|qps
operator|=
name|rrl
operator|->
name|qps
expr_stmt|;
block|}
block|}
name|scale
operator|=
name|rrl
operator|->
name|qps_scale
operator|/
name|qps
expr_stmt|;
block|}
comment|/* 	 * Do maintenance once per second. 	 */
if|if
condition|(
name|rrl
operator|->
name|num_logged
operator|>
literal|0
operator|&&
name|rrl
operator|->
name|log_stops_time
operator|!=
name|now
condition|)
name|log_stops
argument_list|(
name|rrl
argument_list|,
name|now
argument_list|,
literal|8
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
comment|/* 	 * Notice TCP responses when scaling limits by qps. 	 * Do not try to rate limit TCP responses. 	 */
if|if
condition|(
name|is_tcp
condition|)
block|{
if|if
condition|(
name|scale
operator|<
literal|1.0
condition|)
block|{
name|e
operator|=
name|get_entry
argument_list|(
name|rrl
argument_list|,
name|client_addr
argument_list|,
literal|0
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
name|DNS_RRL_RTYPE_TCP
argument_list|,
name|now
argument_list|,
name|ISC_TRUE
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|responses
operator|=
operator|-
operator|(
name|rrl
operator|->
name|window
operator|+
literal|1
operator|)
expr_stmt|;
name|set_age
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * Find the right kind of entry, creating it if necessary. 	 * If that is impossible, then nothing more can be done 	 */
switch|switch
condition|(
name|resp_result
condition|)
block|{
case|case
name|ISC_R_SUCCESS
case|:
name|rtype
operator|=
name|DNS_RRL_RTYPE_QUERY
expr_stmt|;
break|break;
case|case
name|DNS_R_DELEGATION
case|:
name|rtype
operator|=
name|DNS_RRL_RTYPE_REFERRAL
expr_stmt|;
break|break;
case|case
name|DNS_R_NXRRSET
case|:
name|rtype
operator|=
name|DNS_RRL_RTYPE_NODATA
expr_stmt|;
break|break;
case|case
name|DNS_R_NXDOMAIN
case|:
name|rtype
operator|=
name|DNS_RRL_RTYPE_NXDOMAIN
expr_stmt|;
break|break;
default|default:
name|rtype
operator|=
name|DNS_RRL_RTYPE_ERROR
expr_stmt|;
break|break;
block|}
name|e
operator|=
name|get_entry
argument_list|(
name|rrl
argument_list|,
name|client_addr
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|qname
argument_list|,
name|rtype
argument_list|,
name|now
argument_list|,
name|ISC_TRUE
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
block|}
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DEBUG1
argument_list|)
condition|)
block|{
comment|/* 		 * Do not worry about speed or releasing the lock. 		 * This message appears before messages from debit_rrl_entry(). 		 */
name|make_log_buf
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
literal|"consider limiting "
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
name|qname
argument_list|,
name|ISC_FALSE
argument_list|,
name|DNS_RRL_RESULT_OK
argument_list|,
name|resp_result
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DEBUG1
argument_list|,
literal|"%s"
argument_list|,
name|log_buf
argument_list|)
expr_stmt|;
block|}
name|rrl_result
operator|=
name|debit_rrl_entry
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|qps
argument_list|,
name|scale
argument_list|,
name|client_addr
argument_list|,
name|now
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|all_per_second
operator|.
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * We must debit the all-per-second token bucket if we have 		 * an all-per-second limit for the IP address. 		 * The all-per-second limit determines the log message 		 * when both limits are hit. 		 * The response limiting must continue if the 		 * all-per-second limiting lapses. 		 */
name|dns_rrl_entry_t
modifier|*
name|e_all
decl_stmt|;
name|dns_rrl_result_t
name|rrl_all_result
decl_stmt|;
name|e_all
operator|=
name|get_entry
argument_list|(
name|rrl
argument_list|,
name|client_addr
argument_list|,
literal|0
argument_list|,
name|dns_rdatatype_none
argument_list|,
name|NULL
argument_list|,
name|DNS_RRL_RTYPE_ALL
argument_list|,
name|now
argument_list|,
name|ISC_TRUE
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_all
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
block|}
name|rrl_all_result
operator|=
name|debit_rrl_entry
argument_list|(
name|rrl
argument_list|,
name|e_all
argument_list|,
name|qps
argument_list|,
name|scale
argument_list|,
name|client_addr
argument_list|,
name|now
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl_all_result
operator|!=
name|DNS_RRL_RESULT_OK
condition|)
block|{
name|int
name|level
decl_stmt|;
name|e
operator|=
name|e_all
expr_stmt|;
name|rrl_result
operator|=
name|rrl_all_result
expr_stmt|;
if|if
condition|(
name|rrl_result
operator|==
name|DNS_RRL_RESULT_OK
condition|)
name|level
operator|=
name|DNS_RRL_LOG_DEBUG2
expr_stmt|;
else|else
name|level
operator|=
name|DNS_RRL_LOG_DEBUG1
expr_stmt|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|make_log_buf
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
literal|"prefer all-per-second limiting "
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|,
name|qname
argument_list|,
name|ISC_FALSE
argument_list|,
name|DNS_RRL_RESULT_OK
argument_list|,
name|resp_result
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|level
argument_list|,
literal|"%s"
argument_list|,
name|log_buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rrl_result
operator|==
name|DNS_RRL_RESULT_OK
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_RRL_RESULT_OK
operator|)
return|;
block|}
comment|/* 	 * Log occassionally in the rate-limit category. 	 */
if|if
condition|(
operator|(
operator|!
name|e
operator|->
name|logged
operator|||
name|e
operator|->
name|log_secs
operator|>=
name|DNS_RRL_MAX_LOG_SECS
operator|)
operator|&&
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|)
condition|)
block|{
name|make_log_buf
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|rrl
operator|->
name|log_only
condition|?
literal|"would "
else|:
name|NULL
argument_list|,
name|e
operator|->
name|logged
condition|?
literal|"continue limiting "
else|:
literal|"limit "
argument_list|,
name|ISC_TRUE
argument_list|,
name|qname
argument_list|,
name|ISC_TRUE
argument_list|,
name|DNS_RRL_RESULT_OK
argument_list|,
name|resp_result
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|logged
condition|)
block|{
name|e
operator|->
name|logged
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
operator|++
name|rrl
operator|->
name|num_logged
operator|<=
literal|1
condition|)
name|rrl
operator|->
name|last_logged
operator|=
name|e
expr_stmt|;
block|}
name|e
operator|->
name|log_secs
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Avoid holding the lock. 		 */
if|if
condition|(
operator|!
name|wouldlog
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|e
operator|=
name|NULL
expr_stmt|;
block|}
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RRL
argument_list|,
name|DNS_LOGMODULE_REQUEST
argument_list|,
name|DNS_RRL_LOG_DROP
argument_list|,
literal|"%s"
argument_list|,
name|log_buf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make a log message for the caller. 	 */
if|if
condition|(
name|wouldlog
condition|)
name|make_log_buf
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|,
name|rrl
operator|->
name|log_only
condition|?
literal|"would rate limit "
else|:
literal|"rate limit "
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
name|qname
argument_list|,
name|ISC_FALSE
argument_list|,
name|rrl_result
argument_list|,
name|resp_result
argument_list|,
name|log_buf
argument_list|,
name|log_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Do not save the qname unless we might need it for 		 * the ending log message. 		 */
if|if
condition|(
operator|!
name|e
operator|->
name|logged
condition|)
name|free_qname
argument_list|(
name|rrl
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rrl_result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_rrl_view_destroy
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|)
block|{
name|dns_rrl_t
modifier|*
name|rrl
decl_stmt|;
name|dns_rrl_block_t
modifier|*
name|b
decl_stmt|;
name|dns_rrl_hash_t
modifier|*
name|h
decl_stmt|;
name|char
name|log_buf
index|[
name|DNS_RRL_LOG_BUF_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rrl
operator|=
name|view
operator|->
name|rrl
expr_stmt|;
if|if
condition|(
name|rrl
operator|==
name|NULL
condition|)
return|return;
name|view
operator|->
name|rrl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Assume the caller takes care of locking the view and anything else. 	 */
if|if
condition|(
name|rrl
operator|->
name|num_logged
operator|>
literal|0
condition|)
name|log_stops
argument_list|(
name|rrl
argument_list|,
literal|0
argument_list|,
name|ISC_INT32_MAX
argument_list|,
name|log_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|log_buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_RRL_QNAMES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rrl
operator|->
name|qnames
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|isc_mem_put
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|rrl
operator|->
name|qnames
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrl
operator|->
name|qnames
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rrl
operator|->
name|exempt
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|rrl
operator|->
name|exempt
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|rrl
operator|->
name|blocks
argument_list|)
condition|)
block|{
name|b
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|rrl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|rrl
operator|->
name|blocks
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|b
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|h
operator|=
name|rrl
operator|->
name|hash
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|h
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
operator|+
operator|(
name|h
operator|->
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|h
operator|->
name|bins
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|rrl
operator|->
name|old_hash
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|rrl
operator|->
name|mctx
argument_list|,
name|h
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
operator|+
operator|(
name|h
operator|->
name|length
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|h
operator|->
name|bins
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_putanddetach
argument_list|(
operator|&
name|rrl
operator|->
name|mctx
argument_list|,
name|rrl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_rrl_init
parameter_list|(
name|dns_rrl_t
modifier|*
modifier|*
name|rrlp
parameter_list|,
name|dns_view_t
modifier|*
name|view
parameter_list|,
name|int
name|min_entries
parameter_list|)
block|{
name|dns_rrl_t
modifier|*
name|rrl
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
operator|*
name|rrlp
operator|=
name|NULL
expr_stmt|;
name|rrl
operator|=
name|isc_mem_get
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|rrl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrl
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
operator|&
name|rrl
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|rrl
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_putanddetach
argument_list|(
operator|&
name|rrl
operator|->
name|mctx
argument_list|,
name|rrl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rrl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|isc_stdtime_get
argument_list|(
operator|&
name|rrl
operator|->
name|ts_bases
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|view
operator|->
name|rrl
operator|=
name|rrl
expr_stmt|;
name|result
operator|=
name|expand_entries
argument_list|(
name|rrl
argument_list|,
name|min_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rrl_view_destroy
argument_list|(
name|view
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|expand_rrl_hash
argument_list|(
name|rrl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rrl_view_destroy
argument_list|(
name|view
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|rrlp
operator|=
name|rrl
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

