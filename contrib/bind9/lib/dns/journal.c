begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2005  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2002  Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: journal.c,v 1.77.2.1.10.13 2005/11/03 23:08:41 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/compress.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/dbiterator.h>
end_include

begin_include
include|#
directive|include
file|<dns/diff.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/journal.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatasetiter.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/soa.h>
end_include

begin_comment
comment|/*  * When true, accept IXFR difference sequences where the  * SOA serial number does not change (BIND 8 sends such  * sequences).  */
end_comment

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|bind8_compat
init|=
name|ISC_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX config */
end_comment

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Miscellaneous utilities.  */
end_comment

begin_define
define|#
directive|define
name|JOURNAL_COMMON_LOGARGS
define|\
value|dns_lctx, DNS_LOGCATEGORY_GENERAL, DNS_LOGMODULE_JOURNAL
end_define

begin_define
define|#
directive|define
name|JOURNAL_DEBUG_LOGARGS
parameter_list|(
name|n
parameter_list|)
define|\
value|JOURNAL_COMMON_LOGARGS, ISC_LOG_DEBUG(n)
end_define

begin_comment
comment|/*  * It would be non-sensical (or at least obtuse) to use FAIL() with an  * ISC_R_SUCCESS code, but the test is there to keep the Solaris compiler  * from complaining about "end-of-loop code not reached".  */
end_comment

begin_define
define|#
directive|define
name|FAIL
parameter_list|(
name|code
parameter_list|)
define|\
value|do { result = (code);					\ 		if (result != ISC_R_SUCCESS) goto failure;	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|op
parameter_list|)
define|\
value|do { result = (op); 					\ 		if (result != ISC_R_SUCCESS) goto failure; 	\ 	} while (0)
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|index_to_disk
parameter_list|(
name|dns_journal_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|isc_uint32_t
name|decode_uint32
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|encode_uint32
parameter_list|(
name|isc_uint32_t
name|val
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|p
index|[
literal|0
index|]
operator|=
call|(
name|isc_uint8_t
call|)
argument_list|(
name|val
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|isc_uint8_t
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
call|(
name|isc_uint8_t
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|isc_uint8_t
call|)
argument_list|(
name|val
operator|>>
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_db_createsoatuple
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_diffop_t
name|op
parameter_list|,
name|dns_difftuple_t
modifier|*
modifier|*
name|tp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
decl_stmt|;
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_name_t
modifier|*
name|zonename
decl_stmt|;
name|zonename
operator|=
name|dns_db_origin
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|node
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_db_findnode
argument_list|(
name|db
argument_list|,
name|zonename
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|nonode
goto|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_db_findrdataset
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|dns_rdatatype_soa
argument_list|,
literal|0
argument_list|,
operator|(
name|isc_stdtime_t
operator|)
literal|0
argument_list|,
operator|&
name|rdataset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|freenode
goto|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|freenode
goto|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_difftuple_create
argument_list|(
name|mctx
argument_list|,
name|op
argument_list|,
name|zonename
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|freenode
label|:
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
name|nonode
label|:
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"missing SOA"
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Journalling.  */
end_comment

begin_comment
comment|/*  * A journal file consists of  *  *   - A fixed-size header of type journal_rawheader_t.  *  *   - The index.  This is an unordered array of index entries  *     of type journal_rawpos_t giving the locations  *     of some arbitrary subset of the journal's addressable  *     transactions.  The index entries are used as hints to  *     speed up the process of locating a transaction with a given  *     serial number.  Unused index entries have an "offset"  *     field of zero.  The size of the index can vary between  *     journal files, but does not change during the lifetime  *     of a file.  The size can be zero.  *  *   - The journal data.  This  consists of one or more transactions.  *     Each transaction begins with a transaction header of type  *     journal_rawxhdr_t.  The transaction header is followed by a  *     sequence of RRs, similar in structure to an IXFR difference  *     sequence (RFC1995).  That is, the pre-transaction SOA,  *     zero or more other deleted RRs, the post-transaction SOA,  *     and zero or more other added RRs.  Unlike in IXFR, each RR  *     is prefixed with a 32-bit length.  *  *     The journal data part grows as new transactions are  *     appended to the file.  Only those transactions  *     whose serial number is current-(2^31-1) to current  *     are considered "addressable" and may be pointed  *     to from the header or index.  They may be preceded  *     by old transactions that are no longer addressable,  *     and they may be followed by transactions that were  *     appended to the journal but never committed by updating  *     the "end" position in the header.  The latter will  *     be overwritten when new transactions are added.  */
end_comment

begin_comment
comment|/*  * On-disk representation of a "pointer" to a journal entry.  * These are used in the journal header to locate the beginning  * and end of the journal, and in the journal index to locate  * other transactions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|serial
index|[
literal|4
index|]
decl_stmt|;
comment|/* SOA serial before update. */
comment|/* 	 * XXXRTH  Should offset be 8 bytes? 	 * XXXDCL ... probably, since isc_offset_t is 8 bytes on many OSs. 	 * XXXAG  ... but we will not be able to seek>2G anyway on many 	 *            platforms as long as we are using fseek() rather 	 *            than lseek(). 	 */
name|unsigned
name|char
name|offset
index|[
literal|4
index|]
decl_stmt|;
comment|/* Offset from beginning of file. */
block|}
name|journal_rawpos_t
typedef|;
end_typedef

begin_comment
comment|/*  * The on-disk representation of the journal header.  * All numbers are stored in big-endian order.  */
end_comment

begin_comment
comment|/*  * The header is of a fixed size, with some spare room for future  * extensions.  */
end_comment

begin_define
define|#
directive|define
name|JOURNAL_HEADER_SIZE
value|64
end_define

begin_comment
comment|/* Bytes. */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
struct|struct
block|{
comment|/* File format version ID. */
name|unsigned
name|char
name|format
index|[
literal|16
index|]
decl_stmt|;
comment|/* Position of the first addressable transaction */
name|journal_rawpos_t
name|begin
decl_stmt|;
comment|/* Position of the next (yet nonexistent) transaction. */
name|journal_rawpos_t
name|end
decl_stmt|;
comment|/* Number of index entries following the header. */
name|unsigned
name|char
name|index_size
index|[
literal|4
index|]
decl_stmt|;
block|}
name|h
struct|;
comment|/* Pad the header to a fixed size. */
name|unsigned
name|char
name|pad
index|[
name|JOURNAL_HEADER_SIZE
index|]
decl_stmt|;
block|}
name|journal_rawheader_t
typedef|;
end_typedef

begin_comment
comment|/*  * The on-disk representation of the transaction header.  * There is one of these at the beginning of each transaction.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|size
index|[
literal|4
index|]
decl_stmt|;
comment|/* In bytes, excluding header. */
name|unsigned
name|char
name|serial0
index|[
literal|4
index|]
decl_stmt|;
comment|/* SOA serial before update. */
name|unsigned
name|char
name|serial1
index|[
literal|4
index|]
decl_stmt|;
comment|/* SOA serial after update. */
block|}
name|journal_rawxhdr_t
typedef|;
end_typedef

begin_comment
comment|/*  * The on-disk representation of the RR header.  * There is one of these at the beginning of each RR.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|size
index|[
literal|4
index|]
decl_stmt|;
comment|/* In bytes, excluding header. */
block|}
name|journal_rawrrhdr_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core representation of the journal header.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|serial
decl_stmt|;
name|isc_offset_t
name|offset
decl_stmt|;
block|}
name|journal_pos_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|POS_VALID
parameter_list|(
name|pos
parameter_list|)
value|((pos).offset != 0)
end_define

begin_define
define|#
directive|define
name|POS_INVALIDATE
parameter_list|(
name|pos
parameter_list|)
value|((pos).offset = 0, (pos).serial = 0)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|format
index|[
literal|16
index|]
decl_stmt|;
name|journal_pos_t
name|begin
decl_stmt|;
name|journal_pos_t
name|end
decl_stmt|;
name|isc_uint32_t
name|index_size
decl_stmt|;
block|}
name|journal_header_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core representation of the transaction header.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|size
decl_stmt|;
name|isc_uint32_t
name|serial0
decl_stmt|;
name|isc_uint32_t
name|serial1
decl_stmt|;
block|}
name|journal_xhdr_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core representation of the RR header.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|isc_uint32_t
name|size
decl_stmt|;
block|}
name|journal_rrhdr_t
typedef|;
end_typedef

begin_comment
comment|/*  * Initial contents to store in the header of a newly created  * journal file.  *  * The header starts with the magic string ";BIND LOG V9\n"  * to identify the file as a BIND 9 journal file.  An ASCII  * identification string is used rather than a binary magic  * number to be consistent with BIND 8 (BIND 8 journal files  * are ASCII text files).  */
end_comment

begin_decl_stmt
specifier|static
name|journal_header_t
name|initial_journal_header
init|=
block|{
literal|";BIND LOG V9\n"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|JOURNAL_EMPTY
parameter_list|(
name|h
parameter_list|)
value|((h)->begin.offset == (h)->end.offset)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|JOURNAL_STATE_INVALID
block|,
name|JOURNAL_STATE_READ
block|,
name|JOURNAL_STATE_WRITE
block|,
name|JOURNAL_STATE_TRANSACTION
block|}
name|journal_state_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_journal
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/* JOUR */
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* Memory context */
name|journal_state_t
name|state
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Journal file name */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* File handle */
name|isc_offset_t
name|offset
decl_stmt|;
comment|/* Current file offset */
name|journal_header_t
name|header
decl_stmt|;
comment|/* In-core journal header */
name|unsigned
name|char
modifier|*
name|rawindex
decl_stmt|;
comment|/* In-core buffer for journal 						   index in on-disk format */
name|journal_pos_t
modifier|*
name|index
decl_stmt|;
comment|/* In-core journal index */
comment|/* Current transaction state (when writing). */
struct|struct
block|{
name|unsigned
name|int
name|n_soa
decl_stmt|;
comment|/* Number of SOAs seen */
name|journal_pos_t
name|pos
index|[
literal|2
index|]
decl_stmt|;
comment|/* Begin/end position */
block|}
name|x
struct|;
comment|/* Iteration state (when reading). */
struct|struct
block|{
comment|/* These define the part of the journal we iterate over. */
name|journal_pos_t
name|bpos
decl_stmt|;
comment|/* Position before first, */
name|journal_pos_t
name|epos
decl_stmt|;
comment|/* and after last 						   transaction */
comment|/* The rest is iterator state. */
name|isc_uint32_t
name|current_serial
decl_stmt|;
comment|/* Current SOA serial */
name|isc_buffer_t
name|source
decl_stmt|;
comment|/* Data from disk */
name|isc_buffer_t
name|target
decl_stmt|;
comment|/* Data from _fromwire check */
name|dns_decompress_t
name|dctx
decl_stmt|;
comment|/* Dummy decompression ctx */
name|dns_name_t
name|name
decl_stmt|;
comment|/* Current domain name */
name|dns_rdata_t
name|rdata
decl_stmt|;
comment|/* Current rdata */
name|isc_uint32_t
name|ttl
decl_stmt|;
comment|/* Current TTL */
name|unsigned
name|int
name|xsize
decl_stmt|;
comment|/* Size of transaction data */
name|unsigned
name|int
name|xpos
decl_stmt|;
comment|/* Current position in it */
name|isc_result_t
name|result
decl_stmt|;
comment|/* Result of last call */
block|}
name|it
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_JOURNAL_MAGIC
value|ISC_MAGIC('J', 'O', 'U', 'R')
end_define

begin_define
define|#
directive|define
name|DNS_JOURNAL_VALID
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, DNS_JOURNAL_MAGIC)
end_define

begin_function
specifier|static
name|void
name|journal_pos_decode
parameter_list|(
name|journal_rawpos_t
modifier|*
name|raw
parameter_list|,
name|journal_pos_t
modifier|*
name|cooked
parameter_list|)
block|{
name|cooked
operator|->
name|serial
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|->
name|serial
argument_list|)
expr_stmt|;
name|cooked
operator|->
name|offset
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_pos_encode
parameter_list|(
name|journal_rawpos_t
modifier|*
name|raw
parameter_list|,
name|journal_pos_t
modifier|*
name|cooked
parameter_list|)
block|{
name|encode_uint32
argument_list|(
name|cooked
operator|->
name|serial
argument_list|,
name|raw
operator|->
name|serial
argument_list|)
expr_stmt|;
name|encode_uint32
argument_list|(
name|cooked
operator|->
name|offset
argument_list|,
name|raw
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_header_decode
parameter_list|(
name|journal_rawheader_t
modifier|*
name|raw
parameter_list|,
name|journal_header_t
modifier|*
name|cooked
parameter_list|)
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|cooked
operator|->
name|format
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|raw
operator|->
name|h
operator|.
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cooked
operator|->
name|format
argument_list|,
name|raw
operator|->
name|h
operator|.
name|format
argument_list|,
sizeof|sizeof
argument_list|(
name|cooked
operator|->
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|journal_pos_decode
argument_list|(
operator|&
name|raw
operator|->
name|h
operator|.
name|begin
argument_list|,
operator|&
name|cooked
operator|->
name|begin
argument_list|)
expr_stmt|;
name|journal_pos_decode
argument_list|(
operator|&
name|raw
operator|->
name|h
operator|.
name|end
argument_list|,
operator|&
name|cooked
operator|->
name|end
argument_list|)
expr_stmt|;
name|cooked
operator|->
name|index_size
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|->
name|h
operator|.
name|index_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|journal_header_encode
parameter_list|(
name|journal_header_t
modifier|*
name|cooked
parameter_list|,
name|journal_rawheader_t
modifier|*
name|raw
parameter_list|)
block|{
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|cooked
operator|->
name|format
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|raw
operator|->
name|h
operator|.
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|raw
operator|->
name|pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|raw
operator|->
name|pad
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|raw
operator|->
name|h
operator|.
name|format
argument_list|,
name|cooked
operator|->
name|format
argument_list|,
sizeof|sizeof
argument_list|(
name|raw
operator|->
name|h
operator|.
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|journal_pos_encode
argument_list|(
operator|&
name|raw
operator|->
name|h
operator|.
name|begin
argument_list|,
operator|&
name|cooked
operator|->
name|begin
argument_list|)
expr_stmt|;
name|journal_pos_encode
argument_list|(
operator|&
name|raw
operator|->
name|h
operator|.
name|end
argument_list|,
operator|&
name|cooked
operator|->
name|end
argument_list|)
expr_stmt|;
name|encode_uint32
argument_list|(
name|cooked
operator|->
name|index_size
argument_list|,
name|raw
operator|->
name|h
operator|.
name|index_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Journal file I/O subroutines, with error checking and reporting.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|journal_seek
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|offset
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_seek
argument_list|(
name|j
operator|->
name|fp
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: seek: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|j
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_read
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_read
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|,
name|nbytes
argument_list|,
name|j
operator|->
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_EOF
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: read: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|j
operator|->
name|offset
operator|+=
name|nbytes
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_write
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|void
modifier|*
name|mem
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_write
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|,
name|nbytes
argument_list|,
name|j
operator|->
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: write: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|j
operator|->
name|offset
operator|+=
name|nbytes
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_fsync
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_flush
argument_list|(
name|j
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: flush: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|result
operator|=
name|isc_stdio_sync
argument_list|(
name|j
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: fsync: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read/write a transaction header at the current file position.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|journal_read_xhdr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|journal_xhdr_t
modifier|*
name|xhdr
parameter_list|)
block|{
name|journal_rawxhdr_t
name|raw
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|journal_read
argument_list|(
name|j
argument_list|,
operator|&
name|raw
argument_list|,
sizeof|sizeof
argument_list|(
name|raw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|xhdr
operator|->
name|size
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|.
name|size
argument_list|)
expr_stmt|;
name|xhdr
operator|->
name|serial0
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|.
name|serial0
argument_list|)
expr_stmt|;
name|xhdr
operator|->
name|serial1
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|.
name|serial1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_write_xhdr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|size
parameter_list|,
name|isc_uint32_t
name|serial0
parameter_list|,
name|isc_uint32_t
name|serial1
parameter_list|)
block|{
name|journal_rawxhdr_t
name|raw
decl_stmt|;
name|encode_uint32
argument_list|(
name|size
argument_list|,
name|raw
operator|.
name|size
argument_list|)
expr_stmt|;
name|encode_uint32
argument_list|(
name|serial0
argument_list|,
name|raw
operator|.
name|serial0
argument_list|)
expr_stmt|;
name|encode_uint32
argument_list|(
name|serial1
argument_list|,
name|raw
operator|.
name|serial1
argument_list|)
expr_stmt|;
return|return
operator|(
name|journal_write
argument_list|(
name|j
argument_list|,
operator|&
name|raw
argument_list|,
sizeof|sizeof
argument_list|(
name|raw
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read an RR header at the current file position.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|journal_read_rrhdr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|journal_rrhdr_t
modifier|*
name|rrhdr
parameter_list|)
block|{
name|journal_rawrrhdr_t
name|raw
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|journal_read
argument_list|(
name|j
argument_list|,
operator|&
name|raw
argument_list|,
sizeof|sizeof
argument_list|(
name|raw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|rrhdr
operator|->
name|size
operator|=
name|decode_uint32
argument_list|(
name|raw
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_file_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|journal_header_t
name|header
decl_stmt|;
name|journal_rawheader_t
name|rawheader
decl_stmt|;
name|int
name|index_size
init|=
literal|56
decl_stmt|;
comment|/* XXX configurable */
name|int
name|size
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* Memory for temporary index image. */
name|INSIST
argument_list|(
sizeof|sizeof
argument_list|(
name|journal_rawheader_t
argument_list|)
operator|==
name|JOURNAL_HEADER_SIZE
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|filename
argument_list|,
literal|"wb"
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: create: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|header
operator|=
name|initial_journal_header
expr_stmt|;
name|header
operator|.
name|index_size
operator|=
name|index_size
expr_stmt|;
name|journal_header_encode
argument_list|(
operator|&
name|header
argument_list|,
operator|&
name|rawheader
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|journal_rawheader_t
argument_list|)
operator|+
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
expr_stmt|;
name|mem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|isc_stdio_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_file_remove
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mem
argument_list|,
operator|&
name|rawheader
argument_list|,
sizeof|sizeof
argument_list|(
name|rawheader
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_write
argument_list|(
name|mem
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: write: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_stdio_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_file_remove
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: close: %s"
argument_list|,
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_file_remove
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|journal_open
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|isc_boolean_t
name|write
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_journal_t
modifier|*
modifier|*
name|journalp
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|journal_rawheader_t
name|rawheader
decl_stmt|;
name|dns_journal_t
modifier|*
name|j
decl_stmt|;
name|INSIST
argument_list|(
name|journalp
operator|!=
name|NULL
operator|&&
operator|*
name|journalp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|j
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|j
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|j
operator|->
name|state
operator|=
name|JOURNAL_STATE_INVALID
expr_stmt|;
name|j
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
name|j
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|j
operator|->
name|index
operator|=
name|NULL
expr_stmt|;
name|j
operator|->
name|rawindex
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|j
operator|->
name|filename
argument_list|,
name|write
condition|?
literal|"rb+"
else|:
literal|"rb"
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_FILENOTFOUND
condition|)
block|{
if|if
condition|(
name|create
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"journal file %s does not exist, "
literal|"creating it"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_file_create
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Retry. 			 */
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|j
operator|->
name|filename
argument_list|,
literal|"rb+"
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FAIL
argument_list|(
name|ISC_R_NOTFOUND
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: open: %s"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|j
operator|->
name|fp
operator|=
name|fp
expr_stmt|;
comment|/* 	 * Set magic early so that seek/read can succeed. 	 */
name|j
operator|->
name|magic
operator|=
name|DNS_JOURNAL_MAGIC
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_read
argument_list|(
name|j
argument_list|,
operator|&
name|rawheader
argument_list|,
sizeof|sizeof
argument_list|(
name|rawheader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|rawheader
operator|.
name|h
operator|.
name|format
argument_list|,
name|initial_journal_header
operator|.
name|format
argument_list|,
sizeof|sizeof
argument_list|(
name|initial_journal_header
operator|.
name|format
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal format not recognized"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|journal_header_decode
argument_list|(
operator|&
name|rawheader
argument_list|,
operator|&
name|j
operator|->
name|header
argument_list|)
expr_stmt|;
comment|/* 	 * If there is an index, read the raw index into a dynamically 	 * allocated buffer and then convert it into a cooked index. 	 */
if|if
condition|(
name|j
operator|->
name|header
operator|.
name|index_size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|rawbytes
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|rawbytes
operator|=
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
expr_stmt|;
name|j
operator|->
name|rawindex
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|rawbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|rawindex
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_read
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|rawindex
argument_list|,
name|rawbytes
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|index
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_pos_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
name|ISC_R_NOMEMORY
argument_list|)
expr_stmt|;
name|p
operator|=
name|j
operator|->
name|rawindex
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
operator|=
name|decode_uint32
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|decode_uint32
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|p
operator|==
name|j
operator|->
name|rawindex
operator|+
name|rawbytes
argument_list|)
expr_stmt|;
block|}
name|j
operator|->
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Invalid, must seek explicitly. */
comment|/* 	 * Initialize the iterator. 	 */
name|dns_name_init
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|rdata
argument_list|)
expr_stmt|;
comment|/* 	 * Set up empty initial buffers for uncheched and checked 	 * wire format RR data.  They will be reallocated 	 * later. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|target
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dns_decompress_init
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|dctx
argument_list|,
operator|-
literal|1
argument_list|,
name|DNS_DECOMPRESS_NONE
argument_list|)
expr_stmt|;
name|j
operator|->
name|state
operator|=
name|write
condition|?
name|JOURNAL_STATE_WRITE
else|:
name|JOURNAL_STATE_READ
expr_stmt|;
operator|*
name|journalp
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|failure
label|:
name|j
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
operator|->
name|index
argument_list|,
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|index
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|->
name|fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|isc_stdio_close
argument_list|(
name|j
operator|->
name|fp
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_open
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|isc_boolean_t
name|write
parameter_list|,
name|dns_journal_t
modifier|*
modifier|*
name|journalp
parameter_list|)
block|{
return|return
operator|(
name|journal_open
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
name|write
argument_list|,
name|write
argument_list|,
name|journalp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A comparison function defining the sorting order for  * entries in the IXFR-style journal file.  *  * The IXFR format requires that deletions are sorted before  * additions, and within either one, SOA records are sorted  * before others.  *  * Also sort the non-SOA records by type as a courtesy to the  * server receiving the IXFR - it may help reduce the amount of  * rdataset merging it has to do.  */
end_comment

begin_function
specifier|static
name|int
name|ixfr_order
parameter_list|(
specifier|const
name|void
modifier|*
name|av
parameter_list|,
specifier|const
name|void
modifier|*
name|bv
parameter_list|)
block|{
name|dns_difftuple_t
specifier|const
modifier|*
specifier|const
modifier|*
name|ap
init|=
name|av
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
specifier|const
modifier|*
name|bp
init|=
name|bv
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
name|a
init|=
operator|*
name|ap
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
name|b
init|=
operator|*
name|bp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|b
operator|->
name|op
operator|==
name|DNS_DIFFOP_DEL
operator|)
operator|-
operator|(
name|a
operator|->
name|op
operator|==
name|DNS_DIFFOP_DEL
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
operator|(
name|b
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_soa
operator|)
operator|-
operator|(
name|a
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_soa
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
operator|(
name|a
operator|->
name|rdata
operator|.
name|type
operator|-
name|b
operator|->
name|rdata
operator|.
name|type
operator|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advance '*pos' to the next journal transaction.  *  * Requires:  *	*pos refers to a valid journal transaction.  *  * Ensures:  *	When ISC_R_SUCCESS is returned,  *	*pos refers to the next journal transaction.  *  * Returns one of:  *  *    ISC_R_SUCCESS  *    ISC_R_NOMORE 	*pos pointed at the last transaction  *    Other results due to file errors are possible.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|journal_next
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|journal_pos_t
modifier|*
name|pos
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|journal_xhdr_t
name|xhdr
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|journal_seek
argument_list|(
name|j
argument_list|,
name|pos
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|pos
operator|->
name|serial
operator|==
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
comment|/* 	 * Read the header of the current transaction. 	 * This will return ISC_R_NOMORE if we are at EOF. 	 */
name|result
operator|=
name|journal_read_xhdr
argument_list|(
name|j
argument_list|,
operator|&
name|xhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Check serial number consistency. 	 */
if|if
condition|(
name|xhdr
operator|.
name|serial0
operator|!=
name|pos
operator|->
name|serial
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal file corrupt: "
literal|"expected serial %u, got %u"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|pos
operator|->
name|serial
argument_list|,
name|xhdr
operator|.
name|serial0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
comment|/* 	 * Check for offset wraparound. 	 */
if|if
condition|(
call|(
name|isc_offset_t
call|)
argument_list|(
name|pos
operator|->
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|journal_rawxhdr_t
argument_list|)
operator|+
name|xhdr
operator|.
name|size
argument_list|)
operator|<
name|pos
operator|->
name|offset
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: offset too large"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|pos
operator|->
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|journal_rawxhdr_t
argument_list|)
operator|+
name|xhdr
operator|.
name|size
expr_stmt|;
name|pos
operator|->
name|serial
operator|=
name|xhdr
operator|.
name|serial1
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the index of the journal 'j' contains an entry "better"  * than '*best_guess', replace '*best_guess' with it.  *  * "Better" means having a serial number closer to 'serial'  * but not greater than 'serial'.  */
end_comment

begin_function
specifier|static
name|void
name|index_find
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|,
name|journal_pos_t
modifier|*
name|best_guess
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|POS_VALID
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
operator|&&
name|DNS_SERIAL_GE
argument_list|(
name|serial
argument_list|,
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
argument_list|)
operator|&&
name|DNS_SERIAL_GT
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
argument_list|,
name|best_guess
operator|->
name|serial
argument_list|)
condition|)
operator|*
name|best_guess
operator|=
name|j
operator|->
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add a new index entry.  If there is no room, make room by removing  * the odd-numbered entries and compacting the others into the first  * half of the index.  This decimates old index entries exponentially  * over time, so that the index always contains a much larger fraction  * of recent serial numbers than of old ones.  This is deliberate -  * most index searches are for outgoing IXFR, and IXFR tends to request  * recent versions more often than old ones.  */
end_comment

begin_function
specifier|static
name|void
name|index_add
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|journal_pos_t
modifier|*
name|pos
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Search for a vacant position. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|POS_VALID
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|j
operator|->
name|header
operator|.
name|index_size
condition|)
block|{
name|unsigned
name|int
name|k
init|=
literal|0
decl_stmt|;
comment|/* 		 * Found no vacant position.  Make some room. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|j
operator|->
name|index
index|[
name|k
operator|++
index|]
operator|=
name|j
operator|->
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|=
name|k
expr_stmt|;
comment|/* 'i' identifies the first vacant position. */
while|while
condition|(
name|k
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|)
block|{
name|POS_INVALIDATE
argument_list|(
name|j
operator|->
name|index
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
name|INSIST
argument_list|(
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|POS_VALID
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Store the new index entry. 	 */
name|j
operator|->
name|index
index|[
name|i
index|]
operator|=
operator|*
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invalidate any existing index entries that could become  * ambiguous when a new transaction with number 'serial' is added.  */
end_comment

begin_function
specifier|static
name|void
name|index_invalidate
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|DNS_SERIAL_GT
argument_list|(
name|serial
argument_list|,
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
argument_list|)
condition|)
name|POS_INVALIDATE
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to find a transaction with initial serial number 'serial'  * in the journal 'j'.  *  * If found, store its position at '*pos' and return ISC_R_SUCCESS.  *  * If 'serial' is current (= the ending serial number of the  * last transaction in the journal), set '*pos' to  * the position immediately following the last transaction and  * return ISC_R_SUCCESS.  *  * If 'serial' is within the range of addressable serial numbers  * covered by the journal but that particular serial number is missing  * (from the journal, not just from the index), return ISC_R_NOTFOUND.  *  * If 'serial' is outside the range of addressable serial numbers  * covered by the journal, return ISC_R_RANGE.  *  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|journal_find
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|,
name|journal_pos_t
modifier|*
name|pos
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|journal_pos_t
name|current_pos
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DNS_SERIAL_GT
argument_list|(
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|serial
argument_list|,
name|serial
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
if|if
condition|(
name|DNS_SERIAL_GT
argument_list|(
name|serial
argument_list|,
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
if|if
condition|(
name|serial
operator|==
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
condition|)
block|{
operator|*
name|pos
operator|=
name|j
operator|->
name|header
operator|.
name|end
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|current_pos
operator|=
name|j
operator|->
name|header
operator|.
name|begin
expr_stmt|;
name|index_find
argument_list|(
name|j
argument_list|,
name|serial
argument_list|,
operator|&
name|current_pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_pos
operator|.
name|serial
operator|!=
name|serial
condition|)
block|{
if|if
condition|(
name|DNS_SERIAL_GT
argument_list|(
name|current_pos
operator|.
name|serial
argument_list|,
name|serial
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
name|result
operator|=
name|journal_next
argument_list|(
name|j
argument_list|,
operator|&
name|current_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|pos
operator|=
name|current_pos
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_begin_transaction
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_uint32_t
name|offset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|journal_rawxhdr_t
name|hdr
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|j
operator|->
name|state
operator|==
name|JOURNAL_STATE_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Find the file offset where the new transaction should 	 * be written, and seek there. 	 */
if|if
condition|(
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
block|{
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|journal_rawheader_t
argument_list|)
operator|+
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
expr_stmt|;
block|}
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* Initial value, will be incremented. */
name|j
operator|->
name|x
operator|.
name|n_soa
operator|=
literal|0
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Write a dummy transaction header of all zeroes to reserve 	 * space.  It will be filled in when the transaction is 	 * finished. 	 */
name|memset
argument_list|(
operator|&
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|offset
operator|=
name|j
operator|->
name|offset
expr_stmt|;
name|j
operator|->
name|state
operator|=
name|JOURNAL_STATE_TRANSACTION
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_writediff
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|dns_difftuple_t
modifier|*
name|t
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|void
modifier|*
name|mem
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|used
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DIFF_VALID
argument_list|(
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|j
operator|->
name|state
operator|==
name|JOURNAL_STATE_TRANSACTION
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"writing to journal"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_diff_print
argument_list|(
name|diff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Pass 1: determine the buffer size needed, and 	 * keep track of SOA serial numbers. 	 */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|t
operator|->
name|rdata
operator|.
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
if|if
condition|(
name|j
operator|->
name|x
operator|.
name|n_soa
operator|<
literal|2
condition|)
name|j
operator|->
name|x
operator|.
name|pos
index|[
name|j
operator|->
name|x
operator|.
name|n_soa
index|]
operator|.
name|serial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|t
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|j
operator|->
name|x
operator|.
name|n_soa
operator|++
expr_stmt|;
block|}
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|journal_rawrrhdr_t
argument_list|)
expr_stmt|;
name|size
operator|+=
name|t
operator|->
name|name
operator|.
name|length
expr_stmt|;
comment|/* XXX should have access macro? */
name|size
operator|+=
literal|10
expr_stmt|;
name|size
operator|+=
name|t
operator|->
name|rdata
operator|.
name|length
expr_stmt|;
block|}
name|mem
operator|=
name|isc_mem_get
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Pass 2.  Write RRs to buffer. 	 */
for|for
control|(
name|t
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
operator|->
name|tuples
argument_list|)
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|t
argument_list|,
name|link
argument_list|)
control|)
block|{
comment|/* 		 * Write the RR header. 		 */
name|isc_buffer_putuint32
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|name
operator|.
name|length
operator|+
literal|10
operator|+
name|t
operator|->
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* 		 * Write the owner name, RR header, and RR data. 		 */
name|isc_buffer_putmem
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|name
operator|.
name|ndata
argument_list|,
name|t
operator|->
name|name
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|rdata
operator|.
name|type
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|rdata
operator|.
name|rdclass
argument_list|)
expr_stmt|;
name|isc_buffer_putuint32
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|t
operator|->
name|rdata
operator|.
name|length
operator|<
literal|65536
argument_list|)
expr_stmt|;
name|isc_buffer_putuint16
argument_list|(
operator|&
name|buffer
argument_list|,
operator|(
name|isc_uint16_t
operator|)
name|t
operator|->
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|buffer
argument_list|)
operator|>=
name|t
operator|->
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_putmem
argument_list|(
operator|&
name|buffer
argument_list|,
name|t
operator|->
name|rdata
operator|.
name|data
argument_list|,
name|t
operator|->
name|rdata
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|isc_buffer_usedregion
argument_list|(
operator|&
name|buffer
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|used
operator|.
name|length
operator|==
name|size
argument_list|)
expr_stmt|;
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|offset
operator|+=
name|used
operator|.
name|length
expr_stmt|;
comment|/* 	 * Write the buffer contents to the journal file. 	 */
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
name|used
operator|.
name|base
argument_list|,
name|used
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|mem
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_commit
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|journal_rawheader_t
name|rawheader
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|j
operator|->
name|state
operator|==
name|JOURNAL_STATE_TRANSACTION
argument_list|)
expr_stmt|;
comment|/* 	 * Perform some basic consistency checks. 	 */
if|if
condition|(
name|j
operator|->
name|x
operator|.
name|n_soa
operator|!=
literal|2
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: malformed transaction: %d SOAs"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|j
operator|->
name|x
operator|.
name|n_soa
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|DNS_SERIAL_GT
argument_list|(
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|serial
argument_list|)
operator|||
operator|(
name|bind8_compat
operator|&&
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
operator|==
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|serial
operator|)
operator|)
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: malformed transaction: serial number "
literal|"would decrease"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|serial
operator|!=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"malformed transaction: "
literal|"%s last serial %u != "
literal|"transaction first serial %u"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|serial
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
comment|/* 	 * Some old journal entries may become non-addressable 	 * when we increment the current serial number.  Purge them 	 * by stepping header.begin forward to the first addressable 	 * transaction.  Also purge them from the index. 	 */
if|if
condition|(
operator|!
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|DNS_SERIAL_GT
argument_list|(
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
argument_list|,
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|serial
argument_list|)
condition|)
block|{
name|CHECK
argument_list|(
name|journal_next
argument_list|(
name|j
argument_list|,
operator|&
name|j
operator|->
name|header
operator|.
name|begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|index_invalidate
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|DNS_SERIAL_GT
argument_list|(
name|last_dumped_serial
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
argument_list|)
condition|)
block|{
name|force_dump
argument_list|(
operator|...
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Commit the transaction data to stable storage. 	 */
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the transaction header. 	 */
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write_xhdr
argument_list|(
name|j
argument_list|,
operator|(
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|offset
operator|-
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|offset
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|journal_rawxhdr_t
argument_list|)
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
operator|.
name|serial
argument_list|,
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
operator|.
name|serial
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the journal header. 	 */
if|if
condition|(
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
block|{
name|j
operator|->
name|header
operator|.
name|begin
operator|=
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
expr_stmt|;
block|}
name|j
operator|->
name|header
operator|.
name|end
operator|=
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|1
index|]
expr_stmt|;
name|journal_header_encode
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|,
operator|&
name|rawheader
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
operator|&
name|rawheader
argument_list|,
sizeof|sizeof
argument_list|(
name|rawheader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the index. 	 */
name|index_add
argument_list|(
name|j
argument_list|,
operator|&
name|j
operator|->
name|x
operator|.
name|pos
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the index into on-disk format and write 	 * it to disk. 	 */
name|CHECK
argument_list|(
name|index_to_disk
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the header to stable storage. 	 */
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We no longer have a transaction open. 	 */
name|j
operator|->
name|state
operator|=
name|JOURNAL_STATE_WRITE
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_write_transaction
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|dns_diff_sort
argument_list|(
name|diff
argument_list|,
name|ixfr_order
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_begin_transaction
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_writediff
argument_list|(
name|j
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_commit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_journal_destroy
parameter_list|(
name|dns_journal_t
modifier|*
modifier|*
name|journalp
parameter_list|)
block|{
name|dns_journal_t
modifier|*
name|j
init|=
operator|*
name|journalp
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
name|dns_name_invalidate
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|name
argument_list|)
expr_stmt|;
name|dns_decompress_invalidate
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|dctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|rawindex
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
operator|->
name|rawindex
argument_list|,
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|index
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
operator|->
name|index
argument_list|,
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_pos_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|it
operator|.
name|target
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
operator|->
name|it
operator|.
name|target
operator|.
name|base
argument_list|,
name|j
operator|->
name|it
operator|.
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|base
argument_list|,
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|isc_stdio_close
argument_list|(
name|j
operator|->
name|fp
argument_list|)
expr_stmt|;
name|j
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|j
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|j
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|journalp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Roll the open journal 'j' into the database 'db'.  * A new database version will be created.  */
end_comment

begin_comment
comment|/* XXX Share code with incoming IXFR? */
end_comment

begin_function
specifier|static
name|isc_result_t
name|roll_forward
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|)
block|{
name|isc_buffer_t
name|source
decl_stmt|;
comment|/* Transaction data from disk */
name|isc_buffer_t
name|target
decl_stmt|;
comment|/* Ditto after _fromwire check */
name|isc_uint32_t
name|db_serial
decl_stmt|;
comment|/* Database SOA serial */
name|isc_uint32_t
name|end_serial
decl_stmt|;
comment|/* Last journal SOA serial */
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
init|=
name|NULL
decl_stmt|;
name|journal_pos_t
name|pos
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|unsigned
name|int
name|n_soa
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|n_put
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_JOURNAL_VALID
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DB_VALID
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
comment|/* 	 * Set up empty initial buffers for uncheched and checked 	 * wire format transaction data.  They will be reallocated 	 * later. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|source
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Create the new database version. 	 */
name|CHECK
argument_list|(
name|dns_db_newversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the current database SOA serial number. 	 */
name|CHECK
argument_list|(
name|dns_db_getsoaserial
argument_list|(
name|db
argument_list|,
name|ver
argument_list|,
operator|&
name|db_serial
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Locate a journal entry for the current database serial. 	 */
name|CHECK
argument_list|(
name|journal_find
argument_list|(
name|j
argument_list|,
name|db_serial
argument_list|,
operator|&
name|pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX do more drastic things, like marking zone stale, 	 * if this fails? 	 */
comment|/* 	 * XXXRTH  The zone code should probably mark the zone as bad and 	 *         scream loudly into the log if this is a dynamic update 	 *	   log reply that failed. 	 */
name|end_serial
operator|=
name|dns_journal_last_serial
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_serial
operator|==
name|end_serial
condition|)
name|CHECK
argument_list|(
name|DNS_R_UPTODATE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_iter_init
argument_list|(
name|j
argument_list|,
name|db_serial
argument_list|,
name|end_serial
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_journal_first_rr
argument_list|(
name|j
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_journal_next_rr
argument_list|(
name|j
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|dns_journal_current_rr
argument_list|(
name|j
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
name|n_soa
operator|++
expr_stmt|;
if|if
condition|(
name|n_soa
operator|==
literal|2
condition|)
name|db_serial
operator|=
name|j
operator|->
name|it
operator|.
name|current_serial
expr_stmt|;
block|}
if|if
condition|(
name|n_soa
operator|==
literal|3
condition|)
name|n_soa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_soa
operator|==
literal|0
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal file corrupt: missing "
literal|"initial SOA"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|.
name|mctx
argument_list|,
name|n_soa
operator|==
literal|1
condition|?
name|DNS_DIFFOP_DEL
else|:
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_append
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n_put
operator|>
literal|100
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s: applying diff to database (%u)"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|db_serial
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_diff_print
argument_list|(
operator|&
name|diff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_diff_apply
argument_list|(
operator|&
name|diff
argument_list|,
name|db
argument_list|,
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|n_put
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_put
operator|!=
literal|0
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"%s: applying final diff to database (%u)"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|db_serial
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_diff_print
argument_list|(
operator|&
name|diff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_diff_apply
argument_list|(
operator|&
name|diff
argument_list|,
name|db
argument_list|,
name|ver
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
if|if
condition|(
name|ver
operator|!=
name|NULL
condition|)
name|dns_db_closeversion
argument_list|(
name|db
argument_list|,
operator|&
name|ver
argument_list|,
name|result
operator|==
name|ISC_R_SUCCESS
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|source
operator|.
name|base
argument_list|,
name|source
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|target
operator|.
name|base
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_rollforward
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|dns_journal_t
modifier|*
name|j
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_DB_VALID
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|j
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_journal_open
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"no journal file, but that's OK"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_NOJOURNAL
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
name|result
operator|=
name|DNS_R_UPTODATE
expr_stmt|;
else|else
name|result
operator|=
name|roll_forward
argument_list|(
name|j
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_print
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|dns_journal_t
modifier|*
name|j
decl_stmt|;
name|isc_buffer_t
name|source
decl_stmt|;
comment|/* Transaction data from disk */
name|isc_buffer_t
name|target
decl_stmt|;
comment|/* Ditto after _fromwire check */
name|isc_uint32_t
name|start_serial
decl_stmt|;
comment|/* Database SOA serial */
name|isc_uint32_t
name|end_serial
decl_stmt|;
comment|/* Last journal SOA serial */
name|isc_result_t
name|result
decl_stmt|;
name|dns_diff_t
name|diff
decl_stmt|;
name|unsigned
name|int
name|n_soa
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|n_put
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|j
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dns_journal_open
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOTFOUND
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"no journal file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_NOJOURNAL
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"journal open failure: %s: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_diff_init
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
operator|&
name|diff
argument_list|)
expr_stmt|;
comment|/* 	 * Set up empty initial buffers for uncheched and checked 	 * wire format transaction data.  They will be reallocated 	 * later. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|source
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|start_serial
operator|=
name|dns_journal_first_serial
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|end_serial
operator|=
name|dns_journal_last_serial
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_journal_iter_init
argument_list|(
name|j
argument_list|,
name|start_serial
argument_list|,
name|end_serial
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_journal_first_rr
argument_list|(
name|j
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_journal_next_rr
argument_list|(
name|j
argument_list|)
control|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rdata
operator|=
name|NULL
expr_stmt|;
name|dns_journal_current_rr
argument_list|(
name|j
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|->
name|type
operator|==
name|dns_rdatatype_soa
condition|)
name|n_soa
operator|++
expr_stmt|;
if|if
condition|(
name|n_soa
operator|==
literal|3
condition|)
name|n_soa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_soa
operator|==
literal|0
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal file corrupt: missing "
literal|"initial SOA"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|dns_difftuple_create
argument_list|(
name|diff
operator|.
name|mctx
argument_list|,
name|n_soa
operator|==
literal|1
condition|?
name|DNS_DIFFOP_DEL
else|:
name|DNS_DIFFOP_ADD
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
operator|&
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|dns_diff_append
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n_put
operator|>
literal|100
condition|)
block|{
name|result
operator|=
name|dns_diff_print
argument_list|(
operator|&
name|diff
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|n_put
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMORE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|CHECK
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_put
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|dns_diff_print
argument_list|(
operator|&
name|diff
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cleanup
goto|;
name|failure
label|:
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: cannot print: journal file corrupt"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|source
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|source
operator|.
name|base
argument_list|,
name|source
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
name|target
operator|.
name|base
argument_list|,
name|target
operator|.
name|length
argument_list|)
expr_stmt|;
name|dns_diff_clear
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Miscellaneous accessors.  */
end_comment

begin_function
name|isc_uint32_t
name|dns_journal_first_serial
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
return|return
operator|(
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|serial
operator|)
return|;
block|}
end_function

begin_function
name|isc_uint32_t
name|dns_journal_last_serial
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
return|return
operator|(
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Iteration support.  *  * When serving an outgoing IXFR, we transmit a part the journal starting  * at the serial number in the IXFR request and ending at the serial  * number that is current when the IXFR request arrives.  The ending  * serial number is not necessarily at the end of the journal:  * the journal may grow while the IXFR is in progress, but we stop  * when we reach the serial number that was current when the IXFR started.  */
end_comment

begin_function_decl
specifier|static
name|isc_result_t
name|read_one_rr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Make sure the buffer 'b' is has at least 'size' bytes  * allocated, and clear it.  *  * Requires:  *	Either b->base is NULL, or it points to b->length bytes of memory  *	previously allocated by isc_mem_get().  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|size_buffer
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_buffer_t
modifier|*
name|b
parameter_list|,
name|unsigned
name|size
parameter_list|)
block|{
if|if
condition|(
name|b
operator|->
name|length
operator|<
name|size
condition|)
block|{
name|void
modifier|*
name|mem
init|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|b
operator|->
name|base
argument_list|,
name|b
operator|->
name|length
argument_list|)
expr_stmt|;
name|b
operator|->
name|base
operator|=
name|mem
expr_stmt|;
name|b
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
name|isc_buffer_clear
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_iter_init
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|isc_uint32_t
name|begin_serial
parameter_list|,
name|isc_uint32_t
name|end_serial
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|CHECK
argument_list|(
name|journal_find
argument_list|(
name|j
argument_list|,
name|begin_serial
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|bpos
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|j
operator|->
name|it
operator|.
name|bpos
operator|.
name|serial
operator|==
name|begin_serial
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_find
argument_list|(
name|j
argument_list|,
name|end_serial
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|epos
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|j
operator|->
name|it
operator|.
name|epos
operator|.
name|serial
operator|==
name|end_serial
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
name|j
operator|->
name|it
operator|.
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|j
operator|->
name|it
operator|.
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_first_rr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Seek to the beginning of the first transaction we are 	 * interested in. 	 */
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|it
operator|.
name|bpos
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|current_serial
operator|=
name|j
operator|->
name|it
operator|.
name|bpos
operator|.
name|serial
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|xsize
operator|=
literal|0
expr_stmt|;
comment|/* We have no transaction data yet... */
name|j
operator|->
name|it
operator|.
name|xpos
operator|=
literal|0
expr_stmt|;
comment|/* ...and haven't used any of it. */
return|return
operator|(
name|read_one_rr
argument_list|(
name|j
argument_list|)
operator|)
return|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|read_one_rr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|unsigned
name|int
name|rdlen
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|journal_xhdr_t
name|xhdr
decl_stmt|;
name|journal_rrhdr_t
name|rrhdr
decl_stmt|;
name|INSIST
argument_list|(
name|j
operator|->
name|offset
operator|<=
name|j
operator|->
name|it
operator|.
name|epos
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|->
name|offset
operator|==
name|j
operator|->
name|it
operator|.
name|epos
operator|.
name|offset
condition|)
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
if|if
condition|(
name|j
operator|->
name|it
operator|.
name|xpos
operator|==
name|j
operator|->
name|it
operator|.
name|xsize
condition|)
block|{
comment|/* 		 * We are at a transaction boundary. 		 * Read another transaction header. 		 */
name|CHECK
argument_list|(
name|journal_read_xhdr
argument_list|(
name|j
argument_list|,
operator|&
name|xhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xhdr
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal corrupt: empty transaction"
argument_list|,
name|j
operator|->
name|filename
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xhdr
operator|.
name|serial0
operator|!=
name|j
operator|->
name|it
operator|.
name|current_serial
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal file corrupt: "
literal|"expected serial %u, got %u"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|j
operator|->
name|it
operator|.
name|current_serial
argument_list|,
name|xhdr
operator|.
name|serial0
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|j
operator|->
name|it
operator|.
name|xsize
operator|=
name|xhdr
operator|.
name|size
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|xpos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Read an RR. 	 */
name|CHECK
argument_list|(
name|journal_read_rrhdr
argument_list|(
name|j
argument_list|,
operator|&
name|rrhdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Perform a sanity check on the journal RR size. 	 * The smallest possible RR has a 1-byte owner name 	 * and a 10-byte header.  The largest possible 	 * RR has 65535 bytes of data, a header, and a maximum- 	 * size owner name, well below 70 k total. 	 */
if|if
condition|(
name|rrhdr
operator|.
name|size
operator|<
literal|1
operator|+
literal|10
operator|||
name|rrhdr
operator|.
name|size
operator|>
literal|70000
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_COMMON_LOGARGS
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s: journal corrupt: impossible RR size "
literal|"(%d bytes)"
argument_list|,
name|j
operator|->
name|filename
argument_list|,
name|rrhdr
operator|.
name|size
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
name|ISC_R_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|size_buffer
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
name|rrhdr
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_read
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|base
argument_list|,
name|rrhdr
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
name|rrhdr
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * The target buffer is made the same size 	 * as the source buffer, with the assumption that when 	 * no compression in present, the output of dns_*_fromwire() 	 * is no larger than the input. 	 */
name|CHECK
argument_list|(
name|size_buffer
argument_list|(
name|j
operator|->
name|mctx
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|target
argument_list|,
name|rrhdr
operator|.
name|size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the owner name.  We don't know where it 	 * ends yet, so we make the entire "remaining" 	 * part of the buffer "active". 	 */
name|isc_buffer_setactive
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|used
operator|-
name|j
operator|->
name|it
operator|.
name|source
operator|.
name|current
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_name_fromwire
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|name
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|dctx
argument_list|,
literal|0
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the RR header is there, and parse it. 	 */
if|if
condition|(
name|isc_buffer_remaininglength
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|)
operator|<
literal|10
condition|)
name|FAIL
argument_list|(
name|DNS_R_FORMERR
argument_list|)
expr_stmt|;
name|rdtype
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|)
expr_stmt|;
name|rdclass
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|)
expr_stmt|;
name|rdlen
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the rdata. 	 */
name|isc_buffer_setactive
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
name|rdlen
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|rdata
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_rdata_fromwire
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|rdata
argument_list|,
name|rdclass
argument_list|,
name|rdtype
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|source
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|dctx
argument_list|,
literal|0
argument_list|,
operator|&
name|j
operator|->
name|it
operator|.
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|ttl
operator|=
name|ttl
expr_stmt|;
name|j
operator|->
name|it
operator|.
name|xpos
operator|+=
sizeof|sizeof
argument_list|(
name|journal_rawrrhdr_t
argument_list|)
operator|+
name|rrhdr
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|rdtype
operator|==
name|dns_rdatatype_soa
condition|)
block|{
comment|/* XXX could do additional consistency checks here */
name|j
operator|->
name|it
operator|.
name|current_serial
operator|=
name|dns_soa_getserial
argument_list|(
operator|&
name|j
operator|->
name|it
operator|.
name|rdata
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
name|j
operator|->
name|it
operator|.
name|result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_next_rr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|j
operator|->
name|it
operator|.
name|result
operator|=
name|read_one_rr
argument_list|(
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|j
operator|->
name|it
operator|.
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_journal_current_rr
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|,
name|dns_name_t
modifier|*
modifier|*
name|name
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttl
parameter_list|,
name|dns_rdata_t
modifier|*
modifier|*
name|rdata
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|j
operator|->
name|it
operator|.
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
operator|*
name|name
operator|=
operator|&
name|j
operator|->
name|it
operator|.
name|name
expr_stmt|;
operator|*
name|ttl
operator|=
name|j
operator|->
name|it
operator|.
name|ttl
expr_stmt|;
operator|*
name|rdata
operator|=
operator|&
name|j
operator|->
name|it
operator|.
name|rdata
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************/
end_comment

begin_comment
comment|/*  * Generating diffs from databases  */
end_comment

begin_comment
comment|/*  * Construct a diff containing all the RRs at the current name of the  * database iterator 'dbit' in database 'db', version 'ver'.  * Set '*name' to the current name, and append the diff to 'diff'.  * All new tuples will have the operation 'op'.  *  * Requires: 'name' must have buffer large enough to hold the name.  * Typically, a dns_fixedname_t would be used.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|get_name_diff
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbiterator_t
modifier|*
name|dbit
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_diffop_t
name|op
parameter_list|,
name|dns_diff_t
modifier|*
name|diff
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dbnode_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|dns_rdatasetiter_t
modifier|*
name|rdsiter
init|=
name|NULL
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|tuple
init|=
name|NULL
decl_stmt|;
name|result
operator|=
name|dns_dbiterator_current
argument_list|(
name|dbit
argument_list|,
operator|&
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_db_allrdatasets
argument_list|(
name|db
argument_list|,
name|node
argument_list|,
name|ver
argument_list|,
name|now
argument_list|,
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_node
goto|;
for|for
control|(
name|result
operator|=
name|dns_rdatasetiter_first
argument_list|(
name|rdsiter
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdatasetiter_next
argument_list|(
name|rdsiter
argument_list|)
control|)
block|{
name|dns_rdataset_t
name|rdataset
decl_stmt|;
name|dns_rdataset_init
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
name|dns_rdatasetiter_current
argument_list|(
name|rdsiter
argument_list|,
operator|&
name|rdataset
argument_list|)
expr_stmt|;
for|for
control|(
name|result
operator|=
name|dns_rdataset_first
argument_list|(
operator|&
name|rdataset
argument_list|)
init|;
name|result
operator|==
name|ISC_R_SUCCESS
condition|;
name|result
operator|=
name|dns_rdataset_next
argument_list|(
operator|&
name|rdataset
argument_list|)
control|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdataset_current
argument_list|(
operator|&
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_difftuple_create
argument_list|(
name|diff
operator|->
name|mctx
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|rdataset
operator|.
name|ttl
argument_list|,
operator|&
name|rdata
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
goto|goto
name|cleanup_iterator
goto|;
block|}
name|dns_diff_append
argument_list|(
name|diff
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
block|}
name|dns_rdataset_disassociate
argument_list|(
operator|&
name|rdataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|cleanup_iterator
goto|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_NOMORE
condition|)
goto|goto
name|cleanup_iterator
goto|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup_iterator
label|:
name|dns_rdatasetiter_destroy
argument_list|(
operator|&
name|rdsiter
argument_list|)
expr_stmt|;
name|cleanup_node
label|:
name|dns_db_detachnode
argument_list|(
name|db
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Comparison function for use by dns_diff_subtract when sorting  * the diffs to be subtracted.  The sort keys are the rdata type  * and the rdata itself.  The owner name is ignored, because  * it is known to be the same for all tuples.  */
end_comment

begin_function
specifier|static
name|int
name|rdata_order
parameter_list|(
specifier|const
name|void
modifier|*
name|av
parameter_list|,
specifier|const
name|void
modifier|*
name|bv
parameter_list|)
block|{
name|dns_difftuple_t
specifier|const
modifier|*
specifier|const
modifier|*
name|ap
init|=
name|av
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
specifier|const
modifier|*
name|bp
init|=
name|bv
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
name|a
init|=
operator|*
name|ap
decl_stmt|;
name|dns_difftuple_t
specifier|const
modifier|*
name|b
init|=
operator|*
name|bp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|b
operator|->
name|rdata
operator|.
name|type
operator|-
name|a
operator|->
name|rdata
operator|.
name|type
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|r
operator|=
name|dns_rdata_compare
argument_list|(
operator|&
name|a
operator|->
name|rdata
argument_list|,
operator|&
name|b
operator|->
name|rdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_diff_subtract
parameter_list|(
name|dns_diff_t
name|diff
index|[
literal|2
index|]
parameter_list|,
name|dns_diff_t
modifier|*
name|r
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_difftuple_t
modifier|*
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|isc_boolean_t
name|append
decl_stmt|;
name|CHECK
argument_list|(
name|dns_diff_sort
argument_list|(
operator|&
name|diff
index|[
literal|0
index|]
argument_list|,
name|rdata_order
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_diff_sort
argument_list|(
operator|&
name|diff
index|[
literal|1
index|]
argument_list|,
name|rdata_order
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
index|[
operator|!
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
index|[
name|i
index|]
operator|.
name|tuples
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|r
operator|->
name|tuples
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|t
operator|=
name|rdata_order
argument_list|(
operator|&
name|p
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|r
operator|->
name|tuples
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|t
operator|>
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|r
operator|->
name|tuples
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|INSIST
argument_list|(
name|t
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Identical RRs in both databases; skip them both 		 * if the ttl differs. 		 */
name|append
operator|=
name|ISC_TF
argument_list|(
name|p
index|[
literal|0
index|]
operator|->
name|ttl
operator|!=
name|p
index|[
literal|1
index|]
operator|->
name|ttl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|diff
index|[
name|i
index|]
operator|.
name|tuples
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|append
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|r
operator|->
name|tuples
argument_list|,
name|p
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_difftuple_free
argument_list|(
operator|&
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|next
label|:
empty_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the databases 'dba' and 'dbb' and generate a journal  * entry containing the changes to make 'dba' from 'dbb' (note  * the order).  This journal entry will consist of a single,  * possibly very large transaction.  */
end_comment

begin_function
name|isc_result_t
name|dns_db_diff
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_db_t
modifier|*
name|dba
parameter_list|,
name|dns_dbversion_t
modifier|*
name|dbvera
parameter_list|,
name|dns_db_t
modifier|*
name|dbb
parameter_list|,
name|dns_dbversion_t
modifier|*
name|dbverb
parameter_list|,
specifier|const
name|char
modifier|*
name|journal_filename
parameter_list|)
block|{
name|dns_db_t
modifier|*
name|db
index|[
literal|2
index|]
decl_stmt|;
name|dns_dbversion_t
modifier|*
name|ver
index|[
literal|2
index|]
decl_stmt|;
name|dns_dbiterator_t
modifier|*
name|dbit
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|isc_boolean_t
name|have
index|[
literal|2
index|]
init|=
block|{
name|ISC_FALSE
block|,
name|ISC_FALSE
block|}
decl_stmt|;
name|dns_fixedname_t
name|fixname
index|[
literal|2
index|]
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|,
name|itresult
index|[
literal|2
index|]
decl_stmt|;
name|dns_diff_t
name|diff
index|[
literal|2
index|]
decl_stmt|,
name|resultdiff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|dns_journal_t
modifier|*
name|journal
init|=
name|NULL
decl_stmt|;
name|db
index|[
literal|0
index|]
operator|=
name|dba
operator|,
name|db
index|[
literal|1
index|]
operator|=
name|dbb
expr_stmt|;
name|ver
index|[
literal|0
index|]
operator|=
name|dbvera
operator|,
name|ver
index|[
literal|1
index|]
operator|=
name|dbverb
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|diff
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|diff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dns_diff_init
argument_list|(
name|mctx
argument_list|,
operator|&
name|resultdiff
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_journal_open
argument_list|(
name|mctx
argument_list|,
name|journal_filename
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|journal
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|db
index|[
literal|0
index|]
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|dbit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_journal
goto|;
name|result
operator|=
name|dns_db_createiterator
argument_list|(
name|db
index|[
literal|1
index|]
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|dbit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_interator0
goto|;
name|itresult
index|[
literal|0
index|]
operator|=
name|dns_dbiterator_first
argument_list|(
name|dbit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|itresult
index|[
literal|1
index|]
operator|=
name|dns_dbiterator_first
argument_list|(
name|dbit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|have
index|[
name|i
index|]
operator|&&
name|itresult
index|[
name|i
index|]
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|CHECK
argument_list|(
name|get_name_diff
argument_list|(
name|db
index|[
name|i
index|]
argument_list|,
name|ver
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|dbit
index|[
name|i
index|]
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixname
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
operator|==
literal|0
condition|?
name|DNS_DIFFOP_ADD
else|:
name|DNS_DIFFOP_DEL
argument_list|,
operator|&
name|diff
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|itresult
index|[
name|i
index|]
operator|=
name|dns_dbiterator_next
argument_list|(
name|dbit
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|have
index|[
name|i
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|have
index|[
literal|0
index|]
operator|&&
operator|!
name|have
index|[
literal|1
index|]
condition|)
block|{
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|have
index|[
operator|!
name|i
index|]
condition|)
block|{
name|ISC_LIST_APPENDLIST
argument_list|(
name|resultdiff
operator|.
name|tuples
argument_list|,
name|diff
index|[
name|i
index|]
operator|.
name|tuples
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
name|i
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|have
index|[
name|i
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|t
operator|=
name|dns_name_compare
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixname
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|dns_fixedname_name
argument_list|(
operator|&
name|fixname
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
name|ISC_LIST_APPENDLIST
argument_list|(
name|resultdiff
operator|.
name|tuples
argument_list|,
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|have
index|[
literal|0
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t
operator|>
literal|0
condition|)
block|{
name|ISC_LIST_APPENDLIST
argument_list|(
name|resultdiff
operator|.
name|tuples
argument_list|,
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|have
index|[
literal|1
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
continue|continue;
block|}
name|INSIST
argument_list|(
name|t
operator|==
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|dns_diff_subtract
argument_list|(
name|diff
argument_list|,
operator|&
name|resultdiff
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|have
index|[
literal|0
index|]
operator|=
name|have
index|[
literal|1
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
name|next
label|:
empty_stmt|;
block|}
if|if
condition|(
name|itresult
index|[
literal|0
index|]
operator|!=
name|ISC_R_NOMORE
condition|)
name|FAIL
argument_list|(
name|itresult
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|itresult
index|[
literal|1
index|]
operator|!=
name|ISC_R_NOMORE
condition|)
name|FAIL
argument_list|(
name|itresult
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|resultdiff
operator|.
name|tuples
argument_list|)
condition|)
block|{
name|isc_log_write
argument_list|(
name|JOURNAL_DEBUG_LOGARGS
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"no changes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CHECK
argument_list|(
name|dns_journal_write_transaction
argument_list|(
name|journal
argument_list|,
operator|&
name|resultdiff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|0
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|diff
index|[
literal|1
index|]
operator|.
name|tuples
argument_list|)
argument_list|)
expr_stmt|;
name|failure
label|:
name|dns_diff_clear
argument_list|(
operator|&
name|resultdiff
argument_list|)
expr_stmt|;
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbit
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cleanup_interator0
label|:
name|dns_dbiterator_destroy
argument_list|(
operator|&
name|dbit
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cleanup_journal
label|:
name|dns_journal_destroy
argument_list|(
operator|&
name|journal
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_journal_compact
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|isc_uint32_t
name|serial
parameter_list|,
name|isc_uint32_t
name|target_size
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|journal_pos_t
name|best_guess
decl_stmt|;
name|journal_pos_t
name|current_pos
decl_stmt|;
name|dns_journal_t
modifier|*
name|j
init|=
name|NULL
decl_stmt|;
name|journal_rawheader_t
name|rawheader
decl_stmt|;
name|unsigned
name|int
name|copy_length
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|unsigned
name|int
name|indexend
decl_stmt|;
name|CHECK
argument_list|(
name|journal_open
argument_list|(
name|mctx
argument_list|,
name|filename
argument_list|,
name|ISC_TRUE
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|JOURNAL_EMPTY
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|)
condition|)
block|{
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|DNS_SERIAL_GT
argument_list|(
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|serial
argument_list|,
name|serial
argument_list|)
operator|||
name|DNS_SERIAL_GT
argument_list|(
name|serial
argument_list|,
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
argument_list|)
condition|)
block|{
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
comment|/* 	 * Cope with very small target sizes. 	 */
name|indexend
operator|=
sizeof|sizeof
argument_list|(
name|journal_rawheader_t
argument_list|)
operator|+
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_size
operator|<
name|indexend
operator|*
literal|2
condition|)
name|target_size
operator|=
name|target_size
operator|/
literal|2
operator|+
name|indexend
expr_stmt|;
comment|/* 	 * See if there is any work to do. 	 */
if|if
condition|(
operator|(
name|isc_uint32_t
operator|)
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|<
name|target_size
condition|)
block|{
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * Remove overhead so space test below can succeed. 	 */
if|if
condition|(
name|target_size
operator|>=
name|indexend
condition|)
name|target_size
operator|-=
name|indexend
expr_stmt|;
comment|/* 	 * Find if we can create enough free space. 	 */
name|best_guess
operator|=
name|j
operator|->
name|header
operator|.
name|begin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|POS_VALID
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
operator|&&
name|DNS_SERIAL_GE
argument_list|(
name|serial
argument_list|,
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
argument_list|)
operator|&&
operator|(
call|(
name|isc_uint32_t
call|)
argument_list|(
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|-
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
operator|>=
name|target_size
operator|/
literal|2
operator|)
operator|&&
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|offset
operator|>
name|best_guess
operator|.
name|offset
condition|)
name|best_guess
operator|=
name|j
operator|->
name|index
index|[
name|i
index|]
expr_stmt|;
block|}
name|current_pos
operator|=
name|best_guess
expr_stmt|;
while|while
condition|(
name|current_pos
operator|.
name|serial
operator|!=
name|serial
condition|)
block|{
name|CHECK
argument_list|(
name|journal_next
argument_list|(
name|j
argument_list|,
operator|&
name|current_pos
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_pos
operator|.
name|serial
operator|==
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
condition|)
break|break;
if|if
condition|(
name|DNS_SERIAL_GE
argument_list|(
name|serial
argument_list|,
name|current_pos
operator|.
name|serial
argument_list|)
operator|&&
operator|(
call|(
name|isc_uint32_t
call|)
argument_list|(
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|-
name|current_pos
operator|.
name|offset
argument_list|)
operator|>=
operator|(
name|target_size
operator|/
literal|2
operator|)
operator|)
operator|&&
name|current_pos
operator|.
name|offset
operator|>
name|best_guess
operator|.
name|offset
condition|)
name|best_guess
operator|=
name|current_pos
expr_stmt|;
else|else
break|break;
block|}
name|INSIST
argument_list|(
name|best_guess
operator|.
name|serial
operator|!=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_guess
operator|.
name|serial
operator|!=
name|serial
condition|)
name|CHECK
argument_list|(
name|journal_next
argument_list|(
name|j
argument_list|,
operator|&
name|best_guess
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Enough space to proceed? 	 */
if|if
condition|(
call|(
name|isc_uint32_t
call|)
argument_list|(
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|-
name|best_guess
operator|.
name|offset
argument_list|)
operator|>
call|(
name|isc_uint32_t
call|)
argument_list|(
name|best_guess
operator|.
name|offset
operator|-
name|indexend
argument_list|)
condition|)
block|{
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
block|}
name|copy_length
operator|=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|-
name|best_guess
operator|.
name|offset
expr_stmt|;
comment|/* 	 * Invalidate entire index, will be rebuilt at end. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|POS_VALID
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
condition|)
name|POS_INVALIDATE
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Convert the index into on-disk format and write 	 * it to disk. 	 */
name|CHECK
argument_list|(
name|index_to_disk
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update the journal header. 	 */
if|if
condition|(
name|copy_length
operator|==
literal|0
condition|)
block|{
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|j
operator|->
name|header
operator|.
name|begin
operator|=
name|best_guess
expr_stmt|;
block|}
name|journal_header_encode
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|,
operator|&
name|rawheader
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
operator|&
name|rawheader
argument_list|,
sizeof|sizeof
argument_list|(
name|rawheader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_length
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Copy best_guess to end into space just freed. 		 */
name|size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|copy_length
operator|<
name|size
condition|)
name|size
operator|=
name|copy_length
expr_stmt|;
name|buf
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|copy_length
condition|;
name|i
operator|+=
name|size
control|)
block|{
name|len
operator|=
operator|(
name|copy_length
operator|-
name|i
operator|)
operator|>
name|size
condition|?
name|size
else|:
operator|(
name|copy_length
operator|-
name|i
operator|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
name|best_guess
operator|.
name|offset
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_read
argument_list|(
name|j
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
name|indexend
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Compute new header. 		 */
name|j
operator|->
name|header
operator|.
name|begin
operator|.
name|offset
operator|=
name|indexend
expr_stmt|;
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
operator|=
name|indexend
operator|+
name|copy_length
expr_stmt|;
comment|/* 		 * Update the journal header. 		 */
name|journal_header_encode
argument_list|(
operator|&
name|j
operator|->
name|header
argument_list|,
operator|&
name|rawheader
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
operator|&
name|rawheader
argument_list|,
sizeof|sizeof
argument_list|(
name|rawheader
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Build new index. 		 */
name|current_pos
operator|=
name|j
operator|->
name|header
operator|.
name|begin
expr_stmt|;
while|while
condition|(
name|current_pos
operator|.
name|serial
operator|!=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|serial
condition|)
block|{
name|index_add
argument_list|(
name|j
argument_list|,
operator|&
name|current_pos
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_next
argument_list|(
name|j
argument_list|,
operator|&
name|current_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Write index. 		 */
name|CHECK
argument_list|(
name|index_to_disk
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_fsync
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|indexend
operator|=
name|j
operator|->
name|header
operator|.
name|end
operator|.
name|offset
expr_stmt|;
block|}
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_file_truncate
argument_list|(
name|filename
argument_list|,
operator|(
name|isc_offset_t
operator|)
name|indexend
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|failure
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|NULL
condition|)
name|dns_journal_destroy
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|index_to_disk
parameter_list|(
name|dns_journal_t
modifier|*
name|j
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
if|if
condition|(
name|j
operator|->
name|header
operator|.
name|index_size
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|rawbytes
decl_stmt|;
name|rawbytes
operator|=
name|j
operator|->
name|header
operator|.
name|index_size
operator|*
sizeof|sizeof
argument_list|(
name|journal_rawpos_t
argument_list|)
expr_stmt|;
name|p
operator|=
name|j
operator|->
name|rawindex
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
operator|->
name|header
operator|.
name|index_size
condition|;
name|i
operator|++
control|)
block|{
name|encode_uint32
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|serial
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|encode_uint32
argument_list|(
name|j
operator|->
name|index
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|p
operator|==
name|j
operator|->
name|rawindex
operator|+
name|rawbytes
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_seek
argument_list|(
name|j
argument_list|,
sizeof|sizeof
argument_list|(
name|journal_rawheader_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|journal_write
argument_list|(
name|j
argument_list|,
name|j
operator|->
name|rawindex
argument_list|,
name|rawbytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|failure
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

