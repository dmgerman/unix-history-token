begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2009, 2011  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: db.h,v 1.104 2011-01-13 04:59:25 tbox Exp $ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DB_H
end_ifndef

begin_define
define|#
directive|define
name|DNS_DB_H
value|1
end_define

begin_comment
comment|/*****  ***** Module Info  *****/
end_comment

begin_comment
comment|/*! \file dns/db.h  * \brief  * The DNS DB interface allows named rdatasets to be stored and retrieved.  *  * The dns_db_t type is like a "virtual class".  To actually use  * DBs, an implementation of the class is required.  *  * XXX more XXX  *  * MP:  * \li	The module ensures appropriate synchronization of data structures it  *	creates and manipulates.  *  * Reliability:  * \li	No anticipated impact.  *  * Resources:  * \li	TBS  *  * Security:  * \li	No anticipated impact.  *  * Standards:  * \li	None.  */
end_comment

begin_comment
comment|/*****  ***** Imports  *****/
end_comment

begin_include
include|#
directive|include
file|<isc/lang.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/ondestroy.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdtime.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rpz.h>
end_include

begin_include
include|#
directive|include
file|<dns/types.h>
end_include

begin_macro
name|ISC_LANG_BEGINDECLS
end_macro

begin_comment
comment|/*****  ***** Types  *****/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dns_dbmethods
block|{
name|void
function_decl|(
modifier|*
name|attach
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|source
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|detach
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|beginload
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_addrdatasetfunc_t
modifier|*
name|addp
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|endload
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|dump
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|dns_masterformat_t
name|masterformat
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|currentversion
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|newversion
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|attachversion
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|source
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|closeversion
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
name|commit
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|findnode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|find
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|findzonecut
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|attachnode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|source
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|detachnode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|expirenode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|printnode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|createiterator
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|findrdataset
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|allrdatasets
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|addrdataset
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|subtractrdataset
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|newrdataset
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|deleterdataset
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
function_decl|;
name|isc_boolean_t
function_decl|(
modifier|*
name|issecure
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|unsigned
name|int
function_decl|(
modifier|*
name|nodecount
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|isc_boolean_t
function_decl|(
modifier|*
name|ispersistent
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|overmem
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|overmem
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|settask
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_task_t
modifier|*
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|getoriginnode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|transfernode
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|sourcep
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|getnsec3parameters
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_hash_t
modifier|*
name|hash
parameter_list|,
name|isc_uint8_t
modifier|*
name|flags
parameter_list|,
name|isc_uint16_t
modifier|*
name|iterations
parameter_list|,
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|size_t
modifier|*
name|salt_len
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|findnsec3node
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|setsigningtime
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_stdtime_t
name|resign
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|getsigningtime
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|resigned
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
function_decl|;
name|isc_boolean_t
function_decl|(
modifier|*
name|isdnssec
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|dns_stats_t
modifier|*
function_decl|(
modifier|*
name|getrrsetstats
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|rpz_enabled
function_decl|)
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|rpz_findips
function_decl|)
parameter_list|(
name|dns_rpz_zone_t
modifier|*
name|rpz
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
function_decl|;
block|}
name|dns_dbmethods_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|isc_result_t
function_decl|(
modifier|*
name|dns_dbcreatefunc_t
function_decl|)
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbtype_t
name|type
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|DNS_DB_MAGIC
value|ISC_MAGIC('D','N','S','D')
end_define

begin_define
define|#
directive|define
name|DNS_DB_VALID
parameter_list|(
name|db
parameter_list|)
value|ISC_MAGIC_VALID(db, DNS_DB_MAGIC)
end_define

begin_comment
comment|/*%  * This structure is actually just the common prefix of a DNS db  * implementation's version of a dns_db_t.  * \brief  * Direct use of this structure by clients is forbidden.  DB implementations  * may change the structure.  'magic' must be DNS_DB_MAGIC for any of the  * dns_db_ routines to work.  DB implementations must maintain all DB  * invariants.  */
end_comment

begin_struct
struct|struct
name|dns_db
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|impmagic
decl_stmt|;
name|dns_dbmethods_t
modifier|*
name|methods
decl_stmt|;
name|isc_uint16_t
name|attributes
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_name_t
name|origin
decl_stmt|;
name|isc_ondestroy_t
name|ondest
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_DBATTR_CACHE
value|0x01
end_define

begin_define
define|#
directive|define
name|DNS_DBATTR_STUB
value|0x02
end_define

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Options that can be specified for dns_db_find().  */
end_comment

begin_define
define|#
directive|define
name|DNS_DBFIND_GLUEOK
value|0x0001
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_VALIDATEGLUE
value|0x0002
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_NOWILD
value|0x0004
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_PENDINGOK
value|0x0008
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_NOEXACT
value|0x0010
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_FORCENSEC
value|0x0020
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_COVERINGNSEC
value|0x0040
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_FORCENSEC3
value|0x0080
end_define

begin_define
define|#
directive|define
name|DNS_DBFIND_ADDITIONALOK
value|0x0100
end_define

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Options that can be specified for dns_db_addrdataset().  */
end_comment

begin_define
define|#
directive|define
name|DNS_DBADD_MERGE
value|0x01
end_define

begin_define
define|#
directive|define
name|DNS_DBADD_FORCE
value|0x02
end_define

begin_define
define|#
directive|define
name|DNS_DBADD_EXACT
value|0x04
end_define

begin_define
define|#
directive|define
name|DNS_DBADD_EXACTTTL
value|0x08
end_define

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*%  * Options that can be specified for dns_db_subtractrdataset().  */
end_comment

begin_define
define|#
directive|define
name|DNS_DBSUB_EXACT
value|0x01
end_define

begin_comment
comment|/*@{*/
end_comment

begin_comment
comment|/*%  * Iterator options  */
end_comment

begin_define
define|#
directive|define
name|DNS_DB_RELATIVENAMES
value|0x1
end_define

begin_define
define|#
directive|define
name|DNS_DB_NSEC3ONLY
value|0x2
end_define

begin_define
define|#
directive|define
name|DNS_DB_NONSEC3
value|0x4
end_define

begin_comment
comment|/*@}*/
end_comment

begin_comment
comment|/*****  ***** Methods  *****/
end_comment

begin_comment
comment|/***  *** Basic DB Methods  ***/
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
specifier|const
name|char
modifier|*
name|db_type
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_dbtype_t
name|type
parameter_list|,
name|dns_rdataclass_t
name|rdclass
parameter_list|,
name|unsigned
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Create a new database using implementation 'db_type'.  *  * Notes:  * \li	All names in the database must be subdomains of 'origin' and in class  *	'rdclass'.  The database makes its own copy of the origin, so the  *	caller may do whatever they like with 'origin' and its storage once the  *	call returns.  *  * \li	DB implementation-specific parameters are passed using argc and argv.  *  * Requires:  *  * \li	dbp != NULL and *dbp == NULL  *  * \li	'origin' is a valid absolute domain name.  *  * \li	mctx is a valid memory context  *  * Ensures:  *  * \li	A copy of 'origin' has been made for the databases use, and the  *	caller is free to do whatever they want with the name and storage  *	associated with 'origin'.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  * \li	#ISC_R_NOTFOUND				db_type not found  *  * \li	Many other errors are possible, depending on what db_type was  *	specified.  */
end_comment

begin_function_decl
name|void
name|dns_db_attach
parameter_list|(
name|dns_db_t
modifier|*
name|source
parameter_list|,
name|dns_db_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Attach *targetp to source.  *  * Requires:  *  * \li	'source' is a valid database.  *  * \li	'targetp' points to a NULL dns_db_t *.  *  * Ensures:  *  * \li	*targetp is attached to source.  */
end_comment

begin_function_decl
name|void
name|dns_db_detach
parameter_list|(
name|dns_db_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Detach *dbp from its database.  *  * Requires:  *  * \li	'dbp' points to a valid database.  *  * Ensures:  *  * \li	*dbp is NULL.  *  * \li	If '*dbp' is the last reference to the database,  *		all resources used by the database will be freed  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_ondestroy
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
modifier|*
name|eventp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Causes 'eventp' to be sent to be sent to 'task' when the database is  * destroyed.  *  * Note; ownership of the eventp is taken from the caller (and *eventp is  * set to NULL). The sender field of the event is set to 'db' before it is  * sent to the task.  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_iscache
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Does 'db' have cache semantics?  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  * \li	#ISC_TRUE	'db' has cache semantics  * \li	#ISC_FALSE	otherwise  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_iszone
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Does 'db' have zone semantics?  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  * \li	#ISC_TRUE	'db' has zone semantics  * \li	#ISC_FALSE	otherwise  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_isstub
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Does 'db' have stub semantics?  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  * \li	#ISC_TRUE	'db' has zone semantics  * \li	#ISC_FALSE	otherwise  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_issecure
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Is 'db' secure?  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * Returns:  * \li	#ISC_TRUE	'db' is secure.  * \li	#ISC_FALSE	'db' is not secure.  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_isdnssec
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Is 'db' secure or partially secure?  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * Returns:  * \li	#ISC_TRUE	'db' is secure or is partially.  * \li	#ISC_FALSE	'db' is not secure.  */
end_comment

begin_function_decl
name|dns_name_t
modifier|*
name|dns_db_origin
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * The origin of the database.  *  * Note: caller must not try to change this name.  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  *  * \li	The origin of the database.  */
end_comment

begin_function_decl
name|dns_rdataclass_t
name|dns_db_class
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * The class of the database.  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  *  * \li	The class of the database.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_beginload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_addrdatasetfunc_t
modifier|*
name|addp
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Begin loading 'db'.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	This is the first attempt to load 'db'.  *  * \li	addp != NULL&& *addp == NULL  *  * \li	dbloadp != NULL&& *dbloadp == NULL  *  * Ensures:  *  * \li	On success, *addp will be a valid dns_addrdatasetfunc_t suitable  *	for loading 'db'.  *dbloadp will be a valid DB load context which  *	should be used as 'arg' when *addp is called.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  *  * \li	Other results are possible, depending upon the database  *	implementation used, syntax errors in the master file, etc.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_endload
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbload_t
modifier|*
modifier|*
name|dbloadp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Finish loading 'db'.  *  * Requires:  *  * \li	'db' is a valid database that is being loaded.  *  * \li	dbloadp != NULL and *dbloadp is a valid database load context.  *  * Ensures:  *  * \li	*dbloadp == NULL  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  *  * \li	Other results are possible, depending upon the database  *	implementation used, syntax errors in the master file, etc.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_load
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|dns_db_load2
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|dns_db_load3
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Load master file 'filename' into 'db'.  *  * Notes:  * \li	This routine is equivalent to calling  *  *\code  *		dns_db_beginload();  *		dns_master_loadfile();  *		dns_db_endload();  *\endcode  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	This is the first attempt to load 'db'.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  *  * \li	Other results are possible, depending upon the database  *	implementation used, syntax errors in the master file, etc.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_dump
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|isc_result_t
name|dns_db_dump2
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|dns_masterformat_t
name|masterformat
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Dump version 'version' of 'db' to master file 'filename'.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'version' is a valid version.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  *  * \li	Other results are possible, depending upon the database  *	implementation used, OS file errors, etc.  */
end_comment

begin_comment
comment|/***  *** Version Methods  ***/
end_comment

begin_function_decl
name|void
name|dns_db_currentversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Open the current version for reading.  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * \li	versionp != NULL&& *verisonp == NULL  *  * Ensures:  *  * \li	On success, '*versionp' is attached to the current version.  *  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_newversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Open a new version for reading and writing.  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * \li	versionp != NULL&& *verisonp == NULL  *  * Ensures:  *  * \li	On success, '*versionp' is attached to the current version.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|void
name|dns_db_attachversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|source
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Attach '*targetp' to 'source'.  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * \li	source is a valid open version  *  * \li	targetp != NULL&& *targetp == NULL  *  * Ensures:  *  * \li	'*targetp' is attached to source.  */
end_comment

begin_function_decl
name|void
name|dns_db_closeversion
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
modifier|*
name|versionp
parameter_list|,
name|isc_boolean_t
name|commit
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Close version '*versionp'.  *  * Note: if '*versionp' is a read-write version and 'commit' is ISC_TRUE,  * then all changes made in the version will take effect, otherwise they  * will be rolled back.  The value of 'commit' is ignored for read-only  * versions.  *  * Requires:  *  * \li	'db' is a valid database with zone semantics.  *  * \li	'*versionp' refers to a valid version.  *  * \li	If committing a writable version, then there must be no other  *	outstanding references to the version (e.g. an active rdataset  *	iterator).  *  * Ensures:  *  * \li	*versionp == NULL  *  * \li	If *versionp is a read-write version, and commit is ISC_TRUE, then  *	the version will become the current version.  If !commit, then all  *	changes made in the version will be undone, and the version will  *	not become the current version.  */
end_comment

begin_comment
comment|/***  *** Node Methods  ***/
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_findnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Find the node with name 'name'.  *  * Notes:  * \li	If 'create' is ISC_TRUE and no node with name 'name' exists, then  *	such a node will be created.  *  * \li	This routine is for finding or creating a node with the specified  *	name.  There are no partial matches.  It is not suitable for use  *	in building responses to ordinary DNS queries; clients which wish  *	to do that should use dns_db_find() instead.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'name' is a valid, non-empty, absolute name.  *  * \li	nodep != NULL&& *nodep == NULL  *  * Ensures:  *  * \li	On success, *nodep is attached to the node with name 'name'.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND			If !create and name not found.  * \li	#ISC_R_NOMEMORY			Can only happen if create is ISC_TRUE.  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_find
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Find the best match for 'name' and 'type' in version 'version' of 'db'.  *  * Notes:  *  * \li	If type == dns_rdataset_any, then rdataset will not be bound.  *  * \li	If 'options' does not have #DNS_DBFIND_GLUEOK set, then no glue will  *	be returned.  For zone databases, glue is as defined in RFC2181.  *	For cache databases, glue is any rdataset with a trust of  *	dns_trust_glue.  *  * \li	If 'options' does not have #DNS_DBFIND_ADDITIONALOK set, then no  *	additional records will be returned.  Only caches can have  *	rdataset with trust dns_trust_additional.  *  * \li	If 'options' does not have #DNS_DBFIND_PENDINGOK set, then no  *	pending data will be returned.  This option is only meaningful for  *	cache databases.  *  * \li	If the #DNS_DBFIND_NOWILD option is set, then wildcard matching will  *	be disabled.  This option is only meaningful for zone databases.  *  * \li	If the #DNS_DBFIND_FORCENSEC option is set, the database is assumed to  *	have NSEC records, and these will be returned when appropriate.  This  *	is only necessary when querying a database that was not secure  *	when created.  *  * \li	If the DNS_DBFIND_COVERINGNSEC option is set, then look for a  *	NSEC record that potentially covers 'name' if a answer cannot  *	be found.  Note the returned NSEC needs to be checked to ensure  *	that it is correct.  This only affects answers returned from the  *	cache.  *  * \li	To respond to a query for SIG records, the caller should create a  *	rdataset iterator and extract the signatures from each rdataset.  *  * \li	Making queries of type ANY with #DNS_DBFIND_GLUEOK is not recommended,  *	because the burden of determining whether a given rdataset is valid  *	glue or not falls upon the caller.  *  * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a  *	cache database, an rdataset will not be found unless it expires after  *	'now'.  Any ANY query will not match unless at least one rdataset at  *	the node expires after 'now'.  If 'now' is zero, then the current time  *	will be used.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'type' is not SIG, or a meta-RR type other than 'ANY' (e.g. 'OPT').  *  * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.  *  * \li	'foundname' is a valid name with a dedicated buffer.  *  * \li	'rdataset' is NULL, or is a valid unassociated rdataset.  *  * Ensures,  *	on a non-error completion:  *  *	\li	If nodep != NULL, then it is bound to the found node.  *  *	\li	If foundname != NULL, then it contains the full name of the  *		found node.  *  *	\li	If rdataset != NULL and type != dns_rdatatype_any, then  *		rdataset is bound to the found rdataset.  *  *	Non-error results are:  *  *	\li	#ISC_R_SUCCESS			The desired node and type were  *						found.  *  *	\li	#DNS_R_WILDCARD			The desired node and type were  *						found after performing  *						wildcard matching.  This is  *						only returned if the  *						#DNS_DBFIND_INDICATEWILD  *						option is set; otherwise  *						#ISC_R_SUCCESS is returned.  *  *	\li	#DNS_R_GLUE			The desired node and type were  *						found, but are glue.  This  *						result can only occur if  *						the DNS_DBFIND_GLUEOK option  *						is set.  This result can only  *						occur if 'db' is a zone  *						database.  If type ==  *						dns_rdatatype_any, then the  *						node returned may contain, or  *						consist entirely of invalid  *						glue (i.e. data occluded by a  *						zone cut).  The caller must  *						take care not to return invalid  *						glue to a client.  *  *	\li	#DNS_R_DELEGATION		The data requested is beneath  *						a zone cut.  node, foundname,  *						and rdataset reference the  *						NS RRset of the zone cut.  *						If 'db' is a cache database,  *						then this is the deepest known  *						delegation.  *  *	\li	#DNS_R_ZONECUT			type == dns_rdatatype_any, and  *						the desired node is a zonecut.  *						The caller must take care not  *						to return inappropriate glue  *						to a client.  This result can  *						only occur if 'db' is a zone  *						database and DNS_DBFIND_GLUEOK  *						is set.  *  *	\li	#DNS_R_DNAME			The data requested is beneath  *						a DNAME.  node, foundname,  *						and rdataset reference the  *						DNAME RRset.  *  *	\li	#DNS_R_CNAME			The rdataset requested was not  *						found, but there is a CNAME  *						at the desired name.  node,  *						foundname, and rdataset  *						reference the CNAME RRset.  *  *	\li	#DNS_R_NXDOMAIN			The desired name does not  *						exist.  *  *	\li	#DNS_R_NXRRSET			The desired name exists, but  *						the desired type does not.  *  *	\li	#ISC_R_NOTFOUND			The desired name does not  *						exist, and no delegation could  *						be found.  This result can only  *						occur if 'db' is a cache  *						database.  The caller should  *						use its nameserver(s) of last  *						resort (e.g. root hints).  *  *	\li	#DNS_R_NCACHENXDOMAIN		The desired name does not  *						exist.  'node' is bound to the  *						cache node with the desired  *						name, and 'rdataset' contains  *						the negative caching proof.  *  *	\li	#DNS_R_NCACHENXRRSET		The desired type does not  *						exist.  'node' is bound to the  *						cache node with the desired  *						name, and 'rdataset' contains  *						the negative caching proof.  *  *	\li	#DNS_R_EMPTYNAME		The name exists but there is  *						no data at the name.  *  *	\li	#DNS_R_COVERINGNSEC		The returned data is a NSEC  *						that potentially covers 'name'.  *  *	\li	#DNS_R_EMPTYWILD		The name is a wildcard without  *						resource records.  *  *	Error results:  *  *	\li	#ISC_R_NOMEMORY  *  *	\li	#DNS_R_BADDB			Data that is required to be  *						present in the DB, e.g. an NSEC  *						record in a secure zone, is not  *						present.  *  *	\li	Other results are possible, and should all be treated as  *		errors.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_findzonecut
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|,
name|dns_name_t
modifier|*
name|foundname
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Find the deepest known zonecut which encloses 'name' in 'db'.  *  * Notes:  *  * \li	If the #DNS_DBFIND_NOEXACT option is set, then the zonecut returned  *	(if any) will be the deepest known ancestor of 'name'.  *  * \li	If 'now' is zero, then the current time will be used.  *  * Requires:  *  * \li	'db' is a valid database with cache semantics.  *  * \li	'nodep' is NULL, or nodep is a valid pointer and *nodep == NULL.  *  * \li	'foundname' is a valid name with a dedicated buffer.  *  * \li	'rdataset' is NULL, or is a valid unassociated rdataset.  *  * Ensures, on a non-error completion:  *  * \li	If nodep != NULL, then it is bound to the found node.  *  * \li	If foundname != NULL, then it contains the full name of the  *	found node.  *  * \li	If rdataset != NULL and type != dns_rdatatype_any, then  *	rdataset is bound to the found rdataset.  *  * Non-error results are:  *  * \li	#ISC_R_SUCCESS  *  * \li	#ISC_R_NOTFOUND  *  * \li	Other results are possible, and should all be treated as  *	errors.  */
end_comment

begin_function_decl
name|void
name|dns_db_attachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|source
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Attach *targetp to source.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'source' is a valid node.  *  * \li	'targetp' points to a NULL dns_dbnode_t *.  *  * Ensures:  *  * \li	*targetp is attached to source.  */
end_comment

begin_function_decl
name|void
name|dns_db_detachnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Detach *nodep from its node.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'nodep' points to a valid node.  *  * Ensures:  *  * \li	*nodep is NULL.  */
end_comment

begin_function_decl
name|void
name|dns_db_transfernode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|sourcep
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|targetp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Transfer a node between pointer.  *  * This is equivalent to calling dns_db_attachnode() then dns_db_detachnode().  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'*sourcep' is a valid node.  *  * \li	'targetp' points to a NULL dns_dbnode_t *.  *  * Ensures:  *  * \li	'*sourcep' is NULL.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_expirenode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Mark as stale all records at 'node' which expire at or before 'now'.  *  * Note: if 'now' is zero, then the current time will be used.  *  * Requires:  *  * \li	'db' is a valid cache database.  *  * \li	'node' is a valid node.  */
end_comment

begin_function_decl
name|void
name|dns_db_printnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Print a textual representation of the contents of the node to  * 'out'.  *  * Note: this function is intended for debugging, not general use.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  */
end_comment

begin_comment
comment|/***  *** DB Iterator Creation  ***/
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_createiterator
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_dbiterator_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Create an iterator for version 'version' of 'db'.  *  * Notes:  *  * \li	One or more of the following options can be set.  *	#DNS_DB_RELATIVENAMES  *	#DNS_DB_NSEC3ONLY  *	#DNS_DB_NONSEC3  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	iteratorp != NULL&& *iteratorp == NULL  *  * Ensures:  *  * \li	On success, *iteratorp will be a valid database iterator.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  */
end_comment

begin_comment
comment|/***  *** Rdataset Methods  ***/
end_comment

begin_comment
comment|/*  * XXXRTH  Should we check for glue and pending data in dns_db_findrdataset()?  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_findrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_rdataset_t
modifier|*
name|sigrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Search for an rdataset of type 'type' at 'node' that are in version  * 'version' of 'db'.  If found, make 'rdataset' refer to it.  *  * Notes:  *  * \li	If 'version' is NULL, then the current version will be used.  *  * \li	Care must be used when using this routine to build a DNS response:  *	'node' should have been found with dns_db_find(), not  *	dns_db_findnode().  No glue checking is done.  No checking for  *	pending data is done.  *  * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a  *	cache database, an rdataset will not be found unless it expires after  *	'now'.  If 'now' is zero, then the current time will be used.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  *  * \li	'rdataset' is a valid, disassociated rdataset.  *  * \li	'sigrdataset' is a valid, disassociated rdataset, or it is NULL.  *  * \li	If 'covers' != 0, 'type' must be SIG.  *  * \li	'type' is not a meta-RR type such as 'ANY' or 'OPT'.  *  * Ensures:  *  * \li	On success, 'rdataset' is associated with the found rdataset.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_allrdatasets
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdatasetiter_t
modifier|*
modifier|*
name|iteratorp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Make '*iteratorp' an rdataset iterator for all rdatasets at 'node' in  * version 'version' of 'db'.  *  * Notes:  *  * \li	If 'version' is NULL, then the current version will be used.  *  * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is a  *	cache database, an rdataset will not be found unless it expires after  *	'now'.  Any ANY query will not match unless at least one rdataset at  *	the node expires after 'now'.  If 'now' is zero, then the current time  *	will be used.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  *  * \li	iteratorp != NULL&& *iteratorp == NULL  *  * Ensures:  *  * \li	On success, '*iteratorp' is a valid rdataset iterator.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_addrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|isc_stdtime_t
name|now
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|addedrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Add 'rdataset' to 'node' in version 'version' of 'db'.  *  * Notes:  *  * \li	If the database has zone semantics, the #DNS_DBADD_MERGE option is set,  *	and an rdataset of the same type as 'rdataset' already exists at  *	'node' then the contents of 'rdataset' will be merged with the existing  *	rdataset.  If the option is not set, then rdataset will replace any  *	existing rdataset of the same type.  If not merging and the  *	#DNS_DBADD_FORCE option is set, then the data will update the database  *	without regard to trust levels.  If not forcing the data, then the  *	rdataset will only be added if its trust level is>= the trust level of  *	any existing rdataset.  Forcing is only meaningful for cache databases.  *	If #DNS_DBADD_EXACT is set then there must be no rdata in common between  *	the old and new rdata sets.  If #DNS_DBADD_EXACTTTL is set then both  *	the old and new rdata sets must have the same ttl.  *  * \li	The 'now' field is ignored if 'db' is a zone database.  If 'db' is  *	a cache database, then the added rdataset will expire no later than  *	now + rdataset->ttl.  *  * \li	If 'addedrdataset' is not NULL, then it will be attached to the  *	resulting new rdataset in the database, or to the existing data if  *	the existing data was better.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  *  * \li	'rdataset' is a valid, associated rdataset with the same class  *	as 'db'.  *  * \li	'addedrdataset' is NULL, or a valid, unassociated rdataset.  *  * \li	The database has zone semantics and 'version' is a valid  *	read-write version, or the database has cache semantics  *	and version is NULL.  *  * \li	If the database has cache semantics, the #DNS_DBADD_MERGE option must  *	not be set.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#DNS_R_UNCHANGED			The operation did not change anything.  * \li	#ISC_R_NOMEMORY  * \li	#DNS_R_NOTEXACT  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_subtractrdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdataset_t
modifier|*
name|newrdataset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Remove any rdata in 'rdataset' from 'node' in version 'version' of  * 'db'.  *  * Notes:  *  * \li	If 'newrdataset' is not NULL, then it will be attached to the  *	resulting new rdataset in the database, unless the rdataset has  *	become nonexistent.  If DNS_DBSUB_EXACT is set then all elements  *	of 'rdataset' must exist at 'node'.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  *  * \li	'rdataset' is a valid, associated rdataset with the same class  *	as 'db'.  *  * \li	'newrdataset' is NULL, or a valid, unassociated rdataset.  *  * \li	The database has zone semantics and 'version' is a valid  *	read-write version.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#DNS_R_UNCHANGED			The operation did not change anything.  * \li	#DNS_R_NXRRSET			All rdata of the same type as those  *					in 'rdataset' have been deleted.  * \li	#DNS_R_NOTEXACT			Some part of 'rdataset' did not  *					exist and DNS_DBSUB_EXACT was set.  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_deleterdataset
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
name|node
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdatatype_t
name|type
parameter_list|,
name|dns_rdatatype_t
name|covers
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Make it so that no rdataset of type 'type' exists at 'node' in version  * version 'version' of 'db'.  *  * Notes:  *  * \li	If 'type' is dns_rdatatype_any, then no rdatasets will exist in  *	'version' (provided that the dns_db_deleterdataset() isn't followed  *	by one or more dns_db_addrdataset() calls).  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'node' is a valid node.  *  * \li	The database has zone semantics and 'version' is a valid  *	read-write version, or the database has cache semantics  *	and version is NULL.  *  * \li	'type' is not a meta-RR type, except for dns_rdatatype_any, which is  *	allowed.  *  * \li	If 'covers' != 0, 'type' must be SIG.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#DNS_R_UNCHANGED			No rdatasets of 'type' existed before  *					the operation was attempted.  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_getsoaserial
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|ver
parameter_list|,
name|isc_uint32_t
modifier|*
name|serialp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Get the current SOA serial number from a zone database.  *  * Requires:  * \li	'db' is a valid database with zone semantics.  * \li	'ver' is a valid version.  */
end_comment

begin_function_decl
name|void
name|dns_db_overmem
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_boolean_t
name|overmem
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Enable / disable aggressive cache cleaning.  */
end_comment

begin_function_decl
name|unsigned
name|int
name|dns_db_nodecount
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Count the number of nodes in 'db'.  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  * \li	The number of nodes in the database  */
end_comment

begin_function_decl
name|void
name|dns_db_settask
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * If task is set then the final detach maybe performed asynchronously.  *  * Requires:  * \li	'db' is a valid database.  * \li	'task' to be valid or NULL.  */
end_comment

begin_function_decl
name|isc_boolean_t
name|dns_db_ispersistent
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Is 'db' persistent?  A persistent database does not need to be loaded  * from disk or written to disk.  *  * Requires:  *  * \li	'db' is a valid database.  *  * Returns:  * \li	#ISC_TRUE	'db' is persistent.  * \li	#ISC_FALSE	'db' is not persistent.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dns_dbcreatefunc_t
name|create
parameter_list|,
name|void
modifier|*
name|driverarg
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_dbimplementation_t
modifier|*
modifier|*
name|dbimp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Register a new database implementation and add it to the list of  * supported implementations.  *  * Requires:  *  * \li 	'name' is not NULL  * \li	'order' is a valid function pointer  * \li	'mctx' is a valid memory context  * \li	dbimp != NULL&& *dbimp == NULL  *  * Returns:  * \li	#ISC_R_SUCCESS	The registration succeeded  * \li	#ISC_R_NOMEMORY	Out of memory  * \li	#ISC_R_EXISTS	A database implementation with the same name exists  *  * Ensures:  *  * \li	*dbimp points to an opaque structure which must be passed to  *	dns_db_unregister().  */
end_comment

begin_function_decl
name|void
name|dns_db_unregister
parameter_list|(
name|dns_dbimplementation_t
modifier|*
modifier|*
name|dbimp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Remove a database implementation from the list of supported  * implementations.  No databases of this type can be active when this  * is called.  *  * Requires:  * \li 	dbimp != NULL&& *dbimp == NULL  *  * Ensures:  *  * \li	Any memory allocated in *dbimp will be freed.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_getoriginnode
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Get the origin DB node corresponding to the DB's zone.  This function  * should typically succeed unless the underlying DB implementation doesn't  * support the feature.  *  * Requires:  *  * \li	'db' is a valid zone database.  * \li	'nodep' != NULL&& '*nodep' == NULL  *  * Ensures:  * \li	On success, '*nodep' will point to the DB node of the zone's origin.  *  * Returns:  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_getnsec3parameters
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_hash_t
modifier|*
name|hash
parameter_list|,
name|isc_uint8_t
modifier|*
name|flags
parameter_list|,
name|isc_uint16_t
modifier|*
name|interations
parameter_list|,
name|unsigned
name|char
modifier|*
name|salt
parameter_list|,
name|size_t
modifier|*
name|salt_length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Get the NSEC3 parameters that are associated with this zone.  *  * Requires:  * \li	'db' is a valid zone database.  *  * Returns:  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND - the DB implementation does not support this feature  *			  or this zone does not have NSEC3 records.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_findnsec3node
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_dbnode_t
modifier|*
modifier|*
name|nodep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Find the NSEC3 node with name 'name'.  *  * Notes:  * \li	If 'create' is ISC_TRUE and no node with name 'name' exists, then  *	such a node will be created.  *  * Requires:  *  * \li	'db' is a valid database.  *  * \li	'name' is a valid, non-empty, absolute name.  *  * \li	nodep != NULL&& *nodep == NULL  *  * Ensures:  *  * \li	On success, *nodep is attached to the node with name 'name'.  *  * Returns:  *  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND			If !create and name not found.  * \li	#ISC_R_NOMEMORY			Can only happen if create is ISC_TRUE.  *  * \li	Other results are possible, depending upon the database  *	implementation used.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_setsigningtime
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|isc_stdtime_t
name|resign
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Sets the re-signing time associated with 'rdataset' to 'resign'.  *  * Requires:  * \li	'db' is a valid zone database.  * \li	'rdataset' to be associated with 'db'.  *  * Returns:  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOMEMORY  * \li	#ISC_R_NOTIMPLEMENTED - Not supported by this DB implementation.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_getsigningtime
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Return the rdataset with the earliest signing time in the zone.  * Note: the rdataset is version agnostic.  *  * Requires:  * \li	'db' is a valid zone database.  * \li	'rdataset' to be initialized but not associated.  * \li	'name' to be NULL or have a buffer associated with it.  *  * Returns:  * \li	#ISC_R_SUCCESS  * \li	#ISC_R_NOTFOUND - No dataset exists.  */
end_comment

begin_function_decl
name|void
name|dns_db_resigned
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Mark 'rdataset' as not being available to be returned by  * dns_db_getsigningtime().  If the changes associated with 'version'  * are committed this will be permanent.  If the version is not committed  * this change will be rolled back when the version is closed.  *  * Requires:  * \li	'db' is a valid zone database.  * \li	'rdataset' to be associated with 'db'.  * \li	'version' to be open for writing.  */
end_comment

begin_function_decl
name|dns_stats_t
modifier|*
name|dns_db_getrrsetstats
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Get statistics information counting RRsets stored in the DB, when available.  * The statistics may not be available depending on the DB implementation.  *  * Requires:  *  * \li	'db' is a valid database (zone or cache).  *  * Returns:  * \li	when available, a pointer to a statistics object created by  *	dns_rdatasetstats_create(); otherwise NULL.  */
end_comment

begin_function_decl
name|void
name|dns_db_rpz_enabled
parameter_list|(
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * See if a policy database has DNS_RPZ_TYPE_IP, DNS_RPZ_TYPE_NSIP, or  * DNS_RPZ_TYPE_NSDNAME records.  */
end_comment

begin_function_decl
name|isc_result_t
name|dns_db_rpz_findips
parameter_list|(
name|dns_rpz_zone_t
modifier|*
name|rpz
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|,
name|dns_zone_t
modifier|*
name|zone
parameter_list|,
name|dns_db_t
modifier|*
name|db
parameter_list|,
name|dns_dbversion_t
modifier|*
name|version
parameter_list|,
name|dns_rdataset_t
modifier|*
name|ardataset
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*%<  * Search the CDIR block tree of a response policy tree of trees for the best  * match to any of the IP addresses in an A or AAAA rdataset.  *  * Requires:  * \li	search in policy zone 'rpz' for a match of 'rpz_type' either  *	    DNS_RPZ_TYPE_IP or DNS_RPZ_TYPE_NSIP  * \li	'zone' and 'db' are the database corresponding to 'rpz'  * \li	'version' is the required version of the database  * \li	'ardataset' is an A or AAAA rdataset of addresses to check  * \li	'found' specifies the previous best match if any or  *	    or NULL, an empty name, 0, DNS_RPZ_POLICY_MISS, and 0  */
end_comment

begin_macro
name|ISC_LANG_ENDDECLS
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNS_DB_H */
end_comment

end_unit

