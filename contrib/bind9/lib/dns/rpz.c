begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2011-2014  Internet Systems Consortium, Inc. ("ISC")  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/db.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/rpz.h>
end_include

begin_include
include|#
directive|include
file|<dns/view.h>
end_include

begin_comment
comment|/*  * Parallel radix trees for databases of response policy IP addresses  *  * The radix or Patricia trees are somewhat specialized to handle response  * policy addresses by representing the two test of IP IP addresses and name  * server IP addresses in a single tree.  *  * Each leaf indicates that an IP address is listed in the IP address or the  * name server IP address policy sub-zone (or both) of the corresponding  * response response zone.  The policy data such as a CNAME or an A record  * is kept in the policy zone.  After an IP address has been found in a radix  * tree, the node in the policy zone's database is found by converting  * the IP address to a domain name in a canonical form.  *  * The response policy zone canonical form of IPv6 addresses is one of:  *	prefix.W.W.W.W.W.W.W.W  *	prefix.WORDS.zz  *	prefix.WORDS.zz.WORDS  *	prefix.zz.WORDS  *  where  *	prefix	is the prefix length of the IPv6 address between 1 and 128  *	W	is a number between 0 and 65535  *	WORDS	is one or more numbers W separated with "."  *	zz	corresponds to :: in the standard IPv6 text representation  *  * The canonical form of IPv4 addresses is:  *	prefix.B.B.B.B  *  where  *	prefix	is the prefix length of the address between 1 and 32  *	B	is a number between 0 and 255  *  * IPv4 addresses are distinguished from IPv6 addresses by having  * 5 labels all of which are numbers, and a prefix between 1 and 32.  */
end_comment

begin_comment
comment|/*  * Use a private definition of IPv6 addresses because s6_addr32 is not  * always defined and our IPv6 addresses are in non-standard byte order  */
end_comment

begin_typedef
typedef|typedef
name|isc_uint32_t
name|dns_rpz_cidr_word_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DNS_RPZ_CIDR_WORD_BITS
value|((int)sizeof(dns_rpz_cidr_word_t)*8)
end_define

begin_define
define|#
directive|define
name|DNS_RPZ_CIDR_KEY_BITS
value|((int)sizeof(dns_rpz_cidr_key_t)*8)
end_define

begin_define
define|#
directive|define
name|DNS_RPZ_CIDR_WORDS
value|(128/DNS_RPZ_CIDR_WORD_BITS)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|dns_rpz_cidr_word_t
name|w
index|[
name|DNS_RPZ_CIDR_WORDS
index|]
decl_stmt|;
block|}
name|dns_rpz_cidr_key_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ADDR_V4MAPPED
value|0xffff
end_define

begin_define
define|#
directive|define
name|DNS_RPZ_WORD_MASK
parameter_list|(
name|b
parameter_list|)
define|\
value|((b) == 0 ? (dns_rpz_cidr_word_t)(-1)		\ 		  : ((dns_rpz_cidr_word_t)(-1)		\<< (DNS_RPZ_CIDR_WORD_BITS - (b))))
end_define

begin_define
define|#
directive|define
name|DNS_RPZ_IP_BIT
parameter_list|(
name|ip
parameter_list|,
name|bitno
parameter_list|)
define|\
value|(1& ((ip)->w[(bitno)/DNS_RPZ_CIDR_WORD_BITS]>> \ 	    (DNS_RPZ_CIDR_WORD_BITS - 1 - ((bitno) % DNS_RPZ_CIDR_WORD_BITS))))
end_define

begin_typedef
typedef|typedef
name|struct
name|dns_rpz_cidr_node
name|dns_rpz_cidr_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|isc_uint8_t
name|dns_rpz_cidr_flags_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_rpz_cidr_node
block|{
name|dns_rpz_cidr_node_t
modifier|*
name|parent
decl_stmt|;
name|dns_rpz_cidr_node_t
modifier|*
name|child
index|[
literal|2
index|]
decl_stmt|;
name|dns_rpz_cidr_key_t
name|ip
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|bits
decl_stmt|;
name|dns_rpz_cidr_flags_t
name|flags
decl_stmt|;
define|#
directive|define
name|DNS_RPZ_CIDR_FG_IP
value|0x01
comment|/* has IP data or is parent of IP */
define|#
directive|define
name|DNS_RPZ_CIDR_FG_IP_DATA
value|0x02
comment|/* has IP data */
define|#
directive|define
name|DNS_RPZ_CIDR_FG_NSIPv4
value|0x04
comment|/* has or is parent of NSIPv4 data */
define|#
directive|define
name|DNS_RPZ_CIDR_FG_NSIPv6
value|0x08
comment|/* has or is parent of NSIPv6 data */
define|#
directive|define
name|DNS_RPZ_CIDR_FG_NSIP_DATA
value|0x10
comment|/* has NSIP data */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_rpz_cidr
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_boolean_t
name|have_nsdname
decl_stmt|;
comment|/* zone has NSDNAME record */
name|dns_rpz_cidr_node_t
modifier|*
name|root
decl_stmt|;
name|dns_name_t
name|ip_name
decl_stmt|;
comment|/* RPZ_IP_ZONE.origin. */
name|dns_name_t
name|nsip_name
decl_stmt|;
comment|/* RPZ_NSIP_ZONE.origin. */
name|dns_name_t
name|nsdname_name
decl_stmt|;
comment|/* RPZ_NSDNAME_ZONE.origin */
block|}
struct|;
end_struct

begin_function
specifier|const
name|char
modifier|*
name|dns_rpz_type2str
parameter_list|(
name|dns_rpz_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNS_RPZ_TYPE_QNAME
case|:
return|return
operator|(
literal|"QNAME"
operator|)
return|;
case|case
name|DNS_RPZ_TYPE_IP
case|:
return|return
operator|(
literal|"IP"
operator|)
return|;
case|case
name|DNS_RPZ_TYPE_NSIP
case|:
return|return
operator|(
literal|"NSIP"
operator|)
return|;
case|case
name|DNS_RPZ_TYPE_NSDNAME
case|:
return|return
operator|(
literal|"NSDNAME"
operator|)
return|;
case|case
name|DNS_RPZ_TYPE_BAD
case|:
break|break;
block|}
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"impossible rpz type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"impossible"
operator|)
return|;
block|}
end_function

begin_function
name|dns_rpz_policy_t
name|dns_rpz_str2policy
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_ERROR
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"given"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_GIVEN
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"disabled"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_DISABLED
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"passthru"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_PASSTHRU
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"nxdomain"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_NXDOMAIN
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"nodata"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_NODATA
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"cname"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_CNAME
operator|)
return|;
comment|/* 	 * Obsolete 	 */
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"no-op"
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_PASSTHRU
operator|)
return|;
return|return
operator|(
name|DNS_RPZ_POLICY_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|dns_rpz_policy2str
parameter_list|(
name|dns_rpz_policy_t
name|policy
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|policy
condition|)
block|{
case|case
name|DNS_RPZ_POLICY_PASSTHRU
case|:
name|str
operator|=
literal|"PASSTHRU"
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_NXDOMAIN
case|:
name|str
operator|=
literal|"NXDOMAIN"
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_NODATA
case|:
name|str
operator|=
literal|"NODATA"
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_RECORD
case|:
name|str
operator|=
literal|"Local-Data"
expr_stmt|;
break|break;
case|case
name|DNS_RPZ_POLICY_CNAME
case|:
case|case
name|DNS_RPZ_POLICY_WILDCNAME
case|:
name|str
operator|=
literal|"CNAME"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
literal|""
expr_stmt|;
name|POST
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the radix tree of a response policy database.  */
end_comment

begin_function
name|void
name|dns_rpz_cidr_free
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
modifier|*
name|cidrp
parameter_list|)
block|{
name|dns_rpz_cidr_node_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|dns_rpz_cidr_t
modifier|*
name|cidr
decl_stmt|;
name|REQUIRE
argument_list|(
name|cidrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cidr
operator|=
operator|*
name|cidrp
expr_stmt|;
if|if
condition|(
name|cidr
operator|==
name|NULL
condition|)
return|return;
name|cur
operator|=
name|cidr
operator|->
name|root
expr_stmt|;
while|while
condition|(
name|cur
operator|!=
name|NULL
condition|)
block|{
comment|/* Depth first. */
name|child
operator|=
name|cur
operator|->
name|child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|=
name|child
expr_stmt|;
continue|continue;
block|}
name|child
operator|=
name|cur
operator|->
name|child
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|=
name|child
expr_stmt|;
continue|continue;
block|}
comment|/* Delete this leaf and go up. */
name|parent
operator|=
name|cur
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|cidr
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
else|else
name|parent
operator|->
name|child
index|[
name|parent
operator|->
name|child
index|[
literal|1
index|]
operator|==
name|cur
index|]
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|cidr
operator|->
name|mctx
argument_list|,
name|cur
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|parent
expr_stmt|;
block|}
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|,
name|cidr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|nsip_name
argument_list|,
name|cidr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|nsdname_name
argument_list|,
name|cidr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|cidr
operator|->
name|mctx
argument_list|,
name|cidr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|cidrp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Forget a view's list of policy zones.  */
end_comment

begin_function
name|void
name|dns_rpz_view_destroy
parameter_list|(
name|dns_view_t
modifier|*
name|view
parameter_list|)
block|{
name|dns_rpz_zone_t
modifier|*
name|zone
decl_stmt|;
name|REQUIRE
argument_list|(
name|view
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|view
operator|->
name|rpz_zones
argument_list|)
condition|)
block|{
name|zone
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|view
operator|->
name|rpz_zones
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|view
operator|->
name|rpz_zones
argument_list|,
name|zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|origin
argument_list|,
name|view
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|passthru
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|passthru
argument_list|,
name|view
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|nsdname
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|nsdname
argument_list|,
name|view
operator|->
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_dynamic
argument_list|(
operator|&
name|zone
operator|->
name|cname
argument_list|)
condition|)
name|dns_name_free
argument_list|(
operator|&
name|zone
operator|->
name|cname
argument_list|,
name|view
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|view
operator|->
name|mctx
argument_list|,
name|zone
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start a new radix tree for a response policy zone.  */
end_comment

begin_function
name|isc_result_t
name|dns_rpz_new_cidr
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rpz_cidr_t
modifier|*
modifier|*
name|rbtdb_cidr
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rpz_cidr_t
modifier|*
name|cidr
decl_stmt|;
name|REQUIRE
argument_list|(
name|rbtdb_cidr
operator|!=
name|NULL
operator|&&
operator|*
name|rbtdb_cidr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cidr
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cidr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|memset
argument_list|(
name|cidr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
name|cidr
operator|->
name|mctx
operator|=
name|mctx
expr_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromstring2
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|,
name|DNS_RPZ_IP_ZONE
argument_list|,
name|origin
argument_list|,
name|DNS_NAME_DOWNCASE
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cidr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|cidr
operator|->
name|nsip_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromstring2
argument_list|(
operator|&
name|cidr
operator|->
name|nsip_name
argument_list|,
name|DNS_RPZ_NSIP_ZONE
argument_list|,
name|origin
argument_list|,
name|DNS_NAME_DOWNCASE
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cidr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|dns_name_init
argument_list|(
operator|&
name|cidr
operator|->
name|nsdname_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromstring2
argument_list|(
operator|&
name|cidr
operator|->
name|nsdname_name
argument_list|,
name|DNS_RPZ_NSDNAME_ZONE
argument_list|,
name|origin
argument_list|,
name|DNS_NAME_DOWNCASE
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|nsip_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|dns_name_free
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|cidr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cidr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|rbtdb_cidr
operator|=
name|cidr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See if a policy zone has IP, NSIP, or NSDNAME rules or records.  */
end_comment

begin_function
name|void
name|dns_rpz_enabled_get
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
name|dns_rpz_st_t
modifier|*
name|st
parameter_list|)
block|{
if|if
condition|(
name|cidr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|cidr
operator|->
name|root
operator|!=
name|NULL
operator|&&
operator|(
name|cidr
operator|->
name|root
operator|->
name|flags
operator|&
name|DNS_RPZ_CIDR_FG_IP
operator|)
operator|!=
literal|0
condition|)
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_HAVE_IP
expr_stmt|;
if|if
condition|(
name|cidr
operator|->
name|root
operator|!=
name|NULL
operator|&&
operator|(
name|cidr
operator|->
name|root
operator|->
name|flags
operator|&
name|DNS_RPZ_CIDR_FG_NSIPv4
operator|)
operator|!=
literal|0
condition|)
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_HAVE_NSIPv4
expr_stmt|;
if|if
condition|(
name|cidr
operator|->
name|root
operator|!=
name|NULL
operator|&&
operator|(
name|cidr
operator|->
name|root
operator|->
name|flags
operator|&
name|DNS_RPZ_CIDR_FG_NSIPv6
operator|)
operator|!=
literal|0
condition|)
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_HAVE_NSIPv6
expr_stmt|;
if|if
condition|(
name|cidr
operator|->
name|have_nsdname
condition|)
name|st
operator|->
name|state
operator||=
name|DNS_RPZ_HAVE_NSDNAME
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_rpz_cidr_flags_t
name|get_flags
parameter_list|(
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|ip
parameter_list|,
name|dns_rpz_cidr_bits_t
name|prefix
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|)
block|{
if|if
condition|(
name|rpz_type
operator|==
name|DNS_RPZ_TYPE_NSIP
condition|)
block|{
if|if
condition|(
name|prefix
operator|>=
literal|96
operator|&&
name|ip
operator|->
name|w
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|ip
operator|->
name|w
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|ip
operator|->
name|w
index|[
literal|2
index|]
operator|==
name|ADDR_V4MAPPED
condition|)
return|return
operator|(
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIPv4
operator|)
return|;
else|else
return|return
operator|(
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIPv6
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|DNS_RPZ_CIDR_FG_IP
operator||
name|DNS_RPZ_CIDR_FG_IP_DATA
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark a node as having IP or NSIP data and all of its parents  * as members of the IP or NSIP tree.  */
end_comment

begin_function
specifier|static
name|void
name|set_node_flags
parameter_list|(
name|dns_rpz_cidr_node_t
modifier|*
name|node
parameter_list|,
name|dns_rpz_type_t
name|rpz_type
parameter_list|)
block|{
name|dns_rpz_cidr_flags_t
name|flags
decl_stmt|;
name|flags
operator|=
name|get_flags
argument_list|(
operator|&
name|node
operator|->
name|ip
argument_list|,
name|node
operator|->
name|bits
argument_list|,
name|rpz_type
argument_list|)
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator||
name|DNS_RPZ_CIDR_FG_IP_DATA
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
name|node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|node
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make a radix tree node.  */
end_comment

begin_function
specifier|static
name|dns_rpz_cidr_node_t
modifier|*
name|new_node
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|ip
parameter_list|,
name|dns_rpz_cidr_bits_t
name|bits
parameter_list|,
name|dns_rpz_cidr_flags_t
name|flags
parameter_list|)
block|{
name|dns_rpz_cidr_node_t
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|,
name|words
decl_stmt|,
name|wlen
decl_stmt|;
name|node
operator|=
name|isc_mem_get
argument_list|(
name|cidr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|flags
operator|=
name|flags
operator|&
operator|~
operator|(
name|DNS_RPZ_CIDR_FG_IP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator|)
expr_stmt|;
name|node
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
name|words
operator|=
name|bits
operator|/
name|DNS_RPZ_CIDR_WORD_BITS
expr_stmt|;
name|wlen
operator|=
name|bits
operator|%
name|DNS_RPZ_CIDR_WORD_BITS
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|words
condition|)
block|{
name|node
operator|->
name|ip
operator|.
name|w
index|[
name|i
index|]
operator|=
name|ip
operator|->
name|w
index|[
name|i
index|]
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|wlen
operator|!=
literal|0
condition|)
block|{
name|node
operator|->
name|ip
operator|.
name|w
index|[
name|i
index|]
operator|=
name|ip
operator|->
name|w
index|[
name|i
index|]
operator|&
name|DNS_RPZ_WORD_MASK
argument_list|(
name|wlen
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|DNS_RPZ_CIDR_WORDS
condition|)
name|node
operator|->
name|ip
operator|.
name|w
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|badname
parameter_list|(
name|int
name|level
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|str1
parameter_list|,
specifier|const
name|char
modifier|*
name|str2
parameter_list|)
block|{
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
comment|/* 	 * bin/tests/system/rpz/tests.sh looks for "invalid rpz". 	 */
if|if
condition|(
name|level
operator|<
name|DNS_RPZ_DEBUG_QUIET
operator|&&
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|DNS_LOGMODULE_RBTDB
argument_list|,
name|level
argument_list|,
literal|"invalid rpz IP address \"%s\"%s%s"
argument_list|,
name|printname
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert an IP address from radix tree binary (host byte order) to  * to its canonical response policy domain name and its name in the  * policy zone.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|ip2name
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|tgt_ip
parameter_list|,
name|dns_rpz_cidr_bits_t
name|tgt_prefix
parameter_list|,
name|dns_rpz_type_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|canon_name
parameter_list|,
name|dns_name_t
modifier|*
name|search_name
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|INET6_ADDRSTRLEN
define|#
directive|define
name|INET6_ADDRSTRLEN
value|46
endif|#
directive|endif
name|int
name|w
index|[
name|DNS_RPZ_CIDR_WORDS
operator|*
literal|2
index|]
decl_stmt|;
name|char
name|str
index|[
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
name|INET6_ADDRSTRLEN
operator|+
literal|1
index|]
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|zeros
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|tgt_prefix
operator|>
literal|96
operator|&&
name|tgt_ip
operator|->
name|w
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|tgt_ip
operator|->
name|w
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|tgt_ip
operator|->
name|w
index|[
literal|2
index|]
operator|==
name|ADDR_V4MAPPED
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%d.%d.%d.%d.%d"
argument_list|,
name|tgt_prefix
operator|-
literal|96
argument_list|,
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
operator|||
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|str
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_RPZ_CIDR_WORDS
condition|;
name|i
operator|++
control|)
block|{
name|w
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
operator|(
operator|(
name|tgt_ip
operator|->
name|w
index|[
name|DNS_RPZ_CIDR_WORDS
operator|-
literal|1
operator|-
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|w
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|tgt_ip
operator|->
name|w
index|[
name|DNS_RPZ_CIDR_WORDS
operator|-
literal|1
operator|-
name|i
index|]
operator|&
literal|0xffff
expr_stmt|;
block|}
name|zeros
operator|=
name|ISC_FALSE
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|tgt_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|DNS_RPZ_CIDR_WORDS
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|w
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|zeros
operator|||
name|i
operator|>=
name|DNS_RPZ_CIDR_WORDS
operator|*
literal|2
operator|-
literal|1
operator|||
name|w
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
operator|(
name|size_t
operator|)
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
operator|&
name|str
index|[
name|len
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
name|len
argument_list|,
literal|".%x"
argument_list|,
name|w
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|len
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|zeros
operator|=
name|ISC_TRUE
expr_stmt|;
name|INSIST
argument_list|(
operator|(
name|size_t
operator|)
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
operator|&
name|str
index|[
name|len
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
operator|-
name|len
argument_list|,
literal|".zz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
name|len
operator|+=
name|n
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|DNS_RPZ_CIDR_WORDS
operator|*
literal|2
operator|&&
name|w
index|[
name|i
index|]
operator|==
literal|0
condition|)
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|str
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|canon_name
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|canon_name
argument_list|,
operator|&
name|buffer
argument_list|,
name|dns_rootname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|search_name
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DNS_RPZ_TYPE_NSIP
condition|)
name|name
operator|=
operator|&
name|cidr
operator|->
name|nsip_name
expr_stmt|;
else|else
name|name
operator|=
operator|&
name|cidr
operator|->
name|ip_name
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|search_name
argument_list|,
operator|&
name|buffer
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide which kind of IP address response policy zone a name is in.  */
end_comment

begin_function
specifier|static
name|dns_rpz_type_t
name|set_type
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|cidr
operator|->
name|ip_name
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_TYPE_IP
operator|)
return|;
comment|/* 	 * Require `./configure --enable-rpz-nsip` and nsdname 	 * until consistency problems are resolved. 	 */
ifdef|#
directive|ifdef
name|ENABLE_RPZ_NSIP
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|cidr
operator|->
name|nsip_name
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_TYPE_NSIP
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENABLE_RPZ_NSDNAME
if|if
condition|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|cidr
operator|->
name|nsdname_name
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_TYPE_NSDNAME
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|DNS_RPZ_TYPE_QNAME
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an IP address from canonical response policy domain name form  * to radix tree binary (host byte order).  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|name2ipkey
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
name|int
name|level
parameter_list|,
name|dns_name_t
modifier|*
name|src_name
parameter_list|,
name|dns_rpz_type_t
name|type
parameter_list|,
name|dns_rpz_cidr_key_t
modifier|*
name|tgt_ip
parameter_list|,
name|dns_rpz_cidr_bits_t
modifier|*
name|tgt_prefix
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_fixedname_t
name|fname
decl_stmt|;
name|dns_name_t
modifier|*
name|ipname
decl_stmt|;
name|char
name|ipstr
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix_str
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|ip_labels
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|bits
decl_stmt|;
name|unsigned
name|long
name|prefix
decl_stmt|,
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Need at least enough labels for the shortest name, 	 * :: or 128.*.RPZ_x_ZONE.rpz.LOCALHOST. 	 */
name|ip_labels
operator|=
name|dns_name_countlabels
argument_list|(
name|src_name
argument_list|)
expr_stmt|;
name|ip_labels
operator|-=
name|dns_name_countlabels
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|)
expr_stmt|;
name|ip_labels
operator|--
expr_stmt|;
if|if
condition|(
name|ip_labels
operator|<
literal|1
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; too short"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Get text for the IP address 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|ipname
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fname
argument_list|)
expr_stmt|;
name|dns_name_split
argument_list|(
name|src_name
argument_list|,
name|dns_name_countlabels
argument_list|(
operator|&
name|cidr
operator|->
name|ip_name
argument_list|)
argument_list|,
name|ipname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|ipname
argument_list|,
name|ipstr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipstr
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
name|ipstr
index|[
name|strlen
argument_list|(
name|ipstr
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
name|prefix_str
operator|=
name|ipstr
expr_stmt|;
name|prefix
operator|=
name|strtoul
argument_list|(
name|prefix_str
argument_list|,
operator|&
name|cp2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|!=
literal|'.'
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; invalid leading prefix length"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|prefix
operator|<
literal|1U
operator|||
name|prefix
operator|>
literal|128U
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; invalid prefix length of "
argument_list|,
name|prefix_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ip_labels
operator|==
literal|4
operator|&&
operator|!
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'z'
argument_list|)
condition|)
block|{
comment|/* 		 * Convert an IPv4 address 		 * from the form "prefix.w.z.y.x" 		 */
if|if
condition|(
name|prefix
operator|>
literal|32U
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; invalid IPv4 prefix length of "
argument_list|,
name|prefix_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|prefix
operator|+=
literal|96
expr_stmt|;
operator|*
name|tgt_prefix
operator|=
operator|(
name|dns_rpz_cidr_bits_t
operator|)
name|prefix
expr_stmt|;
name|tgt_ip
operator|->
name|w
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tgt_ip
operator|->
name|w
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tgt_ip
operator|->
name|w
index|[
literal|2
index|]
operator|=
name|ADDR_V4MAPPED
expr_stmt|;
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|l
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|cp2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|255U
operator|||
operator|(
operator|*
name|cp2
operator|!=
literal|'.'
operator|&&
operator|*
name|cp2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'.'
condition|)
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; invalid IPv4 octet "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|tgt_ip
operator|->
name|w
index|[
literal|3
index|]
operator||=
name|l
operator|<<
name|i
expr_stmt|;
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Convert a text IPv6 address. 		 */
operator|*
name|tgt_prefix
operator|=
operator|(
name|dns_rpz_cidr_bits_t
operator|)
name|prefix
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ip_labels
operator|>
literal|0
operator|&&
name|i
operator|<
name|DNS_RPZ_CIDR_WORDS
operator|*
literal|2
condition|;
name|ip_labels
operator|--
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'z'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'z'
operator|&&
operator|(
name|cp
index|[
literal|2
index|]
operator|==
literal|'.'
operator|||
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|i
operator|<=
literal|6
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|tgt_ip
operator|->
name|w
index|[
literal|3
operator|-
name|i
operator|/
literal|2
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|ip_labels
operator|+
name|i
operator|<=
literal|8
condition|)
do|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|cp2
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0xffffu
operator|||
operator|(
operator|*
name|cp2
operator|!=
literal|'.'
operator|&&
operator|*
name|cp2
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'.'
condition|)
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; invalid IPv6 word "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|tgt_ip
operator|->
name|w
index|[
literal|3
operator|-
name|i
operator|/
literal|2
index|]
operator|=
name|l
expr_stmt|;
else|else
name|tgt_ip
operator|->
name|w
index|[
literal|3
operator|-
name|i
operator|/
literal|2
index|]
operator||=
name|l
operator|<<
literal|16
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|end
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Check for 1s after the prefix length. 	 */
name|bits
operator|=
operator|(
name|dns_rpz_cidr_bits_t
operator|)
name|prefix
expr_stmt|;
while|while
condition|(
name|bits
operator|<
name|DNS_RPZ_CIDR_KEY_BITS
condition|)
block|{
name|dns_rpz_cidr_word_t
name|aword
decl_stmt|;
name|i
operator|=
name|bits
operator|%
name|DNS_RPZ_CIDR_WORD_BITS
expr_stmt|;
name|aword
operator|=
name|tgt_ip
operator|->
name|w
index|[
name|bits
operator|/
name|DNS_RPZ_CIDR_WORD_BITS
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|aword
operator|&
operator|~
name|DNS_RPZ_WORD_MASK
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; too small prefix length of "
argument_list|,
name|prefix_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|bits
operator|-=
name|i
expr_stmt|;
name|bits
operator|+=
name|DNS_RPZ_CIDR_WORD_BITS
expr_stmt|;
block|}
comment|/* 	 * Convert the address back to a canonical policy domain name 	 * to ensure that it is in canonical form. 	 */
name|result
operator|=
name|ip2name
argument_list|(
name|cidr
argument_list|,
name|tgt_ip
argument_list|,
operator|(
name|dns_rpz_cidr_bits_t
operator|)
name|prefix
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|ipname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|||
operator|!
name|dns_name_equal
argument_list|(
name|src_name
argument_list|,
name|ipname
argument_list|)
condition|)
block|{
name|badname
argument_list|(
name|level
argument_list|,
name|src_name
argument_list|,
literal|"; not canonical"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find first differing bit.  */
end_comment

begin_function
specifier|static
name|int
name|ffbit
parameter_list|(
name|dns_rpz_cidr_word_t
name|w
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
name|bit
operator|=
name|DNS_RPZ_CIDR_WORD_BITS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|>>=
literal|16
expr_stmt|;
name|bit
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|&
literal|0xff00
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|>>=
literal|8
expr_stmt|;
name|bit
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|>>=
literal|4
expr_stmt|;
name|bit
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|&
literal|0xc
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|>>=
literal|2
expr_stmt|;
name|bit
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|w
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
operator|--
name|bit
expr_stmt|;
return|return
operator|(
name|bit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first differing bit in two keys.  */
end_comment

begin_function
specifier|static
name|int
name|diff_keys
parameter_list|(
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|key1
parameter_list|,
name|dns_rpz_cidr_bits_t
name|bits1
parameter_list|,
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|key2
parameter_list|,
name|dns_rpz_cidr_bits_t
name|bits2
parameter_list|)
block|{
name|dns_rpz_cidr_word_t
name|delta
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|maxbit
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|maxbit
operator|=
name|ISC_MIN
argument_list|(
name|bits1
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
comment|/* 	 * find the first differing words 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit
operator|=
literal|0
init|;
name|bit
operator|<=
name|maxbit
condition|;
name|i
operator|++
operator|,
name|bit
operator|+=
name|DNS_RPZ_CIDR_WORD_BITS
control|)
block|{
name|delta
operator|=
name|key1
operator|->
name|w
index|[
name|i
index|]
operator|^
name|key2
operator|->
name|w
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
block|{
name|bit
operator|+=
name|ffbit
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|ISC_MIN
argument_list|(
name|bit
argument_list|,
name|maxbit
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search a radix tree for an IP address for ordinary lookup  *	or for a CIDR block adding or deleting an entry  * The tree read (for simple search) or write lock must be held by the caller.  *  * Return ISC_R_SUCCESS, ISC_R_NOTFOUND, DNS_R_PARTIALMATCH, ISC_R_EXISTS,  *	ISC_R_NOMEMORY  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|search
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
specifier|const
name|dns_rpz_cidr_key_t
modifier|*
name|tgt_ip
parameter_list|,
name|dns_rpz_cidr_bits_t
name|tgt_prefix
parameter_list|,
name|dns_rpz_type_t
name|type
parameter_list|,
name|isc_boolean_t
name|create
parameter_list|,
name|dns_rpz_cidr_node_t
modifier|*
modifier|*
name|found
parameter_list|)
comment|/* NULL or longest match node */
block|{
name|dns_rpz_cidr_node_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|child
decl_stmt|,
modifier|*
name|new_parent
decl_stmt|,
modifier|*
name|sibling
decl_stmt|;
name|int
name|cur_num
decl_stmt|,
name|child_num
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|dbit
decl_stmt|;
name|dns_rpz_cidr_flags_t
name|flags
decl_stmt|,
name|data_flag
decl_stmt|;
name|isc_result_t
name|find_result
decl_stmt|;
name|flags
operator|=
name|get_flags
argument_list|(
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|data_flag
operator|=
name|flags
operator|&
operator|(
name|DNS_RPZ_CIDR_FG_IP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator|)
expr_stmt|;
name|find_result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
name|cidr
operator|->
name|root
expr_stmt|;
name|parent
operator|=
name|NULL
expr_stmt|;
name|cur_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No child so we cannot go down.  Fail or 			 * add the target as a child of the current parent. 			 */
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
name|find_result
operator|)
return|;
name|child
operator|=
name|new_node
argument_list|(
name|cidr
argument_list|,
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|cidr
operator|->
name|root
operator|=
name|child
expr_stmt|;
else|else
name|parent
operator|->
name|child
index|[
name|cur_num
index|]
operator|=
name|child
expr_stmt|;
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|set_node_flags
argument_list|(
name|child
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 		 * Pretend a node not in the correct tree does not exist 		 * if we are not adding to the tree, 		 * If we are adding, then continue down to eventually 		 * add a node and mark/put this node in the correct tree. 		 */
if|if
condition|(
operator|(
name|cur
operator|->
name|flags
operator|&
name|flags
operator|)
operator|==
literal|0
operator|&&
operator|!
name|create
condition|)
return|return
operator|(
name|find_result
operator|)
return|;
name|dbit
operator|=
name|diff_keys
argument_list|(
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
operator|&
name|cur
operator|->
name|ip
argument_list|,
name|cur
operator|->
name|bits
argument_list|)
expr_stmt|;
comment|/* 		 * dbit<= tgt_prefix and dbit<= cur->bits always. 		 * We are finished searching if we matched all of the target. 		 */
if|if
condition|(
name|dbit
operator|==
name|tgt_prefix
condition|)
block|{
if|if
condition|(
name|tgt_prefix
operator|==
name|cur
operator|->
name|bits
condition|)
block|{
comment|/* 				 * The current node matches the target exactly. 				 * It is the answer if it has data. 				 */
if|if
condition|(
operator|(
name|cur
operator|->
name|flags
operator|&
name|data_flag
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|create
condition|)
return|return
operator|(
name|ISC_R_EXISTS
operator|)
return|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|create
condition|)
block|{
comment|/* 					 * The node had no data but does now. 					 */
name|set_node_flags
argument_list|(
name|cur
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|cur
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|find_result
operator|)
return|;
block|}
comment|/* 			 * We know tgt_prefix< cur_bits which means that 			 * the target is shorter than the current node. 			 * Add the target as the current node's parent. 			 */
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
name|find_result
operator|)
return|;
name|new_parent
operator|=
name|new_node
argument_list|(
name|cidr
argument_list|,
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
name|cur
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|new_parent
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|cidr
operator|->
name|root
operator|=
name|new_parent
expr_stmt|;
else|else
name|parent
operator|->
name|child
index|[
name|cur_num
index|]
operator|=
name|new_parent
expr_stmt|;
name|child_num
operator|=
name|DNS_RPZ_IP_BIT
argument_list|(
operator|&
name|cur
operator|->
name|ip
argument_list|,
name|tgt_prefix
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_parent
operator|->
name|child
index|[
name|child_num
index|]
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|parent
operator|=
name|new_parent
expr_stmt|;
name|set_node_flags
argument_list|(
name|new_parent
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|new_parent
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|dbit
operator|==
name|cur
operator|->
name|bits
condition|)
block|{
comment|/* 			 * We have a partial match by matching of all of the 			 * current node but only part of the target. 			 * Try to go down. 			 */
if|if
condition|(
operator|(
name|cur
operator|->
name|flags
operator|&
name|data_flag
operator|)
operator|!=
literal|0
condition|)
block|{
name|find_result
operator|=
name|DNS_R_PARTIALMATCH
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|cur
expr_stmt|;
block|}
name|parent
operator|=
name|cur
expr_stmt|;
name|cur_num
operator|=
name|DNS_RPZ_IP_BIT
argument_list|(
name|tgt_ip
argument_list|,
name|dbit
argument_list|)
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|child
index|[
name|cur_num
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * dbit< tgt_prefix and dbit< cur->bits, 		 * so we failed to match both the target and the current node. 		 * Insert a fork of a parent above the current node and 		 * add the target as a sibling of the current node 		 */
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|(
name|find_result
operator|)
return|;
name|sibling
operator|=
name|new_node
argument_list|(
name|cidr
argument_list|,
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sibling
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|new_parent
operator|=
name|new_node
argument_list|(
name|cidr
argument_list|,
name|tgt_ip
argument_list|,
name|dbit
argument_list|,
name|cur
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_parent
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|cidr
operator|->
name|mctx
argument_list|,
name|sibling
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sibling
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|new_parent
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|cidr
operator|->
name|root
operator|=
name|new_parent
expr_stmt|;
else|else
name|parent
operator|->
name|child
index|[
name|cur_num
index|]
operator|=
name|new_parent
expr_stmt|;
name|child_num
operator|=
name|DNS_RPZ_IP_BIT
argument_list|(
name|tgt_ip
argument_list|,
name|dbit
argument_list|)
expr_stmt|;
name|new_parent
operator|->
name|child
index|[
name|child_num
index|]
operator|=
name|sibling
expr_stmt|;
name|new_parent
operator|->
name|child
index|[
literal|1
operator|-
name|child_num
index|]
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|parent
operator|=
name|new_parent
expr_stmt|;
name|sibling
operator|->
name|parent
operator|=
name|new_parent
expr_stmt|;
name|set_node_flags
argument_list|(
name|sibling
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
operator|*
name|found
operator|=
name|sibling
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add an IP address to the radix tree of a response policy database.  *	The tree write lock must be held by the caller.  */
end_comment

begin_function
name|void
name|dns_rpz_cidr_addip
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rpz_cidr_key_t
name|tgt_ip
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|tgt_prefix
decl_stmt|;
name|dns_rpz_type_t
name|type
decl_stmt|;
name|REQUIRE
argument_list|(
name|cidr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * No worries if the new name is not an IP address. 	 */
name|type
operator|=
name|set_type
argument_list|(
name|cidr
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNS_RPZ_TYPE_IP
case|:
case|case
name|DNS_RPZ_TYPE_NSIP
case|:
break|break;
case|case
name|DNS_RPZ_TYPE_NSDNAME
case|:
name|cidr
operator|->
name|have_nsdname
operator|=
name|ISC_TRUE
expr_stmt|;
return|return;
case|case
name|DNS_RPZ_TYPE_QNAME
case|:
case|case
name|DNS_RPZ_TYPE_BAD
case|:
return|return;
block|}
name|result
operator|=
name|name2ipkey
argument_list|(
name|cidr
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
operator|&
name|tgt_ip
argument_list|,
operator|&
name|tgt_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|result
operator|=
name|search
argument_list|(
name|cidr
argument_list|,
operator|&
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
name|type
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_EXISTS
operator|&&
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|)
condition|)
block|{
name|char
name|printname
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
comment|/* 		 * bin/tests/system/rpz/tests.sh looks for "rpz.*failed". 		 */
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|printname
argument_list|,
sizeof|sizeof
argument_list|(
name|printname
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_RPZ
argument_list|,
name|DNS_LOGMODULE_RBTDB
argument_list|,
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
literal|"rpz add failed; \"%s\" is a duplicate name"
argument_list|,
name|printname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an IP address from the radix tree of a response policy database.  *	The tree write lock must be held by the caller.  */
end_comment

begin_function
name|void
name|dns_rpz_cidr_deleteip
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_rpz_cidr_key_t
name|tgt_ip
decl_stmt|;
name|dns_rpz_cidr_bits_t
name|tgt_prefix
decl_stmt|;
name|dns_rpz_type_t
name|type
decl_stmt|;
name|dns_rpz_cidr_node_t
modifier|*
name|tgt
init|=
name|NULL
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|dns_rpz_cidr_flags_t
name|flags
decl_stmt|,
name|data_flag
decl_stmt|;
if|if
condition|(
name|cidr
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Decide which kind of policy zone IP address it is, if either 	 * and then find its node. 	 */
name|type
operator|=
name|set_type
argument_list|(
name|cidr
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNS_RPZ_TYPE_IP
case|:
case|case
name|DNS_RPZ_TYPE_NSIP
case|:
break|break;
case|case
name|DNS_RPZ_TYPE_NSDNAME
case|:
comment|/* 		 * We cannot easily count nsdnames because 		 * internal rbt nodes get deleted. 		 */
return|return;
case|case
name|DNS_RPZ_TYPE_QNAME
case|:
case|case
name|DNS_RPZ_TYPE_BAD
case|:
return|return;
block|}
comment|/* 	 * Do not get excited about the deletion of interior rbt nodes. 	 */
name|result
operator|=
name|name2ipkey
argument_list|(
name|cidr
argument_list|,
name|DNS_RPZ_DEBUG_QUIET
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
operator|&
name|tgt_ip
argument_list|,
operator|&
name|tgt_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return;
name|result
operator|=
name|search
argument_list|(
name|cidr
argument_list|,
operator|&
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
name|type
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|tgt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|badname
argument_list|(
name|DNS_RPZ_ERROR_LEVEL
argument_list|,
name|name
argument_list|,
literal|"; missing rpz node"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark the node and its parents to reflect the deleted IP address. 	 */
name|flags
operator|=
name|get_flags
argument_list|(
operator|&
name|tgt_ip
argument_list|,
name|tgt_prefix
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|data_flag
operator|=
name|flags
operator|&
operator|(
name|DNS_RPZ_CIDR_FG_IP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator|)
expr_stmt|;
name|tgt
operator|->
name|flags
operator|&=
operator|~
name|data_flag
expr_stmt|;
for|for
control|(
name|parent
operator|=
name|tgt
init|;
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|=
name|parent
operator|->
name|parent
control|)
block|{
if|if
condition|(
operator|(
name|parent
operator|->
name|flags
operator|&
name|data_flag
operator|)
operator|!=
literal|0
operator|||
operator|(
name|parent
operator|->
name|child
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|parent
operator|->
name|child
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|flags
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|parent
operator|->
name|child
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|parent
operator|->
name|child
index|[
literal|1
index|]
operator|->
name|flags
operator|&
name|flags
operator|)
operator|!=
literal|0
operator|)
condition|)
break|break;
name|parent
operator|->
name|flags
operator|&=
operator|~
name|flags
expr_stmt|;
block|}
comment|/* 	 * We might need to delete 2 nodes. 	 */
do|do
block|{
comment|/* 		 * The node is now useless if it has no data of its own 		 * and 0 or 1 children.  We are finished if it is not useless. 		 */
if|if
condition|(
operator|(
name|child
operator|=
name|tgt
operator|->
name|child
index|[
literal|0
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tgt
operator|->
name|child
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
return|return;
block|}
else|else
block|{
name|child
operator|=
name|tgt
operator|->
name|child
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tgt
operator|->
name|flags
operator|&
operator|(
name|DNS_RPZ_CIDR_FG_IP_DATA
operator||
name|DNS_RPZ_CIDR_FG_NSIP_DATA
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 		 * Replace the pointer to this node in the parent with 		 * the remaining child or NULL. 		 */
name|parent
operator|=
name|tgt
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|cidr
operator|->
name|root
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|->
name|child
index|[
name|parent
operator|->
name|child
index|[
literal|1
index|]
operator|==
name|tgt
index|]
operator|=
name|child
expr_stmt|;
block|}
comment|/* 		 * If the child exists fix up its parent pointer. 		 */
if|if
condition|(
name|child
operator|!=
name|NULL
condition|)
name|child
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|isc_mem_put
argument_list|(
name|cidr
operator|->
name|mctx
argument_list|,
name|tgt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tgt
argument_list|)
argument_list|)
expr_stmt|;
name|tgt
operator|=
name|parent
expr_stmt|;
block|}
do|while
condition|(
name|tgt
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Caller must hold tree lock.  * Return  ISC_R_NOTFOUND  *	or ISC_R_SUCCESS and the found entry's canonical and search names  *	    and its prefix length  */
end_comment

begin_function
name|isc_result_t
name|dns_rpz_cidr_find
parameter_list|(
name|dns_rpz_cidr_t
modifier|*
name|cidr
parameter_list|,
specifier|const
name|isc_netaddr_t
modifier|*
name|netaddr
parameter_list|,
name|dns_rpz_type_t
name|type
parameter_list|,
name|dns_name_t
modifier|*
name|canon_name
parameter_list|,
name|dns_name_t
modifier|*
name|search_name
parameter_list|,
name|dns_rpz_cidr_bits_t
modifier|*
name|prefix
parameter_list|)
block|{
name|dns_rpz_cidr_key_t
name|tgt_ip
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|dns_rpz_cidr_node_t
modifier|*
name|found
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Convert IP address to CIDR tree key. 	 */
if|if
condition|(
name|netaddr
operator|->
name|family
operator|==
name|AF_INET
condition|)
block|{
name|tgt_ip
operator|.
name|w
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tgt_ip
operator|.
name|w
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|tgt_ip
operator|.
name|w
index|[
literal|2
index|]
operator|=
name|ADDR_V4MAPPED
expr_stmt|;
name|tgt_ip
operator|.
name|w
index|[
literal|3
index|]
operator|=
name|ntohl
argument_list|(
name|netaddr
operator|->
name|type
operator|.
name|in
operator|.
name|s_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netaddr
operator|->
name|family
operator|==
name|AF_INET6
condition|)
block|{
name|dns_rpz_cidr_key_t
name|src_ip6
decl_stmt|;
comment|/* 		 * Given the int aligned struct in_addr member of netaddr->type 		 * one could cast netaddr->type.in6 to dns_rpz_cidr_key_t *, 		 * but there are objections. 		 */
name|memmove
argument_list|(
name|src_ip6
operator|.
name|w
argument_list|,
operator|&
name|netaddr
operator|->
name|type
operator|.
name|in6
argument_list|,
sizeof|sizeof
argument_list|(
name|src_ip6
operator|.
name|w
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|tgt_ip
operator|.
name|w
index|[
name|i
index|]
operator|=
name|ntohl
argument_list|(
name|src_ip6
operator|.
name|w
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
name|result
operator|=
name|search
argument_list|(
name|cidr
argument_list|,
operator|&
name|tgt_ip
argument_list|,
literal|128
argument_list|,
name|type
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_PARTIALMATCH
condition|)
return|return
operator|(
name|result
operator|)
return|;
operator|*
name|prefix
operator|=
name|found
operator|->
name|bits
expr_stmt|;
return|return
operator|(
name|ip2name
argument_list|(
name|cidr
argument_list|,
operator|&
name|found
operator|->
name|ip
argument_list|,
name|found
operator|->
name|bits
argument_list|,
name|type
argument_list|,
name|canon_name
argument_list|,
name|search_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate CNAME rdata to a QNAME response policy action.  */
end_comment

begin_function
name|dns_rpz_policy_t
name|dns_rpz_decode_cname
parameter_list|(
name|dns_rpz_zone_t
modifier|*
name|rpz
parameter_list|,
name|dns_rdataset_t
modifier|*
name|rdataset
parameter_list|,
name|dns_name_t
modifier|*
name|selfname
parameter_list|)
block|{
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdata_cname_t
name|cname
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|dns_rdataset_first
argument_list|(
name|rdataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdataset_current
argument_list|(
name|rdataset
argument_list|,
operator|&
name|rdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
argument_list|,
operator|&
name|cname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
comment|/* 	 * CNAME . means NXDOMAIN 	 */
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|dns_rootname
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_NXDOMAIN
operator|)
return|;
if|if
condition|(
name|dns_name_iswildcard
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|)
condition|)
block|{
comment|/* 		 * CNAME *. means NODATA 		 */
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|)
operator|==
literal|2
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_NODATA
operator|)
return|;
comment|/* 		 * A qname of www.evil.com and a policy of 		 *	*.evil.com    CNAME   *.garden.net 		 * gives a result of 		 *	evil.com    CNAME   evil.com.garden.net 		 */
if|if
condition|(
name|dns_name_countlabels
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|)
operator|>
literal|2
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_WILDCNAME
operator|)
return|;
block|}
comment|/* 	 * CNAME PASSTHRU.origin means "do not rewrite. 	 */
if|if
condition|(
name|dns_name_equal
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
operator|&
name|rpz
operator|->
name|passthru
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_PASSTHRU
operator|)
return|;
comment|/* 	 * 128.1.0.127.rpz-ip CNAME  128.1.0.0.127. is obsolete PASSTHRU 	 */
if|if
condition|(
name|selfname
operator|!=
name|NULL
operator|&&
name|dns_name_equal
argument_list|(
operator|&
name|cname
operator|.
name|cname
argument_list|,
name|selfname
argument_list|)
condition|)
return|return
operator|(
name|DNS_RPZ_POLICY_PASSTHRU
operator|)
return|;
comment|/* 	 * Any other rdata gives a response consisting of the rdata. 	 */
return|return
operator|(
name|DNS_RPZ_POLICY_RECORD
operator|)
return|;
block|}
end_function

end_unit

