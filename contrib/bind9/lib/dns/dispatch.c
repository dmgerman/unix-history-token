begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2009, 2011, 2012  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/portset.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/portlist.h>
end_include

begin_include
include|#
directive|include
file|<dns/stats.h>
end_include

begin_include
include|#
directive|include
file|<dns/tcpmsg.h>
end_include

begin_include
include|#
directive|include
file|<dns/types.h>
end_include

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_dispentry_t
argument_list|)
name|dns_displist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dispsocket
name|dispsocket_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dispsocket_t
argument_list|)
name|dispsocketlist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dispportentry
name|dispportentry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dispportentry_t
argument_list|)
name|dispportlist_t
expr_stmt|;
end_typedef

begin_comment
comment|/* ARC4 Random generator state */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arc4ctx
block|{
name|isc_uint8_t
name|i
decl_stmt|;
name|isc_uint8_t
name|j
decl_stmt|;
name|isc_uint8_t
name|s
index|[
literal|256
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|isc_entropy_t
modifier|*
name|entropy
decl_stmt|;
comment|/*%< entropy source for ARC4 */
name|isc_mutex_t
modifier|*
name|lock
decl_stmt|;
block|}
name|arc4ctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dns_qid
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|qid_nbuckets
decl_stmt|;
comment|/*%< hash table size */
name|unsigned
name|int
name|qid_increment
decl_stmt|;
comment|/*%< id increment on collision */
name|isc_mutex_t
name|lock
decl_stmt|;
name|dns_displist_t
modifier|*
name|qid_table
decl_stmt|;
comment|/*%< the table itself */
name|dispsocketlist_t
modifier|*
name|sock_table
decl_stmt|;
comment|/*%< socket table */
block|}
name|dns_qid_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_dispatchmgr
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_acl_t
modifier|*
name|blackhole
decl_stmt|;
name|dns_portlist_t
modifier|*
name|portlist
decl_stmt|;
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
name|isc_entropy_t
modifier|*
name|entropy
decl_stmt|;
comment|/*%< entropy source */
comment|/* Locked by "lock". */
name|isc_mutex_t
name|lock
decl_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_dispatch_t
argument_list|)
name|list
expr_stmt|;
comment|/* Locked by arc4_lock. */
name|isc_mutex_t
name|arc4_lock
decl_stmt|;
name|arc4ctx_t
name|arc4ctx
decl_stmt|;
comment|/*%< ARC4 context for QID */
comment|/* locked by buffer lock */
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|isc_mutex_t
name|buffer_lock
decl_stmt|;
name|unsigned
name|int
name|buffers
decl_stmt|;
comment|/*%< allocated buffers */
name|unsigned
name|int
name|buffersize
decl_stmt|;
comment|/*%< size of each buffer */
name|unsigned
name|int
name|maxbuffers
decl_stmt|;
comment|/*%< max buffers */
comment|/* Locked internally. */
name|isc_mutex_t
name|pool_lock
decl_stmt|;
name|isc_mempool_t
modifier|*
name|epool
decl_stmt|;
comment|/*%< memory pool for events */
name|isc_mempool_t
modifier|*
name|rpool
decl_stmt|;
comment|/*%< memory pool for replies */
name|isc_mempool_t
modifier|*
name|dpool
decl_stmt|;
comment|/*%< dispatch allocations */
name|isc_mempool_t
modifier|*
name|bpool
decl_stmt|;
comment|/*%< memory pool for buffers */
name|isc_mempool_t
modifier|*
name|spool
decl_stmt|;
comment|/*%< memory pool for dispsocs */
comment|/*% 	 * Locked by qid->lock if qid exists; otherwise, can be used without 	 * being locked. 	 * Memory footprint considerations: this is a simple implementation of 	 * available ports, i.e., an ordered array of the actual port numbers. 	 * This will require about 256KB of memory in the worst case (128KB for 	 * each of IPv4 and IPv6).  We could reduce it by representing it as a 	 * more sophisticated way such as a list (or array) of ranges that are 	 * searched to identify a specific port.  Our decision here is the saved 	 * memory isn't worth the implementation complexity, considering the 	 * fact that the whole BIND9 process (which is mainly named) already 	 * requires a pretty large memory footprint.  We may, however, have to 	 * revisit the decision when we want to use it as a separate module for 	 * an environment where memory requirement is severer. 	 */
name|in_port_t
modifier|*
name|v4ports
decl_stmt|;
comment|/*%< available ports for IPv4 */
name|unsigned
name|int
name|nv4ports
decl_stmt|;
comment|/*%< # of available ports for IPv4 */
name|in_port_t
modifier|*
name|v6ports
decl_stmt|;
comment|/*%< available ports for IPv4 */
name|unsigned
name|int
name|nv6ports
decl_stmt|;
comment|/*%< # of available ports for IPv4 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MGR_SHUTTINGDOWN
value|0x00000001U
end_define

begin_define
define|#
directive|define
name|MGR_IS_SHUTTINGDOWN
parameter_list|(
name|l
parameter_list|)
value|(((l)->state& MGR_SHUTTINGDOWN) != 0)
end_define

begin_define
define|#
directive|define
name|IS_PRIVATE
parameter_list|(
name|d
parameter_list|)
value|(((d)->attributes& DNS_DISPATCHATTR_PRIVATE) != 0)
end_define

begin_struct
struct|struct
name|dns_dispentry
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_sockaddr_t
name|host
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_taskaction_t
name|action
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|isc_boolean_t
name|item_out
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsocket
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_dispatchevent_t
argument_list|)
name|items
expr_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_dispentry_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * Maximum number of dispatch sockets that can be pooled for reuse.  The  * appropriate value may vary, but experiments have shown a busy caching server  * may need more than 1000 sockets concurrently opened.  The maximum allowable  * number of dispatch sockets (per manager) will be set to the double of this  * value.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DISPATCH_POOLSOCKS
end_ifndef

begin_define
define|#
directive|define
name|DNS_DISPATCH_POOLSOCKS
value|2048
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Quota to control the number of dispatch sockets.  If a dispatch has more  * than the quota of sockets, new queries will purge oldest ones, so that  * a massive number of outstanding queries won't prevent subsequent queries  * (especially if the older ones take longer time and result in timeout).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DISPATCH_SOCKSQUOTA
end_ifndef

begin_define
define|#
directive|define
name|DNS_DISPATCH_SOCKSQUOTA
value|3072
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|dispsocket
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_sockaddr_t
name|host
decl_stmt|;
name|in_port_t
name|localport
decl_stmt|;
comment|/* XXX: should be removed later */
name|dispportentry_t
modifier|*
name|portentry
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dispsocket_t
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|dispsocket_t
argument_list|)
name|blink
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*%  * A port table entry.  We remember every port we first open in a table with a  * reference counter so that we can 'reuse' the same port (with different  * destination addresses) using the SO_REUSEADDR socket option.  */
end_comment

begin_struct
struct|struct
name|dispportentry
block|{
name|in_port_t
name|port
decl_stmt|;
name|unsigned
name|int
name|refs
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|struct dispportentry
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DISPATCH_PORTTABLESIZE
end_ifndef

begin_define
define|#
directive|define
name|DNS_DISPATCH_PORTTABLESIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INVALID_BUCKET
value|(0xffffdead)
end_define

begin_comment
comment|/*%  * Number of tasks for each dispatch that use separate sockets for different  * transactions.  This must be a power of 2 as it will divide 32 bit numbers  * to get an uniformly random tasks selection.  See get_dispsocket().  */
end_comment

begin_define
define|#
directive|define
name|MAX_INTERNAL_TASKS
value|64
end_define

begin_struct
struct|struct
name|dns_dispatch
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/*%< magic */
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
comment|/*%< dispatch manager */
name|int
name|ntasks
decl_stmt|;
comment|/*% 	 * internal task buckets.  We use multiple tasks to distribute various 	 * socket events well when using separate dispatch sockets.  We use the 	 * 1st task (task[0]) for internal control events. 	 */
name|isc_task_t
modifier|*
name|task
index|[
name|MAX_INTERNAL_TASKS
index|]
decl_stmt|;
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
comment|/*%< isc socket attached to */
name|isc_sockaddr_t
name|local
decl_stmt|;
comment|/*%< local address */
name|in_port_t
name|localport
decl_stmt|;
comment|/*%< local UDP port */
name|unsigned
name|int
name|maxrequests
decl_stmt|;
comment|/*%< max requests */
name|isc_event_t
modifier|*
name|ctlevent
decl_stmt|;
comment|/*% Locked by mgr->lock. */
name|ISC_LINK
argument_list|(
argument|dns_dispatch_t
argument_list|)
name|link
expr_stmt|;
comment|/* Locked by "lock". */
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/*%< locks all below */
name|isc_sockettype_t
name|socktype
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|unsigned
name|int
name|refcount
decl_stmt|;
comment|/*%< number of users */
name|dns_dispatchevent_t
modifier|*
name|failsafe_ev
decl_stmt|;
comment|/*%< failsafe cancel event */
name|unsigned
name|int
name|shutting_down
range|:
literal|1
decl_stmt|,
name|shutdown_out
range|:
literal|1
decl_stmt|,
name|connected
range|:
literal|1
decl_stmt|,
name|tcpmsg_valid
range|:
literal|1
decl_stmt|,
name|recv_pending
range|:
literal|1
decl_stmt|;
comment|/*%< is a recv() pending? */
name|isc_result_t
name|shutdown_why
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dispsocket_t
argument_list|)
name|activesockets
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|dispsocket_t
argument_list|)
name|inactivesockets
expr_stmt|;
name|unsigned
name|int
name|nsockets
decl_stmt|;
name|unsigned
name|int
name|requests
decl_stmt|;
comment|/*%< how many requests we have */
name|unsigned
name|int
name|tcpbuffers
decl_stmt|;
comment|/*%< allocated buffers */
name|dns_tcpmsg_t
name|tcpmsg
decl_stmt|;
comment|/*%< for tcp streams */
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|arc4ctx_t
name|arc4ctx
decl_stmt|;
comment|/*%< for QID/UDP port num */
name|dispportlist_t
modifier|*
name|port_table
decl_stmt|;
comment|/*%< hold ports 'owned' by us */
name|isc_mempool_t
modifier|*
name|portpool
decl_stmt|;
comment|/*%< port table entries  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|QID_MAGIC
value|ISC_MAGIC('Q', 'i', 'd', ' ')
end_define

begin_define
define|#
directive|define
name|VALID_QID
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), QID_MAGIC)
end_define

begin_define
define|#
directive|define
name|RESPONSE_MAGIC
value|ISC_MAGIC('D', 'r', 's', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_RESPONSE
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), RESPONSE_MAGIC)
end_define

begin_define
define|#
directive|define
name|DISPSOCK_MAGIC
value|ISC_MAGIC('D', 's', 'o', 'c')
end_define

begin_define
define|#
directive|define
name|VALID_DISPSOCK
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), DISPSOCK_MAGIC)
end_define

begin_define
define|#
directive|define
name|DISPATCH_MAGIC
value|ISC_MAGIC('D', 'i', 's', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_DISPATCH
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), DISPATCH_MAGIC)
end_define

begin_define
define|#
directive|define
name|DNS_DISPATCHMGR_MAGIC
value|ISC_MAGIC('D', 'M', 'g', 'r')
end_define

begin_define
define|#
directive|define
name|VALID_DISPATCHMGR
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), DNS_DISPATCHMGR_MAGIC)
end_define

begin_define
define|#
directive|define
name|DNS_QID
parameter_list|(
name|disp
parameter_list|)
value|((disp)->socktype == isc_sockettype_tcp) ? \ 		       (disp)->qid : (disp)->mgr->qid
end_define

begin_define
define|#
directive|define
name|DISP_ARC4CTX
parameter_list|(
name|disp
parameter_list|)
value|((disp)->socktype == isc_sockettype_udp) ? \ 			(&(disp)->arc4ctx) : (&(disp)->mgr->arc4ctx)
end_define

begin_comment
comment|/*%  * Locking a query port buffer is a bit tricky.  We access the buffer without  * locking until qid is created.  Technically, there is a possibility of race  * between the creation of qid and access to the port buffer; in practice,  * however, this should be safe because qid isn't created until the first  * dispatch is created and there should be no contending situation until then.  */
end_comment

begin_define
define|#
directive|define
name|PORTBUFLOCK
parameter_list|(
name|mgr
parameter_list|)
value|if ((mgr)->qid != NULL) LOCK(&((mgr)->qid->lock))
end_define

begin_define
define|#
directive|define
name|PORTBUFUNLOCK
parameter_list|(
name|mgr
parameter_list|)
value|if ((mgr)->qid != NULL) UNLOCK((&(mgr)->qid->lock))
end_define

begin_comment
comment|/*  * Statics.  */
end_comment

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|entry_search
parameter_list|(
name|dns_qid_t
modifier|*
parameter_list|,
name|isc_sockaddr_t
modifier|*
parameter_list|,
name|dns_messageid_t
parameter_list|,
name|in_port_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|destroy_disp_ok
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_disp
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_dispsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|,
name|dispsocket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|deactivate_dispsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|,
name|dispsocket_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udp_exrecv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udp_shrecv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udp_recv
parameter_list|(
name|isc_event_t
modifier|*
parameter_list|,
name|dns_dispatch_t
modifier|*
parameter_list|,
name|dispsocket_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tcp_recv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|startrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|,
name|dispsocket_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_uint32_t
name|dns_hash
parameter_list|(
name|dns_qid_t
modifier|*
parameter_list|,
name|isc_sockaddr_t
modifier|*
parameter_list|,
name|dns_messageid_t
parameter_list|,
name|in_port_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|allocate_udp_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|free_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dns_dispatchevent_t
modifier|*
name|allocate_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_first
parameter_list|(
name|dns_qid_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_next
parameter_list|(
name|dns_qid_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dispatch_free
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|get_udpsocket
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dispatch_createudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|destroy_mgr_ok
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_mgr
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|qid_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|,
name|isc_boolean_t
name|needaddrtable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qid_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|open_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|portavailable
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddrp
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LVL
parameter_list|(
name|x
parameter_list|)
value|ISC_LOG_DEBUG(x)
end_define

begin_function_decl
specifier|static
name|void
name|mgr_log
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|mgr_log
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatchmgr %p: %s"
argument_list|,
name|mgr
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_statscounter_t
name|counter
parameter_list|)
block|{
if|if
condition|(
name|mgr
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|mgr
operator|->
name|stats
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|dispatch_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|dispatch_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p: %s"
argument_list|,
name|disp
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|request_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|request_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_RESPONSE
argument_list|(
name|resp
argument_list|)
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|resp
operator|->
name|host
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p response %p %s: %s"
argument_list|,
name|disp
argument_list|,
name|resp
argument_list|,
name|peerbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p req/resp %p: %s"
argument_list|,
name|disp
argument_list|,
name|resp
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*%  * ARC4 random number generator derived from OpenBSD.  * Only dispatch_random() and dispatch_uniformrandom() are expected  * to be called from general dispatch routines; the rest of them are subroutines  * for these two.  *  * The original copyright follows:  * Copyright (c) 1996, David Mazieres<dm@uun.org>  * Copyright (c) 2008, Damien Miller<djm@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
specifier|static
name|void
name|dispatch_initrandom
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|isc_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
name|actx
operator|->
name|s
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|actx
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|actx
operator|->
name|j
operator|=
literal|0
expr_stmt|;
name|actx
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|actx
operator|->
name|entropy
operator|=
name|entropy
expr_stmt|;
comment|/* don't have to attach */
name|actx
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_arc4addrandom
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|,
name|unsigned
name|char
modifier|*
name|dat
parameter_list|,
name|int
name|datlen
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|isc_uint8_t
name|si
decl_stmt|;
name|actx
operator|->
name|i
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|actx
operator|->
name|i
operator|=
operator|(
name|actx
operator|->
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|si
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
expr_stmt|;
name|actx
operator|->
name|j
operator|=
operator|(
name|actx
operator|->
name|j
operator|+
name|si
operator|+
name|dat
index|[
name|n
operator|%
name|datlen
index|]
operator|)
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
operator|=
name|si
expr_stmt|;
block|}
name|actx
operator|->
name|j
operator|=
name|actx
operator|->
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_uint8_t
name|dispatch_arc4get8
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint8_t
name|si
decl_stmt|,
name|sj
decl_stmt|;
name|actx
operator|->
name|i
operator|=
operator|(
name|actx
operator|->
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|si
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
expr_stmt|;
name|actx
operator|->
name|j
operator|=
operator|(
name|actx
operator|->
name|j
operator|+
name|si
operator|)
expr_stmt|;
name|sj
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
operator|=
name|sj
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
operator|=
name|si
expr_stmt|;
return|return
operator|(
name|actx
operator|->
name|s
index|[
operator|(
name|si
operator|+
name|sj
operator|)
operator|&
literal|0xff
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_uint16_t
name|dispatch_arc4get16
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint16_t
name|val
decl_stmt|;
name|val
operator|=
name|dispatch_arc4get8
argument_list|(
name|actx
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|val
operator||=
name|dispatch_arc4get8
argument_list|(
name|actx
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_arc4stir
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|unsigned
name|char
name|rnd
index|[
literal|128
index|]
decl_stmt|;
name|isc_uint32_t
name|rnd32
index|[
literal|32
index|]
decl_stmt|;
block|}
name|rnd
union|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|actx
operator|->
name|entropy
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We accept any quality of random data to avoid blocking. 		 */
name|result
operator|=
name|isc_entropy_getdata
argument_list|(
name|actx
operator|->
name|entropy
argument_list|,
name|rnd
operator|.
name|rnd
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|isc_random_get
argument_list|(
operator|&
name|rnd
operator|.
name|rnd32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dispatch_arc4addrandom
argument_list|(
name|actx
argument_list|,
name|rnd
operator|.
name|rnd
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd
operator|.
name|rnd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Discard early keystream, as per recommendations in: 	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|dispatch_arc4get8
argument_list|(
name|actx
argument_list|)
expr_stmt|;
comment|/* 	 * Derived from OpenBSD's implementation.  The rationale is not clear, 	 * but should be conservative enough in safety, and reasonably large 	 * for efficiency. 	 */
name|actx
operator|->
name|count
operator|=
literal|1600000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_uint16_t
name|dispatch_random
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint16_t
name|result
decl_stmt|;
if|if
condition|(
name|actx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|LOCK
argument_list|(
name|actx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|actx
operator|->
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|isc_uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|actx
operator|->
name|count
operator|<=
literal|0
condition|)
name|dispatch_arc4stir
argument_list|(
name|actx
argument_list|)
expr_stmt|;
name|result
operator|=
name|dispatch_arc4get16
argument_list|(
name|actx
argument_list|)
expr_stmt|;
if|if
condition|(
name|actx
operator|->
name|lock
operator|!=
name|NULL
condition|)
name|UNLOCK
argument_list|(
name|actx
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * For general purpose library, we don't have to be too strict about the  * quality of random values.  Performance doesn't matter much, either.  * So we simply use the isc_random module to keep the library as small as  * possible.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_initrandom
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|isc_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|actx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|isc_uint16_t
name|dispatch_random
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint32_t
name|r
decl_stmt|;
name|UNUSED
argument_list|(
name|actx
argument_list|)
expr_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_function
specifier|static
name|isc_uint16_t
name|dispatch_uniformrandom
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|,
name|isc_uint16_t
name|upper_bound
parameter_list|)
block|{
name|isc_uint16_t
name|min
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
name|upper_bound
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Ensure the range of random numbers [min, 0xffff] be a multiple of 	 * upper_bound and contain at least a half of the 16 bit range. 	 */
if|if
condition|(
name|upper_bound
operator|>
literal|0x8000
condition|)
name|min
operator|=
literal|1
operator|+
operator|~
name|upper_bound
expr_stmt|;
comment|/* 0x8000 - upper_bound */
else|else
name|min
operator|=
call|(
name|isc_uint16_t
call|)
argument_list|(
literal|0x10000
operator|%
operator|(
name|isc_uint32_t
operator|)
name|upper_bound
argument_list|)
expr_stmt|;
comment|/* 	 * This could theoretically loop forever but each retry has 	 * p> 0.5 (worst case, usually far better) of selecting a 	 * number inside the range we need, so it should rarely need 	 * to re-roll. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|dispatch_random
argument_list|(
name|actx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|min
condition|)
break|break;
block|}
return|return
operator|(
name|r
operator|%
name|upper_bound
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a hash of the destination and message id.  */
end_comment

begin_function
specifier|static
name|isc_uint32_t
name|dns_hash
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|isc_sockaddr_hash
argument_list|(
name|dest
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|ret
operator|^=
operator|(
name|id
operator|<<
literal|16
operator|)
operator||
name|port
expr_stmt|;
name|ret
operator|%=
name|qid
operator|->
name|qid_nbuckets
expr_stmt|;
name|INSIST
argument_list|(
name|ret
operator|<
name|qid
operator|->
name|qid_nbuckets
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first entry in 'qid'.  Returns NULL if there are no entries.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_first
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|bucket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
condition|)
block|{
name|ret
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next entry after 'resp' in 'qid'.  Return NULL if there are  * no more entries.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_next
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|ret
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|resp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|=
name|resp
operator|->
name|bucket
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
while|while
condition|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
condition|)
block|{
name|ret
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The dispatch must be locked.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|destroy_disp_ok
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
if|if
condition|(
name|disp
operator|->
name|refcount
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when refcount reaches 0 (and safe to destroy).  *  * The dispatcher must not be locked.  * The manager must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_disp
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_boolean_t
name|killmgr
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsocket
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_DISPATCHCONTROL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|disp
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"shutting down; detaching from sock %p, task %p"
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXXX */
if|if
condition|(
name|disp
operator|->
name|socket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dispsocket
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|,
name|dispsocket
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsocket
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|disp
operator|->
name|ntasks
condition|;
name|i
operator|++
control|)
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
name|killmgr
operator|=
name|destroy_mgr_ok
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killmgr
condition|)
name|destroy_mgr
argument_list|(
operator|&
name|mgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Manipulate port table per dispatch: find an entry for a given port number,  * create a new entry, and decrement a given entry with possible clean-up.  */
end_comment

begin_function
specifier|static
name|dispportentry_t
modifier|*
name|port_search
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|dispportentry_t
modifier|*
name|portentry
decl_stmt|;
name|REQUIRE
argument_list|(
name|disp
operator|->
name|port_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|portentry
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|port_table
index|[
name|port
operator|%
name|DNS_DISPATCH_PORTTABLESIZE
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|portentry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|portentry
operator|->
name|port
operator|==
name|port
condition|)
return|return
operator|(
name|portentry
operator|)
return|;
name|portentry
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|portentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dispportentry_t
modifier|*
name|new_portentry
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|dispportentry_t
modifier|*
name|portentry
decl_stmt|;
name|REQUIRE
argument_list|(
name|disp
operator|->
name|port_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|portentry
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|portpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|portentry
operator|==
name|NULL
condition|)
return|return
operator|(
name|portentry
operator|)
return|;
name|portentry
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|portentry
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|portentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|disp
operator|->
name|port_table
index|[
name|port
operator|%
name|DNS_DISPATCH_PORTTABLESIZE
index|]
argument_list|,
name|portentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|portentry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * The caller must not hold the qid->lock.  */
end_comment

begin_function
specifier|static
name|void
name|deref_portentry
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dispportentry_t
modifier|*
modifier|*
name|portentryp
parameter_list|)
block|{
name|dispportentry_t
modifier|*
name|portentry
init|=
operator|*
name|portentryp
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|disp
operator|->
name|port_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|portentry
operator|!=
name|NULL
operator|&&
name|portentry
operator|->
name|refs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|portentry
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|portentry
operator|->
name|refs
operator|==
literal|0
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|disp
operator|->
name|port_table
index|[
name|portentry
operator|->
name|port
operator|%
name|DNS_DISPATCH_PORTTABLESIZE
index|]
argument_list|,
name|portentry
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|portpool
argument_list|,
name|portentry
argument_list|)
expr_stmt|;
block|}
operator|*
name|portentryp
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Find a dispsocket for socket address 'dest', and port number 'port'.  * Return NULL if no such entry exists.  */
end_comment

begin_function
specifier|static
name|dispsocket_t
modifier|*
name|socket_search
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|unsigned
name|int
name|bucket
parameter_list|)
block|{
name|dispsocket_t
modifier|*
name|dispsock
decl_stmt|;
name|REQUIRE
argument_list|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
argument_list|)
expr_stmt|;
name|dispsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|sock_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|dispsock
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dispsock
operator|->
name|portentry
operator|!=
name|NULL
operator|&&
name|dispsock
operator|->
name|portentry
operator|->
name|port
operator|==
name|port
operator|&&
name|isc_sockaddr_equal
argument_list|(
name|dest
argument_list|,
operator|&
name|dispsock
operator|->
name|host
argument_list|)
condition|)
return|return
operator|(
name|dispsock
operator|)
return|;
name|dispsock
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dispsock
argument_list|,
name|blink
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Make a new socket for a single dispatch with a random port number.  * The caller must hold the disp->lock and qid->lock.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|get_dispsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|dispsocket_t
modifier|*
modifier|*
name|dispsockp
parameter_list|,
name|in_port_t
modifier|*
name|portp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_uint32_t
name|r
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
init|=
name|disp
operator|->
name|mgr
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_FAILURE
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|isc_sockaddr_t
name|localaddr
decl_stmt|;
name|unsigned
name|int
name|bucket
init|=
literal|0
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsock
decl_stmt|;
name|unsigned
name|int
name|nports
decl_stmt|;
name|in_port_t
modifier|*
name|ports
decl_stmt|;
name|unsigned
name|int
name|bindoptions
decl_stmt|;
name|dispportentry_t
modifier|*
name|portentry
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|nports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|nv4ports
expr_stmt|;
name|ports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|v4ports
expr_stmt|;
block|}
else|else
block|{
name|nports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|nv6ports
expr_stmt|;
name|ports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|v6ports
expr_stmt|;
block|}
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
name|dispsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsock
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|,
name|dispsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sock
operator|=
name|dispsock
operator|->
name|socket
expr_stmt|;
name|dispsock
operator|->
name|socket
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dispsock
operator|=
name|isc_mempool_get
argument_list|(
name|mgr
operator|->
name|spool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|disp
operator|->
name|nsockets
operator|++
expr_stmt|;
name|dispsock
operator|->
name|socket
operator|=
name|NULL
expr_stmt|;
name|dispsock
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|dispsock
operator|->
name|resp
operator|=
name|NULL
expr_stmt|;
name|dispsock
operator|->
name|portentry
operator|=
name|NULL
expr_stmt|;
name|isc_random_get
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|dispsock
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|disp
operator|->
name|task
index|[
name|r
operator|%
name|disp
operator|->
name|ntasks
index|]
argument_list|,
operator|&
name|dispsock
operator|->
name|task
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|dispsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|dispsock
argument_list|,
name|blink
argument_list|)
expr_stmt|;
name|dispsock
operator|->
name|magic
operator|=
name|DISPSOCK_MAGIC
expr_stmt|;
block|}
comment|/* 	 * Pick up a random UDP port and open a new socket with it.  Avoid 	 * choosing ports that share the same destination because it will be 	 * very likely to fail in bind(2) or connect(2). 	 */
name|localaddr
operator|=
name|disp
operator|->
name|local
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|ports
index|[
name|dispatch_uniformrandom
argument_list|(
name|DISP_ARC4CTX
argument_list|(
name|disp
argument_list|)
argument_list|,
name|nports
argument_list|)
index|]
expr_stmt|;
name|isc_sockaddr_setport
argument_list|(
operator|&
name|localaddr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_search
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|port
argument_list|,
name|bucket
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|bindoptions
operator|=
literal|0
expr_stmt|;
name|portentry
operator|=
name|port_search
argument_list|(
name|disp
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portentry
operator|!=
name|NULL
condition|)
name|bindoptions
operator||=
name|ISC_SOCKET_REUSEADDRESS
expr_stmt|;
name|result
operator|=
name|open_socket
argument_list|(
name|sockmgr
argument_list|,
operator|&
name|localaddr
argument_list|,
name|bindoptions
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|portentry
operator|==
name|NULL
condition|)
block|{
name|portentry
operator|=
name|new_portentry
argument_list|(
name|disp
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portentry
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
break|break;
block|}
block|}
name|portentry
operator|->
name|refs
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_NOPERM
condition|)
block|{
name|char
name|buf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|localaddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"open_socket(%s) -> %s: continuing"
argument_list|,
name|buf
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_ADDRINUSE
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dispsock
operator|->
name|socket
operator|=
name|sock
expr_stmt|;
name|dispsock
operator|->
name|host
operator|=
operator|*
name|dest
expr_stmt|;
name|dispsock
operator|->
name|portentry
operator|=
name|portentry
expr_stmt|;
name|dispsock
operator|->
name|bucket
operator|=
name|bucket
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qid
operator|->
name|sock_table
index|[
name|bucket
index|]
argument_list|,
name|dispsock
argument_list|,
name|blink
argument_list|)
expr_stmt|;
operator|*
name|dispsockp
operator|=
name|dispsock
expr_stmt|;
operator|*
name|portp
operator|=
name|port
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We could keep it in the inactive list, but since this should 		 * be an exceptional case and might be resource shortage, we'd 		 * rather destroy it. 		 */
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Destroy a dedicated dispatch socket.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_dispsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dispsocket_t
modifier|*
modifier|*
name|dispsockp
parameter_list|)
block|{
name|dispsocket_t
modifier|*
name|dispsock
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
comment|/* 	 * The dispatch must be locked. 	 */
name|REQUIRE
argument_list|(
name|dispsockp
operator|!=
name|NULL
operator|&&
operator|*
name|dispsockp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dispsock
operator|=
operator|*
name|dispsockp
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|dispsock
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|->
name|nsockets
operator|--
expr_stmt|;
name|dispsock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dispsock
operator|->
name|portentry
operator|!=
name|NULL
condition|)
name|deref_portentry
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
operator|->
name|portentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsock
operator|->
name|socket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|dispsock
operator|->
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|dispsock
argument_list|,
name|blink
argument_list|)
condition|)
block|{
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|qid
operator|->
name|sock_table
index|[
name|dispsock
operator|->
name|bucket
index|]
argument_list|,
name|dispsock
argument_list|,
name|blink
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dispsock
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|dispsock
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|spool
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
operator|*
name|dispsockp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*%  * Deactivate a dedicated dispatch socket.  Move it to the inactive list for  * future reuse unless the total number of sockets are exceeding the maximum.  */
end_comment

begin_function
specifier|static
name|void
name|deactivate_dispsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dispsocket_t
modifier|*
name|dispsock
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
comment|/* 	 * The dispatch must be locked. 	 */
name|ISC_LIST_UNLINK
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|,
name|dispsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsock
operator|->
name|resp
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|dispsock
operator|->
name|resp
operator|->
name|dispsocket
operator|==
name|dispsock
argument_list|)
expr_stmt|;
name|dispsock
operator|->
name|resp
operator|->
name|dispsocket
operator|=
name|NULL
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|dispsock
operator|->
name|portentry
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|deref_portentry
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
operator|->
name|portentry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|disp
operator|->
name|nsockets
operator|>
name|DNS_DISPATCH_POOLSOCKS
condition|)
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
argument_list|)
expr_stmt|;
else|else
block|{
name|result
operator|=
name|isc_socket_close
argument_list|(
name|dispsock
operator|->
name|socket
argument_list|)
expr_stmt|;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|qid
operator|->
name|sock_table
index|[
name|dispsock
operator|->
name|bucket
index|]
argument_list|,
name|dispsock
argument_list|,
name|blink
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|,
name|dispsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * If the underlying system does not allow this 			 * optimization, destroy this temporary structure (and 			 * create a new one for a new transaction). 			 */
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_NOTIMPLEMENTED
argument_list|)
expr_stmt|;
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* This kind of optimization isn't necessary for normal use */
name|UNUSED
argument_list|(
name|qid
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Find an entry for query ID 'id', socket address 'dest', and port number  * 'port'.  * Return NULL if no such entry exists.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|entry_search
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|unsigned
name|int
name|bucket
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|REQUIRE
argument_list|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
argument_list|)
expr_stmt|;
name|res
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|res
operator|->
name|id
operator|==
name|id
operator|&&
name|isc_sockaddr_equal
argument_list|(
name|dest
argument_list|,
operator|&
name|res
operator|->
name|host
argument_list|)
operator|&&
name|res
operator|->
name|port
operator|==
name|port
condition|)
block|{
return|return
operator|(
name|res
operator|)
return|;
block|}
name|res
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|INSIST
argument_list|(
name|buf
operator|!=
name|NULL
operator|&&
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|disp
operator|->
name|socktype
condition|)
block|{
case|case
name|isc_sockettype_tcp
case|:
name|INSIST
argument_list|(
name|disp
operator|->
name|tcpbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|--
expr_stmt|;
name|isc_mem_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_udp
case|:
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|len
operator|==
name|disp
operator|->
name|mgr
operator|->
name|buffersize
argument_list|)
expr_stmt|;
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|--
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|bpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|allocate_udp_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|void
modifier|*
name|temp
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|temp
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|disp
operator|->
name|failsafe_ev
operator|==
name|ev
condition|)
block|{
name|INSIST
argument_list|(
name|disp
operator|->
name|shutdown_out
operator|==
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|epool
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_dispatchevent_t
modifier|*
name|allocate_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ISC_EVENT_INIT
argument_list|(
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udp_exrecv
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|dispsocket_t
modifier|*
name|dispsock
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPSOCK
argument_list|(
name|dispsock
argument_list|)
argument_list|)
expr_stmt|;
name|udp_recv
argument_list|(
name|ev
argument_list|,
name|dispsock
operator|->
name|disp
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|udp_shrecv
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|ev
operator|->
name|ev_arg
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|udp_recv
argument_list|(
name|ev
argument_list|,
name|disp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General flow:  *  * If I/O result == CANCELED or error, free the buffer.  *  * If query, free the buffer, restart.  *  * If response:  *	Allocate event, fill in details.  *		If cannot allocate, free buffer, restart.  *	find target.  If not found, free buffer, restart.  *	if event queue is not empty, queue.  else, send.  *	restart.  */
end_comment

begin_function
specifier|static
name|void
name|udp_recv
parameter_list|(
name|isc_event_t
modifier|*
name|ev_in
parameter_list|,
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dispsocket_t
modifier|*
name|dispsock
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|ev_in
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|isc_result_t
name|dres
decl_stmt|;
name|isc_buffer_t
name|source
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|rev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|isc_boolean_t
name|queue_response
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|int
name|match
decl_stmt|;
name|int
name|result
decl_stmt|;
name|isc_boolean_t
name|qidlocked
init|=
name|ISC_FALSE
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|qid
operator|=
name|mgr
operator|->
name|qid
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"got packet: requests %d, buffers %d, recvs %d"
argument_list|,
name|disp
operator|->
name|requests
argument_list|,
name|disp
operator|->
name|mgr
operator|->
name|buffers
argument_list|,
name|disp
operator|->
name|recv_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsock
operator|==
name|NULL
operator|&&
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_RECVDONE
condition|)
block|{
comment|/* 		 * Unless the receive event was imported from a listening 		 * interface, in which case the event type is 		 * DNS_EVENT_IMPORTRECVDONE, receive operation must be pending. 		 */
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dispsock
operator|!=
name|NULL
operator|&&
operator|(
name|ev
operator|->
name|result
operator|==
name|ISC_R_CANCELED
operator|||
name|dispsock
operator|->
name|resp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * dispsock->resp can be NULL if this transaction was canceled 		 * just after receiving a response.  Since this socket is 		 * exclusively used and there should be at most one receive 		 * event the canceled event should have been no effect.  So 		 * we can (and should) deactivate the socket right now. 		 */
name|deactivate_dispsocket
argument_list|(
name|disp
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
name|dispsock
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|->
name|shutting_down
condition|)
block|{
comment|/* 		 * This dispatcher is shutting down. 		 */
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
name|ev
operator|=
name|NULL
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dispsock
operator|!=
name|NULL
condition|)
block|{
name|resp
operator|=
name|dispsock
operator|->
name|resp
expr_stmt|;
name|id
operator|=
name|resp
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 				 * This is most likely a network error on a 				 * connected socket.  It makes no sense to 				 * check the address or parse the packet, but it 				 * will help to return the error to the caller. 				 */
goto|goto
name|sendresponse
goto|;
block|}
block|}
else|else
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|result
operator|!=
name|ISC_R_CANCELED
condition|)
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"odd socket result in udp_recv(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|ev
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is from a blackholed address, drop it. 	 */
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|disp
operator|->
name|mgr
operator|->
name|blackhole
argument_list|,
name|NULL
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|netaddrstr
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|netaddr
argument_list|,
name|netaddrstr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddrstr
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"blackholed packet from %s"
argument_list|,
name|netaddrstr
argument_list|)
expr_stmt|;
block|}
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Peek into the buffer to see what we can see. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|source
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|source
argument_list|,
name|ev
operator|->
name|n
argument_list|)
expr_stmt|;
name|dres
operator|=
name|dns_message_peekheader
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dres
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"got garbage packet"
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|92
argument_list|)
argument_list|,
literal|"got valid DNS message header, /QR %c, id %u"
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
condition|?
literal|'1'
else|:
literal|'0'
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Look at flags.  If query, drop it. If response, 	 * look to see where it goes. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* query */
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Search for the corresponding response.  If we are using an exclusive 	 * socket, we've already identified it and we can skip the search; but 	 * the ID and the address must match the expected ones. 	 */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|qidlocked
operator|=
name|ISC_TRUE
expr_stmt|;
name|resp
operator|=
name|entry_search
argument_list|(
name|qid
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"search for response in bucket %d: %s"
argument_list|,
name|bucket
argument_list|,
operator|(
name|resp
operator|==
name|NULL
condition|?
literal|"not found"
else|:
literal|"found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|inc_stats
argument_list|(
name|mgr
argument_list|,
name|dns_resstatscounter_mismatch
argument_list|)
expr_stmt|;
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|resp
operator|->
name|id
operator|!=
name|id
operator|||
operator|!
name|isc_sockaddr_equal
argument_list|(
operator|&
name|ev
operator|->
name|address
argument_list|,
operator|&
name|resp
operator|->
name|host
argument_list|)
condition|)
block|{
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"response to an exclusive socket doesn't match"
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|mgr
argument_list|,
name|dns_resstatscounter_mismatch
argument_list|)
expr_stmt|;
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * Now that we have the original dispatch the query was sent 	 * from check that the address and port the response was 	 * sent to make sense. 	 */
if|if
condition|(
name|disp
operator|!=
name|resp
operator|->
name|disp
condition|)
block|{
name|isc_sockaddr_t
name|a1
decl_stmt|;
name|isc_sockaddr_t
name|a2
decl_stmt|;
comment|/* 		 * Check that the socket types and ports match. 		 */
if|if
condition|(
name|disp
operator|->
name|socktype
operator|!=
name|resp
operator|->
name|disp
operator|->
name|socktype
operator|||
name|isc_sockaddr_getport
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|!=
name|isc_sockaddr_getport
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 		 * If both dispatches are bound to an address then fail as 		 * the addresses can't be equal (enforced by the IP stack). 		 * 		 * Note under Linux a packet can be sent out via IPv4 socket 		 * and the response be received via a IPv6 socket. 		 * 		 * Requests sent out via IPv6 should always come back in 		 * via IPv6. 		 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
operator|==
name|PF_INET6
operator|&&
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|!=
name|PF_INET6
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|a1
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|a2
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|a1
argument_list|,
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
operator|&&
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|a2
argument_list|,
operator|&
name|disp
operator|->
name|local
argument_list|)
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
name|sendresponse
label|:
name|queue_response
operator|=
name|resp
operator|->
name|item_out
expr_stmt|;
name|rev
operator|=
name|allocate_event
argument_list|(
name|resp
operator|->
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * At this point, rev contains the event we want to fill in, and 	 * resp contains the information on the place to send it to. 	 * Send the event off. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|rev
operator|->
name|buffer
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|rev
operator|->
name|buffer
argument_list|,
name|ev
operator|->
name|n
argument_list|)
expr_stmt|;
name|rev
operator|->
name|result
operator|=
name|ev
operator|->
name|result
expr_stmt|;
name|rev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rev
operator|->
name|addr
operator|=
name|ev
operator|->
name|address
expr_stmt|;
name|rev
operator|->
name|pktinfo
operator|=
name|ev
operator|->
name|pktinfo
expr_stmt|;
name|rev
operator|->
name|attributes
operator|=
name|ev
operator|->
name|attributes
expr_stmt|;
if|if
condition|(
name|queue_response
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|resp
operator|->
name|items
argument_list|,
name|rev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISC_EVENT_INIT
argument_list|(
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"[a] Sent event %p buffer %p len %d to task %p"
argument_list|,
name|rev
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
if|if
condition|(
name|qidlocked
condition|)
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Restart recv() to get the next packet. 	 */
name|restart
label|:
name|result
operator|=
name|startrecv
argument_list|(
name|disp
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|dispsock
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXX: wired. There seems to be no recovery process other than 		 * deactivate this socket anyway (since we cannot start 		 * receiving, we won't be able to receive a cancel event 		 * from the user). 		 */
name|deactivate_dispsocket
argument_list|(
name|disp
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General flow:  *  * If I/O result == CANCELED, EOF, or error, notify everyone as the  * various queues drain.  *  * If query, restart.  *  * If response:  *	Allocate event, fill in details.  *		If cannot allocate, restart.  *	find target.  If not found, restart.  *	if event queue is not empty, queue.  else, send.  *	restart.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_recv
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev_in
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|ev_in
operator|->
name|ev_arg
decl_stmt|;
name|dns_tcpmsg_t
modifier|*
name|tcpmsg
init|=
operator|&
name|disp
operator|->
name|tcpmsg
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|isc_result_t
name|dres
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|rev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|isc_boolean_t
name|queue_response
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
name|buf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|qid
operator|=
name|disp
operator|->
name|qid
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"got TCP packet: requests %d, buffers %d, recvs %d"
argument_list|,
name|disp
operator|->
name|requests
argument_list|,
name|disp
operator|->
name|tcpbuffers
argument_list|,
name|disp
operator|->
name|recv_pending
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This dispatcher is shutting down.  Force cancelation. 		 */
name|tcpmsg
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
block|}
if|if
condition|(
name|tcpmsg
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|tcpmsg
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_CANCELED
case|:
break|break;
case|case
name|ISC_R_EOF
case|:
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"shutting down on EOF"
argument_list|)
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISC_R_CONNECTIONRESET
case|:
name|level
operator|=
name|ISC_LOG_INFO
expr_stmt|;
goto|goto
name|logit
goto|;
default|default:
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
name|logit
label|:
name|isc_sockaddr_format
argument_list|(
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|level
argument_list|,
literal|"shutting down due to TCP "
literal|"receive error: %s: %s"
argument_list|,
name|buf
argument_list|,
name|isc_result_totext
argument_list|(
name|tcpmsg
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The event is statically allocated in the tcpmsg 		 * structure, and destroy_disp() frees the tcpmsg, so we must 		 * free the event *before* calling destroy_disp(). 		 */
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|tcpmsg
operator|->
name|result
expr_stmt|;
comment|/* 		 * If the recv() was canceled pass the word on. 		 */
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
return|return;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"result %d, length == %d, addr = %p"
argument_list|,
name|tcpmsg
operator|->
name|result
argument_list|,
name|tcpmsg
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|tcpmsg
operator|->
name|buffer
operator|.
name|base
argument_list|)
expr_stmt|;
comment|/* 	 * Peek into the buffer to see what we can see. 	 */
name|dres
operator|=
name|dns_message_peekheader
argument_list|(
operator|&
name|tcpmsg
operator|->
name|buffer
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dres
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"got garbage packet"
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|92
argument_list|)
argument_list|,
literal|"got valid DNS message header, /QR %c, id %u"
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
condition|?
literal|'1'
else|:
literal|'0'
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate an event to send to the query or response client, and 	 * allocate a new buffer for our use. 	 */
comment|/* 	 * Look at flags.  If query, drop it. If response, 	 * look to see where it goes. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Query. 		 */
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Response. 	 */
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|resp
operator|=
name|entry_search
argument_list|(
name|qid
argument_list|,
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"search for response in bucket %d: %s"
argument_list|,
name|bucket
argument_list|,
operator|(
name|resp
operator|==
name|NULL
condition|?
literal|"not found"
else|:
literal|"found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|queue_response
operator|=
name|resp
operator|->
name|item_out
expr_stmt|;
name|rev
operator|=
name|allocate_event
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * At this point, rev contains the event we want to fill in, and 	 * resp contains the information on the place to send it to. 	 * Send the event off. 	 */
name|dns_tcpmsg_keepbuffer
argument_list|(
name|tcpmsg
argument_list|,
operator|&
name|rev
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|++
expr_stmt|;
name|rev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|rev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rev
operator|->
name|addr
operator|=
name|tcpmsg
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|queue_response
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|resp
operator|->
name|items
argument_list|,
name|rev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISC_EVENT_INIT
argument_list|(
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"[b] Sent event %p buffer %p len %d to task %p"
argument_list|,
name|rev
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Restart recv() to get the next packet. 	 */
name|restart
label|:
operator|(
name|void
operator|)
name|startrecv
argument_list|(
name|disp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * disp must be locked.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|startrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dispsocket_t
modifier|*
name|dispsock
parameter_list|)
block|{
name|isc_result_t
name|res
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
operator|&&
name|dispsock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|>=
name|disp
operator|->
name|mgr
operator|->
name|maxbuffers
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
operator|&&
name|dispsock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
if|if
condition|(
name|dispsock
operator|!=
name|NULL
condition|)
name|socket
operator|=
name|dispsock
operator|->
name|socket
expr_stmt|;
else|else
name|socket
operator|=
name|disp
operator|->
name|socket
expr_stmt|;
name|INSIST
argument_list|(
name|socket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|disp
operator|->
name|socktype
condition|)
block|{
comment|/* 		 * UDP reads are always maximal. 		 */
case|case
name|isc_sockettype_udp
case|:
name|region
operator|.
name|length
operator|=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
expr_stmt|;
name|region
operator|.
name|base
operator|=
name|allocate_udp_buffer
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|base
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
if|if
condition|(
name|dispsock
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|isc_socket_recv
argument_list|(
name|socket
argument_list|,
operator|&
name|region
argument_list|,
literal|1
argument_list|,
name|dispsock
operator|->
name|task
argument_list|,
name|udp_exrecv
argument_list|,
name|dispsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|region
operator|.
name|base
argument_list|,
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
block|}
else|else
block|{
name|res
operator|=
name|isc_socket_recv
argument_list|(
name|socket
argument_list|,
operator|&
name|region
argument_list|,
literal|1
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|udp_shrecv
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|region
operator|.
name|base
argument_list|,
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|res
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* recover by cancel */
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|res
operator|=
name|dns_tcpmsg_readmessage
argument_list|(
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|tcp_recv
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|disp
operator|->
name|shutdown_why
operator|=
name|res
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* recover by cancel */
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mgr must be locked when calling this function.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|destroy_mgr_ok
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"destroy_mgr_ok: shuttingdown=%d, listnonempty=%d, "
literal|"epool=%d, rpool=%d, dpool=%d"
argument_list|,
name|MGR_IS_SHUTTINGDOWN
argument_list|(
name|mgr
argument_list|)
argument_list|,
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|epool
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MGR_IS_SHUTTINGDOWN
argument_list|(
name|mgr
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|epool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mgr must be unlocked when calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_mgr
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|mgr
operator|=
operator|*
name|mgrp
expr_stmt|;
operator|*
name|mgrp
operator|=
name|NULL
expr_stmt|;
name|mctx
operator|=
name|mgr
operator|->
name|mctx
expr_stmt|;
name|mgr
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|dpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|bpool
operator|!=
name|NULL
condition|)
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|spool
operator|!=
name|NULL
condition|)
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|spool
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|mgr
operator|->
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_detach
argument_list|(
operator|&
name|mgr
operator|->
name|entropy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BIND9 */
if|if
condition|(
name|mgr
operator|->
name|qid
operator|!=
name|NULL
condition|)
name|qid_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|mgr
operator|->
name|qid
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_detach
argument_list|(
operator|&
name|mgr
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|v4ports
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
operator|->
name|v4ports
argument_list|,
name|mgr
operator|->
name|nv4ports
operator|*
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mgr
operator|->
name|v6ports
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
operator|->
name|v6ports
argument_list|,
name|mgr
operator|->
name|nv6ports
operator|*
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|open_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|sock
operator|=
operator|*
name|sockp
expr_stmt|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_socket_create
argument_list|(
name|mgr
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|local
argument_list|)
argument_list|,
name|isc_sockettype_udp
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_socket_setname
argument_list|(
name|sock
argument_list|,
literal|"dispatcher"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BIND9
name|result
operator|=
name|isc_socket_open
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ISC_ALLOW_MAPPED
name|isc_socket_ipv6only
argument_list|(
name|sock
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|sock
argument_list|,
name|local
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
operator|*
name|sockp
operator|==
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|BIND9
name|isc_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|#
directive|else
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Create a temporary port list to set the initial default set of dispatch  * ports: [1024, 65535].  This is almost meaningless as the application will  * normally set the ports explicitly, but is provided to fill some minor corner  * cases.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|create_default_portset
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_portset_t
modifier|*
modifier|*
name|portsetp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_portset_create
argument_list|(
name|mctx
argument_list|,
name|portsetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_portset_addrange
argument_list|(
operator|*
name|portsetp
argument_list|,
literal|1024
argument_list|,
literal|65535
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Publics.  */
end_comment

begin_function
name|isc_result_t
name|dns_dispatchmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_portset_t
modifier|*
name|v4portset
init|=
name|NULL
decl_stmt|;
name|isc_portset_t
modifier|*
name|v6portset
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mgrp
operator|!=
name|NULL
operator|&&
operator|*
name|mgrp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|mgr
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|mgr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|blackhole
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_arc4_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_buffer_lock
goto|;
name|mgr
operator|->
name|epool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchevent_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|epool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_pool_lock
goto|;
block|}
name|mgr
operator|->
name|rpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispentry_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_epool
goto|;
block|}
name|mgr
operator|->
name|dpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatch_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|dpool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_rpool
goto|;
block|}
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
literal|"dispmgr_epool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
literal|"dispmgr_rpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
literal|"dispmgr_dpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|buffers
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|buffersize
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|bpool
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|spool
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|entropy
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|qid
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|v4ports
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|v6ports
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|nv4ports
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|nv6ports
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|magic
operator|=
name|DNS_DISPATCHMGR_MAGIC
expr_stmt|;
name|result
operator|=
name|create_default_portset
argument_list|(
name|mctx
argument_list|,
operator|&
name|v4portset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|create_default_portset
argument_list|(
name|mctx
argument_list|,
operator|&
name|v6portset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|dns_dispatchmgr_setavailports
argument_list|(
name|mgr
argument_list|,
name|v4portset
argument_list|,
name|v6portset
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v4portset
operator|!=
name|NULL
condition|)
name|isc_portset_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|v4portset
argument_list|)
expr_stmt|;
if|if
condition|(
name|v6portset
operator|!=
name|NULL
condition|)
name|isc_portset_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|v6portset
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_dpool
goto|;
ifdef|#
directive|ifdef
name|BIND9
if|if
condition|(
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_attach
argument_list|(
name|entropy
argument_list|,
operator|&
name|mgr
operator|->
name|entropy
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|entropy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dispatch_initrandom
argument_list|(
operator|&
name|mgr
operator|->
name|arc4ctx
argument_list|,
name|mgr
operator|->
name|entropy
argument_list|,
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
operator|*
name|mgrp
operator|=
name|mgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|kill_dpool
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|dpool
argument_list|)
expr_stmt|;
name|kill_rpool
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
name|kill_epool
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
name|kill_pool_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|kill_buffer_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|kill_arc4_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
name|kill_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|deallocate
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_setblackhole
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_acl_t
modifier|*
name|blackhole
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|blackhole
argument_list|,
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_dispatchmgr_getblackhole
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mgr
operator|->
name|blackhole
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_setblackportlist
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_portlist_t
modifier|*
name|portlist
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|portlist
argument_list|)
expr_stmt|;
comment|/* This function is deprecated: use dns_dispatchmgr_setavailports(). */
return|return;
block|}
end_function

begin_function
name|dns_portlist_t
modifier|*
name|dns_dispatchmgr_getblackportlist
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* this function is deprecated */
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatchmgr_setavailports
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_portset_t
modifier|*
name|v4portset
parameter_list|,
name|isc_portset_t
modifier|*
name|v6portset
parameter_list|)
block|{
name|in_port_t
modifier|*
name|v4ports
decl_stmt|,
modifier|*
name|v6ports
decl_stmt|,
name|p
decl_stmt|;
name|unsigned
name|int
name|nv4ports
decl_stmt|,
name|nv6ports
decl_stmt|,
name|i4
decl_stmt|,
name|i6
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|nv4ports
operator|=
name|isc_portset_nports
argument_list|(
name|v4portset
argument_list|)
expr_stmt|;
name|nv6ports
operator|=
name|isc_portset_nports
argument_list|(
name|v6portset
argument_list|)
expr_stmt|;
name|v4ports
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nv4ports
operator|!=
literal|0
condition|)
block|{
name|v4ports
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
operator|*
name|nv4ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|v4ports
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|v6ports
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nv6ports
operator|!=
literal|0
condition|)
block|{
name|v6ports
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
operator|*
name|nv6ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|v6ports
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|v4ports
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|v4ports
argument_list|,
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
operator|*
name|isc_portset_nports
argument_list|(
name|v4portset
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
name|p
operator|=
literal|0
expr_stmt|;
name|i4
operator|=
literal|0
expr_stmt|;
name|i6
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|isc_portset_isset
argument_list|(
name|v4portset
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|i4
operator|<
name|nv4ports
argument_list|)
expr_stmt|;
name|v4ports
index|[
name|i4
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|isc_portset_isset
argument_list|(
name|v6portset
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|i6
operator|<
name|nv6ports
argument_list|)
expr_stmt|;
name|v6ports
index|[
name|i6
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
do|while
condition|(
name|p
operator|++
operator|<
literal|65535
condition|)
do|;
name|INSIST
argument_list|(
name|i4
operator|==
name|nv4ports
operator|&&
name|i6
operator|==
name|nv6ports
argument_list|)
expr_stmt|;
name|PORTBUFLOCK
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|v4ports
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|mgr
operator|->
name|v4ports
argument_list|,
name|mgr
operator|->
name|nv4ports
operator|*
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mgr
operator|->
name|v4ports
operator|=
name|v4ports
expr_stmt|;
name|mgr
operator|->
name|nv4ports
operator|=
name|nv4ports
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|v6ports
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|mgr
operator|->
name|v6ports
argument_list|,
name|mgr
operator|->
name|nv6ports
operator|*
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mgr
operator|->
name|v6ports
operator|=
name|v6ports
expr_stmt|;
name|mgr
operator|->
name|nv6ports
operator|=
name|nv6ports
expr_stmt|;
name|PORTBUFUNLOCK
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_dispatchmgr_setudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buffersize
operator|>=
literal|512
operator|&&
name|buffersize
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|maxbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
comment|/* 	 * Keep some number of items around.  This should be a config 	 * option.  For now, keep 8, but later keep at least two even 	 * if the caller wants less.  This allows us to ensure certain 	 * things, like an event can be "freed" and the next allocation 	 * will always succeed. 	 * 	 * Note that if limits are placed on anything here, we use one 	 * event internally, so the actual limit should be "wanted + 1." 	 * 	 * XXXMLG 	 */
if|if
condition|(
name|maxbuffers
operator|<
literal|8
condition|)
name|maxbuffers
operator|=
literal|8
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
comment|/* Create or adjust buffer pool */
if|if
condition|(
name|mgr
operator|->
name|bpool
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We only increase the maxbuffers to avoid accidental buffer 		 * shortage.  Ideally we'd separate the manager-wide maximum 		 * from per-dispatch limits and respect the latter within the 		 * global limit.  But at this moment that's deemed to be 		 * overkilling and isn't worth additional implementation 		 * complexity. 		 */
if|if
condition|(
name|maxbuffers
operator|>
name|mgr
operator|->
name|maxbuffers
condition|)
block|{
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
name|maxbuffers
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
name|maxbuffers
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|=
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|buffersize
argument_list|,
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
literal|"dispmgr_bpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
name|maxbuffers
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Create or adjust socket pool */
if|if
condition|(
name|mgr
operator|->
name|spool
operator|!=
name|NULL
condition|)
block|{
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|spool
argument_list|,
name|DNS_DISPATCH_POOLSOCKS
operator|*
literal|2
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|result
operator|=
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dispsocket_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|spool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|spool
argument_list|,
literal|"dispmgr_spool"
argument_list|)
expr_stmt|;
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|spool
argument_list|,
name|maxrequests
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|spool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|qid_allocate
argument_list|(
name|mgr
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|,
operator|&
name|mgr
operator|->
name|qid
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|mgr
operator|->
name|buffersize
operator|=
name|buffersize
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
name|maxbuffers
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|spool
operator|!=
name|NULL
condition|)
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|spool
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_destroy
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|mgrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
operator|*
name|mgrp
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|=
operator|*
name|mgrp
expr_stmt|;
operator|*
name|mgrp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|state
operator||=
name|MGR_SHUTTINGDOWN
expr_stmt|;
name|killit
operator|=
name|destroy_mgr_ok
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"destroy: killit=%d"
argument_list|,
name|killit
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|destroy_mgr
argument_list|(
operator|&
name|mgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_setstats
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mgr
operator|->
name|stats
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|isc_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|mgr
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|port_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|ent
parameter_list|)
block|{
name|in_port_t
name|p1
init|=
operator|*
operator|(
specifier|const
name|in_port_t
operator|*
operator|)
name|key
decl_stmt|;
name|in_port_t
name|p2
init|=
operator|*
operator|(
specifier|const
name|in_port_t
operator|*
operator|)
name|ent
decl_stmt|;
if|if
condition|(
name|p1
operator|<
name|p2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|portavailable
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddrp
parameter_list|)
block|{
name|isc_sockaddr_t
name|sockaddr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|in_port_t
modifier|*
name|ports
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|int
name|nports
decl_stmt|;
name|isc_boolean_t
name|available
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|!=
name|NULL
operator|||
name|sockaddrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|PORTBUFLOCK
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
block|{
name|sockaddrp
operator|=
operator|&
name|sockaddr
expr_stmt|;
name|result
operator|=
name|isc_socket_getsockname
argument_list|(
name|sock
argument_list|,
name|sockaddrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
name|sockaddrp
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|ports
operator|=
name|mgr
operator|->
name|v4ports
expr_stmt|;
name|nports
operator|=
name|mgr
operator|->
name|nv4ports
expr_stmt|;
block|}
else|else
block|{
name|ports
operator|=
name|mgr
operator|->
name|v6ports
expr_stmt|;
name|nports
operator|=
name|mgr
operator|->
name|nv6ports
expr_stmt|;
block|}
if|if
condition|(
name|ports
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|port
operator|=
name|isc_sockaddr_getport
argument_list|(
name|sockaddrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsearch
argument_list|(
operator|&
name|port
argument_list|,
name|ports
argument_list|,
name|nports
argument_list|,
sizeof|sizeof
argument_list|(
name|in_port_t
argument_list|)
argument_list|,
name|port_cmp
argument_list|)
operator|!=
name|NULL
condition|)
name|available
operator|=
name|ISC_TRUE
expr_stmt|;
name|unlock
label|:
name|PORTBUFUNLOCK
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
return|return
operator|(
name|available
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATTRMATCH
parameter_list|(
name|_a1
parameter_list|,
name|_a2
parameter_list|,
name|_mask
parameter_list|)
value|(((_a1)& (_mask)) == ((_a2)& (_mask)))
end_define

begin_function
specifier|static
name|isc_boolean_t
name|local_addr_match
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|)
block|{
name|isc_sockaddr_t
name|sockaddr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|disp
operator|->
name|socket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Don't match wildcard ports unless the port is available in the 	 * current configuration. 	 */
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|portavailable
argument_list|(
name|disp
operator|->
name|mgr
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
comment|/* 	 * Check if we match the binding<address,port>. 	 * Wildcard ports match/fail here. 	 */
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * Check if we match a bound wildcard port<address,port>. 	 */
if|if
condition|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|isc_socket_getsockname
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
operator|&
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|sockaddr
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Requires mgr be locked.  *  * No dispatcher can be locked by this thread when calling this function.  *  *  * NOTE:  *	If a matching dispatcher is found, it is locked after this function  *	returns, and must be unlocked by the caller.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dispatch_find
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Make certain that we will not match a private or exclusive dispatch. 	 */
name|attributes
operator|&=
operator|~
operator|(
name|DNS_DISPATCHATTR_PRIVATE
operator||
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
expr_stmt|;
name|mask
operator||=
operator|(
name|DNS_DISPATCHATTR_PRIVATE
operator||
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
expr_stmt|;
name|disp
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|disp
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|shutting_down
operator|==
literal|0
operator|)
operator|&&
name|ATTRMATCH
argument_list|(
name|disp
operator|->
name|attributes
argument_list|,
name|attributes
argument_list|,
name|mask
argument_list|)
operator|&&
name|local_addr_match
argument_list|(
name|disp
argument_list|,
name|local
argument_list|)
condition|)
break|break;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|qid_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|,
name|isc_boolean_t
name|needsocktable
parameter_list|)
block|{
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|qidp
operator|!=
name|NULL
operator|&&
operator|*
name|qidp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qid
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|qid
operator|->
name|qid_table
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|->
name|qid_table
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|qid
operator|->
name|sock_table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|needsocktable
condition|)
block|{
name|qid
operator|->
name|sock_table
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dispsocketlist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|->
name|sock_table
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
operator|->
name|qid_table
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
block|}
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|qid
operator|->
name|sock_table
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
operator|->
name|sock_table
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dispsocketlist_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
operator|->
name|qid_table
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buckets
condition|;
name|i
operator|++
control|)
block|{
name|ISC_LIST_INIT
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|->
name|sock_table
operator|!=
name|NULL
condition|)
name|ISC_LIST_INIT
argument_list|(
name|qid
operator|->
name|sock_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|qid
operator|->
name|qid_nbuckets
operator|=
name|buckets
expr_stmt|;
name|qid
operator|->
name|qid_increment
operator|=
name|increment
expr_stmt|;
name|qid
operator|->
name|magic
operator|=
name|QID_MAGIC
expr_stmt|;
operator|*
name|qidp
operator|=
name|qid
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|qid_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
block|{
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|qidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|qid
operator|=
operator|*
name|qidp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QID
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|qidp
operator|=
name|NULL
expr_stmt|;
name|qid
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|qid
operator|->
name|qid_table
argument_list|,
name|qid
operator|->
name|qid_nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|->
name|sock_table
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|qid
operator|->
name|sock_table
argument_list|,
name|qid
operator|->
name|qid_nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|dispsocketlist_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DESTROYLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and set important limits.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dispatch_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the dispatcher, mostly.  Don't bother setting some of 	 * the options that are controlled by tcp vs. udp, etc. 	 */
name|disp
operator|=
name|isc_mempool_get
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|disp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|mgr
operator|=
name|mgr
expr_stmt|;
name|disp
operator|->
name|maxrequests
operator|=
name|maxrequests
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|->
name|localport
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|disp
operator|->
name|requests
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|qid
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|)
expr_stmt|;
name|disp
operator|->
name|nsockets
operator|=
literal|0
expr_stmt|;
name|dispatch_initrandom
argument_list|(
operator|&
name|disp
operator|->
name|arc4ctx
argument_list|,
name|mgr
operator|->
name|entropy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|disp
operator|->
name|port_table
operator|=
name|NULL
expr_stmt|;
name|disp
operator|->
name|portpool
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate
goto|;
name|disp
operator|->
name|failsafe_ev
operator|=
name|allocate_event
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|failsafe_ev
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_lock
goto|;
block|}
name|disp
operator|->
name|magic
operator|=
name|DISPATCH_MAGIC
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* 	 * error returns 	 */
name|kill_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|deallocate
label|:
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MUST be unlocked, and not used by anything.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_free
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
operator|*
name|dispp
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|*
name|dispp
expr_stmt|;
operator|*
name|dispp
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|tcpmsg_valid
condition|)
block|{
name|dns_tcpmsg_invalidate
argument_list|(
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|0
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|tcpbuffers
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|requests
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|disp
operator|->
name|inactivesockets
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
name|disp
operator|->
name|failsafe_ev
argument_list|)
expr_stmt|;
name|disp
operator|->
name|failsafe_ev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|qid
operator|!=
name|NULL
condition|)
name|qid_destroy
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
operator|&
name|disp
operator|->
name|qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|port_table
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_DISPATCH_PORTTABLESIZE
condition|;
name|i
operator|++
control|)
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|disp
operator|->
name|port_table
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
operator|->
name|port_table
argument_list|,
sizeof|sizeof
argument_list|(
name|disp
operator|->
name|port_table
index|[
literal|0
index|]
argument_list|)
operator|*
name|DNS_DISPATCH_PORTTABLESIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|->
name|portpool
operator|!=
name|NULL
condition|)
name|isc_mempool_destroy
argument_list|(
operator|&
name|disp
operator|->
name|portpool
argument_list|)
expr_stmt|;
name|disp
operator|->
name|mgr
operator|=
name|NULL
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_createtcp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|UNUSED
argument_list|(
name|maxbuffers
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|buffersize
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|isc_socket_gettype
argument_list|(
name|sock
argument_list|)
operator|==
name|isc_sockettype_tcp
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_TCP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_UDP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|attributes
operator||=
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
comment|/* XXXMLG */
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * dispatch_allocate() checks mgr for us. 	 * qid_allocate() checks buckets and increment for us. 	 */
name|disp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dispatch_allocate
argument_list|(
name|mgr
argument_list|,
name|maxrequests
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|qid_allocate
argument_list|(
name|mgr
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|,
operator|&
name|disp
operator|->
name|qid
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
name|disp
operator|->
name|socktype
operator|=
name|isc_sockettype_tcp
expr_stmt|;
name|disp
operator|->
name|socket
operator|=
name|NULL
expr_stmt|;
name|isc_socket_attach
argument_list|(
name|sock
argument_list|,
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|disp
operator|->
name|ntasks
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|task
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_socket
goto|;
name|disp
operator|->
name|ctlevent
operator|=
name|isc_event_allocate
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
argument_list|,
name|DNS_EVENT_DISPATCHCONTROL
argument_list|,
name|destroy_disp
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|ctlevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_task
goto|;
block|}
name|isc_task_setname
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
literal|"tcpdispatch"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dns_tcpmsg_init
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
name|attributes
expr_stmt|;
comment|/* 	 * Append it to the dispatcher list. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created TCP dispatcher %p"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created task %p"
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* 	 * Error returns. 	 */
name|kill_task
label|:
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|kill_socket
label|:
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|deallocate_dispatch
label|:
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_getudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sockmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|localaddr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|taskmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buffersize
operator|>=
literal|512
operator|&&
name|buffersize
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|maxbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_TCP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dispatchmgr_setudp
argument_list|(
name|mgr
argument_list|,
name|buffersize
argument_list|,
name|maxbuffers
argument_list|,
name|maxrequests
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|REQUIRE
argument_list|(
name|isc_sockaddr_getport
argument_list|(
name|localaddr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|createudp
goto|;
block|}
comment|/* 	 * See if we have a dispatcher that matches. 	 */
name|result
operator|=
name|dispatch_find
argument_list|(
name|mgr
argument_list|,
name|localaddr
argument_list|,
name|attributes
argument_list|,
name|mask
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|maxrequests
operator|<
name|maxrequests
condition|)
name|disp
operator|->
name|maxrequests
operator|=
name|maxrequests
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|createudp
label|:
comment|/* 	 * Nope, create one. 	 */
name|result
operator|=
name|dispatch_createudp
argument_list|(
name|mgr
argument_list|,
name|sockmgr
argument_list|,
name|taskmgr
argument_list|,
name|localaddr
argument_list|,
name|maxrequests
argument_list|,
name|attributes
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mgr should be locked.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DISPATCH_HELD
end_ifndef

begin_define
define|#
directive|define
name|DNS_DISPATCH_HELD
value|20U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|get_udpsocket
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|isc_socket_t
modifier|*
name|held
index|[
name|DNS_DISPATCH_HELD
index|]
decl_stmt|;
name|isc_sockaddr_t
name|localaddr_bound
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|anyport
decl_stmt|;
name|INSIST
argument_list|(
name|sockp
operator|!=
name|NULL
operator|&&
operator|*
name|sockp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|localaddr_bound
operator|=
operator|*
name|localaddr
expr_stmt|;
name|anyport
operator|=
name|ISC_TF
argument_list|(
name|isc_sockaddr_getport
argument_list|(
name|localaddr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|anyport
condition|)
block|{
name|unsigned
name|int
name|nports
decl_stmt|;
name|in_port_t
modifier|*
name|ports
decl_stmt|;
comment|/* 		 * If no port is specified, we first try to pick up a random 		 * port by ourselves. 		 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|==
name|AF_INET
condition|)
block|{
name|nports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|nv4ports
expr_stmt|;
name|ports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|v4ports
expr_stmt|;
block|}
else|else
block|{
name|nports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|nv6ports
expr_stmt|;
name|ports
operator|=
name|disp
operator|->
name|mgr
operator|->
name|v6ports
expr_stmt|;
block|}
if|if
condition|(
name|nports
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
name|in_port_t
name|prt
decl_stmt|;
name|prt
operator|=
name|ports
index|[
name|dispatch_uniformrandom
argument_list|(
name|DISP_ARC4CTX
argument_list|(
name|disp
argument_list|)
argument_list|,
name|nports
argument_list|)
index|]
expr_stmt|;
name|isc_sockaddr_setport
argument_list|(
operator|&
name|localaddr_bound
argument_list|,
name|prt
argument_list|)
expr_stmt|;
name|result
operator|=
name|open_socket
argument_list|(
name|sockmgr
argument_list|,
operator|&
name|localaddr_bound
argument_list|,
literal|0
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|!=
name|ISC_R_ADDRINUSE
condition|)
block|{
name|disp
operator|->
name|localport
operator|=
name|prt
expr_stmt|;
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* 		 * If this fails 1024 times, we then ask the kernel for 		 * choosing one. 		 */
block|}
else|else
block|{
comment|/* Allow to reuse address for non-random ports. */
name|result
operator|=
name|open_socket
argument_list|(
name|sockmgr
argument_list|,
name|localaddr
argument_list|,
name|ISC_SOCKET_REUSEADDRESS
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|memset
argument_list|(
name|held
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|held
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|0xffffU
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|=
name|open_socket
argument_list|(
name|sockmgr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|end
goto|;
elseif|else
if|if
condition|(
operator|!
name|anyport
condition|)
break|break;
elseif|else
if|if
condition|(
name|portavailable
argument_list|(
name|mgr
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
if|if
condition|(
name|held
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|held
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|held
index|[
name|i
operator|++
index|]
operator|=
name|sock
expr_stmt|;
name|sock
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DNS_DISPATCH_HELD
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0xffffU
condition|)
block|{
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"avoid-v%s-udp-ports: unable to allocate "
literal|"an available port"
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|localaddr
argument_list|)
operator|==
name|AF_INET
condition|?
literal|"4"
else|:
literal|"6"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
name|end
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_DISPATCH_HELD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|held
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|held
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dispatch_createudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 	 * dispatch_allocate() checks mgr for us. 	 */
name|disp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dispatch_allocate
argument_list|(
name|mgr
argument_list|,
name|maxrequests
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|get_udpsocket
argument_list|(
name|mgr
argument_list|,
name|disp
argument_list|,
name|sockmgr
argument_list|,
name|localaddr
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
block|}
else|else
block|{
name|isc_sockaddr_t
name|sa_any
decl_stmt|;
comment|/* 		 * For dispatches using exclusive sockets with a specific 		 * source address, we only check if the specified address is 		 * available on the system.  Query sockets will be created later 		 * on demand. 		 */
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|sa_any
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|localaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|sa_any
argument_list|,
name|localaddr
argument_list|)
condition|)
block|{
name|result
operator|=
name|open_socket
argument_list|(
name|sockmgr
argument_list|,
name|localaddr
argument_list|,
literal|0
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
block|}
name|disp
operator|->
name|port_table
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|disp
operator|->
name|port_table
index|[
literal|0
index|]
argument_list|)
operator|*
name|DNS_DISPATCH_PORTTABLESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|port_table
operator|==
name|NULL
condition|)
goto|goto
name|deallocate_dispatch
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_DISPATCH_PORTTABLESIZE
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|disp
operator|->
name|port_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dispportentry_t
argument_list|)
argument_list|,
operator|&
name|disp
operator|->
name|portpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
name|isc_mempool_setname
argument_list|(
name|disp
operator|->
name|portpool
argument_list|,
literal|"disp_portpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|disp
operator|->
name|portpool
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
name|disp
operator|->
name|socktype
operator|=
name|isc_sockettype_udp
expr_stmt|;
name|disp
operator|->
name|socket
operator|=
name|sock
expr_stmt|;
name|disp
operator|->
name|local
operator|=
operator|*
name|localaddr
expr_stmt|;
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
name|disp
operator|->
name|ntasks
operator|=
name|MAX_INTERNAL_TASKS
expr_stmt|;
else|else
name|disp
operator|->
name|ntasks
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|disp
operator|->
name|ntasks
condition|;
name|i
operator|++
control|)
block|{
name|disp
operator|->
name|task
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|isc_task_shutdown
argument_list|(
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|kill_socket
goto|;
block|}
name|isc_task_setname
argument_list|(
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|,
literal|"udpdispatch"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|disp
operator|->
name|ctlevent
operator|=
name|isc_event_allocate
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
argument_list|,
name|DNS_EVENT_DISPATCHCONTROL
argument_list|,
name|destroy_disp
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|ctlevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_task
goto|;
block|}
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_TCP
expr_stmt|;
name|attributes
operator||=
name|DNS_DISPATCHATTR_UDP
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
name|attributes
expr_stmt|;
comment|/* 	 * Append it to the dispatcher list. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created UDP dispatcher %p"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created task %p"
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|disp
operator|->
name|socket
operator|!=
name|NULL
condition|)
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created socket %p"
argument_list|,
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Error returns. 	 */
name|kill_task
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|disp
operator|->
name|ntasks
condition|;
name|i
operator|++
control|)
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kill_socket
label|:
if|if
condition|(
name|disp
operator|->
name|socket
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|deallocate_dispatch
label|:
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_attach
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It is important to lock the manager while we are deleting the dispatch,  * since dns_dispatch_getudp will call dispatch_find, which returns to  * the caller a dispatch but does not attach to it until later.  _getudp  * locks the manager, however, so locking it here will keep us from attaching  * to a dispatcher that is in the process of going away.  */
end_comment

begin_function
name|void
name|dns_dispatch_detach
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsock
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
name|VALID_DISPATCH
argument_list|(
operator|*
name|dispp
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|*
name|dispp
expr_stmt|;
operator|*
name|dispp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
for|for
control|(
name|dispsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
init|;
name|dispsock
operator|!=
name|NULL
condition|;
name|dispsock
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dispsock
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_socket_cancel
argument_list|(
name|dispsock
operator|->
name|socket
argument_list|,
name|dispsock
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"detach: refcount %d"
argument_list|,
name|disp
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_addresponse2
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_messageid_t
modifier|*
name|idp
parameter_list|,
name|dns_dispentry_t
modifier|*
modifier|*
name|resp
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|in_port_t
name|localport
init|=
literal|0
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|ok
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsocket
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
operator|&&
operator|*
name|resp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|idp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
name|REQUIRE
argument_list|(
name|sockmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SHUTTINGDOWN
operator|)
return|;
block|}
if|if
condition|(
name|disp
operator|->
name|requests
operator|>=
name|disp
operator|->
name|maxrequests
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_QUOTA
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
operator|&&
name|disp
operator|->
name|nsockets
operator|>
name|DNS_DISPATCH_SOCKSQUOTA
condition|)
block|{
name|dispsocket_t
modifier|*
name|oldestsocket
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|oldestresp
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|rev
decl_stmt|;
comment|/* 		 * Kill oldest outstanding query if the number of sockets 		 * exceeds the quota to keep the room for new queries. 		 */
name|oldestsocket
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
expr_stmt|;
name|oldestresp
operator|=
name|oldestsocket
operator|->
name|resp
expr_stmt|;
if|if
condition|(
name|oldestresp
operator|!=
name|NULL
operator|&&
operator|!
name|oldestresp
operator|->
name|item_out
condition|)
block|{
name|rev
operator|=
name|allocate_event
argument_list|(
name|oldestresp
operator|->
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
block|{
name|rev
operator|->
name|buffer
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|rev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|rev
operator|->
name|id
operator|=
name|oldestresp
operator|->
name|id
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|oldestresp
operator|->
name|action
argument_list|,
name|oldestresp
operator|->
name|arg
argument_list|,
name|oldestresp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|oldestresp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|oldestresp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|disp
operator|->
name|mgr
argument_list|,
name|dns_resstatscounter_dispabort
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Move this entry to the tail so that it won't (easily) be 		 * examined before actually being canceled. 		 */
name|ISC_LIST_UNLINK
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|,
name|oldestsocket
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|,
name|oldestsocket
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Get a separate UDP socket with a random port number. 		 */
name|result
operator|=
name|get_dispsocket
argument_list|(
name|disp
argument_list|,
name|dest
argument_list|,
name|sockmgr
argument_list|,
name|qid
argument_list|,
operator|&
name|dispsocket
argument_list|,
operator|&
name|localport
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|disp
operator|->
name|mgr
argument_list|,
name|dns_resstatscounter_dispsockfail
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
else|else
block|{
name|localport
operator|=
name|disp
operator|->
name|localport
expr_stmt|;
block|}
comment|/* 	 * Try somewhat hard to find an unique ID. 	 */
name|id
operator|=
operator|(
name|dns_messageid_t
operator|)
name|dispatch_random
argument_list|(
name|DISP_ARC4CTX
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|localport
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|entry_search
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|localport
argument_list|,
name|bucket
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ok
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|id
operator|+=
name|qid
operator|->
name|qid_increment
expr_stmt|;
name|id
operator|&=
literal|0x0000ffff
expr_stmt|;
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|localport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
name|res
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsocket
operator|!=
name|NULL
condition|)
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsocket
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
name|disp
operator|->
name|requests
operator|++
expr_stmt|;
name|res
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
name|res
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|res
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|res
operator|->
name|port
operator|=
name|localport
expr_stmt|;
name|res
operator|->
name|bucket
operator|=
name|bucket
expr_stmt|;
name|res
operator|->
name|host
operator|=
operator|*
name|dest
expr_stmt|;
name|res
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|res
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|res
operator|->
name|dispsocket
operator|=
name|dispsocket
expr_stmt|;
if|if
condition|(
name|dispsocket
operator|!=
name|NULL
condition|)
name|dispsocket
operator|->
name|resp
operator|=
name|res
expr_stmt|;
name|res
operator|->
name|item_out
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|res
operator|->
name|magic
operator|=
name|RESPONSE_MAGIC
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|,
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|res
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"attached to task %p"
argument_list|,
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_UDP
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_CONNECTED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|result
operator|=
name|startrecv
argument_list|(
name|disp
argument_list|,
name|dispsocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|,
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispsocket
operator|!=
name|NULL
condition|)
name|destroy_dispsocket
argument_list|(
name|disp
argument_list|,
operator|&
name|dispsocket
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|--
expr_stmt|;
name|disp
operator|->
name|requests
operator|--
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|rpool
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dispsocket
operator|!=
name|NULL
condition|)
name|ISC_LIST_APPEND
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|,
name|dispsocket
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|idp
operator|=
name|id
expr_stmt|;
operator|*
name|resp
operator|=
name|res
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
name|INSIST
argument_list|(
name|res
operator|->
name|dispsocket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_addresponse
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_messageid_t
modifier|*
name|idp
parameter_list|,
name|dns_dispentry_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dns_dispatch_addresponse2
argument_list|(
name|disp
argument_list|,
name|dest
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|idp
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_starttcp
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"starttcp %p"
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_CONNECTED
expr_stmt|;
operator|(
name|void
operator|)
name|startrecv
argument_list|(
name|disp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_removeresponse
parameter_list|(
name|dns_dispentry_t
modifier|*
modifier|*
name|resp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
modifier|*
name|sockevent
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|dispsocket_t
modifier|*
name|dispsock
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|isc_eventlist_t
name|events
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESPONSE
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|*
name|resp
expr_stmt|;
operator|*
name|resp
operator|=
name|NULL
expr_stmt|;
name|disp
operator|=
name|res
operator|->
name|disp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockevent
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
operator|*
name|sockevent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|=
operator|*
name|sockevent
expr_stmt|;
operator|*
name|sockevent
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ev
operator|=
name|NULL
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|requests
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|requests
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
for|for
control|(
name|dispsock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|disp
operator|->
name|activesockets
argument_list|)
init|;
name|dispsock
operator|!=
name|NULL
condition|;
name|dispsock
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dispsock
argument_list|,
name|link
argument_list|)
control|)
block|{
name|isc_socket_cancel
argument_list|(
name|dispsock
operator|->
name|socket
argument_list|,
name|dispsock
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
block|}
name|bucket
operator|=
name|res
operator|->
name|bucket
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|,
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
operator|&&
name|res
operator|->
name|item_out
condition|)
block|{
comment|/* 		 * We've posted our event, but the caller hasn't gotten it 		 * yet.  Take it back. 		 */
name|ISC_LIST_INIT
argument_list|(
name|events
argument_list|)
expr_stmt|;
name|n
operator|=
name|isc_task_unsend
argument_list|(
name|res
operator|->
name|task
argument_list|,
name|res
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|NULL
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
comment|/* 		 * We had better have gotten it back. 		 */
name|INSIST
argument_list|(
name|n
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ev
operator|=
operator|(
name|dns_dispatchevent_t
operator|*
operator|)
name|ISC_LIST_HEAD
argument_list|(
name|events
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|res
operator|->
name|item_out
operator|==
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|res
operator|->
name|item_out
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|buffer
operator|.
name|base
operator|!=
name|NULL
condition|)
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_event
argument_list|(
name|disp
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|request_log
argument_list|(
name|disp
argument_list|,
name|res
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"detaching from task %p"
argument_list|,
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|dispsocket
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_cancel
argument_list|(
name|res
operator|->
name|dispsocket
operator|->
name|socket
argument_list|,
name|res
operator|->
name|dispsocket
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
name|res
operator|->
name|dispsocket
operator|->
name|resp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Free any buffered requests as well 	 */
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
while|while
condition|(
name|ev
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|items
argument_list|,
name|ev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|buffer
operator|.
name|base
operator|!=
name|NULL
condition|)
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_event
argument_list|(
name|disp
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|rpool
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|startrecv
argument_list|(
name|disp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutdown_out
operator|==
literal|1
condition|)
return|return;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
comment|/* 	 * Search for the first response handler without packets outstanding 	 * unless a specific hander is given. 	 */
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|resp
operator|=
name|linear_first
argument_list|(
name|qid
argument_list|)
init|;
name|resp
operator|!=
name|NULL
operator|&&
name|resp
operator|->
name|item_out
condition|;
comment|/* Empty. */
control|)
name|resp
operator|=
name|linear_next
argument_list|(
name|qid
argument_list|,
name|resp
argument_list|)
expr_stmt|;
comment|/* 	 * No one to send the cancel event to, so nothing to do. 	 */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * Send the shutdown failsafe event to this resp. 	 */
name|ev
operator|=
name|disp
operator|->
name|failsafe_ev
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|->
name|result
operator|=
name|disp
operator|->
name|shutdown_why
expr_stmt|;
name|ev
operator|->
name|buffer
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ev
operator|->
name|buffer
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|1
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"cancel: failsafe event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_socket_t
modifier|*
name|dns_dispatch_getsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|disp
operator|->
name|socket
operator|)
return|;
block|}
end_function

begin_function
name|isc_socket_t
modifier|*
name|dns_dispatch_getentrysocket
parameter_list|(
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_RESPONSE
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|dispsocket
operator|!=
name|NULL
condition|)
return|return
operator|(
name|resp
operator|->
name|dispsocket
operator|->
name|socket
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_getlocaladdress
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addrp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|socktype
operator|==
name|isc_sockettype_udp
condition|)
block|{
operator|*
name|addrp
operator|=
name|disp
operator|->
name|local
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|disp
operator|->
name|shutdown_why
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|unsigned
name|int
name|dns_dispatch_getattributes
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't bother locking disp here; it's the caller's responsibility 	 * to use only non volatile flags. 	 */
return|return
operator|(
name|disp
operator|->
name|attributes
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_changeattributes
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Exclusive attribute can only be set on creation */
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Also, a dispatch with randomport specified cannot start listening */
name|REQUIRE
argument_list|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_EXCLUSIVE
operator|)
operator|==
literal|0
operator|||
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* XXXMLG 	 * Should check for valid attributes here! 	 */
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
operator|(
name|void
operator|)
name|startrecv
argument_list|(
name|disp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
block|}
name|disp
operator|->
name|attributes
operator|&=
operator|~
name|mask
expr_stmt|;
name|disp
operator|->
name|attributes
operator||=
operator|(
name|attributes
operator|&
name|mask
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_importrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sevent
decl_stmt|,
modifier|*
name|newsevent
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|INSIST
argument_list|(
name|sevent
operator|->
name|n
operator|<=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
argument_list|)
expr_stmt|;
name|newsevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_IMPORTRECVDONE
argument_list|,
name|udp_shrecv
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_socketevent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsevent
operator|==
name|NULL
condition|)
return|return;
name|buf
operator|=
name|allocate_udp_buffer
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|newsevent
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|sevent
operator|->
name|region
operator|.
name|base
argument_list|,
name|sevent
operator|->
name|n
argument_list|)
expr_stmt|;
name|newsevent
operator|->
name|region
operator|.
name|base
operator|=
name|buf
expr_stmt|;
name|newsevent
operator|->
name|region
operator|.
name|length
operator|=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
expr_stmt|;
name|newsevent
operator|->
name|n
operator|=
name|sevent
operator|->
name|n
expr_stmt|;
name|newsevent
operator|->
name|result
operator|=
name|sevent
operator|->
name|result
expr_stmt|;
name|newsevent
operator|->
name|address
operator|=
name|sevent
operator|->
name|address
expr_stmt|;
name|newsevent
operator|->
name|timestamp
operator|=
name|sevent
operator|->
name|timestamp
expr_stmt|;
name|newsevent
operator|->
name|pktinfo
operator|=
name|sevent
operator|->
name|pktinfo
expr_stmt|;
name|newsevent
operator|->
name|attributes
operator|=
name|sevent
operator|->
name|attributes
expr_stmt|;
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
index|[
literal|0
index|]
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|newsevent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void dns_dispatchmgr_dump(dns_dispatchmgr_t *mgr) { 	dns_dispatch_t *disp; 	char foo[1024];  	disp = ISC_LIST_HEAD(mgr->list); 	while (disp != NULL) { 		isc_sockaddr_format(&disp->local, foo, sizeof(foo)); 		printf("\tdispatch %p, addr %s\n", disp, foo); 		disp = ISC_LIST_NEXT(disp, link); 	} }
endif|#
directive|endif
end_endif

end_unit

