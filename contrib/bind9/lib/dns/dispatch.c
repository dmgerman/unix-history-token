begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004, 2006, 2007  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: dispatch.c,v 1.101.2.6.2.21.4.1 2008/05/22 21:11:15 each Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/dispatch.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dns/message.h>
end_include

begin_include
include|#
directive|include
file|<dns/portlist.h>
end_include

begin_include
include|#
directive|include
file|<dns/tcpmsg.h>
end_include

begin_include
include|#
directive|include
file|<dns/types.h>
end_include

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_dispentry_t
argument_list|)
name|dns_displist_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dns_qid
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|unsigned
name|int
name|qid_nbuckets
decl_stmt|;
comment|/* hash table size */
name|unsigned
name|int
name|qid_increment
decl_stmt|;
comment|/* id increment on collision */
name|isc_mutex_t
name|lock
decl_stmt|;
name|dns_displist_t
modifier|*
name|qid_table
decl_stmt|;
comment|/* the table itself */
block|}
name|dns_qid_t
typedef|;
end_typedef

begin_comment
comment|/* ARC4 Random generator state */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arc4ctx
block|{
name|isc_uint8_t
name|i
decl_stmt|;
name|isc_uint8_t
name|j
decl_stmt|;
name|isc_uint8_t
name|s
index|[
literal|256
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
name|arc4ctx_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dns_dispatchmgr
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_acl_t
modifier|*
name|blackhole
decl_stmt|;
name|dns_portlist_t
modifier|*
name|portlist
decl_stmt|;
comment|/* Locked by "lock". */
name|isc_mutex_t
name|lock
decl_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_dispatch_t
argument_list|)
name|list
expr_stmt|;
comment|/* Locked by arc4_lock. */
name|isc_mutex_t
name|arc4_lock
decl_stmt|;
name|arc4ctx_t
name|arc4ctx
decl_stmt|;
comment|/*%< ARC4 context for QID */
comment|/* locked by buffer lock */
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|isc_mutex_t
name|buffer_lock
decl_stmt|;
name|unsigned
name|int
name|buffers
decl_stmt|;
comment|/* allocated buffers */
name|unsigned
name|int
name|buffersize
decl_stmt|;
comment|/* size of each buffer */
name|unsigned
name|int
name|maxbuffers
decl_stmt|;
comment|/* max buffers */
comment|/* Locked internally. */
name|isc_mutex_t
name|pool_lock
decl_stmt|;
name|isc_mempool_t
modifier|*
name|epool
decl_stmt|;
comment|/* memory pool for events */
name|isc_mempool_t
modifier|*
name|rpool
decl_stmt|;
comment|/* memory pool for replies */
name|isc_mempool_t
modifier|*
name|dpool
decl_stmt|;
comment|/* dispatch allocations */
name|isc_mempool_t
modifier|*
name|bpool
decl_stmt|;
comment|/* memory pool for buffers */
name|isc_entropy_t
modifier|*
name|entropy
decl_stmt|;
comment|/* entropy source */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MGR_SHUTTINGDOWN
value|0x00000001U
end_define

begin_define
define|#
directive|define
name|MGR_IS_SHUTTINGDOWN
parameter_list|(
name|l
parameter_list|)
value|(((l)->state& MGR_SHUTTINGDOWN) != 0)
end_define

begin_define
define|#
directive|define
name|IS_PRIVATE
parameter_list|(
name|d
parameter_list|)
value|(((d)->attributes& DNS_DISPATCHATTR_PRIVATE) != 0)
end_define

begin_struct
struct|struct
name|dns_dispentry
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_sockaddr_t
name|host
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|isc_taskaction_t
name|action
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|isc_boolean_t
name|item_out
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_dispatchevent_t
argument_list|)
name|items
expr_stmt|;
name|ISC_LINK
argument_list|(
argument|dns_dispentry_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INVALID_BUCKET
value|(0xffffdead)
end_define

begin_struct
struct|struct
name|dns_dispatch
block|{
comment|/* Unlocked. */
name|unsigned
name|int
name|magic
decl_stmt|;
comment|/* magic */
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
comment|/* dispatch manager */
name|isc_task_t
modifier|*
name|task
decl_stmt|;
comment|/* internal task */
name|isc_socket_t
modifier|*
name|socket
decl_stmt|;
comment|/* isc socket attached to */
name|isc_sockaddr_t
name|local
decl_stmt|;
comment|/* local address */
name|in_port_t
name|localport
decl_stmt|;
comment|/* local UDP port */
name|unsigned
name|int
name|maxrequests
decl_stmt|;
comment|/* max requests */
name|isc_event_t
modifier|*
name|ctlevent
decl_stmt|;
comment|/* Locked by mgr->lock. */
name|ISC_LINK
argument_list|(
argument|dns_dispatch_t
argument_list|)
name|link
expr_stmt|;
comment|/* Locked by "lock". */
name|isc_mutex_t
name|lock
decl_stmt|;
comment|/* locks all below */
name|isc_sockettype_t
name|socktype
decl_stmt|;
name|unsigned
name|int
name|attributes
decl_stmt|;
name|unsigned
name|int
name|refcount
decl_stmt|;
comment|/* number of users */
name|dns_dispatchevent_t
modifier|*
name|failsafe_ev
decl_stmt|;
comment|/* failsafe cancel event */
name|unsigned
name|int
name|shutting_down
range|:
literal|1
decl_stmt|,
name|shutdown_out
range|:
literal|1
decl_stmt|,
name|connected
range|:
literal|1
decl_stmt|,
name|tcpmsg_valid
range|:
literal|1
decl_stmt|,
name|recv_pending
range|:
literal|1
decl_stmt|;
comment|/* is a recv() pending? */
name|isc_result_t
name|shutdown_why
decl_stmt|;
name|unsigned
name|int
name|requests
decl_stmt|;
comment|/* how many requests we have */
name|unsigned
name|int
name|tcpbuffers
decl_stmt|;
comment|/* allocated buffers */
name|dns_tcpmsg_t
name|tcpmsg
decl_stmt|;
comment|/* for tcp streams */
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|QID_MAGIC
value|ISC_MAGIC('Q', 'i', 'd', ' ')
end_define

begin_define
define|#
directive|define
name|VALID_QID
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), QID_MAGIC)
end_define

begin_define
define|#
directive|define
name|RESPONSE_MAGIC
value|ISC_MAGIC('D', 'r', 's', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_RESPONSE
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), RESPONSE_MAGIC)
end_define

begin_define
define|#
directive|define
name|DISPATCH_MAGIC
value|ISC_MAGIC('D', 'i', 's', 'p')
end_define

begin_define
define|#
directive|define
name|VALID_DISPATCH
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), DISPATCH_MAGIC)
end_define

begin_define
define|#
directive|define
name|DNS_DISPATCHMGR_MAGIC
value|ISC_MAGIC('D', 'M', 'g', 'r')
end_define

begin_define
define|#
directive|define
name|VALID_DISPATCHMGR
parameter_list|(
name|e
parameter_list|)
value|ISC_MAGIC_VALID((e), DNS_DISPATCHMGR_MAGIC)
end_define

begin_define
define|#
directive|define
name|DNS_QID
parameter_list|(
name|disp
parameter_list|)
value|((disp)->socktype == isc_sockettype_tcp) ? \ 		       (disp)->qid : (disp)->mgr->qid
end_define

begin_comment
comment|/*  * Statics.  */
end_comment

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|bucket_search
parameter_list|(
name|dns_qid_t
modifier|*
parameter_list|,
name|isc_sockaddr_t
modifier|*
parameter_list|,
name|dns_messageid_t
parameter_list|,
name|in_port_t
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|destroy_disp_ok
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_disp
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|udp_recv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tcp_recv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|startrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_uint32_t
name|dns_hash
parameter_list|(
name|dns_qid_t
modifier|*
parameter_list|,
name|isc_sockaddr_t
modifier|*
parameter_list|,
name|dns_messageid_t
parameter_list|,
name|in_port_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|allocate_udp_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|free_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dns_dispatchevent_t
modifier|*
name|allocate_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_first
parameter_list|(
name|dns_qid_t
modifier|*
name|disp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_next
parameter_list|(
name|dns_qid_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dispatch_free
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|dispatch_createudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|destroy_mgr_ok
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_mgr
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|qid_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|qid_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LVL
parameter_list|(
name|x
parameter_list|)
value|ISC_LOG_DEBUG(x)
end_define

begin_function_decl
specifier|static
name|void
name|mgr_log
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|mgr_log
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatchmgr %p: %s"
argument_list|,
name|mgr
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|dispatch_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|3
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|dispatch_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p: %s"
argument_list|,
name|disp
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|request_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|request_log
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_RESPONSE
argument_list|(
name|resp
argument_list|)
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|resp
operator|->
name|host
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p response %p %s: %s"
argument_list|,
name|disp
argument_list|,
name|resp
argument_list|,
name|peerbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_log_write
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_DISPATCH
argument_list|,
name|DNS_LOGMODULE_DISPATCH
argument_list|,
name|level
argument_list|,
literal|"dispatch %p req/resp %p: %s"
argument_list|,
name|disp
argument_list|,
name|resp
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ARC4 random number generator obtained from OpenBSD  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_arc4init
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
name|actx
operator|->
name|s
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|actx
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|actx
operator|->
name|j
operator|=
literal|0
expr_stmt|;
name|actx
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_arc4addrandom
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|,
name|unsigned
name|char
modifier|*
name|dat
parameter_list|,
name|int
name|datlen
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|isc_uint8_t
name|si
decl_stmt|;
name|actx
operator|->
name|i
operator|--
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|actx
operator|->
name|i
operator|=
operator|(
name|actx
operator|->
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|si
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
expr_stmt|;
name|actx
operator|->
name|j
operator|=
operator|(
name|actx
operator|->
name|j
operator|+
name|si
operator|+
name|dat
index|[
name|n
operator|%
name|datlen
index|]
operator|)
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
operator|=
name|si
expr_stmt|;
block|}
name|actx
operator|->
name|j
operator|=
name|actx
operator|->
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_uint8_t
name|dispatch_arc4get8
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint8_t
name|si
decl_stmt|,
name|sj
decl_stmt|;
name|actx
operator|->
name|i
operator|=
operator|(
name|actx
operator|->
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|si
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
expr_stmt|;
name|actx
operator|->
name|j
operator|=
operator|(
name|actx
operator|->
name|j
operator|+
name|si
operator|)
expr_stmt|;
name|sj
operator|=
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|i
index|]
operator|=
name|sj
expr_stmt|;
name|actx
operator|->
name|s
index|[
name|actx
operator|->
name|j
index|]
operator|=
name|si
expr_stmt|;
return|return
operator|(
name|actx
operator|->
name|s
index|[
operator|(
name|si
operator|+
name|sj
operator|)
operator|&
literal|0xff
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_uint16_t
name|dispatch_arc4get16
parameter_list|(
name|arc4ctx_t
modifier|*
name|actx
parameter_list|)
block|{
name|isc_uint16_t
name|val
decl_stmt|;
name|val
operator|=
name|dispatch_arc4get8
argument_list|(
name|actx
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|val
operator||=
name|dispatch_arc4get8
argument_list|(
name|actx
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_arc4stir
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|unsigned
name|char
name|rnd
index|[
literal|128
index|]
decl_stmt|;
name|isc_uint32_t
name|rnd32
index|[
literal|32
index|]
decl_stmt|;
block|}
name|rnd
union|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|mgr
operator|->
name|entropy
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We accept any quality of random data to avoid blocking. 		 */
name|result
operator|=
name|isc_entropy_getdata
argument_list|(
name|mgr
operator|->
name|entropy
argument_list|,
name|rnd
operator|.
name|rnd
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|isc_random_get
argument_list|(
operator|&
name|rnd
operator|.
name|rnd32
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dispatch_arc4addrandom
argument_list|(
operator|&
name|mgr
operator|->
name|arc4ctx
argument_list|,
name|rnd
operator|.
name|rnd
argument_list|,
sizeof|sizeof
argument_list|(
name|rnd
operator|.
name|rnd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Discard early keystream, as per recommendations in: 	 * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.ps 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|dispatch_arc4get8
argument_list|(
operator|&
name|mgr
operator|->
name|arc4ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Derived from OpenBSD's implementation.  The rationale is not clear, 	 * but should be conservative enough in safety, and reasonably large 	 * for efficiency. 	 */
name|mgr
operator|->
name|arc4ctx
operator|.
name|count
operator|=
literal|1600000
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_uint16_t
name|dispatch_arc4random
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|isc_uint16_t
name|result
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|arc4ctx
operator|.
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|isc_uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|arc4ctx
operator|.
name|count
operator|<=
literal|0
condition|)
name|dispatch_arc4stir
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|result
operator|=
name|dispatch_arc4get16
argument_list|(
operator|&
name|mgr
operator|->
name|arc4ctx
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_uint16_t
name|dispatch_arc4uniformrandom
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_uint16_t
name|upper_bound
parameter_list|)
block|{
name|isc_uint16_t
name|min
decl_stmt|,
name|r
decl_stmt|;
comment|/* The caller must hold the manager lock. */
if|if
condition|(
name|upper_bound
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Ensure the range of random numbers [min, 0xffff] be a multiple of 	 * upper_bound and contain at least a half of the 16 bit range. 	 */
if|if
condition|(
name|upper_bound
operator|>
literal|0x8000
condition|)
name|min
operator|=
literal|1
operator|+
operator|~
name|upper_bound
expr_stmt|;
comment|/* 0x8000 - upper_bound */
else|else
name|min
operator|=
call|(
name|isc_uint16_t
call|)
argument_list|(
literal|0x10000
operator|%
operator|(
name|isc_uint32_t
operator|)
name|upper_bound
argument_list|)
expr_stmt|;
comment|/* 	 * This could theoretically loop forever but each retry has 	 * p> 0.5 (worst case, usually far better) of selecting a 	 * number inside the range we need, so it should rarely need 	 * to re-roll. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|r
operator|=
name|dispatch_arc4random
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|min
condition|)
break|break;
block|}
return|return
operator|(
name|r
operator|%
name|upper_bound
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a hash of the destination and message id.  */
end_comment

begin_function
specifier|static
name|isc_uint32_t
name|dns_hash
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|in_port_t
name|port
parameter_list|)
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|isc_sockaddr_hash
argument_list|(
name|dest
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|ret
operator|^=
operator|(
name|id
operator|<<
literal|16
operator|)
operator||
name|port
expr_stmt|;
name|ret
operator|%=
name|qid
operator|->
name|qid_nbuckets
expr_stmt|;
name|INSIST
argument_list|(
name|ret
operator|<
name|qid
operator|->
name|qid_nbuckets
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first entry in 'qid'.  Returns NULL if there are no entries.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_first
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|bucket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
condition|)
block|{
name|ret
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next entry after 'resp' in 'qid'.  Return NULL if there are  * no more entries.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|linear_next
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|dns_dispentry_t
modifier|*
name|resp
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|ret
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|resp
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|=
name|resp
operator|->
name|bucket
expr_stmt|;
name|bucket
operator|++
expr_stmt|;
while|while
condition|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
condition|)
block|{
name|ret
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|bucket
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The dispatch must be locked.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|destroy_disp_ok
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
if|if
condition|(
name|disp
operator|->
name|refcount
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when refcount reaches 0 (and safe to destroy).  *  * The dispatcher must not be locked.  * The manager must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_disp
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_boolean_t
name|killmgr
decl_stmt|;
name|INSIST
argument_list|(
name|event
operator|->
name|ev_type
operator|==
name|DNS_EVENT_DISPATCHCONTROL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|disp
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"shutting down; detaching from sock %p, task %p"
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
name|killmgr
operator|=
name|destroy_mgr_ok
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killmgr
condition|)
name|destroy_mgr
argument_list|(
operator|&
name|mgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an entry for query ID 'id' and socket address 'dest' in 'qid'.  * Return NULL if no such entry exists.  */
end_comment

begin_function
specifier|static
name|dns_dispentry_t
modifier|*
name|bucket_search
parameter_list|(
name|dns_qid_t
modifier|*
name|qid
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|dns_messageid_t
name|id
parameter_list|,
name|in_port_t
name|port
parameter_list|,
name|unsigned
name|int
name|bucket
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|REQUIRE
argument_list|(
name|bucket
operator|<
name|qid
operator|->
name|qid_nbuckets
argument_list|)
expr_stmt|;
name|res
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|->
name|id
operator|==
name|id
operator|)
operator|&&
name|isc_sockaddr_equal
argument_list|(
name|dest
argument_list|,
operator|&
name|res
operator|->
name|host
argument_list|)
operator|&&
name|res
operator|->
name|port
operator|==
name|port
condition|)
block|{
return|return
operator|(
name|res
operator|)
return|;
block|}
name|res
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|INSIST
argument_list|(
name|buf
operator|!=
name|NULL
operator|&&
name|len
operator|!=
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|disp
operator|->
name|socktype
condition|)
block|{
case|case
name|isc_sockettype_tcp
case|:
name|INSIST
argument_list|(
name|disp
operator|->
name|tcpbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|--
expr_stmt|;
name|isc_mem_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_udp
case|:
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|len
operator|==
name|disp
operator|->
name|mgr
operator|->
name|buffersize
argument_list|)
expr_stmt|;
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|--
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|bpool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|allocate_udp_buffer
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|void
modifier|*
name|temp
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|temp
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|free_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
name|ev
parameter_list|)
block|{
if|if
condition|(
name|disp
operator|->
name|failsafe_ev
operator|==
name|ev
condition|)
block|{
name|INSIST
argument_list|(
name|disp
operator|->
name|shutdown_out
operator|==
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|epool
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dns_dispatchevent_t
modifier|*
name|allocate_event
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ISC_EVENT_INIT
argument_list|(
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * General flow:  *  * If I/O result == CANCELED or error, free the buffer.  *  * If query, free the buffer, restart.  *  * If response:  *	Allocate event, fill in details.  *		If cannot allocate, free buffer, restart.  *	find target.  If not found, free buffer, restart.  *	if event queue is not empty, queue.  else, send.  *	restart.  */
end_comment

begin_function
specifier|static
name|void
name|udp_recv
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev_in
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|ev_in
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|ev_in
operator|->
name|ev_arg
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|isc_result_t
name|dres
decl_stmt|;
name|isc_buffer_t
name|source
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|rev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|isc_boolean_t
name|queue_response
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|isc_netaddr_t
name|netaddr
decl_stmt|;
name|int
name|match
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|qid
operator|=
name|mgr
operator|->
name|qid
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"got packet: requests %d, buffers %d, recvs %d"
argument_list|,
name|disp
operator|->
name|requests
argument_list|,
name|disp
operator|->
name|mgr
operator|->
name|buffers
argument_list|,
name|disp
operator|->
name|recv_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_RECVDONE
condition|)
block|{
comment|/* 		 * Unless the receive event was imported from a listening 		 * interface, in which case the event type is 		 * DNS_EVENT_IMPORTRECVDONE, receive operation must be pending. 		 */
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|->
name|shutting_down
condition|)
block|{
comment|/* 		 * This dispatcher is shutting down. 		 */
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
name|ev
operator|=
name|NULL
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ev
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|result
operator|!=
name|ISC_R_CANCELED
condition|)
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"odd socket result in udp_recv(): %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|ev
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is from a blackholed address, drop it. 	 */
name|isc_netaddr_fromsockaddr
argument_list|(
operator|&
name|netaddr
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
operator|&&
name|dns_acl_match
argument_list|(
operator|&
name|netaddr
argument_list|,
name|NULL
argument_list|,
name|disp
operator|->
name|mgr
operator|->
name|blackhole
argument_list|,
name|NULL
argument_list|,
operator|&
name|match
argument_list|,
name|NULL
argument_list|)
operator|==
name|ISC_R_SUCCESS
operator|&&
name|match
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|dns_lctx
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|netaddrstr
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|netaddr
argument_list|,
name|netaddrstr
argument_list|,
sizeof|sizeof
argument_list|(
name|netaddrstr
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"blackholed packet from %s"
argument_list|,
name|netaddrstr
argument_list|)
expr_stmt|;
block|}
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Peek into the buffer to see what we can see. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|source
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|source
argument_list|,
name|ev
operator|->
name|n
argument_list|)
expr_stmt|;
name|dres
operator|=
name|dns_message_peekheader
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dres
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"got garbage packet"
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|92
argument_list|)
argument_list|,
literal|"got valid DNS message header, /QR %c, id %u"
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
condition|?
literal|'1'
else|:
literal|'0'
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Look at flags.  If query, drop it. If response, 	 * look to see where it goes. 	 */
name|queue_response
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* query */
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* response */
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|resp
operator|=
name|bucket_search
argument_list|(
name|qid
argument_list|,
operator|&
name|ev
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"search for response in bucket %d: %s"
argument_list|,
name|bucket
argument_list|,
operator|(
name|resp
operator|==
name|NULL
condition|?
literal|"not found"
else|:
literal|"found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * Now that we have the original dispatch the query was sent 	 * from check that the address and port the response was 	 * sent to make sense. 	 */
if|if
condition|(
name|disp
operator|!=
name|resp
operator|->
name|disp
condition|)
block|{
name|isc_sockaddr_t
name|a1
decl_stmt|;
name|isc_sockaddr_t
name|a2
decl_stmt|;
comment|/* 		 * Check that the socket types and ports match. 		 */
if|if
condition|(
name|disp
operator|->
name|socktype
operator|!=
name|resp
operator|->
name|disp
operator|->
name|socktype
operator|||
name|isc_sockaddr_getport
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|!=
name|isc_sockaddr_getport
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 		 * If both dispatches are bound to an address then fail as 		 * the addresses can't be equal (enforced by the IP stack).   		 * 		 * Note under Linux a packet can be sent out via IPv4 socket 		 * and the response be received via a IPv6 socket. 		 *  		 * Requests sent out via IPv6 should always come back in 		 * via IPv6. 		 */
if|if
condition|(
name|isc_sockaddr_pf
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
operator|==
name|PF_INET6
operator|&&
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|!=
name|PF_INET6
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|a1
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|a2
argument_list|,
name|isc_sockaddr_pf
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|a1
argument_list|,
operator|&
name|resp
operator|->
name|disp
operator|->
name|local
argument_list|)
operator|&&
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|a2
argument_list|,
operator|&
name|disp
operator|->
name|local
argument_list|)
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
block|}
name|queue_response
operator|=
name|resp
operator|->
name|item_out
expr_stmt|;
name|rev
operator|=
name|allocate_event
argument_list|(
name|resp
operator|->
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * At this point, rev contains the event we want to fill in, and 	 * resp contains the information on the place to send it to. 	 * Send the event off. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|rev
operator|->
name|buffer
argument_list|,
name|ev
operator|->
name|region
operator|.
name|base
argument_list|,
name|ev
operator|->
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|rev
operator|->
name|buffer
argument_list|,
name|ev
operator|->
name|n
argument_list|)
expr_stmt|;
name|rev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|rev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rev
operator|->
name|addr
operator|=
name|ev
operator|->
name|address
expr_stmt|;
name|rev
operator|->
name|pktinfo
operator|=
name|ev
operator|->
name|pktinfo
expr_stmt|;
name|rev
operator|->
name|attributes
operator|=
name|ev
operator|->
name|attributes
expr_stmt|;
if|if
condition|(
name|queue_response
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|resp
operator|->
name|items
argument_list|,
name|rev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISC_EVENT_INIT
argument_list|(
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"[a] Sent event %p buffer %p len %d to task %p"
argument_list|,
name|rev
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Restart recv() to get the next packet. 	 */
name|restart
label|:
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General flow:  *  * If I/O result == CANCELED, EOF, or error, notify everyone as the  * various queues drain.  *  * If query, restart.  *  * If response:  *	Allocate event, fill in details.  *		If cannot allocate, restart.  *	find target.  If not found, restart.  *	if event queue is not empty, queue.  else, send.  *	restart.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_recv
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|ev_in
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|ev_in
operator|->
name|ev_arg
decl_stmt|;
name|dns_tcpmsg_t
modifier|*
name|tcpmsg
init|=
operator|&
name|disp
operator|->
name|tcpmsg
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|isc_result_t
name|dres
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|rev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|isc_boolean_t
name|queue_response
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
name|buf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|qid
operator|=
name|disp
operator|->
name|qid
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"got TCP packet: requests %d, buffers %d, recvs %d"
argument_list|,
name|disp
operator|->
name|requests
argument_list|,
name|disp
operator|->
name|tcpbuffers
argument_list|,
name|disp
operator|->
name|recv_pending
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This dispatcher is shutting down.  Force cancelation. 		 */
name|tcpmsg
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
block|}
if|if
condition|(
name|tcpmsg
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|tcpmsg
operator|->
name|result
condition|)
block|{
case|case
name|ISC_R_CANCELED
case|:
break|break;
case|case
name|ISC_R_EOF
case|:
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"shutting down on EOF"
argument_list|)
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISC_R_CONNECTIONRESET
case|:
name|level
operator|=
name|ISC_LOG_INFO
expr_stmt|;
goto|goto
name|logit
goto|;
default|default:
name|level
operator|=
name|ISC_LOG_ERROR
expr_stmt|;
name|logit
label|:
name|isc_sockaddr_format
argument_list|(
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|level
argument_list|,
literal|"shutting down due to TCP "
literal|"receive error: %s: %s"
argument_list|,
name|buf
argument_list|,
name|isc_result_totext
argument_list|(
name|tcpmsg
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * The event is statically allocated in the tcpmsg 		 * structure, and destroy_disp() frees the tcpmsg, so we must 		 * free the event *before* calling destroy_disp(). 		 */
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|tcpmsg
operator|->
name|result
expr_stmt|;
comment|/* 		 * If the recv() was canceled pass the word on. 		 */
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
return|return;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"result %d, length == %d, addr = %p"
argument_list|,
name|tcpmsg
operator|->
name|result
argument_list|,
name|tcpmsg
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|tcpmsg
operator|->
name|buffer
operator|.
name|base
argument_list|)
expr_stmt|;
comment|/* 	 * Peek into the buffer to see what we can see. 	 */
name|dres
operator|=
name|dns_message_peekheader
argument_list|(
operator|&
name|tcpmsg
operator|->
name|buffer
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dres
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"got garbage packet"
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|92
argument_list|)
argument_list|,
literal|"got valid DNS message header, /QR %c, id %u"
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
condition|?
literal|'1'
else|:
literal|'0'
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate an event to send to the query or response client, and 	 * allocate a new buffer for our use. 	 */
comment|/* 	 * Look at flags.  If query, drop it. If response, 	 * look to see where it goes. 	 */
name|queue_response
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DNS_MESSAGEFLAG_QR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Query. 		 */
goto|goto
name|restart
goto|;
block|}
comment|/* 	 * Response. 	 */
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|resp
operator|=
name|bucket_search
argument_list|(
name|qid
argument_list|,
operator|&
name|tcpmsg
operator|->
name|address
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"search for response in bucket %d: %s"
argument_list|,
name|bucket
argument_list|,
operator|(
name|resp
operator|==
name|NULL
condition|?
literal|"not found"
else|:
literal|"found"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
name|queue_response
operator|=
name|resp
operator|->
name|item_out
expr_stmt|;
name|rev
operator|=
name|allocate_event
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * At this point, rev contains the event we want to fill in, and 	 * resp contains the information on the place to send it to. 	 * Send the event off. 	 */
name|dns_tcpmsg_keepbuffer
argument_list|(
name|tcpmsg
argument_list|,
operator|&
name|rev
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|++
expr_stmt|;
name|rev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|rev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|rev
operator|->
name|addr
operator|=
name|tcpmsg
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|queue_response
condition|)
block|{
name|ISC_LIST_APPEND
argument_list|(
name|resp
operator|->
name|items
argument_list|,
name|rev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISC_EVENT_INIT
argument_list|(
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"[b] Sent event %p buffer %p len %d to task %p"
argument_list|,
name|rev
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|rev
operator|->
name|buffer
operator|.
name|length
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Restart recv() to get the next packet. 	 */
name|restart
label|:
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|ev_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * disp must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|startrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|isc_result_t
name|res
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|disp
operator|->
name|mgr
operator|->
name|buffers
operator|>=
name|disp
operator|->
name|mgr
operator|->
name|maxbuffers
condition|)
return|return;
switch|switch
condition|(
name|disp
operator|->
name|socktype
condition|)
block|{
comment|/* 		 * UDP reads are always maximal. 		 */
case|case
name|isc_sockettype_udp
case|:
name|region
operator|.
name|length
operator|=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
expr_stmt|;
name|region
operator|.
name|base
operator|=
name|allocate_udp_buffer
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|region
operator|.
name|base
operator|==
name|NULL
condition|)
return|return;
name|res
operator|=
name|isc_socket_recv
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
operator|&
name|region
argument_list|,
literal|1
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|udp_recv
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|region
operator|.
name|base
argument_list|,
name|region
operator|.
name|length
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|res
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|res
operator|=
name|dns_tcpmsg_readmessage
argument_list|(
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|tcp_recv
argument_list|,
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|disp
operator|->
name|shutdown_why
operator|=
name|res
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Mgr must be locked when calling this function.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|destroy_mgr_ok
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"destroy_mgr_ok: shuttingdown=%d, listnonempty=%d, "
literal|"epool=%d, rpool=%d, dpool=%d"
argument_list|,
name|MGR_IS_SHUTTINGDOWN
argument_list|(
name|mgr
argument_list|)
argument_list|,
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|epool
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|)
argument_list|,
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MGR_IS_SHUTTINGDOWN
argument_list|(
name|mgr
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|epool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|isc_mempool_getallocated
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mgr must be unlocked when calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_mgr
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|mgr
operator|=
operator|*
name|mgrp
expr_stmt|;
operator|*
name|mgrp
operator|=
name|NULL
expr_stmt|;
name|mctx
operator|=
name|mgr
operator|->
name|mctx
expr_stmt|;
name|mgr
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|dpool
argument_list|)
expr_stmt|;
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_detach
argument_list|(
operator|&
name|mgr
operator|->
name|entropy
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|qid
operator|!=
name|NULL
condition|)
name|qid_destroy
argument_list|(
name|mctx
argument_list|,
operator|&
name|mgr
operator|->
name|qid
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|portlist
operator|!=
name|NULL
condition|)
name|dns_portlist_detach
argument_list|(
operator|&
name|mgr
operator|->
name|portlist
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|create_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|sock
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_socket_create
argument_list|(
name|mgr
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|local
argument_list|)
argument_list|,
name|isc_sockettype_udp
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
ifndef|#
directive|ifndef
name|ISC_ALLOW_MAPPED
name|isc_socket_ipv6only
argument_list|(
name|sock
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|isc_socket_bind
argument_list|(
name|sock
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_socket_detach
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
operator|*
name|sockp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Publics.  */
end_comment

begin_function
name|isc_result_t
name|dns_dispatchmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_entropy_t
modifier|*
name|entropy
parameter_list|,
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mgrp
operator|!=
name|NULL
operator|&&
operator|*
name|mgrp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|mgr
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|mgr
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|blackhole
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|portlist
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_arc4_lock
goto|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_buffer_lock
goto|;
name|mgr
operator|->
name|epool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchevent_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|epool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_pool_lock
goto|;
block|}
name|mgr
operator|->
name|rpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispentry_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_epool
goto|;
block|}
name|mgr
operator|->
name|dpool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatch_t
argument_list|)
argument_list|,
operator|&
name|mgr
operator|->
name|dpool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_rpool
goto|;
block|}
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
literal|"dispmgr_epool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
literal|"dispmgr_rpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|rpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
literal|"dispmgr_dpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setfreemax
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|buffers
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|buffersize
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
literal|0
expr_stmt|;
name|mgr
operator|->
name|bpool
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|entropy
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|qid
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|magic
operator|=
name|DNS_DISPATCHMGR_MAGIC
expr_stmt|;
if|if
condition|(
name|entropy
operator|!=
name|NULL
condition|)
name|isc_entropy_attach
argument_list|(
name|entropy
argument_list|,
operator|&
name|mgr
operator|->
name|entropy
argument_list|)
expr_stmt|;
name|dispatch_arc4init
argument_list|(
operator|&
name|mgr
operator|->
name|arc4ctx
argument_list|)
expr_stmt|;
operator|*
name|mgrp
operator|=
name|mgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|kill_rpool
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
name|kill_epool
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|epool
argument_list|)
expr_stmt|;
name|kill_pool_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|kill_buffer_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
name|kill_arc4_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|arc4_lock
argument_list|)
expr_stmt|;
name|kill_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|deallocate
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|mgr
argument_list|,
sizeof|sizeof
argument_list|(
name|dns_dispatchmgr_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_setblackhole
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_acl_t
modifier|*
name|blackhole
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|blackhole
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
name|dns_acl_attach
argument_list|(
name|blackhole
argument_list|,
operator|&
name|mgr
operator|->
name|blackhole
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_acl_t
modifier|*
name|dns_dispatchmgr_getblackhole
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mgr
operator|->
name|blackhole
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_setblackportlist
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|dns_portlist_t
modifier|*
name|portlist
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|portlist
operator|!=
name|NULL
condition|)
name|dns_portlist_detach
argument_list|(
operator|&
name|mgr
operator|->
name|portlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|portlist
operator|!=
name|NULL
condition|)
name|dns_portlist_attach
argument_list|(
name|portlist
argument_list|,
operator|&
name|mgr
operator|->
name|portlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dns_portlist_t
modifier|*
name|dns_dispatchmgr_getblackportlist
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|mgr
operator|->
name|portlist
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|dns_dispatchmgr_setudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buffersize
operator|>=
literal|512
operator|&&
name|buffersize
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|maxbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
comment|/* 	 * Keep some number of items around.  This should be a config 	 * option.  For now, keep 8, but later keep at least two even 	 * if the caller wants less.  This allows us to ensure certain 	 * things, like an event can be "freed" and the next allocation 	 * will always succeed. 	 * 	 * Note that if limits are placed on anything here, we use one 	 * event internally, so the actual limit should be "wanted + 1." 	 * 	 * XXXMLG 	 */
if|if
condition|(
name|maxbuffers
operator|<
literal|8
condition|)
name|maxbuffers
operator|=
literal|8
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|bpool
operator|!=
name|NULL
condition|)
block|{
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
name|maxbuffers
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
name|maxbuffers
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|isc_mempool_create
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|buffersize
argument_list|,
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|isc_mempool_setname
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
literal|"dispmgr_bpool"
argument_list|)
expr_stmt|;
name|isc_mempool_setmaxalloc
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
name|maxbuffers
argument_list|)
expr_stmt|;
name|isc_mempool_associatelock
argument_list|(
name|mgr
operator|->
name|bpool
argument_list|,
operator|&
name|mgr
operator|->
name|pool_lock
argument_list|)
expr_stmt|;
name|result
operator|=
name|qid_allocate
argument_list|(
name|mgr
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|,
operator|&
name|mgr
operator|->
name|qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|mgr
operator|->
name|buffersize
operator|=
name|buffersize
expr_stmt|;
name|mgr
operator|->
name|maxbuffers
operator|=
name|maxbuffers
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
name|isc_mempool_destroy
argument_list|(
operator|&
name|mgr
operator|->
name|bpool
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|buffer_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatchmgr_destroy
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
modifier|*
name|mgrp
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|mgrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
operator|*
name|mgrp
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|=
operator|*
name|mgrp
expr_stmt|;
operator|*
name|mgrp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|state
operator||=
name|MGR_SHUTTINGDOWN
expr_stmt|;
name|killit
operator|=
name|destroy_mgr_ok
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"destroy: killit=%d"
argument_list|,
name|killit
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|destroy_mgr
argument_list|(
operator|&
name|mgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|blacklisted
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddrp
parameter_list|)
block|{
name|isc_sockaddr_t
name|sockaddr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|!=
name|NULL
operator|||
name|sockaddrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|->
name|portlist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
if|if
condition|(
name|sock
operator|!=
name|NULL
condition|)
block|{
name|sockaddrp
operator|=
operator|&
name|sockaddr
expr_stmt|;
name|result
operator|=
name|isc_socket_getsockname
argument_list|(
name|sock
argument_list|,
name|sockaddrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|mgr
operator|->
name|portlist
operator|!=
name|NULL
operator|&&
name|dns_portlist_match
argument_list|(
name|mgr
operator|->
name|portlist
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|sockaddrp
argument_list|)
argument_list|,
name|isc_sockaddr_getport
argument_list|(
name|sockaddrp
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATTRMATCH
parameter_list|(
name|_a1
parameter_list|,
name|_a2
parameter_list|,
name|_mask
parameter_list|)
value|(((_a1)& (_mask)) == ((_a2)& (_mask)))
end_define

begin_function
specifier|static
name|isc_boolean_t
name|local_addr_match
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|)
block|{
name|isc_sockaddr_t
name|sockaddr
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 	 * Don't match wildcard ports against newly blacklisted ports. 	 */
if|if
condition|(
name|disp
operator|->
name|mgr
operator|->
name|portlist
operator|!=
name|NULL
operator|&&
name|isc_sockaddr_getport
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|)
operator|==
literal|0
operator|&&
name|blacklisted
argument_list|(
name|disp
operator|->
name|mgr
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * Check if we match the binding<address,port>. 	 * Wildcard ports match/fail here. 	 */
if|if
condition|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
comment|/* 	 * Check if we match a bound wildcard port<address,port>. 	 */
if|if
condition|(
operator|!
name|isc_sockaddr_eqaddr
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|result
operator|=
name|isc_socket_getsockname
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
operator|&
name|sockaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
return|return
operator|(
name|isc_sockaddr_equal
argument_list|(
operator|&
name|sockaddr
argument_list|,
name|addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Requires mgr be locked.  *  * No dispatcher can be locked by this thread when calling this function.  *  *  * NOTE:  *	If a matching dispatcher is found, it is locked after this function  *	returns, and must be unlocked by the caller.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dispatch_find
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|local
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * Make certain that we will not match a private dispatch. 	 */
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
name|mask
operator||=
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
name|disp
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mgr
operator|->
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|disp
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|shutting_down
operator|==
literal|0
operator|)
operator|&&
name|ATTRMATCH
argument_list|(
name|disp
operator|->
name|attributes
argument_list|,
name|attributes
argument_list|,
name|mask
argument_list|)
operator|&&
name|local_addr_match
argument_list|(
name|disp
argument_list|,
name|local
argument_list|)
condition|)
break|break;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disp
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTFOUND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|qid_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
block|{
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|qidp
operator|!=
name|NULL
operator|&&
operator|*
name|qidp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qid
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|qid
operator|->
name|qid_table
operator|=
name|isc_mem_get
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|->
name|qid_table
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init failed"
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
operator|->
name|qid_table
argument_list|,
name|buckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buckets
condition|;
name|i
operator|++
control|)
name|ISC_LIST_INIT
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|qid
operator|->
name|qid_nbuckets
operator|=
name|buckets
expr_stmt|;
name|qid
operator|->
name|qid_increment
operator|=
name|increment
expr_stmt|;
name|qid
operator|->
name|magic
operator|=
name|QID_MAGIC
expr_stmt|;
operator|*
name|qidp
operator|=
name|qid
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|qid_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_qid_t
modifier|*
modifier|*
name|qidp
parameter_list|)
block|{
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|qidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|qid
operator|=
operator|*
name|qidp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_QID
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|qidp
operator|=
name|NULL
expr_stmt|;
name|qid
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|qid
operator|->
name|qid_table
argument_list|,
name|qid
operator|->
name|qid_nbuckets
operator|*
sizeof|sizeof
argument_list|(
name|dns_displist_t
argument_list|)
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|qid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and set important limits.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|dispatch_allocate
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_result_t
name|res
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the dispatcher, mostly.  Don't bother setting some of 	 * the options that are controlled by tcp vs. udp, etc. 	 */
name|disp
operator|=
name|isc_mempool_get
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|disp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|mgr
operator|=
name|mgr
expr_stmt|;
name|disp
operator|->
name|maxrequests
operator|=
name|maxrequests
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|recv_pending
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|disp
operator|->
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|disp
operator|->
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|->
name|localport
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_why
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|disp
operator|->
name|requests
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|tcpbuffers
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|qid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|isc_mutex_init
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|res
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_mutex_init failed"
argument_list|)
expr_stmt|;
goto|goto
name|deallocate
goto|;
block|}
name|disp
operator|->
name|failsafe_ev
operator|=
name|allocate_event
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|failsafe_ev
operator|==
name|NULL
condition|)
block|{
name|res
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_lock
goto|;
block|}
name|disp
operator|->
name|magic
operator|=
name|DISPATCH_MAGIC
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* 	 * error returns 	 */
name|kill_lock
label|:
name|DESTROYLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|deallocate
label|:
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MUST be unlocked, and not used by anthing.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_free
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
operator|*
name|dispp
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|*
name|dispp
expr_stmt|;
operator|*
name|dispp
operator|=
name|NULL
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|tcpmsg_valid
condition|)
block|{
name|dns_tcpmsg_invalidate
argument_list|(
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|0
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|disp
operator|->
name|tcpbuffers
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|requests
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|recv_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|epool
argument_list|,
name|disp
operator|->
name|failsafe_ev
argument_list|)
expr_stmt|;
name|disp
operator|->
name|failsafe_ev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|qid
operator|!=
name|NULL
condition|)
name|qid_destroy
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
operator|&
name|disp
operator|->
name|qid
argument_list|)
expr_stmt|;
name|disp
operator|->
name|mgr
operator|=
name|NULL
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|mgr
operator|->
name|dpool
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_createtcp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|UNUSED
argument_list|(
name|maxbuffers
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|buffersize
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|isc_socket_gettype
argument_list|(
name|sock
argument_list|)
operator|==
name|isc_sockettype_tcp
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_TCP
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_UDP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|attributes
operator||=
name|DNS_DISPATCHATTR_PRIVATE
expr_stmt|;
comment|/* XXXMLG */
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * dispatch_allocate() checks mgr for us. 	 * qid_allocate() checks buckets and increment for us. 	 */
name|disp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dispatch_allocate
argument_list|(
name|mgr
argument_list|,
name|maxrequests
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|result
operator|=
name|qid_allocate
argument_list|(
name|mgr
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|,
operator|&
name|disp
operator|->
name|qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
name|disp
operator|->
name|socktype
operator|=
name|isc_sockettype_tcp
expr_stmt|;
name|disp
operator|->
name|socket
operator|=
name|NULL
expr_stmt|;
name|isc_socket_attach
argument_list|(
name|sock
argument_list|,
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|disp
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_socket
goto|;
name|disp
operator|->
name|ctlevent
operator|=
name|isc_event_allocate
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
argument_list|,
name|DNS_EVENT_DISPATCHCONTROL
argument_list|,
name|destroy_disp
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|ctlevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_task
goto|;
block|}
name|isc_task_setname
argument_list|(
name|disp
operator|->
name|task
argument_list|,
literal|"tcpdispatch"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dns_tcpmsg_init
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
operator|->
name|socket
argument_list|,
operator|&
name|disp
operator|->
name|tcpmsg
argument_list|)
expr_stmt|;
name|disp
operator|->
name|tcpmsg_valid
operator|=
literal|1
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
name|attributes
expr_stmt|;
comment|/* 	 * Append it to the dispatcher list. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created TCP dispatcher %p"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created task %p"
argument_list|,
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/* 	 * Error returns. 	 */
name|kill_task
label|:
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|kill_socket
label|:
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|deallocate_dispatch
label|:
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_getudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|buffersize
parameter_list|,
name|unsigned
name|int
name|maxbuffers
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|buckets
parameter_list|,
name|unsigned
name|int
name|increment
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sockmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|localaddr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|taskmgr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buffersize
operator|>=
literal|512
operator|&&
name|buffersize
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|maxbuffers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buckets
operator|<
literal|2097169
argument_list|)
expr_stmt|;
comment|/* next prime> 65536 * 32 */
name|REQUIRE
argument_list|(
name|increment
operator|>
name|buckets
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_TCP
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_dispatchmgr_setudp
argument_list|(
name|mgr
argument_list|,
name|buffersize
argument_list|,
name|maxbuffers
argument_list|,
name|buckets
argument_list|,
name|increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_RANDOMPORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|REQUIRE
argument_list|(
name|isc_sockaddr_getport
argument_list|(
name|localaddr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|createudp
goto|;
block|}
comment|/* 	 * First, see if we have a dispatcher that matches. 	 */
name|disp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dispatch_find
argument_list|(
name|mgr
argument_list|,
name|localaddr
argument_list|,
name|attributes
argument_list|,
name|mask
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|maxrequests
operator|<
name|maxrequests
condition|)
name|disp
operator|->
name|maxrequests
operator|=
name|maxrequests
expr_stmt|;
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|createudp
label|:
comment|/* 	 * Nope, create one. 	 */
name|result
operator|=
name|dispatch_createudp
argument_list|(
name|mgr
argument_list|,
name|sockmgr
argument_list|,
name|taskmgr
argument_list|,
name|localaddr
argument_list|,
name|maxrequests
argument_list|,
name|attributes
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mgr should be locked.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_DISPATCH_HELD
end_ifndef

begin_define
define|#
directive|define
name|DNS_DISPATCH_HELD
value|20U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|dispatch_createudp
parameter_list|(
name|dns_dispatchmgr_t
modifier|*
name|mgr
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_taskmgr_t
modifier|*
name|taskmgr
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|localaddr
parameter_list|,
name|unsigned
name|int
name|maxrequests
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_socket_t
modifier|*
name|held
index|[
name|DNS_DISPATCH_HELD
index|]
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|isc_sockaddr_t
name|localaddr_bound
decl_stmt|;
name|in_port_t
name|localport
init|=
literal|0
decl_stmt|;
comment|/* 	 * dispatch_allocate() checks mgr for us. 	 */
name|disp
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|dispatch_allocate
argument_list|(
name|mgr
argument_list|,
name|maxrequests
argument_list|,
operator|&
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * Try to allocate a socket that is not on the blacklist. 	 * Hold up to DNS_DISPATCH_HELD sockets to prevent the OS 	 * from returning the same port to us too quickly. 	 */
name|memset
argument_list|(
name|held
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|held
argument_list|)
argument_list|)
expr_stmt|;
name|localaddr_bound
operator|=
operator|*
name|localaddr
expr_stmt|;
name|getsocket
label|:
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_RANDOMPORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|in_port_t
name|prt
decl_stmt|;
comment|/* XXX: should the range be configurable? */
name|prt
operator|=
literal|1024
operator|+
name|dispatch_arc4uniformrandom
argument_list|(
name|mgr
argument_list|,
literal|65535
operator|-
literal|1023
argument_list|)
expr_stmt|;
name|isc_sockaddr_setport
argument_list|(
operator|&
name|localaddr_bound
argument_list|,
name|prt
argument_list|)
expr_stmt|;
if|if
condition|(
name|blacklisted
argument_list|(
name|mgr
argument_list|,
name|NULL
argument_list|,
operator|&
name|localaddr_bound
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|k
operator|==
literal|1024
condition|)
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_RANDOMPORT
expr_stmt|;
goto|goto
name|getsocket
goto|;
block|}
name|result
operator|=
name|create_socket
argument_list|(
name|sockmgr
argument_list|,
operator|&
name|localaddr_bound
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_ADDRINUSE
condition|)
block|{
if|if
condition|(
operator|++
name|k
operator|==
literal|1024
condition|)
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_RANDOMPORT
expr_stmt|;
goto|goto
name|getsocket
goto|;
block|}
name|localport
operator|=
name|prt
expr_stmt|;
block|}
else|else
name|result
operator|=
name|create_socket
argument_list|(
name|sockmgr
argument_list|,
name|localaddr
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|deallocate_dispatch
goto|;
if|if
condition|(
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_RANDOMPORT
operator|)
operator|==
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
name|localaddr
argument_list|)
operator|==
literal|0
operator|&&
name|blacklisted
argument_list|(
name|mgr
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|held
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|held
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|held
index|[
name|i
operator|++
index|]
operator|=
name|sock
expr_stmt|;
name|sock
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DNS_DISPATCH_HELD
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|++
operator|==
literal|0xffffU
condition|)
block|{
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"avoid-v%s-udp-ports: "
literal|"unable to allocate a non-blacklisted port"
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|localaddr
argument_list|)
operator|==
name|AF_INET
condition|?
literal|"4"
else|:
literal|"6"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|deallocate_dispatch
goto|;
block|}
goto|goto
name|getsocket
goto|;
block|}
name|disp
operator|->
name|socktype
operator|=
name|isc_sockettype_udp
expr_stmt|;
name|disp
operator|->
name|socket
operator|=
name|sock
expr_stmt|;
name|disp
operator|->
name|local
operator|=
operator|*
name|localaddr
expr_stmt|;
name|disp
operator|->
name|localport
operator|=
name|localport
expr_stmt|;
name|disp
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_task_create
argument_list|(
name|taskmgr
argument_list|,
literal|0
argument_list|,
operator|&
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|kill_socket
goto|;
name|disp
operator|->
name|ctlevent
operator|=
name|isc_event_allocate
argument_list|(
name|mgr
operator|->
name|mctx
argument_list|,
name|disp
argument_list|,
name|DNS_EVENT_DISPATCHCONTROL
argument_list|,
name|destroy_disp
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_event_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|ctlevent
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|kill_task
goto|;
block|}
name|isc_task_setname
argument_list|(
name|disp
operator|->
name|task
argument_list|,
literal|"udpdispatch"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_TCP
expr_stmt|;
name|attributes
operator||=
name|DNS_DISPATCHATTR_UDP
expr_stmt|;
name|disp
operator|->
name|attributes
operator|=
name|attributes
expr_stmt|;
comment|/* 	 * Append it to the dispatcher list. 	 */
name|ISC_LIST_APPEND
argument_list|(
name|mgr
operator|->
name|list
argument_list|,
name|disp
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mgr_log
argument_list|(
name|mgr
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created UDP dispatcher %p"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created task %p"
argument_list|,
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"created socket %p"
argument_list|,
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
goto|goto
name|cleanheld
goto|;
comment|/* 	 * Error returns. 	 */
name|kill_task
label|:
name|isc_task_detach
argument_list|(
operator|&
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|kill_socket
label|:
name|isc_socket_detach
argument_list|(
operator|&
name|disp
operator|->
name|socket
argument_list|)
expr_stmt|;
name|deallocate_dispatch
label|:
name|dispatch_free
argument_list|(
operator|&
name|disp
argument_list|)
expr_stmt|;
name|cleanheld
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DNS_DISPATCH_HELD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|held
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|isc_socket_detach
argument_list|(
operator|&
name|held
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_attach
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
operator|*
name|dispp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|dispp
operator|=
name|disp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It is important to lock the manager while we are deleting the dispatch,  * since dns_dispatch_getudp will call dispatch_find, which returns to  * the caller a dispatch but does not attach to it until later.  _getudp  * locks the manager, however, so locking it here will keep us from attaching  * to a dispatcher that is in the process of going away.  */
end_comment

begin_function
name|void
name|dns_dispatch_detach
parameter_list|(
name|dns_dispatch_t
modifier|*
modifier|*
name|dispp
parameter_list|)
block|{
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|REQUIRE
argument_list|(
name|dispp
operator|!=
name|NULL
operator|&&
name|VALID_DISPATCH
argument_list|(
operator|*
name|dispp
argument_list|)
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|*
name|dispp
expr_stmt|;
operator|*
name|dispp
operator|=
name|NULL
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|--
expr_stmt|;
name|killit
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
block|}
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"detach: refcount %d"
argument_list|,
name|disp
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_addresponse
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|dest
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dns_messageid_t
modifier|*
name|idp
parameter_list|,
name|dns_dispentry_t
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|dns_messageid_t
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|ok
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dest
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
operator|&&
operator|*
name|resp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|idp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SHUTTINGDOWN
operator|)
return|;
block|}
if|if
condition|(
name|disp
operator|->
name|requests
operator|>=
name|disp
operator|->
name|maxrequests
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_QUOTA
operator|)
return|;
block|}
comment|/* 	 * Try somewhat hard to find an unique ID. 	 */
name|id
operator|=
operator|(
name|dns_messageid_t
operator|)
name|dispatch_arc4random
argument_list|(
name|disp
operator|->
name|mgr
argument_list|)
expr_stmt|;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
name|ok
operator|=
name|ISC_FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bucket_search
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|,
name|bucket
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ok
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
name|id
operator|+=
name|qid
operator|->
name|qid_increment
expr_stmt|;
name|id
operator|&=
literal|0x0000ffff
expr_stmt|;
name|bucket
operator|=
name|dns_hash
argument_list|(
name|qid
argument_list|,
name|dest
argument_list|,
name|id
argument_list|,
name|disp
operator|->
name|localport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMORE
operator|)
return|;
block|}
name|res
operator|=
name|isc_mempool_get
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|rpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|disp
operator|->
name|refcount
operator|++
expr_stmt|;
name|disp
operator|->
name|requests
operator|++
expr_stmt|;
name|res
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
name|res
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|res
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|res
operator|->
name|port
operator|=
name|disp
operator|->
name|localport
expr_stmt|;
name|res
operator|->
name|bucket
operator|=
name|bucket
expr_stmt|;
name|res
operator|->
name|host
operator|=
operator|*
name|dest
expr_stmt|;
name|res
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|res
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|res
operator|->
name|item_out
operator|=
name|ISC_FALSE
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|res
operator|->
name|magic
operator|=
name|RESPONSE_MAGIC
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|,
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|res
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"attached to task %p"
argument_list|,
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_UDP
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_CONNECTED
operator|)
operator|!=
literal|0
operator|)
condition|)
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|idp
operator|=
name|id
expr_stmt|;
operator|*
name|resp
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_starttcp
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|dispatch_log
argument_list|(
name|disp
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"starttcp %p"
argument_list|,
name|disp
operator|->
name|task
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_CONNECTED
expr_stmt|;
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_removeresponse
parameter_list|(
name|dns_dispentry_t
modifier|*
modifier|*
name|resp
parameter_list|,
name|dns_dispatchevent_t
modifier|*
modifier|*
name|sockevent
parameter_list|)
block|{
name|dns_dispatchmgr_t
modifier|*
name|mgr
decl_stmt|;
name|dns_dispatch_t
modifier|*
name|disp
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|res
decl_stmt|;
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|unsigned
name|int
name|bucket
decl_stmt|;
name|isc_boolean_t
name|killit
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|isc_eventlist_t
name|events
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
name|REQUIRE
argument_list|(
name|resp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_RESPONSE
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|*
name|resp
expr_stmt|;
operator|*
name|resp
operator|=
name|NULL
expr_stmt|;
name|disp
operator|=
name|res
operator|->
name|disp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|=
name|disp
operator|->
name|mgr
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCHMGR
argument_list|(
name|mgr
argument_list|)
argument_list|)
expr_stmt|;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockevent
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
operator|*
name|sockevent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|=
operator|*
name|sockevent
expr_stmt|;
operator|*
name|sockevent
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ev
operator|=
name|NULL
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|requests
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|requests
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|disp
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|disp
operator|->
name|refcount
operator|--
expr_stmt|;
name|killit
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|>
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
block|}
name|bucket
operator|=
name|res
operator|->
name|bucket
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|qid
operator|->
name|qid_table
index|[
name|bucket
index|]
argument_list|,
name|res
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
operator|&&
name|res
operator|->
name|item_out
condition|)
block|{
comment|/* 		 * We've posted our event, but the caller hasn't gotten it 		 * yet.  Take it back. 		 */
name|ISC_LIST_INIT
argument_list|(
name|events
argument_list|)
expr_stmt|;
name|n
operator|=
name|isc_task_unsend
argument_list|(
name|res
operator|->
name|task
argument_list|,
name|res
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|NULL
argument_list|,
operator|&
name|events
argument_list|)
expr_stmt|;
comment|/* 		 * We had better have gotten it back. 		 */
name|INSIST
argument_list|(
name|n
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ev
operator|=
operator|(
name|dns_dispatchevent_t
operator|*
operator|)
name|ISC_LIST_HEAD
argument_list|(
name|events
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|res
operator|->
name|item_out
operator|==
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|res
operator|->
name|item_out
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|buffer
operator|.
name|base
operator|!=
name|NULL
condition|)
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_event
argument_list|(
name|disp
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
name|request_log
argument_list|(
name|disp
argument_list|,
name|res
argument_list|,
name|LVL
argument_list|(
literal|90
argument_list|)
argument_list|,
literal|"detaching from task %p"
argument_list|,
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|res
operator|->
name|task
argument_list|)
expr_stmt|;
comment|/* 	 * Free any buffered requests as well 	 */
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
while|while
condition|(
name|ev
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|res
operator|->
name|items
argument_list|,
name|ev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|buffer
operator|.
name|base
operator|!=
name|NULL
condition|)
name|free_buffer
argument_list|(
name|disp
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|base
argument_list|,
name|ev
operator|->
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
name|free_event
argument_list|(
name|disp
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|res
operator|->
name|items
argument_list|)
expr_stmt|;
block|}
name|res
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mempool_put
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|rpool
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
else|else
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|killit
operator|=
name|destroy_disp_ok
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|killit
condition|)
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
argument_list|,
operator|&
name|disp
operator|->
name|ctlevent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|dns_dispatchevent_t
modifier|*
name|ev
decl_stmt|;
name|dns_dispentry_t
modifier|*
name|resp
decl_stmt|;
name|dns_qid_t
modifier|*
name|qid
decl_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutdown_out
operator|==
literal|1
condition|)
return|return;
name|qid
operator|=
name|DNS_QID
argument_list|(
name|disp
argument_list|)
expr_stmt|;
comment|/* 	 * Search for the first response handler without packets outstanding. 	 */
name|LOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|resp
operator|=
name|linear_first
argument_list|(
name|qid
argument_list|)
init|;
name|resp
operator|!=
name|NULL
operator|&&
name|resp
operator|->
name|item_out
operator|!=
name|ISC_FALSE
condition|;
comment|/* Empty. */
control|)
name|resp
operator|=
name|linear_next
argument_list|(
name|qid
argument_list|,
name|resp
argument_list|)
expr_stmt|;
comment|/* 	 * No one to send the cancel event to, so nothing to do. 	 */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
comment|/* 	 * Send the shutdown failsafe event to this resp. 	 */
name|ev
operator|=
name|disp
operator|->
name|failsafe_ev
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_DISPATCH
argument_list|,
name|resp
operator|->
name|action
argument_list|,
name|resp
operator|->
name|arg
argument_list|,
name|resp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|->
name|result
operator|=
name|disp
operator|->
name|shutdown_why
expr_stmt|;
name|ev
operator|->
name|buffer
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ev
operator|->
name|buffer
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|disp
operator|->
name|shutdown_out
operator|=
literal|1
expr_stmt|;
name|request_log
argument_list|(
name|disp
argument_list|,
name|resp
argument_list|,
name|LVL
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"cancel: failsafe event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|resp
operator|->
name|task
argument_list|)
expr_stmt|;
name|resp
operator|->
name|item_out
operator|=
name|ISC_TRUE
expr_stmt|;
name|isc_task_send
argument_list|(
name|resp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|unlock
label|:
name|UNLOCK
argument_list|(
operator|&
name|qid
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_socket_t
modifier|*
name|dns_dispatch_getsocket
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|disp
operator|->
name|socket
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_dispatch_getlocaladdress
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addrp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addrp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|socktype
operator|==
name|isc_sockettype_udp
condition|)
block|{
operator|*
name|addrp
operator|=
name|disp
operator|->
name|local
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_cancel
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|shutting_down
operator|==
literal|1
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|disp
operator|->
name|shutdown_why
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|disp
operator|->
name|shutting_down
operator|=
literal|1
expr_stmt|;
name|do_cancel
argument_list|(
name|disp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|dns_dispatch_changeattributes
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|unsigned
name|int
name|attributes
parameter_list|,
name|unsigned
name|int
name|mask
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXXMLG 	 * Should check for valid attributes here! 	 */
name|LOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator|&=
operator|~
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
name|startrecv
argument_list|(
name|disp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|disp
operator|->
name|attributes
operator||=
name|DNS_DISPATCHATTR_NOLISTEN
expr_stmt|;
if|if
condition|(
name|disp
operator|->
name|recv_pending
operator|!=
literal|0
condition|)
name|isc_socket_cancel
argument_list|(
name|disp
operator|->
name|socket
argument_list|,
name|disp
operator|->
name|task
argument_list|,
name|ISC_SOCKCANCEL_RECV
argument_list|)
expr_stmt|;
block|}
block|}
name|disp
operator|->
name|attributes
operator|&=
operator|~
name|mask
expr_stmt|;
name|disp
operator|->
name|attributes
operator||=
operator|(
name|attributes
operator|&
name|mask
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|disp
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_dispatch_importrecv
parameter_list|(
name|dns_dispatch_t
modifier|*
name|disp
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|sevent
decl_stmt|,
modifier|*
name|newsevent
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_DISPATCH
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|disp
operator|->
name|attributes
operator|&
name|DNS_DISPATCHATTR_NOLISTEN
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
expr_stmt|;
name|INSIST
argument_list|(
name|sevent
operator|->
name|n
operator|<=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
argument_list|)
expr_stmt|;
name|newsevent
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|disp
operator|->
name|mgr
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_IMPORTRECVDONE
argument_list|,
name|udp_recv
argument_list|,
name|disp
argument_list|,
sizeof|sizeof
argument_list|(
name|isc_socketevent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsevent
operator|==
name|NULL
condition|)
return|return;
name|buf
operator|=
name|allocate_udp_buffer
argument_list|(
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|newsevent
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|sevent
operator|->
name|region
operator|.
name|base
argument_list|,
name|sevent
operator|->
name|n
argument_list|)
expr_stmt|;
name|newsevent
operator|->
name|region
operator|.
name|base
operator|=
name|buf
expr_stmt|;
name|newsevent
operator|->
name|region
operator|.
name|length
operator|=
name|disp
operator|->
name|mgr
operator|->
name|buffersize
expr_stmt|;
name|newsevent
operator|->
name|n
operator|=
name|sevent
operator|->
name|n
expr_stmt|;
name|newsevent
operator|->
name|result
operator|=
name|sevent
operator|->
name|result
expr_stmt|;
name|newsevent
operator|->
name|address
operator|=
name|sevent
operator|->
name|address
expr_stmt|;
name|newsevent
operator|->
name|timestamp
operator|=
name|sevent
operator|->
name|timestamp
expr_stmt|;
name|newsevent
operator|->
name|pktinfo
operator|=
name|sevent
operator|->
name|pktinfo
expr_stmt|;
name|newsevent
operator|->
name|attributes
operator|=
name|sevent
operator|->
name|attributes
expr_stmt|;
name|isc_task_send
argument_list|(
name|disp
operator|->
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|newsevent
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void dns_dispatchmgr_dump(dns_dispatchmgr_t *mgr) { 	dns_dispatch_t *disp; 	char foo[1024];  	disp = ISC_LIST_HEAD(mgr->list); 	while (disp != NULL) { 		isc_sockaddr_format(&disp->local, foo, sizeof(foo)); 		printf("\tdispatch %p, addr %s\n", disp, foo); 		disp = ISC_LIST_NEXT(disp, link); 	} }
endif|#
directive|endif
end_endif

end_unit

