begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2014  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000, 2001  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: gssapictx.c,v 1.29 2011/08/29 06:33:25 marka Exp $ */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/dir.h>
end_include

begin_include
include|#
directive|include
file|<isc/entropy.h>
end_include

begin_include
include|#
directive|include
file|<isc/file.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/random.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/time.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/types.h>
end_include

begin_include
include|#
directive|include
file|<dns/keyvalues.h>
end_include

begin_include
include|#
directive|include
file|<dns/log.h>
end_include

begin_include
include|#
directive|include
file|<dst/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<dst/result.h>
end_include

begin_include
include|#
directive|include
file|"dst_internal.h"
end_include

begin_comment
comment|/*  * If we're using our own SPNEGO implementation (see configure.in),  * pull it in now.  Otherwise, we just use whatever GSSAPI supplies.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|GSSAPI
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_ISC_SPNEGO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"spnego.h"
end_include

begin_define
define|#
directive|define
name|gss_accept_sec_context
value|gss_accept_sec_context_spnego
end_define

begin_define
define|#
directive|define
name|gss_init_sec_context
value|gss_init_sec_context_spnego
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Solaris8 apparently needs an explicit OID set, and Solaris10 needs  * one for anything but Kerberos.  Supplying an explicit OID set  * doesn't appear to hurt anything in other implementations, so we  * always use one.  If we're not using our own SPNEGO implementation,  * we include SPNEGO's OID.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_include
include|#
directive|include
file|<krb5/krb5.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
include|ISC_PLATFORM_KRB5HEADER
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|krb5_mech_oid_bytes
index|[]
init|=
block|{
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x86
block|,
literal|0xf7
block|,
literal|0x12
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_ISC_SPNEGO
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|spnego_mech_oid_bytes
index|[]
init|=
block|{
literal|0x2b
block|,
literal|0x06
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0x02
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|mech_oid_set_array
index|[]
init|=
block|{
block|{
sizeof|sizeof
argument_list|(
name|krb5_mech_oid_bytes
argument_list|)
block|,
name|krb5_mech_oid_bytes
block|}
block|,
ifndef|#
directive|ifndef
name|USE_ISC_SPNEGO
block|{
sizeof|sizeof
argument_list|(
name|spnego_mech_oid_bytes
argument_list|)
block|,
name|spnego_mech_oid_bytes
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gss_OID_set_desc
name|mech_oid_set
init|=
block|{
sizeof|sizeof
argument_list|(
name|mech_oid_set_array
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|mech_oid_set_array
argument_list|)
block|,
name|mech_oid_set_array
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REGION_TO_GBUFFER
parameter_list|(
name|r
parameter_list|,
name|gb
parameter_list|)
define|\
value|do { \ 		(gb).length = (r).length; \ 		(gb).value = (r).base; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|GBUFFER_TO_REGION
parameter_list|(
name|gb
parameter_list|,
name|r
parameter_list|)
define|\
value|do { \ 	  (r).length = (unsigned int)(gb).length; \ 		(r).base = (gb).value; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|RETERR
parameter_list|(
name|x
parameter_list|)
value|do { \ 	result = (x); \ 	if (result != ISC_R_SUCCESS) \ 		goto out; \ 	} while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|name_to_gbuffer
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|gss_buffer_desc
modifier|*
name|gbuffer
parameter_list|)
block|{
name|dns_name_t
name|tname
decl_stmt|,
modifier|*
name|namep
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|dns_name_isabsolute
argument_list|(
name|name
argument_list|)
condition|)
name|namep
operator|=
name|name
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|labels
decl_stmt|;
name|dns_name_init
argument_list|(
operator|&
name|tname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labels
operator|=
name|dns_name_countlabels
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dns_name_getlabelsequence
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|labels
operator|-
literal|1
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
name|namep
operator|=
operator|&
name|tname
expr_stmt|;
block|}
name|result
operator|=
name|dns_name_toprincipal
argument_list|(
name|namep
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|REGION_TO_GBUFFER
argument_list|(
name|r
argument_list|,
operator|*
name|gbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_cred
parameter_list|(
specifier|const
name|gss_cred_id_t
name|cred
parameter_list|)
block|{
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|,
name|lifetime
decl_stmt|;
name|gss_name_t
name|gname
decl_stmt|;
name|gss_buffer_desc
name|gbuffer
decl_stmt|;
name|gss_cred_usage_t
name|usage
decl_stmt|;
specifier|const
name|char
modifier|*
name|usage_text
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|gret
operator|=
name|gss_inquire_cred
argument_list|(
operator|&
name|minor
argument_list|,
name|cred
argument_list|,
operator|&
name|gname
argument_list|,
operator|&
name|lifetime
argument_list|,
operator|&
name|usage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_inquire_cred: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|gret
operator|=
name|gss_display_name
argument_list|(
operator|&
name|minor
argument_list|,
name|gname
argument_list|,
operator|&
name|gbuffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_display_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|usage
condition|)
block|{
case|case
name|GSS_C_BOTH
case|:
name|usage_text
operator|=
literal|"GSS_C_BOTH"
expr_stmt|;
break|break;
case|case
name|GSS_C_INITIATE
case|:
name|usage_text
operator|=
literal|"GSS_C_INITIATE"
expr_stmt|;
break|break;
case|case
name|GSS_C_ACCEPT
case|:
name|usage_text
operator|=
literal|"GSS_C_ACCEPT"
expr_stmt|;
break|break;
default|default:
name|usage_text
operator|=
literal|"???"
expr_stmt|;
block|}
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"gss cred: \"%s\", %s, %lu"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|gbuffer
operator|.
name|value
argument_list|,
name|usage_text
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|lifetime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gret
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
if|if
condition|(
name|gbuffer
operator|.
name|length
operator|!=
literal|0U
condition|)
block|{
name|gret
operator|=
name|gss_release_buffer
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_release_buffer: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|gret
operator|=
name|gss_release_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_release_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_comment
comment|/*  * check for the most common configuration errors.  *  * The errors checked for are:  *   - tkey-gssapi-credential doesn't start with DNS/  *   - the default realm in /etc/krb5.conf and the  *     tkey-gssapi-credential bind config option don't match  *  * Note that if tkey-gssapi-keytab is set then these configure checks  * are not performed, and runtime errors from gssapi are used instead  */
end_comment

begin_function
specifier|static
name|void
name|check_config
parameter_list|(
specifier|const
name|char
modifier|*
name|gss_name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|krb5_context
name|krb5_ctx
decl_stmt|;
name|char
modifier|*
name|krb5_realm
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|gss_name
argument_list|,
literal|"DNS/"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gss_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"tkey-gssapi-credential (%s) "
literal|"should start with 'DNS/'"
argument_list|,
name|gss_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|krb5_init_context
argument_list|(
operator|&
name|krb5_ctx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gss_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"Unable to initialise krb5 context"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|krb5_get_default_realm
argument_list|(
name|krb5_ctx
argument_list|,
operator|&
name|krb5_realm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gss_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"Unable to get krb5 default realm"
argument_list|)
expr_stmt|;
name|krb5_free_context
argument_list|(
name|krb5_ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|gss_name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|gss_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"badly formatted "
literal|"tkey-gssapi-credentials (%s)"
argument_list|,
name|gss_name
argument_list|)
expr_stmt|;
name|krb5_free_context
argument_list|(
name|krb5_ctx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|krb5_realm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gss_log
argument_list|(
name|ISC_LOG_ERROR
argument_list|,
literal|"default realm from krb5.conf (%s) "
literal|"does not match tkey-gssapi-credential (%s)"
argument_list|,
name|krb5_realm
argument_list|,
name|gss_name
argument_list|)
expr_stmt|;
name|krb5_free_context
argument_list|(
name|krb5_ctx
argument_list|)
expr_stmt|;
return|return;
block|}
name|krb5_free_context
argument_list|(
name|krb5_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|dst_gssapi_acquirecred
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_boolean_t
name|initiate
parameter_list|,
name|gss_cred_id_t
modifier|*
name|cred
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|isc_result_t
name|result
decl_stmt|;
name|isc_buffer_t
name|namebuf
decl_stmt|;
name|gss_name_t
name|gname
decl_stmt|;
name|gss_buffer_desc
name|gnamebuf
decl_stmt|;
name|unsigned
name|char
name|array
index|[
name|DNS_NAME_MAXTEXT
operator|+
literal|1
index|]
decl_stmt|;
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|;
name|OM_uint32
name|lifetime
decl_stmt|;
name|gss_cred_usage_t
name|usage
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|cred
operator|!=
name|NULL
operator|&&
operator|*
name|cred
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXXSRA In theory we could use GSS_C_NT_HOSTBASED_SERVICE 	 * here when we're in the acceptor role, which would let us 	 * default the hostname and use a compiled in default service 	 * name of "DNS", giving one less thing to configure in 	 * named.conf.	Unfortunately, this creates a circular 	 * dependency due to DNS-based realm lookup in at least one 	 * GSSAPI implementation (Heimdal).  Oh well. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|isc_buffer_init
argument_list|(
operator|&
name|namebuf
argument_list|,
name|array
argument_list|,
sizeof|sizeof
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|name_to_gbuffer
argument_list|(
name|name
argument_list|,
operator|&
name|namebuf
argument_list|,
operator|&
name|gnamebuf
argument_list|)
expr_stmt|;
name|gret
operator|=
name|gss_import_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gnamebuf
argument_list|,
name|GSS_C_NO_OID
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|check_config
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_import_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
block|}
else|else
name|gname
operator|=
name|NULL
expr_stmt|;
comment|/* Get the credentials. */
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"acquiring credentials for %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|gnamebuf
operator|.
name|value
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXXDCL does this even make any sense? */
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"acquiring credentials for ?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initiate
condition|)
name|usage
operator|=
name|GSS_C_INITIATE
expr_stmt|;
else|else
name|usage
operator|=
name|GSS_C_ACCEPT
expr_stmt|;
name|gret
operator|=
name|gss_acquire_cred
argument_list|(
operator|&
name|minor
argument_list|,
name|gname
argument_list|,
name|GSS_C_INDEFINITE
argument_list|,
operator|&
name|mech_oid_set
argument_list|,
name|usage
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
operator|&
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed to acquire %s credentials for %s: %s"
argument_list|,
name|initiate
condition|?
literal|"initiate"
else|:
literal|"accept"
argument_list|,
operator|(
name|gname
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|gnamebuf
operator|.
name|value
else|:
literal|"?"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
name|check_config
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|gss_log
argument_list|(
literal|4
argument_list|,
literal|"acquired %s credentials for %s"
argument_list|,
name|initiate
condition|?
literal|"initiate"
else|:
literal|"accept"
argument_list|,
operator|(
name|gname
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|gnamebuf
operator|.
name|value
else|:
literal|"?"
argument_list|)
expr_stmt|;
name|log_cred
argument_list|(
operator|*
name|cred
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
block|{
name|gret
operator|=
name|gss_release_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_release_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|REQUIRE
argument_list|(
name|cred
operator|!=
name|NULL
operator|&&
operator|*
name|cred
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|initiate
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_boolean_t
name|dst_gssapi_identitymatchesrealmkrb5
parameter_list|(
name|dns_name_t
modifier|*
name|signer
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|realm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|char
name|sbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|rbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|char
modifier|*
name|rname
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * It is far, far easier to write the names we are looking at into 	 * a string, and do string operations on them. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_toprincipal
argument_list|(
name|signer
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|realm
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the realm portion.  This is the part after the @.  If it 	 * does not exist, we don't have something we like, so we fail our 	 * compare. 	 */
name|rname
operator|=
name|strchr
argument_list|(
name|sbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rname
operator|==
name|NULL
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
operator|*
name|rname
operator|=
literal|'\0'
expr_stmt|;
name|rname
operator|++
expr_stmt|;
comment|/* 	 * Find the host portion of the signer's name.	We do this by 	 * searching for the first / character.  We then check to make 	 * certain the instance name is "host" 	 * 	 * This will work for 	 *    host/example.com@EXAMPLE.COM 	 */
name|sname
operator|=
name|strchr
argument_list|(
name|sbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
operator|*
name|sname
operator|=
literal|'\0'
expr_stmt|;
name|sname
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sbuf
argument_list|,
literal|"host"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
comment|/* 	 * Now, we do a simple comparison between the name and the realm. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|sname
argument_list|,
name|nbuf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|rname
argument_list|,
name|rbuf
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|isc_boolean_true
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rname
argument_list|,
name|rbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|isc_boolean_true
operator|)
return|;
block|}
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|signer
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|realm
argument_list|)
expr_stmt|;
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_boolean_t
name|dst_gssapi_identitymatchesrealmms
parameter_list|(
name|dns_name_t
modifier|*
name|signer
parameter_list|,
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|dns_name_t
modifier|*
name|realm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|char
name|sbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
name|rbuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|char
modifier|*
name|nname
decl_stmt|;
name|char
modifier|*
name|rname
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* 	 * It is far, far easier to write the names we are looking at into 	 * a string, and do string operations on them. 	 */
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_toprincipal
argument_list|(
name|signer
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|isc_buffer_putuint8
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dns_name_format
argument_list|(
name|realm
argument_list|,
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the realm portion.  This is the part after the @.  If it 	 * does not exist, we don't have something we like, so we fail our 	 * compare. 	 */
name|rname
operator|=
name|strchr
argument_list|(
name|sbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rname
operator|==
name|NULL
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
name|sname
operator|=
name|strchr
argument_list|(
name|sbuf
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
comment|/* 	 * Verify that the $ and @ follow one another. 	 */
if|if
condition|(
name|rname
operator|-
name|sname
operator|!=
literal|1
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
comment|/* 	 * Find the host portion of the signer's name.	Zero out the $ so 	 * it terminates the signer's name, and skip past the @ for 	 * the realm. 	 * 	 * All service principals in Microsoft format seem to be in 	 *    machinename$@EXAMPLE.COM 	 * format. 	 */
name|rname
operator|++
expr_stmt|;
operator|*
name|sname
operator|=
literal|'\0'
expr_stmt|;
name|sname
operator|=
name|sbuf
expr_stmt|;
comment|/* 	 * Find the first . in the target name, and make it the end of 	 * the string.	 The rest of the name has to match the realm. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|nname
operator|=
name|strchr
argument_list|(
name|nbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nname
operator|==
name|NULL
condition|)
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
operator|*
name|nname
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Now, we do a simple comparison between the name and the realm. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|sname
argument_list|,
name|nbuf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|rname
argument_list|,
name|rbuf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|nname
argument_list|,
name|rbuf
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|isc_boolean_true
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rname
argument_list|,
name|rbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|isc_boolean_true
operator|)
return|;
block|}
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|signer
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|realm
argument_list|)
expr_stmt|;
return|return
operator|(
name|isc_boolean_false
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|dst_gssapi_releasecred
parameter_list|(
name|gss_cred_id_t
modifier|*
name|cred
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|cred
operator|!=
name|NULL
operator|&&
operator|*
name|cred
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gret
operator|=
name|gss_release_cred
argument_list|(
operator|&
name|minor
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
comment|/* Log the error, but still free the credential's memory */
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed releasing credential: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cred
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|GSSAPI
end_ifdef

begin_comment
comment|/*  * Format a gssapi error message info into a char ** on the given memory  * context. This is used to return gssapi error messages back up the  * call chain for reporting to the user.  */
end_comment

begin_function
specifier|static
name|void
name|gss_err_message
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_uint32_t
name|major
parameter_list|,
name|isc_uint32_t
name|minor
parameter_list|,
name|char
modifier|*
modifier|*
name|err_message
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|estr
decl_stmt|;
if|if
condition|(
name|err_message
operator|==
name|NULL
operator|||
name|mctx
operator|==
name|NULL
condition|)
block|{
comment|/* the caller doesn't want any error messages */
return|return;
block|}
name|estr
operator|=
name|gss_error_tostring
argument_list|(
name|major
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|estr
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|err_message
operator|)
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|estr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|isc_result_t
name|dst_gssapi_initctx
parameter_list|(
name|dns_name_t
modifier|*
name|name
parameter_list|,
name|isc_buffer_t
modifier|*
name|intoken
parameter_list|,
name|isc_buffer_t
modifier|*
name|outtoken
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|gssctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|char
modifier|*
modifier|*
name|err_message
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_t
name|namebuf
decl_stmt|;
name|gss_name_t
name|gname
decl_stmt|;
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|,
name|ret_flags
decl_stmt|,
name|flags
decl_stmt|;
name|gss_buffer_desc
name|gintoken
decl_stmt|,
modifier|*
name|gintokenp
decl_stmt|,
name|gouttoken
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|gss_buffer_desc
name|gnamebuf
decl_stmt|;
name|unsigned
name|char
name|array
index|[
name|DNS_NAME_MAXTEXT
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Client must pass us a valid gss_ctx_id_t here */
name|REQUIRE
argument_list|(
name|gssctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|namebuf
argument_list|,
name|array
argument_list|,
sizeof|sizeof
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|name_to_gbuffer
argument_list|(
name|name
argument_list|,
operator|&
name|namebuf
argument_list|,
operator|&
name|gnamebuf
argument_list|)
expr_stmt|;
comment|/* Get the name as a GSS name */
name|gret
operator|=
name|gss_import_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gnamebuf
argument_list|,
name|GSS_C_NO_OID
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_err_message
argument_list|(
name|mctx
argument_list|,
name|gret
argument_list|,
name|minor
argument_list|,
name|err_message
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|intoken
operator|!=
name|NULL
condition|)
block|{
comment|/* Don't call gss_release_buffer for gintoken! */
name|REGION_TO_GBUFFER
argument_list|(
operator|*
name|intoken
argument_list|,
name|gintoken
argument_list|)
expr_stmt|;
name|gintokenp
operator|=
operator|&
name|gintoken
expr_stmt|;
block|}
else|else
block|{
name|gintokenp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Note that we don't set GSS_C_SEQUENCE_FLAG as Windows DNS 	 * servers don't like it. 	 */
name|flags
operator|=
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_MUTUAL_FLAG
operator||
name|GSS_C_INTEG_FLAG
expr_stmt|;
name|gret
operator|=
name|gss_init_sec_context
argument_list|(
operator|&
name|minor
argument_list|,
name|GSS_C_NO_CREDENTIAL
argument_list|,
name|gssctx
argument_list|,
name|gname
argument_list|,
name|GSS_SPNEGO_MECHANISM
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|gintokenp
argument_list|,
name|NULL
argument_list|,
operator|&
name|gouttoken
argument_list|,
operator|&
name|ret_flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|gret
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|gss_err_message
argument_list|(
name|mctx
argument_list|,
name|gret
argument_list|,
name|minor
argument_list|,
name|err_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_message
operator|!=
name|NULL
operator|&&
operator|*
name|err_message
operator|!=
name|NULL
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"Failure initiating security context: %s"
argument_list|,
operator|*
name|err_message
argument_list|)
expr_stmt|;
else|else
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"Failure initiating security context"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * XXXSRA Not handled yet: RFC 3645 3.1.1: check ret_flags 	 * MUTUAL and INTEG flags, fail if either not set. 	 */
comment|/* 	 * RFC 2744 states the a valid output token has a non-zero length. 	 */
if|if
condition|(
name|gouttoken
operator|.
name|length
operator|!=
literal|0U
condition|)
block|{
name|GBUFFER_TO_REGION
argument_list|(
name|gouttoken
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|isc_buffer_copyregion
argument_list|(
name|outtoken
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gouttoken
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gret
operator|==
name|GSS_S_COMPLETE
condition|)
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
else|else
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|gss_release_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|intoken
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|outtoken
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|gssctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|err_message
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|dst_gssapi_acceptctx
parameter_list|(
name|gss_cred_id_t
name|cred
parameter_list|,
specifier|const
name|char
modifier|*
name|gssapi_keytab
parameter_list|,
name|isc_region_t
modifier|*
name|intoken
parameter_list|,
name|isc_buffer_t
modifier|*
modifier|*
name|outtoken
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|ctxout
parameter_list|,
name|dns_name_t
modifier|*
name|principal
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|isc_region_t
name|r
decl_stmt|;
name|isc_buffer_t
name|namebuf
decl_stmt|;
name|gss_buffer_desc
name|gnamebuf
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|,
name|gintoken
decl_stmt|,
name|gouttoken
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|;
name|gss_ctx_id_t
name|context
init|=
name|GSS_C_NO_CONTEXT
decl_stmt|;
name|gss_name_t
name|gname
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|outtoken
operator|!=
name|NULL
operator|&&
operator|*
name|outtoken
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REGION_TO_GBUFFER
argument_list|(
operator|*
name|intoken
argument_list|,
name|gintoken
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ctxout
operator|==
name|NULL
condition|)
name|context
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
else|else
name|context
operator|=
operator|*
name|ctxout
expr_stmt|;
if|if
condition|(
name|gssapi_keytab
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_GSSAPI_KRB5_HEADER
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
name|gret
operator|=
name|gsskrb5_register_acceptor_identity
argument_list|(
name|gssapi_keytab
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed "
literal|"gsskrb5_register_acceptor_identity(%s): %s"
argument_list|,
name|gssapi_keytab
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_INVALIDTKEY
operator|)
return|;
block|}
else|#
directive|else
comment|/* 		 * Minimize memory leakage by only setting KRB5_KTNAME 		 * if it needs to change. 		 */
specifier|const
name|char
modifier|*
name|old
init|=
name|getenv
argument_list|(
literal|"KRB5_KTNAME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|old
argument_list|,
name|gssapi_keytab
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|kt
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|gssapi_keytab
argument_list|)
operator|+
literal|13
argument_list|)
decl_stmt|;
if|if
condition|(
name|kt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|sprintf
argument_list|(
name|kt
argument_list|,
literal|"KRB5_KTNAME=%s"
argument_list|,
name|gssapi_keytab
argument_list|)
expr_stmt|;
if|if
condition|(
name|putenv
argument_list|(
name|kt
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
endif|#
directive|endif
block|}
name|log_cred
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|gret
operator|=
name|gss_accept_sec_context
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|context
argument_list|,
name|cred
argument_list|,
operator|&
name|gintoken
argument_list|,
name|GSS_C_NO_CHANNEL_BINDINGS
argument_list|,
operator|&
name|gname
argument_list|,
name|NULL
argument_list|,
operator|&
name|gouttoken
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
switch|switch
condition|(
name|gret
condition|)
block|{
case|case
name|GSS_S_COMPLETE
case|:
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
break|break;
case|case
name|GSS_S_CONTINUE_NEEDED
case|:
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
break|break;
case|case
name|GSS_S_DEFECTIVE_TOKEN
case|:
case|case
name|GSS_S_DEFECTIVE_CREDENTIAL
case|:
case|case
name|GSS_S_BAD_SIG
case|:
case|case
name|GSS_S_DUPLICATE_TOKEN
case|:
case|case
name|GSS_S_OLD_TOKEN
case|:
case|case
name|GSS_S_NO_CRED
case|:
case|case
name|GSS_S_CREDENTIALS_EXPIRED
case|:
case|case
name|GSS_S_BAD_BINDINGS
case|:
case|case
name|GSS_S_NO_CONTEXT
case|:
case|case
name|GSS_S_BAD_MECH
case|:
case|case
name|GSS_S_FAILURE
case|:
name|result
operator|=
name|DNS_R_INVALIDTKEY
expr_stmt|;
comment|/* fall through */
default|default:
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_accept_sec_context: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|gouttoken
operator|.
name|length
operator|>
literal|0U
condition|)
block|{
name|RETERR
argument_list|(
name|isc_buffer_allocate
argument_list|(
name|mctx
argument_list|,
name|outtoken
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|gouttoken
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|GBUFFER_TO_REGION
argument_list|(
name|gouttoken
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|isc_buffer_copyregion
argument_list|(
operator|*
name|outtoken
argument_list|,
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gouttoken
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gret
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|gret
operator|=
name|gss_display_name
argument_list|(
operator|&
name|minor
argument_list|,
name|gname
argument_list|,
operator|&
name|gnamebuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_display_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|ISC_R_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Compensate for a bug in Solaris8's implementation 		 * of gss_display_name().  Should be harmless in any 		 * case, since principal names really should not 		 * contain null characters. 		 */
if|if
condition|(
name|gnamebuf
operator|.
name|length
operator|>
literal|0U
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|gnamebuf
operator|.
name|value
operator|)
index|[
name|gnamebuf
operator|.
name|length
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|gnamebuf
operator|.
name|length
operator|--
expr_stmt|;
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"gss-api source name (accept) is %.*s"
argument_list|,
operator|(
name|int
operator|)
name|gnamebuf
operator|.
name|length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|gnamebuf
operator|.
name|value
argument_list|)
expr_stmt|;
name|GBUFFER_TO_REGION
argument_list|(
name|gnamebuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|namebuf
argument_list|,
name|r
operator|.
name|base
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|namebuf
argument_list|,
name|r
operator|.
name|length
argument_list|)
expr_stmt|;
name|RETERR
argument_list|(
name|dns_name_fromtext
argument_list|(
name|principal
argument_list|,
operator|&
name|namebuf
argument_list|,
name|dns_rootname
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnamebuf
operator|.
name|length
operator|!=
literal|0U
condition|)
block|{
name|gret
operator|=
name|gss_release_buffer
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gnamebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_release_buffer: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ctxout
operator|=
name|context
expr_stmt|;
name|out
label|:
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
block|{
name|gret
operator|=
name|gss_release_name
argument_list|(
operator|&
name|minor
argument_list|,
operator|&
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"failed gss_release_name: %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|gssapi_keytab
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|intoken
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|outtoken
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|ctxout
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|principal
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|dst_gssapi_deletectx
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|gss_ctx_id_t
modifier|*
name|gssctx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|OM_uint32
name|gret
decl_stmt|,
name|minor
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|gssctx
operator|!=
name|NULL
operator|&&
operator|*
name|gssctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Delete the context from the GSS provider */
name|gret
operator|=
name|gss_delete_sec_context
argument_list|(
operator|&
name|minor
argument_list|,
name|gssctx
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|gret
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
comment|/* Log the error, but still free the context's memory */
name|gss_log
argument_list|(
literal|3
argument_list|,
literal|"Failure deleting security context %s"
argument_list|,
name|gss_error_tostring
argument_list|(
name|gret
argument_list|,
name|minor
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|mctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|gssctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|char
modifier|*
name|gss_error_tostring
parameter_list|(
name|isc_uint32_t
name|major
parameter_list|,
name|isc_uint32_t
name|minor
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GSSAPI
name|gss_buffer_desc
name|msg_minor
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|,
name|msg_major
init|=
name|GSS_C_EMPTY_BUFFER
decl_stmt|;
name|OM_uint32
name|msg_ctx
decl_stmt|,
name|minor_stat
decl_stmt|;
comment|/* Handle major status */
name|msg_ctx
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gss_display_status
argument_list|(
operator|&
name|minor_stat
argument_list|,
name|major
argument_list|,
name|GSS_C_GSS_CODE
argument_list|,
name|GSS_C_NULL_OID
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|msg_major
argument_list|)
expr_stmt|;
comment|/* Handle minor status */
name|msg_ctx
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gss_display_status
argument_list|(
operator|&
name|minor_stat
argument_list|,
name|minor
argument_list|,
name|GSS_C_MECH_CODE
argument_list|,
name|GSS_C_NULL_OID
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|msg_minor
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"GSSAPI error: Major = %s, Minor = %s."
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg_major
operator|.
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg_minor
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_major
operator|.
name|length
operator|!=
literal|0U
condition|)
operator|(
name|void
operator|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor_stat
argument_list|,
operator|&
name|msg_major
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_minor
operator|.
name|length
operator|!=
literal|0U
condition|)
operator|(
name|void
operator|)
name|gss_release_buffer
argument_list|(
operator|&
name|minor_stat
argument_list|,
operator|&
name|msg_minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
else|#
directive|else
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"GSSAPI error: Major = %u, Minor = %u."
argument_list|,
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|gss_log
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|isc_log_vwrite
argument_list|(
name|dns_lctx
argument_list|,
name|DNS_LOGCATEGORY_GENERAL
argument_list|,
name|DNS_LOGMODULE_TKEY
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
name|level
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*! \file */
end_comment

end_unit

