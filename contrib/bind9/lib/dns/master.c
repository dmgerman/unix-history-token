begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2009, 2011, 2012  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1999-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<isc/event.h>
end_include

begin_include
include|#
directive|include
file|<isc/lex.h>
end_include

begin_include
include|#
directive|include
file|<isc/magic.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/serial.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdio.h>
end_include

begin_include
include|#
directive|include
file|<isc/stdtime.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/callbacks.h>
end_include

begin_include
include|#
directive|include
file|<dns/events.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/master.h>
end_include

begin_include
include|#
directive|include
file|<dns/name.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdata.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatalist.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataset.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatastruct.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/result.h>
end_include

begin_include
include|#
directive|include
file|<dns/soa.h>
end_include

begin_include
include|#
directive|include
file|<dns/time.h>
end_include

begin_include
include|#
directive|include
file|<dns/ttl.h>
end_include

begin_comment
comment|/*!  * Grow the number of dns_rdatalist_t (#RDLSZ) and dns_rdata_t (#RDSZ) structures  * by these sizes when we need to.  *  */
end_comment

begin_comment
comment|/*% RDLSZ reflects the number of different types with the same name expected. */
end_comment

begin_define
define|#
directive|define
name|RDLSZ
value|32
end_define

begin_comment
comment|/*%  * RDSZ reflects the number of rdata expected at a give name that can fit into  * 64k.  */
end_comment

begin_define
define|#
directive|define
name|RDSZ
value|512
end_define

begin_define
define|#
directive|define
name|NBUFS
value|4
end_define

begin_define
define|#
directive|define
name|MAXWIRESZ
value|255
end_define

begin_comment
comment|/*%  * Target buffer size and minimum target size.  * MINTSIZ must be big enough to hold the largest rdata record.  * \brief  * TSIZ>= MINTSIZ  */
end_comment

begin_define
define|#
directive|define
name|TSIZ
value|(128*1024)
end_define

begin_comment
comment|/*%  * max message size - header - root - type - class - ttl - rdlen  */
end_comment

begin_define
define|#
directive|define
name|MINTSIZ
value|DNS_RDATA_MAXLENGTH
end_define

begin_comment
comment|/*%  * Size for tokens in the presentation format,  * The largest tokens are the base64 blocks in KEY and CERT records,  * Largest key allowed is about 1372 bytes but  * there is no fixed upper bound on CERT records.  * 2K is too small for some X.509s, 8K is overkill.  */
end_comment

begin_define
define|#
directive|define
name|TOKENSIZ
value|(8*1024)
end_define

begin_comment
comment|/*%  * Buffers sizes for $GENERATE.  */
end_comment

begin_define
define|#
directive|define
name|DNS_MASTER_LHS
value|2048
end_define

begin_define
define|#
directive|define
name|DNS_MASTER_RHS
value|MINTSIZ
end_define

begin_typedef
typedef|typedef
name|ISC_LIST
argument_list|(
argument|dns_rdatalist_t
argument_list|)
name|rdatalist_head_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dns_incctx
name|dns_incctx_t
typedef|;
end_typedef

begin_comment
comment|/*%  * Master file load state.  */
end_comment

begin_struct
struct|struct
name|dns_loadctx
block|{
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_masterformat_t
name|format
decl_stmt|;
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|dns_loaddonefunc_t
name|done
decl_stmt|;
name|void
modifier|*
name|done_arg
decl_stmt|;
comment|/* Common methods */
name|isc_result_t
function_decl|(
modifier|*
name|openfile
function_decl|)
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
name|isc_result_t
function_decl|(
modifier|*
name|load
function_decl|)
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
comment|/* Members specific to the text format: */
name|isc_lex_t
modifier|*
name|lex
decl_stmt|;
name|isc_boolean_t
name|keep_lex
decl_stmt|;
name|unsigned
name|int
name|options
decl_stmt|;
name|isc_boolean_t
name|ttl_known
decl_stmt|;
name|isc_boolean_t
name|default_ttl_known
decl_stmt|;
name|isc_boolean_t
name|warn_1035
decl_stmt|;
name|isc_boolean_t
name|warn_tcr
decl_stmt|;
name|isc_boolean_t
name|warn_sigexpired
decl_stmt|;
name|isc_boolean_t
name|seen_include
decl_stmt|;
name|isc_uint32_t
name|ttl
decl_stmt|;
name|isc_uint32_t
name|default_ttl
decl_stmt|;
name|dns_rdataclass_t
name|zclass
decl_stmt|;
name|dns_fixedname_t
name|fixed_top
decl_stmt|;
name|dns_name_t
modifier|*
name|top
decl_stmt|;
comment|/*%< top of zone */
comment|/* Members specific to the raw format: */
name|FILE
modifier|*
name|f
decl_stmt|;
name|isc_boolean_t
name|first
decl_stmt|;
comment|/* Which fixed buffers we are using? */
name|unsigned
name|int
name|loop_cnt
decl_stmt|;
comment|/*% records per quantum, 							 * 0 => all. */
name|isc_boolean_t
name|canceled
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
comment|/* locked by lock */
name|isc_uint32_t
name|references
decl_stmt|;
name|dns_incctx_t
modifier|*
name|inc
decl_stmt|;
name|isc_uint32_t
name|resign
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dns_incctx
block|{
name|dns_incctx_t
modifier|*
name|parent
decl_stmt|;
name|dns_name_t
modifier|*
name|origin
decl_stmt|;
name|dns_name_t
modifier|*
name|current
decl_stmt|;
name|dns_name_t
modifier|*
name|glue
decl_stmt|;
name|dns_fixedname_t
name|fixed
index|[
name|NBUFS
index|]
decl_stmt|;
comment|/* working buffers */
name|unsigned
name|int
name|in_use
index|[
name|NBUFS
index|]
decl_stmt|;
comment|/* covert to bitmap? */
name|int
name|glue_in_use
decl_stmt|;
name|int
name|current_in_use
decl_stmt|;
name|int
name|origin_in_use
decl_stmt|;
name|isc_boolean_t
name|drop
decl_stmt|;
name|unsigned
name|int
name|glue_line
decl_stmt|;
name|unsigned
name|int
name|current_line
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DNS_LCTX_MAGIC
value|ISC_MAGIC('L','c','t','x')
end_define

begin_define
define|#
directive|define
name|DNS_LCTX_VALID
parameter_list|(
name|lctx
parameter_list|)
value|ISC_MAGIC_VALID(lctx, DNS_LCTX_MAGIC)
end_define

begin_define
define|#
directive|define
name|DNS_AS_STR
parameter_list|(
name|t
parameter_list|)
value|((t).value.as_textregion.base)
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|openfile_text
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|master_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|openfile_raw
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|master_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|load_text
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|load_raw
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|pushfile
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|commit
parameter_list|(
name|dns_rdatacallbacks_t
modifier|*
parameter_list|,
name|dns_loadctx_t
modifier|*
parameter_list|,
name|rdatalist_head_t
modifier|*
parameter_list|,
name|dns_name_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|is_glue
parameter_list|(
name|rdatalist_head_t
modifier|*
parameter_list|,
name|dns_name_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_rdatalist_t
modifier|*
name|grow_rdatalist
parameter_list|(
name|int
parameter_list|,
name|dns_rdatalist_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rdatalist_head_t
modifier|*
parameter_list|,
name|rdatalist_head_t
modifier|*
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dns_rdata_t
modifier|*
name|grow_rdata
parameter_list|(
name|int
parameter_list|,
name|dns_rdata_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rdatalist_head_t
modifier|*
parameter_list|,
name|rdatalist_head_t
modifier|*
parameter_list|,
name|isc_mem_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_quantum
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|task_send
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loadctx_destroy
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GETTOKEN
parameter_list|(
name|lexer
parameter_list|,
name|options
parameter_list|,
name|token
parameter_list|,
name|eol
parameter_list|)
define|\
value|do { \ 		result = gettoken(lexer, options, token, eol, callbacks); \ 		switch (result) { \ 		case ISC_R_SUCCESS: \ 			break; \ 		case ISC_R_UNEXPECTED: \ 			goto insist_and_cleanup; \ 		default: \ 			if (MANYERRS(lctx, result)) { \ 				SETRESULT(lctx, result); \ 				LOGIT(result); \ 				read_till_eol = ISC_TRUE; \ 				goto next_line; \ 			} else \ 				goto log_and_cleanup; \ 		} \ 		if ((token)->type == isc_tokentype_special) { \ 			result = DNS_R_SYNTAX; \ 			if (MANYERRS(lctx, result)) { \ 				SETRESULT(lctx, result); \ 				LOGIT(result); \ 				read_till_eol = ISC_TRUE; \ 				goto next_line; \ 			} else \ 				goto log_and_cleanup; \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|COMMITALL
define|\
value|do { \ 		result = commit(callbacks, lctx,&current_list, \ 				ictx->current, source, ictx->current_line); \ 		if (MANYERRS(lctx, result)) { \ 			SETRESULT(lctx, result); \ 		} else if (result != ISC_R_SUCCESS) \ 			goto insist_and_cleanup; \ 		result = commit(callbacks, lctx,&glue_list, \ 				ictx->glue, source, ictx->glue_line); \ 		if (MANYERRS(lctx, result)) { \ 			SETRESULT(lctx, result); \ 		} else if (result != ISC_R_SUCCESS) \ 			goto insist_and_cleanup; \ 		rdcount = 0; \ 		rdlcount = 0; \ 		isc_buffer_init(&target, target_mem, target_size); \ 		rdcount_save = rdcount; \ 		rdlcount_save = rdlcount; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|WARNUNEXPECTEDEOF
parameter_list|(
name|lexer
parameter_list|)
define|\
value|do { \ 		if (isc_lex_isfile(lexer)) \ 			(*callbacks->warn)(callbacks, \ 				"%s: file does not end with newline", \ 				source); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|EXPECTEOL
define|\
value|do { \ 		GETTOKEN(lctx->lex, 0,&token, ISC_TRUE); \ 		if (token.type != isc_tokentype_eol) { \ 			isc_lex_ungettoken(lctx->lex,&token); \ 			result = DNS_R_EXTRATOKEN; \ 			if (MANYERRS(lctx, result)) { \ 				SETRESULT(lctx, result); \ 				LOGIT(result); \ 				read_till_eol = ISC_TRUE; \ 				continue; \ 			} else if (result != ISC_R_SUCCESS) \ 				goto log_and_cleanup; \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MANYERRS
parameter_list|(
name|lctx
parameter_list|,
name|result
parameter_list|)
define|\
value|((result != ISC_R_SUCCESS)&& \ 		 (result != ISC_R_IOERROR)&& \ 		 ((lctx)->options& DNS_MASTER_MANYERRORS) != 0)
end_define

begin_define
define|#
directive|define
name|SETRESULT
parameter_list|(
name|lctx
parameter_list|,
name|r
parameter_list|)
define|\
value|do { \ 			if ((lctx)->result == ISC_R_SUCCESS) \ 				(lctx)->result = r; \ 		} while (0)
end_define

begin_define
define|#
directive|define
name|LOGITFILE
parameter_list|(
name|result
parameter_list|,
name|filename
parameter_list|)
define|\
value|if (result == ISC_R_INVALIDFILE || result == ISC_R_FILENOTFOUND || \ 	    result == ISC_R_IOERROR || result == ISC_R_TOOMANYOPENFILES || \ 	    result == ISC_R_NOPERM) \ 		(*callbacks->error)(callbacks, "%s: %s:%lu: %s: %s", \ 				    "dns_master_load", source, line, \ 				    filename, dns_result_totext(result)); \ 	else LOGIT(result)
end_define

begin_define
define|#
directive|define
name|LOGIT
parameter_list|(
name|result
parameter_list|)
define|\
value|if (result == ISC_R_NOMEMORY) \ 		(*callbacks->error)(callbacks, "dns_master_load: %s", \ 				    dns_result_totext(result)); \ 	else \ 		(*callbacks->error)(callbacks, "%s: %s:%lu: %s", \ 				    "dns_master_load", \ 				    source, line, dns_result_totext(result))
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|in_addr_arpa_data
index|[]
init|=
literal|"\007IN-ADDR\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|in_addr_arpa_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|8
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dns_name_t
name|in_addr_arpa
init|=
block|{
name|DNS_NAME_MAGIC
block|,
name|in_addr_arpa_data
block|,
literal|14
block|,
literal|3
block|,
name|DNS_NAMEATTR_READONLY
operator||
name|DNS_NAMEATTR_ABSOLUTE
block|,
name|in_addr_arpa_offsets
block|,
name|NULL
block|,
block|{
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ip6_int_data
index|[]
init|=
literal|"\003IP6\003INT"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ip6_int_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dns_name_t
name|ip6_int
init|=
block|{
name|DNS_NAME_MAGIC
block|,
name|ip6_int_data
block|,
literal|9
block|,
literal|3
block|,
name|DNS_NAMEATTR_READONLY
operator||
name|DNS_NAMEATTR_ABSOLUTE
block|,
name|ip6_int_offsets
block|,
name|NULL
block|,
block|{
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ip6_arpa_data
index|[]
init|=
literal|"\003IP6\004ARPA"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ip6_arpa_offsets
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dns_name_t
name|ip6_arpa
init|=
block|{
name|DNS_NAME_MAGIC
block|,
name|ip6_arpa_data
block|,
literal|10
block|,
literal|3
block|,
name|DNS_NAMEATTR_READONLY
operator||
name|DNS_NAMEATTR_ABSOLUTE
block|,
name|ip6_arpa_offsets
block|,
name|NULL
block|,
block|{
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|,
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|gettoken
parameter_list|(
name|isc_lex_t
modifier|*
name|lex
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_token_t
modifier|*
name|token
parameter_list|,
name|isc_boolean_t
name|eol
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|options
operator||=
name|ISC_LEXOPT_EOL
operator||
name|ISC_LEXOPT_EOF
operator||
name|ISC_LEXOPT_DNSMULTILINE
operator||
name|ISC_LEXOPT_ESCAPE
expr_stmt|;
name|result
operator|=
name|isc_lex_gettoken
argument_list|(
name|lex
argument_list|,
name|options
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|ISC_R_NOMEMORY
case|:
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
default|default:
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: %s:%lu:"
literal|" isc_lex_gettoken() failed: %s"
argument_list|,
name|isc_lex_getsourcename
argument_list|(
name|lex
argument_list|)
argument_list|,
name|isc_lex_getsourceline
argument_list|(
name|lex
argument_list|)
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|eol
operator|!=
name|ISC_TRUE
condition|)
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|isc_tokentype_eol
operator|||
name|token
operator|->
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: %s:%lu: unexpected end of %s"
argument_list|,
name|isc_lex_getsourcename
argument_list|(
name|lex
argument_list|)
argument_list|,
name|isc_lex_getsourceline
argument_list|(
name|lex
argument_list|)
argument_list|,
operator|(
name|token
operator|->
name|type
operator|==
name|isc_tokentype_eol
operator|)
condition|?
literal|"line"
else|:
literal|"file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTEDEND
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_loadctx_attach
parameter_list|(
name|dns_loadctx_t
modifier|*
name|source
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|target
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|target
operator|!=
name|NULL
operator|&&
operator|*
name|target
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|source
operator|->
name|references
operator|++
expr_stmt|;
name|INSIST
argument_list|(
name|source
operator|->
name|references
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Overflow? */
name|UNLOCK
argument_list|(
operator|&
name|source
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|source
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dns_loadctx_detach
parameter_list|(
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|)
block|{
name|dns_loadctx_t
modifier|*
name|lctx
decl_stmt|;
name|isc_boolean_t
name|need_destroy
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|lctxp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lctx
operator|=
operator|*
name|lctxp
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|lctx
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|references
operator|==
literal|0
condition|)
name|need_destroy
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
name|loadctx_destroy
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
operator|*
name|lctxp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|incctx_destroy
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_incctx_t
modifier|*
name|ictx
parameter_list|)
block|{
name|dns_incctx_t
modifier|*
name|parent
decl_stmt|;
name|again
label|:
name|parent
operator|=
name|ictx
operator|->
name|parent
expr_stmt|;
name|ictx
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|ictx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ictx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|ictx
operator|=
name|parent
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|loadctx_destroy
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|inc
operator|!=
name|NULL
condition|)
name|incctx_destroy
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|lctx
operator|->
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|f
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|isc_stdio_close
argument_list|(
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_stdio_close() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* isc_lex_destroy() will close all open streams */
if|if
condition|(
name|lctx
operator|->
name|lex
operator|!=
name|NULL
operator|&&
operator|!
name|lctx
operator|->
name|keep_lex
condition|)
name|isc_lex_destroy
argument_list|(
operator|&
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|task
operator|!=
name|NULL
condition|)
name|isc_task_detach
argument_list|(
operator|&
name|lctx
operator|->
name|task
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
operator|&
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|lctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|incctx_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_incctx_t
modifier|*
modifier|*
name|ictxp
parameter_list|)
block|{
name|dns_incctx_t
modifier|*
name|ictx
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ictx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ictx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ictx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUFS
condition|;
name|i
operator|++
control|)
block|{
name|dns_fixedname_init
argument_list|(
operator|&
name|ictx
operator|->
name|fixed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ictx
operator|->
name|in_use
index|[
name|i
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|ictx
operator|->
name|origin_in_use
operator|=
literal|0
expr_stmt|;
name|ictx
operator|->
name|origin
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ictx
operator|->
name|fixed
index|[
name|ictx
operator|->
name|origin_in_use
index|]
argument_list|)
expr_stmt|;
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|origin_in_use
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|origin
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
name|ictx
operator|->
name|origin
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|ictx
operator|->
name|glue
operator|=
name|NULL
expr_stmt|;
name|ictx
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|ictx
operator|->
name|glue_in_use
operator|=
operator|-
literal|1
expr_stmt|;
name|ictx
operator|->
name|current_in_use
operator|=
operator|-
literal|1
expr_stmt|;
name|ictx
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|ictx
operator|->
name|drop
operator|=
name|ISC_FALSE
expr_stmt|;
name|ictx
operator|->
name|glue_line
operator|=
literal|0
expr_stmt|;
name|ictx
operator|->
name|current_line
operator|=
literal|0
expr_stmt|;
operator|*
name|ictxp
operator|=
name|ictx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|loadctx_create
parameter_list|(
name|dns_masterformat_t
name|format
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_uint32_t
name|resign
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|isc_lex_t
modifier|*
name|lex
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|)
block|{
name|dns_loadctx_t
modifier|*
name|lctx
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|isc_lexspecials_t
name|specials
decl_stmt|;
name|REQUIRE
argument_list|(
name|lctxp
operator|!=
name|NULL
operator|&&
operator|*
name|lctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|callbacks
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|callbacks
operator|->
name|add
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|callbacks
operator|->
name|error
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|callbacks
operator|->
name|warn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|mctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|top
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|dns_name_isabsolute
argument_list|(
name|origin
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|task
operator|==
name|NULL
operator|&&
name|done
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|!=
name|NULL
operator|&&
name|done
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|lctx
operator|->
name|inc
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|incctx_create
argument_list|(
name|mctx
argument_list|,
name|origin
argument_list|,
operator|&
name|lctx
operator|->
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_ctx
goto|;
name|lctx
operator|->
name|format
operator|=
name|format
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|dns_masterformat_text
case|:
name|lctx
operator|->
name|openfile
operator|=
name|openfile_text
expr_stmt|;
name|lctx
operator|->
name|load
operator|=
name|load_text
expr_stmt|;
break|break;
case|case
name|dns_masterformat_raw
case|:
name|lctx
operator|->
name|openfile
operator|=
name|openfile_raw
expr_stmt|;
name|lctx
operator|->
name|load
operator|=
name|load_raw
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lex
operator|!=
name|NULL
condition|)
block|{
name|lctx
operator|->
name|lex
operator|=
name|lex
expr_stmt|;
name|lctx
operator|->
name|keep_lex
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|lctx
operator|->
name|lex
operator|=
name|NULL
expr_stmt|;
name|result
operator|=
name|isc_lex_create
argument_list|(
name|mctx
argument_list|,
name|TOKENSIZ
argument_list|,
operator|&
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup_inc
goto|;
name|lctx
operator|->
name|keep_lex
operator|=
name|ISC_FALSE
expr_stmt|;
name|memset
argument_list|(
name|specials
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|specials
argument_list|)
argument_list|)
expr_stmt|;
name|specials
index|[
literal|'('
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|')'
index|]
operator|=
literal|1
expr_stmt|;
name|specials
index|[
literal|'"'
index|]
operator|=
literal|1
expr_stmt|;
name|isc_lex_setspecials
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|specials
argument_list|)
expr_stmt|;
name|isc_lex_setcomments
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|ISC_LEXCOMMENT_DNSMASTERFILE
argument_list|)
expr_stmt|;
block|}
name|lctx
operator|->
name|ttl_known
operator|=
name|ISC_FALSE
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|default_ttl_known
operator|=
name|ISC_FALSE
expr_stmt|;
name|lctx
operator|->
name|default_ttl
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|warn_1035
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* XXX Argument? */
name|lctx
operator|->
name|warn_tcr
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* XXX Argument? */
name|lctx
operator|->
name|warn_sigexpired
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* XXX Argument? */
name|lctx
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|lctx
operator|->
name|seen_include
operator|=
name|ISC_FALSE
expr_stmt|;
name|lctx
operator|->
name|zclass
operator|=
name|zclass
expr_stmt|;
name|lctx
operator|->
name|resign
operator|=
name|resign
expr_stmt|;
name|lctx
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|lctx
operator|->
name|fixed_top
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|top
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|lctx
operator|->
name|fixed_top
argument_list|)
expr_stmt|;
name|dns_name_toregion
argument_list|(
name|top
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
name|lctx
operator|->
name|top
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|f
operator|=
name|NULL
expr_stmt|;
name|lctx
operator|->
name|first
operator|=
name|ISC_TRUE
expr_stmt|;
name|lctx
operator|->
name|loop_cnt
operator|=
operator|(
name|done
operator|!=
name|NULL
operator|)
condition|?
literal|100
else|:
literal|0
expr_stmt|;
name|lctx
operator|->
name|callbacks
operator|=
name|callbacks
expr_stmt|;
name|lctx
operator|->
name|task
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|task
operator|!=
name|NULL
condition|)
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|lctx
operator|->
name|task
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|done
operator|=
name|done
expr_stmt|;
name|lctx
operator|->
name|done_arg
operator|=
name|done_arg
expr_stmt|;
name|lctx
operator|->
name|canceled
operator|=
name|ISC_FALSE
expr_stmt|;
name|lctx
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|lctx
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|references
operator|=
literal|1
expr_stmt|;
comment|/* Implicit attach. */
name|lctx
operator|->
name|magic
operator|=
name|DNS_LCTX_MAGIC
expr_stmt|;
operator|*
name|lctxp
operator|=
name|lctx
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup_inc
label|:
name|incctx_destroy
argument_list|(
name|mctx
argument_list|,
name|lctx
operator|->
name|inc
argument_list|)
expr_stmt|;
name|cleanup_ctx
label|:
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hex
init|=
literal|"0123456789abcdef0123456789ABCDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*%  * Convert value into a nibble sequence from least significant to most  * significant nibble.  Zero fill upper most significant nibbles if  * required to make the width.  *  * Returns the number of characters that should have been written without  * counting the terminating NUL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|nibbles
parameter_list|(
name|char
modifier|*
name|numbuf
parameter_list|,
name|size_t
name|length
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
name|char
name|mode
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* 	 * This reserve space for the NUL string terminator. 	 */
if|if
condition|(
name|length
operator|>
literal|0U
condition|)
block|{
operator|*
name|numbuf
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
do|do
block|{
name|char
name|val
init|=
name|hex
index|[
operator|(
name|value
operator|&
literal|0x0f
operator|)
operator|+
operator|(
operator|(
name|mode
operator|==
literal|'n'
operator|)
condition|?
literal|0
else|:
literal|16
operator|)
index|]
decl_stmt|;
name|value
operator|>>=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0U
condition|)
block|{
operator|*
name|numbuf
operator|++
operator|=
name|val
expr_stmt|;
operator|*
name|numbuf
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
literal|0
condition|)
name|width
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* 		 * If width is non zero then we need to add a label seperator. 		 * If value is non zero then we need to add another label and 		 * that requires a label seperator. 		 */
if|if
condition|(
name|width
operator|>
literal|0
operator|||
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|length
operator|>
literal|0U
condition|)
block|{
operator|*
name|numbuf
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|numbuf
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|>
literal|0
condition|)
name|width
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|value
operator|!=
literal|0
operator|||
name|width
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|genname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|it
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|char
name|fmt
index|[
sizeof|sizeof
argument_list|(
literal|"%04000000000d"
argument_list|)
index|]
decl_stmt|;
name|char
name|numbuf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|mode
index|[
literal|2
index|]
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|isc_textregion_t
name|r
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|width
decl_stmt|;
name|isc_boolean_t
name|nibblemode
decl_stmt|;
name|r
operator|.
name|base
operator|=
name|buffer
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|length
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'$'
condition|)
block|{
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|isc_textregion_consume
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nibblemode
operator|=
name|ISC_FALSE
expr_stmt|;
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
comment|/* Get format specifier. */
if|if
condition|(
operator|*
name|name
operator|==
literal|'{'
condition|)
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|name
argument_list|,
literal|"{%d,%u,%1[doxXnN]}"
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|width
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|n
operator|=
name|snprintf
argument_list|(
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|,
literal|"%%0%ud"
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'n'
operator|||
name|mode
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
name|nibblemode
operator|=
name|ISC_TRUE
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|,
literal|"%%0%u%c"
argument_list|,
name|width
argument_list|,
name|mode
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DNS_R_SYNTAX
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
comment|/* Skip past closing brace. */
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
operator|&&
operator|*
name|name
operator|++
operator|!=
literal|'}'
condition|)
continue|continue;
block|}
if|if
condition|(
name|nibblemode
condition|)
name|n
operator|=
name|nibbles
argument_list|(
name|numbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
argument_list|,
name|width
argument_list|,
name|mode
index|[
literal|0
index|]
argument_list|,
name|it
operator|+
name|delta
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|snprintf
argument_list|(
name|numbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|it
operator|+
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|cp
operator|=
name|numbuf
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|isc_textregion_consume
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|isc_textregion_consume
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|isc_textregion_consume
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|isc_textregion_consume
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|.
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOSPACE
operator|)
return|;
name|r
operator|.
name|base
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|openfile_text
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|master_file
parameter_list|)
block|{
return|return
operator|(
name|isc_lex_openfile
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|master_file
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|openfile_raw
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
specifier|const
name|char
modifier|*
name|master_file
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_stdio_open
argument_list|(
name|master_file
argument_list|,
literal|"r"
argument_list|,
operator|&
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|ISC_R_FILENOTFOUND
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_stdio_open() failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|generate
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
name|char
modifier|*
name|range
parameter_list|,
name|char
modifier|*
name|lhs
parameter_list|,
name|char
modifier|*
name|gtype
parameter_list|,
name|char
modifier|*
name|rhs
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|char
modifier|*
name|target_mem
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|lhsbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rhsbuf
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|ownerfixed
decl_stmt|;
name|dns_name_t
modifier|*
name|owner
decl_stmt|;
name|dns_rdata_t
name|rdata
init|=
name|DNS_RDATA_INIT
decl_stmt|;
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
decl_stmt|;
name|dns_rdatalist_t
name|rdatalist
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|rdatalist_head_t
name|head
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|target_size
init|=
name|MINTSIZ
decl_stmt|;
comment|/* only one rdata at a time */
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_buffer_t
name|target
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_textregion_t
name|r
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|step
decl_stmt|,
name|i
decl_stmt|;
name|dns_incctx_t
modifier|*
name|ictx
decl_stmt|;
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|callbacks
operator|=
name|lctx
operator|->
name|callbacks
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ownerfixed
argument_list|)
expr_stmt|;
name|owner
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ownerfixed
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|target_mem
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
name|rhsbuf
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|DNS_MASTER_RHS
argument_list|)
expr_stmt|;
name|lhsbuf
operator|=
name|isc_mem_get
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|DNS_MASTER_LHS
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mem
operator|==
name|NULL
operator|||
name|rhsbuf
operator|==
name|NULL
operator|||
name|lhsbuf
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|error_cleanup
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|range
argument_list|,
literal|"%u-%u/%u"
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|2
operator|||
name|stop
operator|<
name|start
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: invalid range '%s'"
argument_list|,
literal|"$GENERATE"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_SYNTAX
expr_stmt|;
goto|goto
name|insist_cleanup
goto|;
block|}
if|if
condition|(
name|n
operator|==
literal|2
condition|)
name|step
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get type. 	 */
name|r
operator|.
name|base
operator|=
name|gtype
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|gtype
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdatatype_fromtext
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: unknown RR type '%s'"
argument_list|,
literal|"$GENERATE"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|gtype
argument_list|)
expr_stmt|;
goto|goto
name|insist_cleanup
goto|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|)
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
operator|&
name|rdatalist
argument_list|,
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|stop
condition|;
name|i
operator|+=
name|step
control|)
block|{
name|result
operator|=
name|genname
argument_list|(
name|lhs
argument_list|,
name|i
argument_list|,
name|lhsbuf
argument_list|,
name|DNS_MASTER_LHS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
name|result
operator|=
name|genname
argument_list|(
name|rhs
argument_list|,
name|i
argument_list|,
name|rhsbuf
argument_list|,
name|DNS_MASTER_RHS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|lhsbuf
argument_list|,
name|strlen
argument_list|(
name|lhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|lhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_setactive
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|lhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|owner
argument_list|,
operator|&
name|buffer
argument_list|,
name|ictx
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_ZONE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_SLAVE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_KEY
operator|)
operator|==
literal|0
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|owner
argument_list|,
name|lctx
operator|->
name|top
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Ignore out-of-zone data. 			 */
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: "
literal|"ignoring out-of-zone data (%s)"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|rhsbuf
argument_list|,
name|strlen
argument_list|(
name|rhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|rhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_setactive
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|rhsbuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_lex_openbuffer
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_fromtext
argument_list|(
operator|&
name|rdata
argument_list|,
name|lctx
operator|->
name|zclass
argument_list|,
name|type
argument_list|,
name|lctx
operator|->
name|lex
argument_list|,
name|ictx
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
name|lctx
operator|->
name|mctx
argument_list|,
operator|&
name|target
argument_list|,
name|callbacks
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_lex_close
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
name|rdatalist
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|rdatalist
operator|.
name|covers
operator|=
literal|0
expr_stmt|;
name|rdatalist
operator|.
name|rdclass
operator|=
name|lctx
operator|->
name|zclass
expr_stmt|;
name|rdatalist
operator|.
name|ttl
operator|=
name|lctx
operator|->
name|ttl
expr_stmt|;
name|ISC_LIST_PREPEND
argument_list|(
name|head
argument_list|,
operator|&
name|rdatalist
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|head
argument_list|,
name|owner
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|error_cleanup
goto|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
goto|goto
name|cleanup
goto|;
name|error_cleanup
label|:
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMEMORY
condition|)
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"$GENERATE: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"$GENERATE: %s:%lu: %s"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|insist_cleanup
label|:
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|target_mem
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhsbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|lhsbuf
argument_list|,
name|DNS_MASTER_LHS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhsbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|rhsbuf
argument_list|,
name|DNS_MASTER_RHS
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|limit_ttl
parameter_list|(
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|isc_uint32_t
modifier|*
name|ttlp
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ttlp
operator|>
literal|0x7fffffffUL
condition|)
block|{
call|(
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: "
literal|"$TTL %lu> MAXTTL, "
literal|"setting $TTL to 0"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
operator|*
name|ttlp
argument_list|)
expr_stmt|;
operator|*
name|ttlp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_ns
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
name|isc_token_t
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|unsigned
name|long
name|line
parameter_list|)
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|dns_rdatacallbacks
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_FATALNS
operator|)
operator|!=
literal|0
condition|)
name|callback
operator|=
name|lctx
operator|->
name|callbacks
operator|->
name|error
expr_stmt|;
else|else
name|callback
operator|=
name|lctx
operator|->
name|callbacks
operator|->
name|warn
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|isc_tokentype_string
condition|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|in6_addr
name|addr6
decl_stmt|;
name|tmp
operator|=
name|isc_mem_strdup
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
operator|*
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 		 * Catch both "1.2.3.4" and "1.2.3.4." 		 */
if|if
condition|(
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|tmp
index|[
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|tmp
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|1
operator|||
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|tmp
argument_list|,
operator|&
name|addr6
argument_list|)
operator|==
literal|1
condition|)
name|result
operator|=
name|DNS_R_NSISADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
call|(
modifier|*
name|callback
call|)
argument_list|(
name|lctx
operator|->
name|callbacks
argument_list|,
literal|"%s:%lu: NS record '%s' "
literal|"appears to be an address"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|DNS_AS_STR
argument_list|(
operator|*
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_wildcard
parameter_list|(
name|dns_incctx_t
modifier|*
name|ictx
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|unsigned
name|long
name|line
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
operator|)
condition|?
name|ictx
operator|->
name|glue
else|:
name|ictx
operator|->
name|current
expr_stmt|;
if|if
condition|(
name|dns_name_internalwildcard
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: warning: ownername "
literal|"'%s' contains an non-terminal wildcard"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|load_text
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|,
name|covers
decl_stmt|;
name|isc_uint32_t
name|ttl_offset
init|=
literal|0
decl_stmt|;
name|dns_name_t
modifier|*
name|new_name
decl_stmt|;
name|isc_boolean_t
name|current_has_delegation
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|finish_origin
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|finish_include
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|read_till_eol
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_boolean_t
name|initialws
decl_stmt|;
name|char
modifier|*
name|include_file
init|=
name|NULL
decl_stmt|;
name|isc_token_t
name|token
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_UNEXPECTED
decl_stmt|;
name|rdatalist_head_t
name|glue_list
decl_stmt|;
name|rdatalist_head_t
name|current_list
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|this
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|rdatalist
init|=
name|NULL
decl_stmt|;
name|dns_rdatalist_t
modifier|*
name|new_rdatalist
decl_stmt|;
name|int
name|rdlcount
init|=
literal|0
decl_stmt|;
name|int
name|rdlcount_save
init|=
literal|0
decl_stmt|;
name|int
name|rdatalist_size
init|=
literal|0
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_buffer_t
name|target
decl_stmt|;
name|isc_buffer_t
name|target_ft
decl_stmt|;
name|isc_buffer_t
name|target_save
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|dns_rdata_t
modifier|*
name|new_rdata
decl_stmt|;
name|int
name|rdcount
init|=
literal|0
decl_stmt|;
name|int
name|rdcount_save
init|=
literal|0
decl_stmt|;
name|int
name|rdata_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target_mem
init|=
name|NULL
decl_stmt|;
name|int
name|target_size
init|=
name|TSIZ
decl_stmt|;
name|int
name|new_in_use
decl_stmt|;
name|unsigned
name|int
name|loop_cnt
init|=
literal|0
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
decl_stmt|;
name|dns_incctx_t
modifier|*
name|ictx
decl_stmt|;
name|char
modifier|*
name|range
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|lhs
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|gtype
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|rhs
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|source
init|=
literal|""
decl_stmt|;
name|unsigned
name|long
name|line
init|=
literal|0
decl_stmt|;
name|isc_boolean_t
name|explicit_ttl
decl_stmt|;
name|isc_stdtime_t
name|now
decl_stmt|;
name|char
name|classname1
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|char
name|classname2
index|[
name|DNS_RDATACLASS_FORMATSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|options
init|=
literal|0
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|callbacks
operator|=
name|lctx
operator|->
name|callbacks
expr_stmt|;
name|mctx
operator|=
name|lctx
operator|->
name|mctx
expr_stmt|;
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|glue_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|current_list
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate target_size of buffer space.  This is greater than twice 	 * the maximum individual RR data size. 	 */
name|target_mem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mem
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
name|target_save
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKNAMES
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|DNS_RDATA_CHECKNAMES
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKNAMESFAIL
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|DNS_RDATA_CHECKNAMESFAIL
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKMX
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|DNS_RDATA_CHECKMX
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKMXFAIL
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|DNS_RDATA_CHECKMXFAIL
expr_stmt|;
name|source
operator|=
name|isc_lex_getsourcename
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
do|do
block|{
name|initialws
operator|=
name|ISC_FALSE
expr_stmt|;
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|ISC_LEXOPT_INITIALWS
operator||
name|ISC_LEXOPT_QSTRING
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
if|if
condition|(
name|read_till_eol
condition|)
name|WARNUNEXPECTEDEOF
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
comment|/* Pop the include stack? */
if|if
condition|(
name|ictx
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|COMMITALL
expr_stmt|;
name|lctx
operator|->
name|inc
operator|=
name|ictx
operator|->
name|parent
expr_stmt|;
name|ictx
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|incctx_destroy
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|ictx
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_lex_close
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|source
operator|=
name|isc_lex_getsourcename
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|EXPECTEOL
expr_stmt|;
continue|continue;
block|}
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eol
condition|)
block|{
name|read_till_eol
operator|=
name|ISC_FALSE
expr_stmt|;
continue|continue;
comment|/* blank line */
block|}
if|if
condition|(
name|read_till_eol
condition|)
continue|continue;
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_initialws
condition|)
block|{
comment|/* 			 * Still working on the same name. 			 */
name|initialws
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_string
operator|||
name|token
operator|.
name|type
operator|==
name|isc_tokentype_qstring
condition|)
block|{
comment|/* 			 * "$" Support. 			 * 			 * "$ORIGIN" and "$INCLUDE" can both take domain names. 			 * The processing of "$ORIGIN" and "$INCLUDE" extends 			 * across the normal domain name processing. 			 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$ORIGIN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|finish_origin
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$TTL"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_ttl_fromtext
argument_list|(
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
name|limit_ttl
argument_list|(
name|callbacks
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|default_ttl
operator|=
name|lctx
operator|->
name|ttl
expr_stmt|;
name|lctx
operator|->
name|default_ttl_known
operator|=
name|ISC_TRUE
expr_stmt|;
name|EXPECTEOL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$INCLUDE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|COMMITALL
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_NOINCLUDE
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: $INCLUDE not allowed"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_REFUSED
expr_stmt|;
goto|goto
name|insist_and_cleanup
goto|;
block|}
if|if
condition|(
name|ttl_offset
operator|!=
literal|0
condition|)
block|{
call|(
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: $INCLUDE "
literal|"may not be used with $DATE"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_SYNTAX
expr_stmt|;
goto|goto
name|insist_and_cleanup
goto|;
block|}
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|ISC_LEXOPT_QSTRING
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_file
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
name|include_file
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_file
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eol
operator|||
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
name|WARNUNEXPECTEDEOF
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|isc_lex_ungettoken
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
comment|/* 					 * No origin field. 					 */
name|result
operator|=
name|pushfile
argument_list|(
name|include_file
argument_list|,
name|ictx
operator|->
name|origin
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOGITFILE
argument_list|(
name|result
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOGITFILE
argument_list|(
name|result
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
goto|goto
name|insist_and_cleanup
goto|;
block|}
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|source
operator|=
name|isc_lex_getsourcename
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|POST
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * There is an origin field.  Fall through 				 * to domain name processing code and do 				 * the actual inclusion later. 				 */
name|finish_include
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$DATE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_int64_t
name|dump_time64
decl_stmt|;
name|isc_stdtime_t
name|dump_time
decl_stmt|,
name|current_time
decl_stmt|;
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|isc_stdtime_get
argument_list|(
operator|&
name|current_time
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_time64_fromtext
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
operator|&
name|dump_time64
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOGIT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|dump_time64
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|log_and_cleanup
goto|;
name|dump_time
operator|=
operator|(
name|isc_stdtime_t
operator|)
name|dump_time64
expr_stmt|;
if|if
condition|(
name|dump_time
operator|!=
name|dump_time64
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: %s:%lu: $DATE outside epoch"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|insist_and_cleanup
goto|;
block|}
if|if
condition|(
name|dump_time
operator|>
name|current_time
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: %s:%lu: "
literal|"$DATE in future, using current date"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|dump_time
operator|=
name|current_time
expr_stmt|;
block|}
name|ttl_offset
operator|=
name|current_time
operator|-
name|dump_time
expr_stmt|;
name|EXPECTEOL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$GENERATE"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Lazy cleanup. 				 */
if|if
condition|(
name|range
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtype
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|gtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|range
operator|=
name|lhs
operator|=
name|gtype
operator|=
name|rhs
operator|=
name|NULL
expr_stmt|;
comment|/* RANGE */
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|range
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
comment|/* LHS */
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
name|rdclass
operator|=
literal|0
expr_stmt|;
name|explicit_ttl
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* CLASS? */
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* TTL? */
if|if
condition|(
name|dns_ttl_fromtext
argument_list|(
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|limit_ttl
argument_list|(
name|callbacks
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl_known
operator|=
name|ISC_TRUE
expr_stmt|;
name|explicit_ttl
operator|=
name|ISC_TRUE
expr_stmt|;
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* CLASS? */
if|if
condition|(
name|rdclass
operator|==
literal|0
operator|&&
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
comment|/* TYPE */
name|gtype
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtype
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
comment|/* RHS */
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|ISC_LEXOPT_QSTRING
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|lctx
operator|->
name|ttl_known
operator|&&
operator|!
name|lctx
operator|->
name|default_ttl_known
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: no TTL specified"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_NOTTL
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|explicit_ttl
operator|&&
name|lctx
operator|->
name|default_ttl_known
condition|)
block|{
name|lctx
operator|->
name|ttl
operator|=
name|lctx
operator|->
name|default_ttl
expr_stmt|;
block|}
comment|/* 				 * If the class specified does not match the 				 * zone's class print out a error message and 				 * exit. 				 */
if|if
condition|(
name|rdclass
operator|!=
literal|0
operator|&&
name|rdclass
operator|!=
name|lctx
operator|->
name|zclass
condition|)
block|{
goto|goto
name|bad_class
goto|;
block|}
name|result
operator|=
name|generate
argument_list|(
name|lctx
argument_list|,
name|range
argument_list|,
name|lhs
argument_list|,
name|gtype
argument_list|,
name|rhs
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
name|EXPECTEOL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|,
literal|"$"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: "
literal|"unknown $ directive '%s'"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|DNS_AS_STR
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_SYNTAX
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
comment|/* 			 * Normal processing resumes. 			 * 			 * Find a free name buffer. 			 */
for|for
control|(
name|new_in_use
operator|=
literal|0
init|;
name|new_in_use
operator|<
name|NBUFS
condition|;
name|new_in_use
operator|++
control|)
if|if
condition|(
operator|!
name|ictx
operator|->
name|in_use
index|[
name|new_in_use
index|]
condition|)
break|break;
name|INSIST
argument_list|(
name|new_in_use
operator|<
name|NBUFS
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|ictx
operator|->
name|fixed
index|[
name|new_in_use
index|]
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|ictx
operator|->
name|fixed
index|[
name|new_in_use
index|]
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_region
operator|.
name|base
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_region
operator|.
name|length
argument_list|)
expr_stmt|;
name|isc_buffer_setactive
argument_list|(
operator|&
name|buffer
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_region
operator|.
name|length
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|new_name
argument_list|,
operator|&
name|buffer
argument_list|,
name|ictx
operator|->
name|origin
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOGIT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|log_and_cleanup
goto|;
comment|/* 			 * Finish $ORIGIN / $INCLUDE processing if required. 			 */
if|if
condition|(
name|finish_origin
condition|)
block|{
if|if
condition|(
name|ictx
operator|->
name|origin_in_use
operator|!=
operator|-
literal|1
condition|)
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|origin_in_use
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
name|ictx
operator|->
name|origin_in_use
operator|=
name|new_in_use
expr_stmt|;
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|origin_in_use
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
name|ictx
operator|->
name|origin
operator|=
name|new_name
expr_stmt|;
name|finish_origin
operator|=
name|ISC_FALSE
expr_stmt|;
name|EXPECTEOL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|finish_include
condition|)
block|{
name|finish_include
operator|=
name|ISC_FALSE
expr_stmt|;
name|result
operator|=
name|pushfile
argument_list|(
name|include_file
argument_list|,
name|new_name
argument_list|,
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOGITFILE
argument_list|(
name|result
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|LOGITFILE
argument_list|(
name|result
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
goto|goto
name|insist_and_cleanup
goto|;
block|}
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|source
operator|=
name|isc_lex_getsourcename
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|line
operator|=
name|isc_lex_getsourceline
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|POST
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * "$" Processing Finished 			 */
comment|/* 			 * If we are processing glue and the new name does 			 * not match the current glue name, commit the glue 			 * and pop stacks leaving us in 'normal' processing 			 * state.  Linked lists are undone by commit(). 			 */
if|if
condition|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
operator|&&
name|dns_name_compare
argument_list|(
name|ictx
operator|->
name|glue
argument_list|,
name|new_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|glue_list
argument_list|,
name|ictx
operator|->
name|glue
argument_list|,
name|source
argument_list|,
name|ictx
operator|->
name|glue_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
if|if
condition|(
name|ictx
operator|->
name|glue_in_use
operator|!=
operator|-
literal|1
condition|)
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|glue_in_use
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
name|ictx
operator|->
name|glue_in_use
operator|=
operator|-
literal|1
expr_stmt|;
name|ictx
operator|->
name|glue
operator|=
name|NULL
expr_stmt|;
name|rdcount
operator|=
name|rdcount_save
expr_stmt|;
name|rdlcount
operator|=
name|rdlcount_save
expr_stmt|;
name|target
operator|=
name|target_save
expr_stmt|;
block|}
comment|/* 			 * If we are in 'normal' processing state and the new 			 * name does not match the current name, see if the 			 * new name is for glue and treat it as such, 			 * otherwise we have a new name so commit what we 			 * have. 			 */
if|if
condition|(
operator|(
name|ictx
operator|->
name|glue
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|ictx
operator|->
name|current
operator|==
name|NULL
operator|||
name|dns_name_compare
argument_list|(
name|ictx
operator|->
name|current
argument_list|,
name|new_name
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|current_has_delegation
operator|&&
name|is_glue
argument_list|(
operator|&
name|current_list
argument_list|,
name|new_name
argument_list|)
condition|)
block|{
name|rdcount_save
operator|=
name|rdcount
expr_stmt|;
name|rdlcount_save
operator|=
name|rdlcount
expr_stmt|;
name|target_save
operator|=
name|target
expr_stmt|;
name|ictx
operator|->
name|glue
operator|=
name|new_name
expr_stmt|;
name|ictx
operator|->
name|glue_in_use
operator|=
name|new_in_use
expr_stmt|;
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|glue_in_use
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|current_list
argument_list|,
name|ictx
operator|->
name|current
argument_list|,
name|source
argument_list|,
name|ictx
operator|->
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
name|rdcount
operator|=
literal|0
expr_stmt|;
name|rdlcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ictx
operator|->
name|current_in_use
operator|!=
operator|-
literal|1
condition|)
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|current_in_use
index|]
operator|=
name|ISC_FALSE
expr_stmt|;
name|ictx
operator|->
name|current_in_use
operator|=
name|new_in_use
expr_stmt|;
name|ictx
operator|->
name|in_use
index|[
name|ictx
operator|->
name|current_in_use
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
name|ictx
operator|->
name|current
operator|=
name|new_name
expr_stmt|;
name|current_has_delegation
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check for internal wildcards. 				 */
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKWILDCARD
operator|)
operator|!=
literal|0
condition|)
name|check_wildcard
argument_list|(
name|ictx
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|callbacks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_ZONE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_SLAVE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_KEY
operator|)
operator|==
literal|0
operator|&&
operator|!
name|dns_name_issubdomain
argument_list|(
name|new_name
argument_list|,
name|lctx
operator|->
name|top
argument_list|)
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|new_name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Ignore out-of-zone data. 				 */
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: "
literal|"ignoring out-of-zone data (%s)"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|ictx
operator|->
name|drop
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
name|ictx
operator|->
name|drop
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
else|else
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s:%lu: isc_lex_gettoken() returned "
literal|"unexpected token type (%d)"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|token
operator|.
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|LOGIT
argument_list|(
name|result
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
comment|/* 		 * Find TTL, class and type.  Both TTL and class are optional 		 * and may occur in any order if they exist. TTL and class 		 * come before type which must exist. 		 * 		 * [<TTL>] [<class>]<type><RDATA> 		 * [<class>] [<TTL>]<type><RDATA> 		 */
name|type
operator|=
literal|0
expr_stmt|;
name|rdclass
operator|=
literal|0
expr_stmt|;
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|initialws
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialws
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eol
condition|)
block|{
name|read_till_eol
operator|=
name|ISC_FALSE
expr_stmt|;
continue|continue;
comment|/* blank line */
block|}
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|isc_tokentype_eof
condition|)
block|{
name|WARNUNEXPECTEDEOF
argument_list|(
name|lctx
operator|->
name|lex
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_FALSE
expr_stmt|;
name|isc_lex_ungettoken
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ictx
operator|->
name|current
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: no current owner name"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_NOOWNER
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
block|}
if|if
condition|(
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|explicit_ttl
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|dns_ttl_fromtext
argument_list|(
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|limit_ttl
argument_list|(
name|callbacks
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|explicit_ttl
operator|=
name|ISC_TRUE
expr_stmt|;
name|lctx
operator|->
name|ttl_known
operator|=
name|ISC_TRUE
expr_stmt|;
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_lex_gettoken() returned unexpected token type"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
if|if
condition|(
name|rdclass
operator|==
literal|0
operator|&&
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|type
operator|!=
name|isc_tokentype_string
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_lex_gettoken() returned unexpected token type"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
name|result
operator|=
name|dns_rdatatype_fromtext
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|token
operator|.
name|value
operator|.
name|as_textregion
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: unknown RR type '%.*s'"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_textregion
operator|.
name|length
argument_list|,
name|token
operator|.
name|value
operator|.
name|as_textregion
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
comment|/* 		 * If the class specified does not match the zone's class 		 * print out a error message and exit. 		 */
if|if
condition|(
name|rdclass
operator|!=
literal|0
operator|&&
name|rdclass
operator|!=
name|lctx
operator|->
name|zclass
condition|)
block|{
name|bad_class
label|:
name|dns_rdataclass_format
argument_list|(
name|rdclass
argument_list|,
name|classname1
argument_list|,
sizeof|sizeof
argument_list|(
name|classname1
argument_list|)
argument_list|)
expr_stmt|;
name|dns_rdataclass_format
argument_list|(
name|lctx
operator|->
name|zclass
argument_list|,
name|classname2
argument_list|,
sizeof|sizeof
argument_list|(
name|classname2
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: class '%s' != "
literal|"zone class '%s'"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|classname1
argument_list|,
name|classname2
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADCLASS
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
name|ictx
operator|->
name|glue
operator|==
name|NULL
condition|)
name|current_has_delegation
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 		 * RFC1123: MD and MF are not allowed to be loaded from 		 * master files. 		 */
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_ZONE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_SLAVE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|type
operator|==
name|dns_rdatatype_md
operator|||
name|type
operator|==
name|dns_rdatatype_mf
operator|)
condition|)
block|{
name|char
name|typename
index|[
name|DNS_RDATATYPE_FORMATSIZE
index|]
decl_stmt|;
name|result
operator|=
name|DNS_R_OBSOLETE
expr_stmt|;
name|dns_rdatatype_format
argument_list|(
name|type
argument_list|,
name|typename
argument_list|,
sizeof|sizeof
argument_list|(
name|typename
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: %s '%s': %s"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
literal|"type"
argument_list|,
name|typename
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|insist_and_cleanup
goto|;
block|}
comment|/* 		 * Find a rdata structure. 		 */
if|if
condition|(
name|rdcount
operator|==
name|rdata_size
condition|)
block|{
name|new_rdata
operator|=
name|grow_rdata
argument_list|(
name|rdata_size
operator|+
name|RDSZ
argument_list|,
name|rdata
argument_list|,
name|rdata_size
argument_list|,
operator|&
name|current_list
argument_list|,
operator|&
name|glue_list
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rdata
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
name|rdata_size
operator|+=
name|RDSZ
expr_stmt|;
name|rdata
operator|=
name|new_rdata
expr_stmt|;
block|}
comment|/* 		 * Peek at the NS record. 		 */
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ns
operator|&&
name|lctx
operator|->
name|zclass
operator|==
name|dns_rdataclass_in
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKNS
operator|)
operator|!=
literal|0
condition|)
block|{
name|GETTOKEN
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
literal|0
argument_list|,
operator|&
name|token
argument_list|,
name|ISC_FALSE
argument_list|)
expr_stmt|;
name|result
operator|=
name|check_ns
argument_list|(
name|lctx
argument_list|,
operator|&
name|token
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|isc_lex_ungettoken
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
operator|&
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_FATALNS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
block|}
comment|/* 		 * Check owner name. 		 */
name|options
operator|&=
operator|~
name|DNS_RDATA_CHECKREVERSE
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKNAMES
operator|)
operator|!=
literal|0
condition|)
block|{
name|isc_boolean_t
name|ok
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
operator|)
condition|?
name|ictx
operator|->
name|glue
else|:
name|ictx
operator|->
name|current
expr_stmt|;
name|ok
operator|=
name|dns_rdata_checkowner
argument_list|(
name|name
argument_list|,
name|lctx
operator|->
name|zclass
argument_list|,
name|type
argument_list|,
name|ISC_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_BADOWNERNAME
expr_stmt|;
name|desc
operator|=
name|dns_result_totext
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_CHECKNAMESFAIL
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: %s: %s"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: %s: %s"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_ptr
operator|&&
operator|(
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|in_addr_arpa
argument_list|)
operator|||
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|ip6_arpa
argument_list|)
operator|||
name|dns_name_issubdomain
argument_list|(
name|name
argument_list|,
operator|&
name|ip6_int
argument_list|)
operator|)
condition|)
name|options
operator||=
name|DNS_RDATA_CHECKREVERSE
expr_stmt|;
block|}
comment|/* 		 * Read rdata contents. 		 */
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|)
expr_stmt|;
name|target_ft
operator|=
name|target
expr_stmt|;
name|result
operator|=
name|dns_rdata_fromtext
argument_list|(
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|,
name|lctx
operator|->
name|zclass
argument_list|,
name|type
argument_list|,
name|lctx
operator|->
name|lex
argument_list|,
name|ictx
operator|->
name|origin
argument_list|,
name|options
argument_list|,
name|lctx
operator|->
name|mctx
argument_list|,
operator|&
name|target
argument_list|,
name|callbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
if|if
condition|(
name|ictx
operator|->
name|drop
condition|)
block|{
name|target
operator|=
name|target_ft
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_ZONE
operator|)
operator|!=
literal|0
operator|&&
name|dns_name_compare
argument_list|(
name|ictx
operator|->
name|current
argument_list|,
name|lctx
operator|->
name|top
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|ictx
operator|->
name|current
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: SOA "
literal|"record not at top of zone (%s)"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_NOTZONETOP
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|read_till_eol
operator|=
name|ISC_TRUE
expr_stmt|;
name|target
operator|=
name|target_ft
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|||
name|type
operator|==
name|dns_rdatatype_sig
condition|)
name|covers
operator|=
name|dns_rdata_covers
argument_list|(
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|)
expr_stmt|;
else|else
name|covers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|lctx
operator|->
name|ttl_known
operator|&&
operator|!
name|lctx
operator|->
name|default_ttl_known
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_soa
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: no TTL specified; "
literal|"using SOA MINTTL instead"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
name|dns_soa_getminimum
argument_list|(
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|)
expr_stmt|;
name|limit_ttl
argument_list|(
name|callbacks
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
operator|&
name|lctx
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|default_ttl
operator|=
name|lctx
operator|->
name|ttl
expr_stmt|;
name|lctx
operator|->
name|default_ttl_known
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_HINT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Zero TTL's are fine for hints. 				 */
name|lctx
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
name|lctx
operator|->
name|default_ttl
operator|=
name|lctx
operator|->
name|ttl
expr_stmt|;
name|lctx
operator|->
name|default_ttl_known
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: no TTL specified; "
literal|"zone rejected"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_NOTTL
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|insist_and_cleanup
goto|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|explicit_ttl
operator|&&
name|lctx
operator|->
name|default_ttl_known
condition|)
block|{
name|lctx
operator|->
name|ttl
operator|=
name|lctx
operator|->
name|default_ttl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|explicit_ttl
operator|&&
name|lctx
operator|->
name|warn_1035
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: "
literal|"using RFC1035 TTL semantics"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|warn_1035
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
name|lctx
operator|->
name|warn_sigexpired
condition|)
block|{
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|result
operator|=
name|dns_rdata_tostruct
argument_list|(
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_serial_lt
argument_list|(
name|sig
operator|.
name|timeexpire
argument_list|,
name|now
argument_list|)
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: "
literal|"signature has expired"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|warn_sigexpired
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|dns_rdatatype_sig
operator|||
name|type
operator|==
name|dns_rdatatype_nxt
operator|)
operator|&&
name|lctx
operator|->
name|warn_tcr
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_ZONE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_SLAVE
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: old style DNSSEC "
literal|" zone detected"
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|warn_tcr
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_AGETTL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Adjust the TTL for $DATE.  If the RR has already 			 * expired, ignore it. 			 */
if|if
condition|(
name|lctx
operator|->
name|ttl
operator|<
name|ttl_offset
condition|)
continue|continue;
name|lctx
operator|->
name|ttl
operator|-=
name|ttl_offset
expr_stmt|;
block|}
comment|/* 		 * Find type in rdatalist. 		 * If it does not exist create new one and prepend to list 		 * as this will minimise list traversal. 		 */
if|if
condition|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
condition|)
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|glue_list
argument_list|)
expr_stmt|;
else|else
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|current_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|type
operator|==
name|type
operator|&&
name|this
operator|->
name|covers
operator|==
name|covers
condition|)
break|break;
name|this
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rdlcount
operator|==
name|rdatalist_size
condition|)
block|{
name|new_rdatalist
operator|=
name|grow_rdatalist
argument_list|(
name|rdatalist_size
operator|+
name|RDLSZ
argument_list|,
name|rdatalist
argument_list|,
name|rdatalist_size
argument_list|,
operator|&
name|current_list
argument_list|,
operator|&
name|glue_list
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rdatalist
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|log_and_cleanup
goto|;
block|}
name|rdatalist
operator|=
name|new_rdatalist
expr_stmt|;
name|rdatalist_size
operator|+=
name|RDLSZ
expr_stmt|;
block|}
name|this
operator|=
operator|&
name|rdatalist
index|[
name|rdlcount
operator|++
index|]
expr_stmt|;
name|this
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|->
name|covers
operator|=
name|covers
expr_stmt|;
name|this
operator|->
name|rdclass
operator|=
name|lctx
operator|->
name|zclass
expr_stmt|;
name|this
operator|->
name|ttl
operator|=
name|lctx
operator|->
name|ttl
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|this
operator|->
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
condition|)
name|ISC_LIST_INITANDPREPEND
argument_list|(
name|glue_list
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|ISC_LIST_INITANDPREPEND
argument_list|(
name|current_list
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this
operator|->
name|ttl
operator|!=
name|lctx
operator|->
name|ttl
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|warn
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s:%lu: "
literal|"TTL set to prior TTL (%lu)"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|this
operator|->
name|ttl
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|ttl
operator|=
name|this
operator|->
name|ttl
expr_stmt|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|this
operator|->
name|rdata
argument_list|,
operator|&
name|rdata
index|[
name|rdcount
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
condition|)
name|ictx
operator|->
name|glue_line
operator|=
name|line
expr_stmt|;
else|else
name|ictx
operator|->
name|current_line
operator|=
name|line
expr_stmt|;
name|rdcount
operator|++
expr_stmt|;
comment|/* 		 * We must have at least 64k as rdlen is 16 bits. 		 * If we don't commit everything we have so far. 		 */
if|if
condition|(
operator|(
name|target
operator|.
name|length
operator|-
name|target
operator|.
name|used
operator|)
operator|<
name|MINTSIZ
condition|)
name|COMMITALL
expr_stmt|;
name|next_line
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|!
name|done
operator|&&
operator|(
name|lctx
operator|->
name|loop_cnt
operator|==
literal|0
operator|||
name|loop_cnt
operator|++
operator|<
name|lctx
operator|->
name|loop_cnt
operator|)
condition|)
do|;
comment|/* 	 * Commit what has not yet been committed. 	 */
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|current_list
argument_list|,
name|ictx
operator|->
name|current
argument_list|,
name|source
argument_list|,
name|ictx
operator|->
name|current_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|glue_list
argument_list|,
name|ictx
operator|->
name|glue
argument_list|,
name|source
argument_list|,
name|ictx
operator|->
name|glue_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
block|{
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|insist_and_cleanup
goto|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|INSIST
argument_list|(
name|lctx
operator|->
name|done
operator|!=
name|NULL
operator|&&
name|lctx
operator|->
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|lctx
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|lctx
operator|->
name|result
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|lctx
operator|->
name|seen_include
condition|)
name|result
operator|=
name|DNS_R_SEENINCLUDE
expr_stmt|;
goto|goto
name|cleanup
goto|;
name|log_and_cleanup
label|:
name|LOGIT
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|insist_and_cleanup
label|:
name|INSIST
argument_list|(
name|result
operator|!=
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|cleanup
label|:
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|current_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|current_list
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|glue_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|glue_list
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdatalist
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdatalist
argument_list|,
name|rdatalist_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rdatalist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdata
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdata
argument_list|,
name|rdata_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mem
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_file
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|include_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|range
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtype
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|gtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|!=
name|NULL
condition|)
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|pushfile
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_incctx_t
modifier|*
name|ictx
decl_stmt|;
name|dns_incctx_t
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
name|isc_region_t
name|r
decl_stmt|;
name|int
name|new_in_use
decl_stmt|;
name|REQUIRE
argument_list|(
name|master_file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|ictx
operator|=
name|lctx
operator|->
name|inc
expr_stmt|;
name|lctx
operator|->
name|seen_include
operator|=
name|ISC_TRUE
expr_stmt|;
name|result
operator|=
name|incctx_create
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|origin
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* Set current domain. */
if|if
condition|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
operator|||
name|ictx
operator|->
name|current
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|new_in_use
operator|=
literal|0
init|;
name|new_in_use
operator|<
name|NBUFS
condition|;
name|new_in_use
operator|++
control|)
if|if
condition|(
operator|!
name|new
operator|->
name|in_use
index|[
name|new_in_use
index|]
condition|)
break|break;
name|INSIST
argument_list|(
name|new_in_use
operator|<
name|NBUFS
argument_list|)
expr_stmt|;
name|new
operator|->
name|current_in_use
operator|=
name|new_in_use
expr_stmt|;
name|new
operator|->
name|current
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|new
operator|->
name|fixed
index|[
name|new
operator|->
name|current_in_use
index|]
argument_list|)
expr_stmt|;
name|new
operator|->
name|in_use
index|[
name|new
operator|->
name|current_in_use
index|]
operator|=
name|ISC_TRUE
expr_stmt|;
name|dns_name_toregion
argument_list|(
operator|(
name|ictx
operator|->
name|glue
operator|!=
name|NULL
operator|)
condition|?
name|ictx
operator|->
name|glue
else|:
name|ictx
operator|->
name|current
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
name|new
operator|->
name|current
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|new
operator|->
name|drop
operator|=
name|ictx
operator|->
name|drop
expr_stmt|;
block|}
name|result
operator|=
call|(
name|lctx
operator|->
name|openfile
call|)
argument_list|(
name|lctx
argument_list|,
name|master_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|new
operator|->
name|parent
operator|=
name|ictx
expr_stmt|;
name|lctx
operator|->
name|inc
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|incctx_destroy
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|read_and_check
parameter_list|(
name|isc_boolean_t
name|do_read
parameter_list|,
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|size_t
name|len
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|if
condition|(
name|do_read
condition|)
block|{
name|INSIST
argument_list|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|>=
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_read
argument_list|(
name|isc_buffer_used
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isc_buffer_remaininglength
argument_list|(
name|buffer
argument_list|)
operator|<
name|len
condition|)
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|load_raw
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
name|unsigned
name|int
name|loop_cnt
init|=
literal|0
decl_stmt|;
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
decl_stmt|;
name|unsigned
name|char
name|namebuf
index|[
name|DNS_NAME_MAXWIRE
index|]
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|rdatalist_head_t
name|head
decl_stmt|,
name|dummy
decl_stmt|;
name|dns_rdatalist_t
name|rdatalist
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
init|=
name|lctx
operator|->
name|mctx
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|rdata_size
init|=
literal|0
decl_stmt|;
name|int
name|target_size
init|=
name|TSIZ
decl_stmt|;
name|isc_buffer_t
name|target
decl_stmt|,
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|target_mem
init|=
name|NULL
decl_stmt|;
name|dns_decompress_t
name|dctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|callbacks
operator|=
name|lctx
operator|->
name|callbacks
expr_stmt|;
name|dns_decompress_init
argument_list|(
operator|&
name|dctx
argument_list|,
operator|-
literal|1
argument_list|,
name|DNS_DECOMPRESS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|first
condition|)
block|{
name|dns_masterrawheader_t
name|header
decl_stmt|;
name|isc_uint32_t
name|format
decl_stmt|,
name|version
decl_stmt|,
name|dumptime
decl_stmt|;
name|size_t
name|hdrlen
init|=
sizeof|sizeof
argument_list|(
name|format
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|version
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dumptime
argument_list|)
decl_stmt|;
name|INSIST
argument_list|(
name|hdrlen
operator|<=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_read
argument_list|(
operator|&
name|header
argument_list|,
literal|1
argument_list|,
name|hdrlen
argument_list|,
name|lctx
operator|->
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_stdio_read failed: %s"
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|isc_buffer_add
argument_list|(
operator|&
name|target
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|format
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|!=
name|dns_masterformat_raw
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: "
literal|"file format mismatch"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
name|version
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|DNS_RAWFORMAT_VERSION
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: "
literal|"unsupported file format version"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
comment|/* Empty read: currently, we do not use dumptime */
name|dumptime
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|POST
argument_list|(
name|dumptime
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|first
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|dns_rdatalist_init
argument_list|(
operator|&
name|rdatalist
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate target_size of buffer space.  This is greater than twice 	 * the maximum individual RR data size. 	 */
name|target_mem
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mem
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|isc_buffer_init
argument_list|(
operator|&
name|target
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
comment|/* 	 * In the following loop, we regard any error fatal regardless of 	 * whether "MANYERRORS" is set in the context option.  This is because 	 * normal errors should already have been checked at creation time. 	 * Besides, it is very unlikely that we can recover from an error 	 * in this format, and so trying to continue parsing erroneous data 	 * does not really make sense. 	 */
for|for
control|(
name|loop_cnt
operator|=
literal|0
init|;
operator|(
name|lctx
operator|->
name|loop_cnt
operator|==
literal|0
operator|||
name|loop_cnt
operator|<
name|lctx
operator|->
name|loop_cnt
operator|)
condition|;
name|loop_cnt
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|rdcount
decl_stmt|;
name|isc_uint16_t
name|namelen
decl_stmt|;
name|isc_uint32_t
name|totallen
decl_stmt|;
name|size_t
name|minlen
decl_stmt|,
name|readlen
decl_stmt|;
name|isc_boolean_t
name|sequential_read
init|=
name|ISC_FALSE
decl_stmt|;
comment|/* Read the data length */
name|isc_buffer_clear
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|isc_buffer_availablelength
argument_list|(
operator|&
name|target
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_stdio_read
argument_list|(
name|target
operator|.
name|base
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
argument_list|,
name|lctx
operator|->
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_EOF
condition|)
block|{
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|done
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|isc_buffer_add
argument_list|(
operator|&
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
argument_list|)
expr_stmt|;
name|totallen
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
comment|/* 		 * Validation: the input data must at least contain the common 		 * header. 		 */
name|minlen
operator|=
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isc_uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isc_uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isc_uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isc_uint32_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|isc_uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|totallen
operator|<
name|minlen
condition|)
block|{
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|totallen
operator|-=
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
expr_stmt|;
name|isc_buffer_clear
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|totallen
operator|>
name|isc_buffer_availablelength
argument_list|(
operator|&
name|target
argument_list|)
condition|)
block|{
comment|/* 			 * The default buffer size should typically be large 			 * enough to store the entire RRset.  We could try to 			 * allocate enough space if this is not the case, but 			 * it might cause a hazardous result when "totallen" 			 * is forged.  Thus, we'd rather take an inefficient 			 * but robust approach in this atypical case: read 			 * data step by step, and commit partial data when 			 * necessary.  Note that the buffer must be large 			 * enough to store the "header part", owner name, and 			 * at least one rdata (however large it is). 			 */
name|sequential_read
operator|=
name|ISC_TRUE
expr_stmt|;
name|readlen
operator|=
name|minlen
operator|-
sizeof|sizeof
argument_list|(
name|totallen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Typical case.  We can read the whole RRset at once 			 * with the default buffer. 			 */
name|readlen
operator|=
name|totallen
expr_stmt|;
block|}
name|result
operator|=
name|isc_stdio_read
argument_list|(
name|target
operator|.
name|base
argument_list|,
literal|1
argument_list|,
name|readlen
argument_list|,
name|lctx
operator|->
name|f
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|isc_buffer_add
argument_list|(
operator|&
name|target
argument_list|,
name|readlen
argument_list|)
expr_stmt|;
comment|/* Construct RRset headers */
name|rdatalist
operator|.
name|rdclass
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|rdatalist
operator|.
name|type
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|rdatalist
operator|.
name|covers
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|rdatalist
operator|.
name|ttl
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|rdcount
operator|=
name|isc_buffer_getuint32
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdcount
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|INSIST
argument_list|(
name|isc_buffer_consumedlength
argument_list|(
operator|&
name|target
argument_list|)
operator|<=
name|readlen
argument_list|)
expr_stmt|;
comment|/* Owner name: length followed by name */
name|result
operator|=
name|read_and_check
argument_list|(
name|sequential_read
argument_list|,
operator|&
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|namelen
argument_list|)
argument_list|,
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|namelen
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
condition|)
block|{
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|result
operator|=
name|read_and_check
argument_list|(
name|sequential_read
argument_list|,
operator|&
name|target
argument_list|,
name|namelen
argument_list|,
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|isc_buffer_setactive
argument_list|(
operator|&
name|target
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|namelen
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromwire
argument_list|(
name|name
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|dctx
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Rdata contents. */
if|if
condition|(
name|rdcount
operator|>
name|rdata_size
condition|)
block|{
name|dns_rdata_t
modifier|*
name|new_rdata
init|=
name|NULL
decl_stmt|;
name|new_rdata
operator|=
name|grow_rdata
argument_list|(
name|rdcount
operator|+
name|RDSZ
argument_list|,
name|rdata
argument_list|,
name|rdata_size
argument_list|,
operator|&
name|head
argument_list|,
operator|&
name|dummy
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_rdata
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|rdata_size
operator|=
name|rdcount
operator|+
name|RDSZ
expr_stmt|;
name|rdata
operator|=
name|new_rdata
expr_stmt|;
block|}
name|continue_read
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdcount
condition|;
name|i
operator|++
control|)
block|{
name|isc_uint16_t
name|rdlen
decl_stmt|;
name|dns_rdata_init
argument_list|(
operator|&
name|rdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequential_read
operator|&&
name|isc_buffer_availablelength
argument_list|(
operator|&
name|target
argument_list|)
operator|<
name|MINTSIZ
condition|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|INSIST
argument_list|(
name|i
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* detect an infinite loop */
comment|/* Partial Commit. */
name|ISC_LIST_APPEND
argument_list|(
name|head
argument_list|,
operator|&
name|rdatalist
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|head
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
index|[
name|j
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Rewind the buffer and continue */
name|isc_buffer_clear
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
name|rdcount
operator|-=
name|i
expr_stmt|;
goto|goto
name|continue_read
goto|;
block|}
comment|/* rdata length */
name|result
operator|=
name|read_and_check
argument_list|(
name|sequential_read
argument_list|,
operator|&
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|rdlen
argument_list|)
argument_list|,
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|rdlen
operator|=
name|isc_buffer_getuint16
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
comment|/* rdata */
name|result
operator|=
name|read_and_check
argument_list|(
name|sequential_read
argument_list|,
operator|&
name|target
argument_list|,
name|rdlen
argument_list|,
name|lctx
operator|->
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|isc_buffer_setactive
argument_list|(
operator|&
name|target
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rdlen
argument_list|)
expr_stmt|;
comment|/* 			 * It is safe to have the source active region and 			 * the target available region be the same if 			 * decompression is disabled (see dctx above) and we 			 * are not downcasing names (options == 0). 			 */
name|isc_buffer_init
argument_list|(
operator|&
name|buf
argument_list|,
name|isc_buffer_current
argument_list|(
operator|&
name|target
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rdlen
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdata_fromwire
argument_list|(
operator|&
name|rdata
index|[
name|i
index|]
argument_list|,
name|rdatalist
operator|.
name|rdclass
argument_list|,
name|rdatalist
operator|.
name|type
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|dctx
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|ISC_LIST_APPEND
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Sanity check.  Still having remaining space is not 		 * necessarily critical, but it very likely indicates broken 		 * or malformed data. 		 */
if|if
condition|(
name|isc_buffer_remaininglength
argument_list|(
operator|&
name|target
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|ISC_LIST_APPEND
argument_list|(
name|head
argument_list|,
operator|&
name|rdatalist
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Commit this RRset.  rdatalist will be unlinked. */
name|result
operator|=
name|commit
argument_list|(
name|callbacks
argument_list|,
name|lctx
argument_list|,
operator|&
name|head
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdcount
condition|;
name|i
operator|++
control|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|rdatalist
operator|.
name|rdata
argument_list|,
operator|&
name|rdata
index|[
name|i
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|dns_rdata_reset
argument_list|(
operator|&
name|rdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|INSIST
argument_list|(
name|lctx
operator|->
name|done
operator|!=
name|NULL
operator|&&
name|lctx
operator|->
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNS_R_CONTINUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|&&
name|lctx
operator|->
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|lctx
operator|->
name|result
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|rdata
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|rdata
argument_list|,
name|rdata_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mem
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|target_mem
argument_list|,
name|target_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|!=
name|DNS_R_CONTINUE
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfile
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
return|return
operator|(
name|dns_master_loadfile3
argument_list|(
name|master_file
argument_list|,
name|top
argument_list|,
name|origin
argument_list|,
name|zclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|callbacks
argument_list|,
name|mctx
argument_list|,
name|dns_masterformat_text
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfile2
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
block|{
return|return
operator|(
name|dns_master_loadfile3
argument_list|(
name|master_file
argument_list|,
name|top
argument_list|,
name|origin
argument_list|,
name|zclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|callbacks
argument_list|,
name|mctx
argument_list|,
name|format
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfile3
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_uint32_t
name|resign
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
block|{
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|format
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
name|resign
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
call|(
name|lctx
operator|->
name|openfile
call|)
argument_list|(
name|lctx
argument_list|,
name|master_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
call|(
name|lctx
operator|->
name|load
call|)
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfileinc
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
return|return
operator|(
name|dns_master_loadfileinc3
argument_list|(
name|master_file
argument_list|,
name|top
argument_list|,
name|origin
argument_list|,
name|zclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|lctxp
argument_list|,
name|mctx
argument_list|,
name|dns_masterformat_text
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfileinc2
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
block|{
return|return
operator|(
name|dns_master_loadfileinc3
argument_list|(
name|master_file
argument_list|,
name|top
argument_list|,
name|origin
argument_list|,
name|zclass
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|lctxp
argument_list|,
name|mctx
argument_list|,
name|format
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadfileinc3
parameter_list|(
specifier|const
name|char
modifier|*
name|master_file
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|isc_uint32_t
name|resign
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|dns_masterformat_t
name|format
parameter_list|)
block|{
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|format
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
name|resign
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
call|(
name|lctx
operator|->
name|openfile
call|)
argument_list|(
name|lctx
argument_list|,
name|master_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|task_send
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_loadctx_attach
argument_list|(
name|lctx
argument_list|,
name|lctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|cleanup
label|:
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadstream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|stream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_lex_openstream
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
call|(
name|lctx
operator|->
name|load
call|)
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|lctx
operator|!=
name|NULL
condition|)
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadstreaminc
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|stream
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|isc_lex_openstream
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|task_send
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_loadctx_attach
argument_list|(
name|lctx
argument_list|,
name|lctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|cleanup
label|:
if|if
condition|(
name|lctx
operator|!=
name|NULL
condition|)
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadbuffer
parameter_list|(
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|isc_lex_openbuffer
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
call|(
name|lctx
operator|->
name|load
call|)
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadbufferinc
parameter_list|(
name|isc_buffer_t
modifier|*
name|buffer
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|buffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|NULL
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|isc_lex_openbuffer
argument_list|(
name|lctx
operator|->
name|lex
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|result
operator|=
name|task_send
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_loadctx_attach
argument_list|(
name|lctx
argument_list|,
name|lctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|cleanup
label|:
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadlexer
parameter_list|(
name|isc_lex_t
modifier|*
name|lex
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|lex
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|lex
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
call|(
name|lctx
operator|->
name|load
call|)
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|!=
name|DNS_R_CONTINUE
argument_list|)
expr_stmt|;
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|dns_master_loadlexerinc
parameter_list|(
name|isc_lex_t
modifier|*
name|lex
parameter_list|,
name|dns_name_t
modifier|*
name|top
parameter_list|,
name|dns_name_t
modifier|*
name|origin
parameter_list|,
name|dns_rdataclass_t
name|zclass
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|,
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|dns_loaddonefunc_t
name|done
parameter_list|,
name|void
modifier|*
name|done_arg
parameter_list|,
name|dns_loadctx_t
modifier|*
modifier|*
name|lctxp
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
init|=
name|NULL
decl_stmt|;
name|REQUIRE
argument_list|(
name|lex
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|loadctx_create
argument_list|(
name|dns_masterformat_text
argument_list|,
name|mctx
argument_list|,
name|options
argument_list|,
literal|0
argument_list|,
name|top
argument_list|,
name|zclass
argument_list|,
name|origin
argument_list|,
name|callbacks
argument_list|,
name|task
argument_list|,
name|done
argument_list|,
name|done_arg
argument_list|,
name|lex
argument_list|,
operator|&
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|result
operator|=
name|task_send
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_loadctx_attach
argument_list|(
name|lctx
argument_list|,
name|lctxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNS_R_CONTINUE
operator|)
return|;
block|}
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grow the slab of dns_rdatalist_t structures.  * Re-link glue and current list.  */
end_comment

begin_function
specifier|static
name|dns_rdatalist_t
modifier|*
name|grow_rdatalist
parameter_list|(
name|int
name|new_len
parameter_list|,
name|dns_rdatalist_t
modifier|*
name|old
parameter_list|,
name|int
name|old_len
parameter_list|,
name|rdatalist_head_t
modifier|*
name|current
parameter_list|,
name|rdatalist_head_t
modifier|*
name|glue
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_rdatalist_t
modifier|*
name|new
decl_stmt|;
name|int
name|rdlcount
init|=
literal|0
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_rdatalist_t
argument_list|)
name|save
expr_stmt|;
name|dns_rdatalist_t
modifier|*
name|this
decl_stmt|;
name|new
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|new_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ISC_LIST_INIT
argument_list|(
name|save
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|current
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|current
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|save
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|save
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|save
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdlcount
operator|<
name|new_len
argument_list|)
expr_stmt|;
name|new
index|[
name|rdlcount
index|]
operator|=
operator|*
name|this
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|current
argument_list|,
operator|&
name|new
index|[
name|rdlcount
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdlcount
operator|++
expr_stmt|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|save
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|glue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|glue
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|save
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|save
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|save
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdlcount
operator|<
name|new_len
argument_list|)
expr_stmt|;
name|new
index|[
name|rdlcount
index|]
operator|=
operator|*
name|this
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
operator|*
name|glue
argument_list|,
operator|&
name|new
index|[
name|rdlcount
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdlcount
operator|++
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|rdlcount
operator|==
name|old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|old
argument_list|,
name|old_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|old
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grow the slab of rdata structs.  * Re-link the current and glue chains.  */
end_comment

begin_function
specifier|static
name|dns_rdata_t
modifier|*
name|grow_rdata
parameter_list|(
name|int
name|new_len
parameter_list|,
name|dns_rdata_t
modifier|*
name|old
parameter_list|,
name|int
name|old_len
parameter_list|,
name|rdatalist_head_t
modifier|*
name|current
parameter_list|,
name|rdatalist_head_t
modifier|*
name|glue
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|dns_rdata_t
modifier|*
name|new
decl_stmt|;
name|int
name|rdcount
init|=
literal|0
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|dns_rdata_t
argument_list|)
name|save
expr_stmt|;
name|dns_rdatalist_t
modifier|*
name|this
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|new
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|new_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
name|new_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy current relinking. 	 */
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|current
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_INIT
argument_list|(
name|save
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|this
operator|->
name|rdata
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|this
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|save
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|save
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|save
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdcount
operator|<
name|new_len
argument_list|)
expr_stmt|;
name|new
index|[
name|rdcount
index|]
operator|=
operator|*
name|rdata
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|this
operator|->
name|rdata
argument_list|,
operator|&
name|new
index|[
name|rdcount
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdcount
operator|++
expr_stmt|;
block|}
name|this
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy glue relinking. 	 */
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|glue
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_INIT
argument_list|(
name|save
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|this
operator|->
name|rdata
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|this
operator|->
name|rdata
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|save
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|save
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|save
argument_list|,
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdcount
operator|<
name|new_len
argument_list|)
expr_stmt|;
name|new
index|[
name|rdcount
index|]
operator|=
operator|*
name|rdata
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|this
operator|->
name|rdata
argument_list|,
operator|&
name|new
index|[
name|rdcount
index|]
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rdcount
operator|++
expr_stmt|;
block|}
name|this
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|rdcount
operator|==
name|old_len
operator|||
name|rdcount
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|old
argument_list|,
name|old_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|old
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_uint32_t
name|resign_fromlist
parameter_list|(
name|dns_rdatalist_t
modifier|*
name|this
parameter_list|,
name|isc_uint32_t
name|resign
parameter_list|)
block|{
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|dns_rdata_rrsig_t
name|sig
decl_stmt|;
name|isc_uint32_t
name|when
decl_stmt|;
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|this
operator|->
name|rdata
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|rdata
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dns_rdata_tostruct
argument_list|(
name|rdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|when
operator|=
name|sig
operator|.
name|timeexpire
operator|-
name|resign
expr_stmt|;
name|rdata
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
while|while
condition|(
name|rdata
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|dns_rdata_tostruct
argument_list|(
name|rdata
argument_list|,
operator|&
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|timeexpire
operator|-
name|resign
operator|<
name|when
condition|)
name|when
operator|=
name|sig
operator|.
name|timeexpire
operator|-
name|resign
expr_stmt|;
name|rdata
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|when
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert each element from a rdatalist_t to rdataset then call commit.  * Unlink each element as we go.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|commit
parameter_list|(
name|dns_rdatacallbacks_t
modifier|*
name|callbacks
parameter_list|,
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|,
name|rdatalist_head_t
modifier|*
name|head
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|dns_rdatalist_t
modifier|*
name|this
decl_stmt|;
name|dns_rdataset_t
name|dataset
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|void
function_decl|(
modifier|*
name|error
function_decl|)
parameter_list|(
name|struct
name|dns_rdatacallbacks
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|head
argument_list|)
expr_stmt|;
name|error
operator|=
name|callbacks
operator|->
name|error
expr_stmt|;
if|if
condition|(
name|this
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
do|do
block|{
name|dns_rdataset_init
argument_list|(
operator|&
name|dataset
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|dns_rdatalist_tordataset
argument_list|(
name|this
argument_list|,
operator|&
name|dataset
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|dataset
operator|.
name|trust
operator|=
name|dns_trust_ultimate
expr_stmt|;
comment|/* 		 * If this is a secure dynamic zone set the re-signing time. 		 */
if|if
condition|(
name|dataset
operator|.
name|type
operator|==
name|dns_rdatatype_rrsig
operator|&&
operator|(
name|lctx
operator|->
name|options
operator|&
name|DNS_MASTER_RESIGN
operator|)
operator|!=
literal|0
condition|)
block|{
name|dataset
operator|.
name|attributes
operator||=
name|DNS_RDATASETATTR_RESIGN
expr_stmt|;
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|dataset
operator|.
name|resign
operator|=
name|resign_fromlist
argument_list|(
name|this
argument_list|,
name|lctx
operator|->
name|resign
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
call|(
modifier|*
name|callbacks
operator|->
name|add
call|)
argument_list|(
name|callbacks
operator|->
name|add_private
argument_list|,
name|owner
argument_list|,
operator|&
name|dataset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_NOMEMORY
condition|)
block|{
call|(
modifier|*
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"dns_master_load: %s"
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|dns_name_format
argument_list|(
name|owner
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s:%lu: %s: %s"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|source
argument_list|,
name|line
argument_list|,
name|namebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|error
call|)
argument_list|(
name|callbacks
argument_list|,
literal|"%s: %s: %s"
argument_list|,
literal|"dns_master_load"
argument_list|,
name|namebuf
argument_list|,
name|dns_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|MANYERRS
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
condition|)
name|SETRESULT
argument_list|(
name|lctx
argument_list|,
name|result
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|ISC_LIST_UNLINK
argument_list|(
operator|*
name|head
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|head
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|this
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns ISC_TRUE if one of the NS rdata's contains 'owner'.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|is_glue
parameter_list|(
name|rdatalist_head_t
modifier|*
name|head
parameter_list|,
name|dns_name_t
modifier|*
name|owner
parameter_list|)
block|{
name|dns_rdatalist_t
modifier|*
name|this
decl_stmt|;
name|dns_rdata_t
modifier|*
name|rdata
decl_stmt|;
name|isc_region_t
name|region
decl_stmt|;
name|dns_name_t
name|name
decl_stmt|;
comment|/* 	 * Find NS rrset. 	 */
name|this
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
name|this
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|type
operator|==
name|dns_rdatatype_ns
condition|)
break|break;
name|this
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
name|rdata
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|this
operator|->
name|rdata
argument_list|)
expr_stmt|;
while|while
condition|(
name|rdata
operator|!=
name|NULL
condition|)
block|{
name|dns_name_init
argument_list|(
operator|&
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dns_rdata_toregion
argument_list|(
name|rdata
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
name|dns_name_fromregion
argument_list|(
operator|&
name|name
argument_list|,
operator|&
name|region
argument_list|)
expr_stmt|;
if|if
condition|(
name|dns_name_compare
argument_list|(
operator|&
name|name
argument_list|,
name|owner
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
name|rdata
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|rdata
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_quantum
parameter_list|(
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|dns_loadctx_t
modifier|*
name|lctx
decl_stmt|;
name|REQUIRE
argument_list|(
name|event
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lctx
operator|=
name|event
operator|->
name|ev_arg
expr_stmt|;
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lctx
operator|->
name|canceled
condition|)
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
else|else
name|result
operator|=
call|(
name|lctx
operator|->
name|load
call|)
argument_list|(
name|lctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|DNS_R_CONTINUE
condition|)
block|{
name|event
operator|->
name|ev_arg
operator|=
name|lctx
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
name|lctx
operator|->
name|done
call|)
argument_list|(
name|lctx
operator|->
name|done_arg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|dns_loadctx_detach
argument_list|(
operator|&
name|lctx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|task_send
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|isc_event_t
modifier|*
name|event
decl_stmt|;
name|event
operator|=
name|isc_event_allocate
argument_list|(
name|lctx
operator|->
name|mctx
argument_list|,
name|NULL
argument_list|,
name|DNS_EVENT_MASTERQUANTUM
argument_list|,
name|load_quantum
argument_list|,
name|lctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|isc_task_send
argument_list|(
name|lctx
operator|->
name|task
argument_list|,
operator|&
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dns_loadctx_cancel
parameter_list|(
name|dns_loadctx_t
modifier|*
name|lctx
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|DNS_LCTX_VALID
argument_list|(
name|lctx
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lctx
operator|->
name|canceled
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|lctx
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

